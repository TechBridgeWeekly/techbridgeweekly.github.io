<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Leetcode 刷題 pattern - Breadth-First Search | TechBridge 技術共筆部落格</title>
  <meta name="description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- google-site-verification -->
  <meta name="google-site-verification" content="WX_9sZlrIYOEpy8RR7zCoa7-pJk611zZt11BSBUcDVY" />
  <link rel="stylesheet preload" type="text/css" href="/css/screen.css" as="style" />
  <link rel="stylesheet preload" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" as="style" />

  <!-- Favicons -->
  <link rel="apple-touch-icon" href="/img/favicon.ico">
  <link rel="icon preload" href="/img/favicon.ico" as="image">

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml">
  
  

  
</head>


<body class="post-template">

  <header class="site-head" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="/img/logo-tb-500-500.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">TechBridge 技術共筆部落格</h1>
            <h2 class="blog-description">var topics = ['Web前後端', '行動網路', '機器人/物聯網', '數據分析', '產品設計', 'etc.']</h2>
            <div class="navbar-block">
                <span><a href="/">首頁</a></span> / <span><a href="/about/">關於我們</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>
                <br>
            </div>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2019-12-21T19:32:59.000Z" itemprop="datePublished">
          2019-12-21
      </time>
    
</span>

<meta name="generator" content="Leetcode 刷題 pattern - Breadth-First Search">
<meta name="og:title" content="Leetcode 刷題 pattern - Breadth-First Search">
<meta name="og:description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享。">
<meta name="og:type" content="website">
<meta name="og:image" content="/img/og-cover.png">

    <h1 class="post-title">Leetcode 刷題 pattern - Breadth-First Search</h1>
    <section class="post-content">
      <div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>   
      <hr>
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>身在大 CS 時代，有越來越多人投入刷題的行列，在眼花撩亂的題海中，要想有效率地刷題，就需要掌握題目解法中，可以在許多地方應用的觀念，才能以簡禦繁。 Huli 寫的 <a href="https://blog.techbridge.cc/2019/11/02/before-start-leetcode/">程式解題新手入門注意事項</a> 講得很好，寫題目是為了學會解題的思考方法，確保自己掌握重要的資料結構跟演算法。這也是為什麼我想要寫這系列的文章，把多個散落在各處的題目銜接起來，以後看到相似的問題就可以舉一反三，而不是去背各題目的解法。</p>
<p>舉例來說，之前遇過一題電話面試，問到的題目是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: vector&lt;bool&gt; holidays, int pto</span><br><span class="line">holidays 表示平日或假日，例如 0000011 表示前面 5 天是平日，後面 2 天是假日。</span><br><span class="line">pto 表示最多可以放幾天假。</span><br><span class="line">Output: 計算在可以用完 pto 的情況下，最久可以放多長的假。</span><br><span class="line"></span><br><span class="line">範例：holidays = &#123;0,0,0,0,0,1,1&#125;, pto = 2, output = 4</span><br><span class="line">     因為可以放 &#123;0,0,0,1,1,1,1&#125;</span><br></pre></td></tr></table></figure>

<p>基本上因為之前有寫過 Sliding Window 的 pattern，所以這題很快就寫出來了，也順利進到下一關，所以大家不需要追求把題目都刷完，而是掌握好重要的基礎，接下來就是應用這些基礎就可以面對很多變化題（當然還是會有一些解法很巧妙的題目，但其實大部分公司不會硬出巧妙題）。</p>
<p>放上程式碼給大家參考：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longest_holidays</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">bool</span>&gt;&amp; holidays, <span class="type">int</span> pto)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> longestHoliday = <span class="number">-1</span>, windowStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> windowEnd = <span class="number">0</span>; windowEnd &lt; holidays.<span class="built_in">size</span>(); ++windowEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(holidays[windowEnd] == <span class="number">0</span>) &#123;</span><br><span class="line">            -- pto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shrink window size</span></span><br><span class="line">        <span class="keyword">while</span>(pto &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(holidays[windowStart++] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ pto;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compare valid window size and longestHoliday</span></span><br><span class="line">        longestHoliday = <span class="built_in">max</span>(longestHoliday, windowEnd - windowStart + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longestHoliday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 000001100000110000111</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; holidays = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> longest_holiday = <span class="built_in">longest_holidays</span>(holidays, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My longest holiday: &quot;</span> &lt;&lt; longest_holiday &lt;&lt; <span class="string">&quot;, hooray!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面這題還有一個 follow-up 問題，可以看我的 <a target="_blank" rel="noopener" href="https://www.1point3acres.com/bbs/thread-558279-1-1.html">面經分享</a>。</p>
<h2 id="Breadth-First-Search-簡介"><a href="#Breadth-First-Search-簡介" class="headerlink" title="Breadth-First Search 簡介"></a>Breadth-First Search 簡介</h2><p>言歸正傳，今天要來跟大家介紹相當基礎的演算法 pattern - Breadth-First Search，雖然 BFS 是基礎中的基礎，大家多少都會，但你真的確定自己除了在 tree 跟 graph 這些顯而易見的題型以外，都能活用 BFS 嗎？</p>
<p>我們先看一個題目 - Leetcode #279 - Perfect Squares：</p>
<p><img src="https://i.imgur.com/iCbSTEd.png" alt="img"></p>
<p>如果沒什麼刷題經驗，可能會想要用暴力的枚舉方法來解這個問題；如果有一些刷題經驗，可能會想到用 Dynamic Programming 來解。但其實，這題也可以用 BFS 解！而且實作非常簡單，舉這個例子是想讓大家看看 BFS 也可以應用在沒有明顯 graph 結構的問題上，我們會在第四個範例中解釋怎麼用 BFS 來解這題。</p>
<p>在進到題目之前，先給大家 BFS 實作的模板，這樣只要寫過幾題，之後在實作 BFS 就不容易出錯，因為基本的模板相通，只要將注意力集中在各題目不同的細節上就好。</p>
<h3 id="BFS-template-1"><a href="#BFS-template-1" class="headerlink" title="BFS template 1"></a>BFS template 1</h3><p>BFS 跟 queue 這個資料結構是好夥伴，使用 queue 讓 BFS 的實作變得很簡單，比如說下面這個嘗試計算 root node 跟 target node 距離的 pseudo code：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node&gt; queue; <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    step = <span class="number">0</span>;      <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is <span class="keyword">not</span> empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BFS-template-2"><a href="#BFS-template-2" class="headerlink" title="BFS template 2"></a>BFS template 2</h3><p>有時候，我們必須要避免走到重複的 node（例如在 cyclic graph 中，就可能又走回起點），才不會讓 BFS 無法結束，所以需要紀錄哪些 node 已經走過，模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; visited;  <span class="comment">// store all the nodes that we&#x27;ve visited</span></span><br><span class="line">    step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is <span class="keyword">not</span> empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="type">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is <span class="keyword">not</span> in visited) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to visited;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-First-Search-的第一個範例-Leetcode-286-Walls-and-Gates"><a href="#Breadth-First-Search-的第一個範例-Leetcode-286-Walls-and-Gates" class="headerlink" title="Breadth-First Search 的第一個範例 - Leetcode #286 - Walls and Gates"></a>Breadth-First Search 的第一個範例 - Leetcode #286 - Walls and Gates</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p><img src="https://i.imgur.com/7y3XvVN.png" alt="img"></p>
<p>這個題目比較明顯有 graph 的樣子，因為每一步都只能走到上&#x2F;下&#x2F;左&#x2F;右的其中一個鄰居，而且是要找 “距離最近” 的門，所以比較直覺會想到可以用 BFS，我們就直接來看看解法。</p>
<h3 id="Breadth-First-Search-解法"><a href="#Breadth-First-Search-解法" class="headerlink" title="Breadth-First Search 解法"></a>Breadth-First Search 解法</h3><p>要做 BFS，我們有兩種選擇，第一種是從每個房間開始，尋找離這個房間最近的門；第二種則是先把每個門都放進 queue 裡面，每次都只走一步，如果遇到的是房間，就更新房間到門口的步數。</p>
<p>雖然這題的想法很簡單，可是如果你對 BFS 的模板還不是很熟，還是會需要花一些時間想一想邏輯要怎麼寫的，所以不用緊張，慢慢地想過一遍，盡力自己寫寫看，寫不出來就看看答案，看完自己想一遍再寫，反覆幾次就會越來越熟悉。提供一份 C++ 版本的實作如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wallsAndGates</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check corner cases</span></span><br><span class="line">        <span class="type">int</span> m = rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="type">int</span> n = rooms[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare for BFS</span></span><br><span class="line">        <span class="type">int</span> GATE = <span class="number">0</span>, WALL = <span class="number">-1</span>, ROOM = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Put all gates into queue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(rooms[i][j] == GATE) q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start BFS</span></span><br><span class="line">        <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> sz = q.<span class="built_in">size</span>()<span class="number">-1</span>; sz &gt;= <span class="number">0</span>; --sz) &#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(rooms[cur.first][cur.second] == ROOM) &#123;</span><br><span class="line">                    rooms[cur.first][cur.second] = steps;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(rooms[cur.first][cur.second] != WALL) &#123;</span><br><span class="line">                    <span class="comment">// Traverse neighbor</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                        cur.first += dirs[i].first;</span><br><span class="line">                        cur.second += dirs[i].second;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">isValid</span>(cur, m, n) &amp;&amp; rooms[cur.first][cur.second] == ROOM) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(cur);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        cur.first -= dirs[i].first;</span><br><span class="line">                        cur.second -= dirs[i].second;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++steps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; cur, <span class="type">const</span> <span class="type">int</span>&amp; m, <span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur.first &gt;= <span class="number">0</span> &amp;&amp; cur.first &lt; m &amp;&amp; cur.second &gt;= <span class="number">0</span> &amp;&amp; cur.second &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-First-Search-的第二個範例-Leetcode-200-Number-of-Islands"><a href="#Breadth-First-Search-的第二個範例-Leetcode-200-Number-of-Islands" class="headerlink" title="Breadth-First Search 的第二個範例 - Leetcode #200 - Number of Islands"></a>Breadth-First Search 的第二個範例 - Leetcode #200 - Number of Islands</h2><h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h3><p><img src="https://i.imgur.com/uIVF6nc.png" alt="img"></p>
<h3 id="Depth-First-Search-解法"><a href="#Depth-First-Search-解法" class="headerlink" title="Depth-First Search 解法"></a>Depth-First Search 解法</h3><p>這題應該算是非常經典的問題，目前在面試中出現的頻率也還是很高，以寫程式的簡潔度來說，DFS 是比較容易寫的，概念上就是，每次我們遇到一個島的邊界（也就是 ‘1’ 的地方），我們就呼叫 DFS function 把跟這個 ‘1’ 相鄰的 ‘1’ 都變成 ‘0’，實作如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = m ? grid[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>, islands = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走過矩陣的所有 element，只要遇到島，就把島都消滅(即 &#x27;1&#x27; -&gt; &#x27;0&#x27;)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    islands++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, m, n, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> islands;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">const</span> <span class="type">int</span>&amp; m, <span class="type">const</span> <span class="type">int</span>&amp; n, <span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123; <span class="built_in">dfs</span>(grid, m, n, i<span class="number">-1</span>, j); &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m)  &#123; <span class="built_in">dfs</span>(grid, m, n, i<span class="number">+1</span>, j); &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123; <span class="built_in">dfs</span>(grid, m, n, i, j<span class="number">-1</span>); &#125;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n)  &#123; <span class="built_in">dfs</span>(grid, m, n, i, j<span class="number">+1</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Breadth-First-Search-解法-1"><a href="#Breadth-First-Search-解法-1" class="headerlink" title="Breadth-First Search 解法"></a>Breadth-First Search 解法</h3><p>DFS 的實作雖然簡潔，可是，如果輸入的矩陣非常大，並且包含著很大的島，那隨著 DFS 的遞迴呼叫層數增加，是有可能產生 stack overflow 的，所以如果能用 BFS 解決，就會是比較安全的解法。</p>
<p>一樣，雖然想法上很簡單，但實作上還是需要多寫幾次才會熟悉，附上一份 BFS 的實作給大家參考：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = m ? grid[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>, islands = <span class="number">0</span>, offsets[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    islands++;</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; todo;</span><br><span class="line">                    todo.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (!todo.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = todo.<span class="built_in">front</span>();</span><br><span class="line">                        todo.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="type">int</span> r = p.first + offsets[k], c = p.second + offsets[k + <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                                grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                                todo.<span class="built_in">push</span>(&#123;r, c&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-First-Search-的第三個範例-Leetcode-752-Open-the-Lock"><a href="#Breadth-First-Search-的第三個範例-Leetcode-752-Open-the-Lock" class="headerlink" title="Breadth-First Search 的第三個範例 - Leetcode #752 - Open the Lock"></a>Breadth-First Search 的第三個範例 - Leetcode #752 - Open the Lock</h2><h3 id="題目-2"><a href="#題目-2" class="headerlink" title="題目"></a>題目</h3><p><img src="https://i.imgur.com/W3vNo1V.png" alt="img"><br><img src="https://i.imgur.com/dfJsEUy.png" alt="img"><br><img src="https://i.imgur.com/RzPSMal.png" alt="img"></p>
<p>這一題開始變得比較有趣，因為一看到這個題目的時候，未必會想到要用 BFS，所以接下來，讓我先分享一下思考的方法。</p>
<h3 id="思考方法"><a href="#思考方法" class="headerlink" title="思考方法"></a>思考方法</h3><p>這題雖然乍看之下不會直接想到要用 BFS，但其實還是有很多蛛絲馬跡，比如說：</p>
<ol>
<li>我們從 0000 開始，所以有一個起點。</li>
<li>希望尋找的是 0000 到 target 之間的 “最短距離”。</li>
</ol>
<p>看到這兩個提示，腦海中就會開始浮現一個從 0000 為 root，開始探索直到走到 target 的一個搜尋過程：</p>
<p>0000 -&gt; 1000, 9000, 0100, 0900, 0010, 0090, 0001, 0009 -&gt; … -&gt; … -&gt; target</p>
<p>所以就開始有可以使用 BFS 的影子出現。換句話說，因為看到有起點、要求最短距離，所以想了 “走一步” 是什麼意思？然後想到就是把其中一個數字 +1 或 -1。接著就可以再延伸，發現這就是一個從 0000 開始，然後假設 deadends 是已經 visit 過所以不能再走，的一個 BFS 問題。</p>
<h3 id="Breadth-First-Search-解法-2"><a href="#Breadth-First-Search-解法-2" class="headerlink" title="Breadth-First Search 解法"></a>Breadth-First Search 解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Prepare for BFS</span></span><br><span class="line">        <span class="comment">// 因為不能走到 deadends 裡面的排列，所以我們直接放進 visited，這樣做 BFS 時就不會考慮這些路線</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">visited</span><span class="params">(deadends.begin(), deadends.end())</span></span>;</span><br><span class="line">        array&lt;<span class="type">char</span>, 10&gt; digit= &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        queue&lt;string&gt; todo;</span><br><span class="line">        <span class="comment">// 假設 0000 沒有在 visited(也就是 deadends 裡沒有) 中，我們才需要開始尋找</span></span><br><span class="line">        <span class="keyword">if</span>(!visited.<span class="built_in">count</span>(<span class="string">&quot;0000&quot;</span>)) &#123;</span><br><span class="line">            todo.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">            visited.<span class="built_in">insert</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start BFS</span></span><br><span class="line">        <span class="type">int</span> steps = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!todo.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++steps;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> sz = todo.<span class="built_in">size</span>() - <span class="number">1</span>; sz &gt;= <span class="number">0</span>; --sz) &#123;</span><br><span class="line">                string cur = todo.<span class="built_in">front</span>();</span><br><span class="line">                todo.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if it&#x27;s target</span></span><br><span class="line">                <span class="keyword">if</span>(cur == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> steps;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Go through neighbors</span></span><br><span class="line">                <span class="comment">// 如何找到對的 neighbor 也是這題比較 tricky 的地方之一</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                        string neighbor = cur;</span><br><span class="line">                        <span class="comment">// Wrap around index to prevent out-of-bound error</span></span><br><span class="line">                        neighbor[i] = digit[(neighbor[i]-<span class="string">&#x27;0&#x27;</span>+j<span class="number">+10</span>) % <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(!visited.<span class="built_in">count</span>(neighbor)) &#123;</span><br><span class="line">                            todo.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                            visited.<span class="built_in">insert</span>(neighbor);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>寫完這題，如果你是 BFS 新手，應該會覺得頗好玩，因為這題的鄰居找法跟之前有明顯 matrix 結構的情況不太一樣，而是變成在另一個抽象的搜索空間中做 BFS。</p>
<h2 id="Breadth-First-Search-的第四個範例-Leetcode-279-Perfect-Squares"><a href="#Breadth-First-Search-的第四個範例-Leetcode-279-Perfect-Squares" class="headerlink" title="Breadth-First Search 的第四個範例 - Leetcode #279 - Perfect Squares"></a>Breadth-First Search 的第四個範例 - Leetcode #279 - Perfect Squares</h2><h3 id="題目-3"><a href="#題目-3" class="headerlink" title="題目"></a>題目</h3><p><img src="https://i.imgur.com/iCbSTEd.png" alt="img"></p>
<h3 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h3><p>暴力法很直覺，反正就每種組合都試試看就對了，例如若要看 12 至少要由幾個 perfect suqare number 組成，那就看 “1 至少要幾個 + 11 至少要幾個”、”2 至少要幾個 + 10 至少要幾個” … 依此類推，直到比較過所有可能的拆分方法，就知道最少要幾個，實作如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPerfectSquare</span>(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> comb = <span class="built_in">numSquares</span>(i) + <span class="built_in">numSquares</span>(n - i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(comb &lt; res) &#123;</span><br><span class="line">                res = comb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Find floating point value of square root of x.</span></span><br><span class="line">      <span class="type">double</span> sr = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If square root is an integer</span></span><br><span class="line">      <span class="keyword">return</span> ((sr - <span class="built_in">floor</span>(sr)) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很顯然，這種方法有夠慢，在 leetcode 上面跑也確實會超時。雖然可以用 memoization、Dynamic Programming，不過今天的重點是 BFS，所以我們來探討一下 BFS 解。</p>
<h3 id="Breadth-First-Search-解法-3"><a href="#Breadth-First-Search-解法-3" class="headerlink" title="Breadth-First Search 解法"></a>Breadth-First Search 解法</h3><p>如果你有辦法想到 BFS，應該會覺得滿好玩的。這題的思路如下：</p>
<ol>
<li>如果 n 是 perfect square，答案就是 1。</li>
<li>如果 n 可以由兩個 perfect square 組成，答案就是 2。</li>
</ol>
<p>所以我們如果要使用 BFS，起點就是所有的 perfect square！</p>
<p>看一個範例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 12</span><br><span class="line">起點：1, 4, 9</span><br><span class="line">走一步：1+1 = 2, 1+4 = 5, 1 + 9 = 10, 4+4 = 8</span><br><span class="line">走兩步：2+1 = 3, 2+4 = 6, 2+9 = 11...</span><br></pre></td></tr></table></figure>

<p>所以，每次要拜訪的鄰居就是 queue 裡面的數字再加上一個 perfect square！</p>
<p>想懂觀念之後，實作出來就只是時間問題：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Declare data structure for BFS</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; todo;</span><br><span class="line"></span><br><span class="line">        todo.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        visited.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start BFS</span></span><br><span class="line">        <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!todo.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++steps;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> sz = todo.<span class="built_in">size</span>() - <span class="number">1</span>; sz &gt;= <span class="number">0</span>; --sz) &#123;</span><br><span class="line">                <span class="comment">// Retrieve current int</span></span><br><span class="line">                <span class="type">int</span> cur = todo.<span class="built_in">front</span>();</span><br><span class="line">                todo.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="type">int</span> sum = cur + j * j;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(sum == n) &#123; <span class="keyword">return</span> steps; &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; n) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!visited.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">                            todo.<span class="built_in">push</span>(sum);</span><br><span class="line">                            visited.<span class="built_in">insert</span>(sum);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-First-Search-的第五個範例-Leetcode-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix"><a href="#Breadth-First-Search-的第五個範例-Leetcode-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix" class="headerlink" title="Breadth-First Search 的第五個範例 - Leetcode #1284 - Minimum Number of Flips to Convert Binary Matrix to Zero Matrix"></a>Breadth-First Search 的第五個範例 - Leetcode #1284 - Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</h2><h3 id="題目-4"><a href="#題目-4" class="headerlink" title="題目"></a>題目</h3><p><img src="https://i.imgur.com/DpIil2u.png" alt="img"></p>
<p><img src="https://i.imgur.com/ILEBcZi.png" alt="img"></p>
<p>這一題是我在某一週的 Leetcode contest 寫到的，因為當時我正好寫完上面四個 BFS 的範例題，對 BFS 的 pattern 很有感覺，所以這題很快就寫出來了。</p>
<h3 id="Breadth-First-Search-解法-4"><a href="#Breadth-First-Search-解法-4" class="headerlink" title="Breadth-First Search 解法"></a>Breadth-First Search 解法</h3><p>因為概念上跟第三個範例有點像，都是在自己想像中的搜索空間中進行 BFS，所以這題的想法我就不贅述了，基本上就是把整個 matrix 的狀態當作 node，每翻一次就是走一步，就可以用 BFS 解決了，附上程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlips</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check corner cases</span></span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = m ? mat[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">1</span> <span class="keyword">or</span> n &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare for BFS</span></span><br><span class="line">        set&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; visited;</span><br><span class="line">        queue&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(mat);</span><br><span class="line">        visited.<span class="built_in">insert</span>(mat);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> sz = q.<span class="built_in">size</span>() - <span class="number">1</span>; sz &gt;= <span class="number">0</span>; --sz) &#123;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 已經成功翻成全部都是 0</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">allZero</span>(cur)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> steps;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                        <span class="comment">// 以 (r,c) 為中心翻一次 matrix</span></span><br><span class="line">                        <span class="built_in">flip</span>(cur, m, n, r, c);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果還沒走過這個盤面，放入 queue</span></span><br><span class="line">                        <span class="keyword">if</span>(!visited.<span class="built_in">count</span>(cur)) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(cur);</span><br><span class="line">                            visited.<span class="built_in">insert</span>(cur);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 把盤面翻回來</span></span><br><span class="line">                        <span class="built_in">flip</span>(cur, m, n, r, c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++steps;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span>&amp; m, <span class="type">int</span>&amp; n, <span class="type">int</span>&amp; r, <span class="type">int</span>&amp; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 翻鄰居</span></span><br><span class="line">        <span class="keyword">if</span>(r - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123; mat[r<span class="number">-1</span>][c] = (mat[r<span class="number">-1</span>][c] == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(r + <span class="number">1</span> &lt; m)  &#123; mat[r<span class="number">+1</span>][c] = (mat[r<span class="number">+1</span>][c] == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(c - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123; mat[r][c<span class="number">-1</span>] = (mat[r][c<span class="number">-1</span>] == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(c + <span class="number">1</span> &lt; n)  &#123; mat[r][c<span class="number">+1</span>] = (mat[r][c<span class="number">+1</span>] == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻(r,c)</span></span><br><span class="line">        mat[r][c] = (mat[r][c] == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">allZero</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; mat.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; mat[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天跟大家介紹了一個新的 pattern - Breadth-First Search，上面提供的五題是讓大家體驗一下，BFS 看似簡單的，卻可以應用在很多乍看之下不會聯想到 BFS 的題目。能夠體驗到這一層，就是你可以開始靈活運用 BFS 的起點。刷題不只是為了通過面試，而是加強自己對資結和演算法的洞見和體驗，進而優雅有效率地解決工程問題，共勉之。</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="https://blog.techbridge.cc/2019/08/30/leetcode-pattern-two-pointer/">Leetcode 刷題 pattern - Two Pointer</a></li>
<li><a href="https://blog.techbridge.cc/2019/09/28/leetcode-pattern-sliding-window/">Leetcode 刷題 pattern - Sliding Window</a></li>
<li><a href="https://blog.techbridge.cc/2019/10/26/leetcode-pattern-next-greater-element/">Leetcode 刷題 pattern - Next Greater Element</a></li>
<li><a href="https://blog.techbridge.cc/2019/11/22/leetcode-pattern-fast-and-slow-pointer/">Leetcode 刷題 pattern - Fast &amp; Slow Pointer</a></li>
</ol>
<p>關於作者：<br><a target="_blank" rel="noopener" href="https://pojenlai.wordpress.com/">@pojenlai</a> 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正致力改善 <a target="_blank" rel="noopener" href="https://www.books.com.tw/products/0010822522">自己的習慣</a>。</p>
  
      <div>喜歡我們的文章嗎？歡迎分享按讚給予我們支持和鼓勵！</div>
      <div class="fb-like" data-href="https://blog.techbridge.cc/2019/12/21/leetcode-%E5%88%B7%E9%A1%8C-pattern-breadth-first-search/index.html" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>
      <br>
      <br>
      <div class="fb-page" data-href="https://www.facebook.com/techbridge.cc" data-small-header="false" data-adapt-container-width="true" data-hide-cover="false" data-show-facepile="true"><blockquote cite="https://www.facebook.com/techbridge.cc" class="fb-xfbml-parse-ignore"><a target="_blank" rel="noopener" href="https://www.facebook.com/techbridge.cc">TechBridge 技術日報</a></blockquote></div>
      <br>
    </section>
    <br>
    <hr>
    <div>
      <h4>訂閱 TechBridge Weekly 技術週刊，每週發送最精華的技術開發、產品設計的資訊給您</h4>
      <form class="form-control" method="post" action="https://goodbits.io/e/cab8a418-6b70-48d6-97ea-b5f0ef34b22c" target="_blank">
        <input class="form-control" type="text" name="first_name" placeholder="First Name"></input>
        <input class="form-control" type="text" name="last_name" placeholder="Last Name"></input>
        <div>
          <input class="form-control" type="text" name="email" placeholder="Email"></input>
        </div>
        <br>
        <div>
          <button class="form-control btn subscribe-btn" type="submit">馬上訂閱技術週刊</button>
        </div>
        <br>
        <label for="">PS. 我們討厭垃圾信，所以我們只提供有價值的內容給您 :)</label>
      </form>
    </div>
    <footer class="post-footer">
      <section class="author">
    <h4>TechBridge Weekly 技術週刊編輯團隊</h4>
    <p>TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、資料科學與產品設計等技術分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robotics, IoT, Data Science technology sharing.</p>
    <span><a href="/2016/03/19/about/">關於我們</a></span> / <span><a href="https://www.techbridge.cc/" target="_blank">技術日報</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>   
	<div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-size="large" data-action="like" data-show-faces="false" data-share="true"></div>    
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" target="_blank" rel="noopener" href="http://twitter.com/share?url=https://blog.techbridge.cc/2019/12/21/leetcode-刷題-pattern-breadth-first-search/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" target="_blank" rel="noopener" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.techbridge.cc/2019/12/21/leetcode-刷題-pattern-breadth-first-search/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" target="_blank" rel="noopener" href="https://plus.google.com/share?url=https://blog.techbridge.cc/2019/12/21/leetcode-刷題-pattern-breadth-first-search/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
    <iframe src="https://ghbtns.com/github-btn.html?user=TechBridgeHQ&repo=blog-starter-kit&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>      
</section>
    </footer>
    <br>
  </article>
  <nav class="pagination" role="pagination">
    <h2>更多優質技術文章</h2>
    
    <a class="newer-posts" href="/2019/12/27/from-nand-to-tetris%EF%BC%9A%E6%83%B3%E7%90%86%E8%A7%A3%E9%9B%BB%E8%85%A6%E9%81%8B%E4%BD%9C%EF%BC%8C%E5%B0%B1%E5%85%88%E5%81%9A%E5%87%BA%E4%B8%80%E5%8F%B0%E5%90%A7%EF%BC%81/">
        ← From Nand To Tetris：想理解電腦運作，就先做出一台吧！
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2019/12/15/APCS-%E5%A4%A7%E5%AD%B8%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%85%88%E4%BF%AE%E6%AA%A2%E6%B8%AC%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/">
        簡明 APCS 大學程式設計先修檢測入門教學 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">留言討論</a></h1>

    
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    
</div>
</main>


  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75308642-1', 'auto');
  ga('send', 'pageview');

</script>
<footer class="site-footer">
  
  <a class="subscribe icon-feed" href="/atom.xml"><span class="tooltip">Subscribe!</span></a>
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">TechBridge 技術共筆部落格</a> &copy; 2017 &bull; All rights reserved.</section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>


<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '[object Object]']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>


<script type="text/javascript">
    var disqus_shortname = 'techbridgeweekly';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.4/dist/medium-zoom.min.js"></script>
<script>
// NodeList
mediumZoom(document.querySelectorAll('img'));
</script>
  <div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, 'script', 'facebook-jssdk'));</script>
</body>
</html>
