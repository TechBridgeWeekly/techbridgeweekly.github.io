<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>使用 JavaScript 處理二進位資料 | TechBridge 技術共筆部落格</title>
  <meta name="description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- google-site-verification -->
  <meta name="google-site-verification" content="WX_9sZlrIYOEpy8RR7zCoa7-pJk611zZt11BSBUcDVY">
  <link rel="stylesheet preload" type="text/css" href="/css/screen.css" as="style">
  <link rel="stylesheet preload" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" as="style">

  <!-- Favicons -->
  <link rel="apple-touch-icon" href="/img/favicon.ico">
  <link rel="icon preload" href="/img/favicon.ico" as="image">

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
  

  
</head>


<body class="post-template">

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="site-head" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="/img/logo-tb-500-500.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">TechBridge 技術共筆部落格</h1>
            <h2 class="blog-description">var topics = ['Web前後端', '行動網路', '機器人/物聯網', '數據分析', '產品設計', 'etc.']</h2>
            <div class="navbar-block">
                <span><a href="/">首頁</a></span> / <span><a href="/about/">關於我們</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>
                <br>
            </div>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-09-24T10:46:57.000Z" itemprop="datePublished">
          2017-09-24
      </time>
    
    
    | 
    <a href='/tags/JavaScript/'>JavaScript</a>,
    
    <a href='/tags/Endianness/'>Endianness</a>,
    
    <a href='/tags/Binary-Data/'>Binary Data</a>,
    
    <a href='/tags/Memory-Alignment/'>Memory Alignment</a>
    
    
</span>

<meta name="generator" content="使用 JavaScript 處理二進位資料">
<meta name="og:title" content="使用 JavaScript 處理二進位資料">
<meta name="og:description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享。">
<meta name="og:type" content="website">
<meta name="og:image" content="/img/og-cover.png">

    <h1 class="post-title">使用 JavaScript 處理二進位資料</h1>
    <section class="post-content">
      <div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>   
      <hr>
      <p>由於高度封裝與抽象，JavaScript 的執行效率比不上 C 的語言。例如 JavaScript 的 Array 下標（subscript）是根據 hash key 而非實體記憶體位址 offset 取值，雖然方便，卻多了效能開銷。當 Canvas、WebGL、WebVR 開始走紅，效能越來越受重視，如何讓 JavaScript 達到如同 C 指標般操作 binary data 變得至關重要。</p>
<p>存在許久但最近才變為 ES6 標準「<strong>Typed Array</strong>」就是解放 JavaScript 操作 binary data 能力的好工具！一起來了解 Typed Array 吧！</p>
<p><em>（基於 ECMAScript 6+，Node.js 8.3）</em></p>
<a id="more"></a>
<h2 id="Buffer-v-s-View"><a href="#Buffer-v-s-View" class="headerlink" title="Buffer v.s View"></a>Buffer v.s View</h2><p>ES6 引入的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="noopener">Typed Array 家族</a>，可以分為兩大類：<strong>Buffer</strong> 與 <strong>View</strong>。</p>
<p>所謂 <strong>Buffer</strong> 是一個指向儲存資料的記憶體區塊之物件，類似於 <code>malloc</code> 配置出來的空間，無法直接存取或修改 buffer 內部的資料，在 JavaScript 中 Buffer 的實作就是 <code>ArrayBuffer</code>。</p>
<p>如果我們想存取某些 buffer 底下的內容，我們需要 <strong>View</strong>（視圖），透過宣告不同資料型別的 view，電腦就會了解如何操作這段 data chunk，該當作 float32 讀取呢？抑或以 unsigned integer 來操作。</p>
<p>ES6 規範了三個 Typed Array 相關物件，對應類別如下：</p>
<ul>
<li><code>ArrayBuffer</code>：Buffer，代表一段記憶體區塊，僅能透過 View 操作其內容。</li>
<li><code>TypedArray</code>：View，儲存固定型別資料的 Array，例如 <code>Uint8Array</code>（8-bit unsigned integer）、<code>Float64Array</code>（64-bit IEEE floating point number)。</li>
<li><code>DataView</code>：View，不限制型別，可自定義從哪個 byte，以什麼型別，用哪種 byte order（endian）存取。</li>
</ul>
<h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> 代表一段固定大小的記憶體區塊，也稱為 byte-array。主要的功能就是配置實體記憶體來儲存 raw binary data。一般很少直接操作 ArrayBuffer，實際上也只能將其 reference 傳給其他物件，讓其他物件來處理／使用資料。</p>
<p>建立一個 ArrayBuffer 有非常多種方法，可以直接配置，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接配置 8 bytes，初始值為 0 的記憶體區塊</span></span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 `slice` 將某些 bytes 複製到另一個 ArrayBuffer</span></span><br><span class="line"><span class="comment">// 這裡複製 `buffer` 倒數四個 bytes 到 bufferCopied 中</span></span><br><span class="line"><span class="keyword">const</span> bufferCopied = buffer.slice(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure>
<p>或是最常使用的，HTTP response 選擇接收 buffer，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLHttpRequest 指定 resopnseType (XMLHttpRequest v2)</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/path/to/黑人問號.jpg'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.responseType = <span class="string">'arraybuffer'</span> <span class="comment">// 將 reponse 型別設定為 arraybuffer</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.response) <span class="comment">// this.response 為 ArrayBuffer</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch API 也提供 Body#arrayBuffer 的方法轉換 Request／Response stream body</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/path/to/柯P火影.gif'</span>)</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">await</span> response.arrayBuffer() <span class="comment">// 取得 ArrayBuffer 實例</span></span><br><span class="line"><span class="built_in">console</span>.log(buffer.byteLength) <span class="comment">// 查看當前這個 ArrayBuffer 有多少 bytes。</span></span><br></pre></td></tr></table></figure>
<p>當然，也可以透過 <code>File</code> 與 <code>FileReader</code> API，讀取使用者上傳的資料。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>)</span><br><span class="line">input.addEventListener(<span class="string">'change'</span>, handleFiles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFiles</span> (<span class="params">files</span>) </span>&#123; <span class="comment">// files -&gt; FileList 物件，裡面有 File 實例</span></span><br><span class="line">  <span class="keyword">if</span> (files[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; target: &#123; result &#125; &#125;</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result.byteLength) <span class="comment">// result 是一個 ArrayBuffer</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.readAsArrayBuffer = files[<span class="number">0</span>] <span class="comment">// File 是特殊的 Blob 型別</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h2><p>TypedArray 並非任何一個型別，也非全域可取得的建構函數，而是一個抽象概念，對應到許多不同型別的 Array 罷了。老實說，TypedArray 這個的命名已說明一切，讓我來說文解字，先從 Typed 講起。</p>
<h3 id="Types-of-TypedArray"><a href="#Types-of-TypedArray" class="headerlink" title="Types of TypedArray"></a>Types of TypedArray</h3><p>所謂的 Typed，意指「<strong>限定型別</strong>」，Array 中的元素都是同一種型別。有哪些型別呢？TypedArray 是為了操作 binary 而生，當然只有最底層以 bytes 為基礎，幾乎沒有什麼抽象概念的型別。我們可根據需求，決定每個元素該從 raw data 讀取多少與如何讀取 bytes。</p>
<p>目前 ES6 定義以下幾種 typed array types：</p>
<table>
<thead>
<tr>
<th>型別</th>
<th style="text-align:center">bytes／元素</th>
<th style="text-align:center">對應 C 語言</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Int8Array</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">int8_t</td>
</tr>
<tr>
<td><code>Uint8Array</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">uint8_t</td>
</tr>
<tr>
<td><code>Uint8ClampedArray</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">uint8_t</td>
</tr>
<tr>
<td><code>Int16Array</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">int16_t</td>
</tr>
<tr>
<td><code>Uint16Array</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">uint16_t</td>
</tr>
<tr>
<td><code>Int32Array</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">int32_t</td>
</tr>
<tr>
<td><code>Uint32Array</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">uint32_t</td>
</tr>
<tr>
<td><code>Float32Array</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td><code>Float64Array</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">double</td>
</tr>
</tbody>
</table>
<p>實際上，TypedArray 本身並並不儲存任何 buffer 資料，只保存該 buffer 的 reference，我們可以透過 <code>TypedArray#buffer</code> 獲取原始的 ArrayBuffer。也因此，同一個 ArrayBuffer 可以建構出多個不同的 TypedArray。可視為「<strong>從不同視角解讀 ArrayBuffer 中的 binary data</strong>」。</p>
<p>例如下圖是一個 16 bytes 的 ArrayBuffer，我們可以透過它，建立多個不同型別的 TypedArray。</p>
<p><img src="https://mdn.mozillademos.org/files/8629/typed_arrays.png" alt></p>
<p>不同型別的 TypedArray 的元素對應到不同的 byte 數量，這項資訊會記錄在 <code>TypedArray#BYTES_PER_ELEMENT</code> property 上。例如：Uint8Array 一個元素對應到一個 byte，Float64Array 則對應到 8 bytes。</p>
<p>如果還是無法理解，其實可以將 TypedArray 想像為 C 語言的 <code>void *ptr</code>，在存取、遍歷不同 data type 的 Array 時，轉型（cast）成不同的型別，讓指標根據不同 data type 的 size 做對應 offset。</p>
<h3 id="Array-like-Methods"><a href="#Array-like-Methods" class="headerlink" title="Array-like Methods"></a>Array-like Methods</h3><p>而 TypedArray 中的 Array，其實就是我們熟悉的 JavaScript Array，可視為「<strong>在 ArrayBuffer 的資料之上，架一層可存取資料的 Array API</strong>」。你想得到的 method <code>map</code>、<code>filter</code>、<code>reduce</code> 幾乎應有盡有，而 <code>push</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code> 這類會改變 Array 長度的 <strong>Mutator methods</strong> 沒有實作，畢竟 TypedArray 就只是 buffer 的 reference，<code>pop</code> 後原始資料依然存在。</p>
<p>比較好玩的是，<code>TypedArray#subarray</code> 和 <code>TypedArray#slice</code> 同樣是回傳陣列切片，<code>slice</code> 是回傳一個淺拷貝（shallow-copy）的<strong>新 Array</strong>，新 array 的 <code>buffer</code> property 指向新切出來的 buffer，<code>byteOffset</code> 也是依據新的 buffer，所以會是 <strong>0</strong>。</p>
<p>而 <code>subarray</code> 則是在同個 buffer 繼續切片，調用 subarray 的 <code>buffer</code> 會取得相同的原始 buffer，<code>byteOffset</code> 也是根據原始 buffer 計算 offset。</p>
<h3 id="Consturct-a-TypedArray"><a href="#Consturct-a-TypedArray" class="headerlink" title="Consturct a TypedArray"></a>Consturct a TypedArray</h3><p>建構 TypedArray 非常簡單，選擇好 data type 之後，<code>new</code> 一個就完成了！</p>
<p><strong>直接初始化</strong></p>
<p>建立一個 4 * 2 bytes 初始值為 0 的 Uint16Array。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u16 = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><strong>從 TypedArray 建立</strong></p>
<p>我們也可以從其他 TypedArray 建立相同長度的 TypedArray，會指向同一個 buffer。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(u16) <span class="comment">// length of u8 is 4</span></span><br></pre></td></tr></table></figure>
<p>這樣會建立一個新的型別 array，但記憶體區塊不變。我們的例子中，u8 因為溢位的緣故（overflow），自動過濾偶數 bytes（或奇數，視 <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener">endianness</a> 而定），僅顯示餘下 4 個 bytes 的資料，記憶體位址變得不連續。</p>
<p><strong>從 ArrayBuffer 建立</strong></p>
<p>不過，也可以透過 <code>TypedArray#buffer</code> 取得並共享當前的 buffer，該 array 的記憶體區間就會是連續的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因為 buffer 總共有 4 * 2 = 8 bytes，所以 u8_continuous 長度為 8</span></span><br><span class="line"><span class="keyword">const</span> u8_continuous = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(u16.buffer)</span><br></pre></td></tr></table></figure>
<p>當然，ArrayBuffer 可直接配置一塊記憶體區塊，並使用它建構 TypedArray，甚至透過 <code>length</code> 和 <code>byteOffset</code> 指定該 buffer 不同的區間來建構。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">const</span> i32 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer) <span class="comment">// 32 * 2 bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 從 4 bytes offset 的位址開始，切一個長度為 7 bytes 的 array。</span></span><br><span class="line"><span class="keyword">const</span> i8 = <span class="keyword">new</span> Iint8Array(buffer, <span class="number">4</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h3><p>如同 C 語言，不同類型的 TypedArray 可以容納的 bytes 範圍是固定的，超過此一範圍，就會出現<a href="https://en.wikipedia.org/wiki/Integer_overflow" target="_blank" rel="noopener">「溢位（Overflow）」</a>，例如 Uint8Array 中僅能放入 1 byte = 8 bits 的資料，如果放入 <code>0x100</code>（256，9 bits），就會溢位。</p>
<p>那溢位後，資料會怎麼呈現呢？</p>
<p>每個語言實作不盡相同，TypedArray 的溢位處理規則和多數語言相同：<strong>捨棄溢出的 high bits。</strong> 我們來看簡單的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Uint8Array</span>.of(<span class="number">0xff</span>, <span class="number">0x100</span>)</span><br><span class="line"><span class="comment">// Unit8Array [255, 0]</span></span><br></pre></td></tr></table></figure>
<p>第一個例子中，我們選用 Uint8Array，一個元素最多儲存 8 bits 的資料，第二個元素是 256，需要第 9 bit 來儲存，因此溢位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 255，至少需要 8 bits 儲存</span></span><br><span class="line"><span class="number">0b11111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 256，至少需要 9 bits 儲存</span></span><br><span class="line"><span class="number">0b100000000</span></span><br><span class="line"><span class="comment">//└── 這個 1 溢位，將被捨棄，僅保留最低有效的 8 bits，計算結果為 `0`</span></span><br><span class="line"><span class="comment">// 捨棄的方式同於 bitwise or `&amp; 0xFF`</span></span><br><span class="line"><span class="number">0x100</span> &amp; <span class="number">0xFF</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：underflow 的處理方式與 overflow 相同。</p>
</blockquote>
<h3 id="What-is-Uint8ClampedArray"><a href="#What-is-Uint8ClampedArray" class="headerlink" title="What is Uint8ClampedArray"></a>What is Uint8ClampedArray</h3><p>Clamp 的本意是鉗子，在計算機科學中，通常意味將資料值限制在特定範圍間。而 <code>Uint8ClampedArray</code> 中，就是將元素值限制在 0 - 255。換句話說，就是處理溢位的規則與 <code>Uint8Array</code> 不同。<strong>當 overflow 時，該值會等於最大值 255；當 underflow 時，該值會等於 0</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Uint8Array</span>.of(<span class="number">0xff</span>, <span class="number">0x100</span>, <span class="number">-100</span>)</span><br><span class="line"><span class="comment">// Unit8Array [255, 0, 156]</span></span><br><span class="line"><span class="built_in">Uint8ClampedArray</span>.of(<span class="number">0xff</span>, <span class="number">0x100</span>, <span class="number">-100</span>)</span><br><span class="line"><span class="comment">// Uint8ClampedArray [255, 255, 0]</span></span><br></pre></td></tr></table></figure>
<p>這有什麼好處呢？在影像處理上非常方便。有個很常舉的例子，有 3 bytes 的 Uint8Array 存放 RGB 色碼，我們想要增加他的 gamma factor，如果使用 Uint8Array 儲存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必須自行限制大小，防止 ooverflow／underflow。</span></span><br><span class="line">u8[i] = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="built_in">Math</span>.min(<span class="number">255</span>, u8[i] * gamma)) <span class="comment">// u8 是一個 Uint8Array</span></span><br></pre></td></tr></table></figure>
<p>如果是 <code>Uint8ClampedArray</code>，只需要直接乘上 gammer factor，非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixels[i] *= gamma <span class="comment">// pixels 是一個 Uint8ClampedArray</span></span><br></pre></td></tr></table></figure>
<h3 id="Composite-Data-Structure"><a href="#Composite-Data-Structure" class="headerlink" title="Composite Data Structure"></a>Composite Data Structure</h3><p>當需處理類似 C struct 的複合資料結構，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">employee</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> id;               <span class="comment">// 4 * 1 bytes</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> department[<span class="number">4</span>];   <span class="comment">// 1 * 4 bytes</span></span><br><span class="line">  <span class="keyword">float</span> salary;         <span class="comment">// 4 * 1 bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我們可以宣告對應的 TypedArray 來處理。模擬出如果 C struct 的資料結構。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">12</span>)</span><br><span class="line"><span class="keyword">const</span> idView = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> deptView = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> salaryView = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(buffer, <span class="number">8</span>)</span><br><span class="line">idView[<span class="number">0</span>] = <span class="number">123</span></span><br><span class="line">deptView.forEach(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123; deptView[i] = i * i &#125;)</span><br><span class="line">salaryView[<span class="number">0</span>] = <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><p>顧名思義，<strong>DataView</strong> 是一種建構在 buffer 之上的 view。與一般 TypedArray 不同的是，建構 DataView 時並不會固定的資料型別，取而代之的是存取 data 時，必須明確的指定從哪個 byte offset 取哪一種 data type 出來。</p>
<p>借用前例的複合資料來示範，<code>DataView</code> 如何針對每個 bytes 處理自定義的資料。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line"><span class="comment">// 從 byte offset 0 的位址開始取 Uint32 的資料</span></span><br><span class="line"><span class="comment">// 取得 ID -&gt; 123</span></span><br><span class="line">dv.getUint32(<span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從 byte offset 8 的位址開始寫入 Float32 的資料</span></span><br><span class="line">dv.setFloat32(<span class="number">8</span>, <span class="number">200000</span>, <span class="literal">true</span>)</span><br><span class="line">dv.getFloat32(<span class="number">8</span>, <span class="literal">true</span>) <span class="comment">// 加薪囉！！</span></span><br></pre></td></tr></table></figure>
<p>各位有沒有注意到，DataView 的 bytes getter／setter 最後面都多帶了一個 boolean 參數？這個參數是指定使用 Little-endian 讀取資料，預設為 <code>false</code> 也就是以 Big-endian 讀取。可控制 endian 是 DataView 蠻重要但也頗惱人的特性，在下一節會介紹 Endianness。</p>
<p>DataView 另一個重要特性就是不會 <a href="https://en.wikipedia.org/wiki/Buffer_overflow" target="_blank" rel="noopener">buffer overflow</a>，所謂的 buffer overflow 是「<strong>當寫入一筆資料到指定 buffer 中，若寫入的資料大小超過該 buffer 的 boundary，溢出值就會覆寫下個 byte</strong>」。這種不安全的性質，也讓 buffer overflow 成為許多駭客的攻擊手法，有潛在的安全性問題。而透過 DataView setter 賦予一個超過型別最大值的數字，並不會覆蓋臨近記憶體位址的資料，而是內部先檢查邊界，處理 overflow 之後，再寫入該記憶體區間，彌補了 buffer overflow 的漏洞。</p>
<h2 id="Precautions"><a href="#Precautions" class="headerlink" title="Precautions"></a>Precautions</h2><p>Typed Arrays 幾乎可以做到如同 C 語言般細膩的記憶體操作。不過越是自由的 API，就代表要學習更多知識，注意更多細節，以下是操作 TypedArray 該銘記在心的事情：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener">Endianness (Byte order)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment" target="_blank" rel="noopener">Data Structure Alignment</a></li>
</ul>
<h3 id="Endianness-Byte-order"><a href="#Endianness-Byte-order" class="headerlink" title="Endianness (Byte order)"></a>Endianness (Byte order)</h3><p>在計算機科學領域下，Data 是一個物理概念，指儲存在電腦記憶體上的一個 bits／bytes 序列。Data 本身並沒有任何意義，想使用它，必須自行解讀出抽象的意義，例如將 Data 讀取為字串或數字。</p>
<p>我們知道記憶體是基於位址（address）依序儲存 Data，每個位址可以存上 1 byte data。如果使用 <code>Uint8Array</code> 這種一次存取一個 byte 的格式，那麼完全不會有任何問題，怎麼存取，都是依連續的記憶體位址順序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- 資料讀取順序 --&gt;</span><br><span class="line">| Offset | 0    | 1    | 2    | 3    |</span><br><span class="line">| ------ | ---- | ---- | ---- | ---- |</span><br><span class="line">| Data   | 0x11 | 0x22 | 0x33 | 0x44 |</span><br></pre></td></tr></table></figure>
<p>我們會得到 <code>[17, 34, 51, 68]</code> 的 Array。</p>
<p>當我們需要一次存取多 bytes，例如這個範例的記憶體區塊其實是一個 32 bit 的整數，那實際代表的數字會是多大？是 <code>0x11223344</code>（十進位：287454020) 嗎？</p>
<p>這其實牽扯到 CPU 的設計，目前市面上的多數 CPU 處理 multi-bytes 的資料時，大多從「最低有效位（LSB，least significant byte）」，也就是從權重最小的位數開始寫入。所以讀取這筆資料時，最前面的記憶體 offset 就是最權重最小的 bytes，所以最後會得到 <code>0x44332211</code>（十進位：1144201745）。這種存取排序，我們稱之為 <strong>Little-endian</strong>。</p>
<p>有最低，當然就有最高，<strong>Big-endian</strong> 則是從「最高有效位（MSB，most significant byte）」開始存取。因此照著記憶體位址依序讀取，會得到跟記憶體 offset 順序相同的 <code>0x11223344</code>。Big-endian 雖然在個人電腦中不常見，但許多網路協議和設備都是採用 Big-endian 存取資料，佔有一定的重要性。</p>
<p>Little-endian 和 Big-endian 可以視為不同的電腦（CPU）講不同的語言，一個從右到左，另一個從左到右。其實在人類日常生活中也可以看到相同的現象，例如歐洲常用的日期格式為 day-month-year，ISO 國際標準則反之 year-month-day，所以，當你看到一個 17-09-07 的日期時，必須先判斷是否為 ISO 的標準，才能知道這場約會是在下禮拜的九月七日，抑或你需要一台時光機回到過去。</p>
<p><strong>Q：那在 JavaScipt 要如何處理 endian？</strong></p>
<p>如果不碰底層的記憶體操作，寫 JavaScript 是不用理會 endianness 的，但當你要操作 TypedArray 時，了解 data 的 endian 就至關重要了。<code>TypedArray</code> 預設是使用系統的 endianness，所以如果你接收一筆資料，與你的系統的 endianness 不一致，TypedArray 便使不上力。而前面介紹到 DataView 的 byte getter／setter 最後一個參數就是用來決定以哪種 byte order 存取資料，預設是 Big-endian（<code>false</code>），透過切換這個 flag，任何 binary data 都橫看成嶺側成峰了。</p>
<p><strong>Q：那我們要如何得知資料的 byte order？</strong></p>
<p>如果資料是自己家內部系統使用，其實溝通好就 OK，用 Mixed-endian 也不會有人管你。但如果是外界得來的任意資料，我們可以透過「<a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16" target="_blank" rel="noopener">BOM（byte order mark）</a>」來判斷資料屬於哪種 endianness。BOM 是一個 Unicode  magic number，通常放置在 text stream 的最前端。不過，並不是每個資料都會加上這個 header，而且有時候我們不需要 BOM 資訊，使用資料前還必須先 <a href="https://www.npmjs.com/package/strip-bom" target="_blank" rel="noopener">strip bom</a>，說實話挺麻煩的。</p>
<h3 id="Data-Structure-Alignment"><a href="#Data-Structure-Alignment" class="headerlink" title="Data Structure Alignment"></a>Data Structure Alignment</h3><p>要接觸底層的記憶體，免不了瞭解 CPU 如何從記憶體中讀取資料，記憶體底層到底如何配置。</p>
<p>一般來說，現代的 CPU 通常設計以 word 為單位（例如 4 bytes）讀寫記憶體裡的資料，而資料對齊（data aligment）則是將資料放置在 word-size * n 倍的記憶體位址上，使 CPU 以最為有效率的方式讀寫。那為什麼對齊 word-size 會最有效率呢？假設有個 C struct 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignDemo</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;     <span class="comment">// 1 byte</span></span><br><span class="line">  <span class="keyword">int</span> i;      <span class="comment">// 4 bytes</span></span><br><span class="line">  <span class="keyword">short</span> s;      <span class="comment">// 2 bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>理論上的記憶體配置如下，總共需要 7 bytes 的記憶體空間。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = char 所佔的 byte</span><br><span class="line">s = short 所佔的 byte</span><br><span class="line">i = int 所佔的 byte</span><br><span class="line"></span><br><span class="line">| 0x000           | 0x020           |</span><br><span class="line">| [c] [i] [i] [i] | [i] [s] [s] [ ] |</span><br></pre></td></tr></table></figure>
<p>前面提到 CPU 是以 word-size 存取記憶體上的資料，當嘗試讀取 char 和 short 時並沒有什麼問題，CPU 只需取一次 word chunk 再 offset 就可取得正確的值。然而，當欲讀取 int 時，CPU 需先取第一個 data chunk 以獲取 int 前三個 bytes，再取第二個 word chunk 並 shift 資料，以取得 int 最後一個 byte。如此多餘的記憶體存取會造成 CPU 額外的負擔。</p>
<p>解決方法是 <strong>Data Structure Padding</strong>，也就是在資料無法對齊 word-size 時，加上一些填充用的成員。</p>
<p>在我們的例子中，可以這樣做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignDemo</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">char</span> padding_0[<span class="number">3</span>]; <span class="comment">// 填充用成員</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">short</span> s;</span><br><span class="line">  <span class="keyword">char</span> padding_1[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>記憶體配置則如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = padding 所佔的 byte</span><br><span class="line"></span><br><span class="line">| 0x000           | 0x020           | 0x040           |</span><br><span class="line">| [c] [p] [p] [p] | [i] [i] [i] [i] | [s] [s] [p] [p] |</span><br></pre></td></tr></table></figure>
<p>本來只需要 7 bytes，對個齊後，反而用掉這麼多額外的 bytes，你玩我嗎？</p>
<p>我們可以試著改變一下 struct member 的順序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignDemo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">short</span> s;</span><br><span class="line">  <span class="keyword">char</span> padding[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>記憶體配置對應改變，只佔用 8 bytes。Brilliant！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 0x000           | 0x020           |</span><br><span class="line">| [i] [i] [i] [i] | [c] [s] [s] [p] |</span><br></pre></td></tr></table></figure>
<p>結構對齊（struct alignment）在 C 語言中是一門不小學問，除了結構內的成員本身要對齊，結構本身也要對齊。</p>
<p>回到 JavaScript，當你在創建不同的 view 時，JavaScript engine 其實會進行簡單的 <a href="https://stackoverflow.com/a/25658188" target="_blank" rel="noopener">natural alignment</a> 檢查。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buffer, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// RangeError: start offset of Uint16Array should be a multiple of 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// RangeError: byte length of Uint32Array should be a multiple of 4</span></span><br></pre></td></tr></table></figure>
<p>所以囉，當我們在設計複合資料時，想想對應的 C struct alignment，多考量記憶體底層，才不會讓操作 binary data 產生效能低落的反效果。</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>最後，讓我們來認識除了 Typed Array 家族以外，JavaScript 的生態圈其他與記憶體息息相關的成員吧！</p>
<h3 id="Node-js-Buffer"><a href="#Node-js-Buffer" class="headerlink" title="Node.js Buffer"></a>Node.js <code>Buffer</code></h3><p>早在 ES6 引入 TypedArray 之前，Node.js 為了處理 binary data，就實作 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html" target="_blank" rel="noopener">Buffer class</a>，也針對 V8 引擎做最佳化。Buffer 在 Node.js 的環境中是 Global object，其功能可視為 ArrayBuffer + TypedArray + DataView 的複合體，甚至可以配置 non-zero-filled 的 unsafe buffer，好危險啊。</p>
<p>在使用上，Buffer 可從 ArrayBuffer 建構，也可從自身建構 TypedArray。事實上，Node.js v3+ 之後，Buffer 就繼承自 <code>Uint8Array</code> 了，不過有些 memory share／copy 的實作與 spec 有出入，在與 TypedArray<br> ArrayBuffer 轉換時，<a href="https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_buffers_and_typedarray" target="_blank" rel="noopener">需注意這些小細節</a>。</p>
<h3 id="Web-API-Blob"><a href="#Web-API-Blob" class="headerlink" title="Web API Blob"></a>Web API <code>Blob</code></h3><p><a href="https://w3c.github.io/FileAPI/#blob" target="_blank" rel="noopener">Blob</a> 是一個不可變（immutable）的 raw binary sequence，只有兩個 attribute 和一個 method。</p>
<ul>
<li><code>size</code>：blob 實例的 byte 大小。</li>
<li><code>type</code>：blob 實例的 <a href="https://en.wikipedia.org/wiki/MIME" target="_blank" rel="noopener">MIME type</a>。</li>
<li><code>slice</code>：切割一部分的 blob 實例，返回新的 blob。</li>
</ul>
<p>Blob 的 spec 寫在 <a href="https://w3c.github.io/FileAPI/#blob" target="_blank" rel="noopener">W3C File API draft</a> 中，為 <code>File</code> class 的父類別。主要目的是提供可代表與儲存 JavaScript native 以外的格式，例如以 blob 儲存 <strong>死肥宅.jpg</strong>。Blob 除了可以從 object 建構，也可傳入 TypedArray 或 DOMString 建構。此外，File API，Fetch API、XMLHttpRequest v2 也都可以將 Request／Response 的 body 轉換成 Blob，非常泛用途呢！</p>
<p>而 Blob 最強大的地方就是配合 <code>URL.createObjectURL</code> 生成一個 Blob URL。如同你我認知中的 URL，任何運用 URL 之處，都可以傳入 Blob URL，比起 <code>Image</code>、<code>ImageData</code>、<code>MediaSource</code>，URL 接受與使用度肯定更為廣闊，這讓資料處理，物件傳遞的耦合性變得更低。</p>
<p>當我們建立 Blob URL 後，若可預期的未來內不需要用到該 URL，就使用 <code>URL.revokeObjectURL</code> 取消註冊，否則該 URL 指向的 Blob 會持續留存，佔用你的儲存空間，直到瀏覽器執行 unload document cleanup 的步驟（如關閉分頁），才會將所有 Blob URL 清除。所以說，如需管理 Blob URL，還是老老實實把這些 URL 記錄起來吧！</p>
<h2 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap-up"></a>Wrap-up</h2><p>藉由這些直接操作 binary data 的 API，現代的 JavaScript 環境的效能提升到另一個層次，若再配合 Web worker  Service worker 等多線程技術，加上線程共享的 <code>ShareArrayBuffer</code> 與 <code>Atomic</code> API，高效能的 web app 指日可待。如果再加上逐漸普及，<a href="https://medium.com/webpack/webpack-awarded-125-000-from-moss-program-f63eeaaf4e15" target="_blank" rel="noopener">即將成為 Webpack 一等公民</a> 的 <a href="http://webassembly.org/" target="_blank" rel="noopener">WebAssembly</a>，JavaScript／Web 的世界更是不可限量啊！或許，使用 Rust 寫網頁的世代即將來臨 XD。</p>
<p>前端工程師們，活到老，學到掛吧！</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">MDN: ArrayBuffer</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="noopener">MDN: TypedArray</a></li>
<li><a href="https://w3c.github.io/FileAPI/#blob" target="_blank" rel="noopener">W3C: File API - Blob</a></li>
<li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment" target="_blank" rel="noopener">Wiki: Data structure alignment</a></li>
<li><a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener">Wiki: Endianness</a></li>
<li><a href="https://en.wikipedia.org/wiki/Integer_overflow" target="_blank" rel="noopener">Wiki: Integer overflow</a></li>
<li><a href="https://www.html5rocks.com/en/tutorials/webgl/typed_arrays/" target="_blank" rel="noopener">HTML5 Rocks: Typed Arrays</a></li>
<li><a href="https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html" target="_blank" rel="noopener">Node.js: Buffer</a></li>
<li><a href="http://opass.logdown.com/posts/743054-about-memory-alignment" target="_blank" rel="noopener">OPass：關於記憶體對齊(Alignment) </a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/arraybuffer" target="_blank" rel="noopener">阮一峰：ECMAScript 6 入门</a></li>
</ul>
<p>關於作者：<br><a href="https://weihanglo.github.io" target="_blank" rel="noopener">@weihanglo</a> 掛著 iOS 工程師之名，行開發 Web App 之實。</p>
  
      <div>喜歡我們的文章嗎？歡迎分享按讚給予我們支持和鼓勵！</div>
      <div class="fb-like" data-href="https://blog.techbridge.cc/2017/09/24/binary-data-manipulations-in-javascript/index.html" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>
      <br>
      <br>
      <div class="fb-page" data-href="https://www.facebook.com/techbridge.cc" data-small-header="false" data-adapt-container-width="true" data-hide-cover="false" data-show-facepile="true"><blockquote cite="https://www.facebook.com/techbridge.cc" class="fb-xfbml-parse-ignore"><a href="https://www.facebook.com/techbridge.cc">TechBridge 技術日報</a></blockquote></div>
      <br>
    </section>
    <br>
    <hr>
    <div>
      <h4>訂閱 TechBridge Weekly 技術週刊，每週發送最精華的技術開發、產品設計的資訊給您</h4>
      <form class="form-control" method="post" action="https://goodbits.io/e/cab8a418-6b70-48d6-97ea-b5f0ef34b22c" target="_blank">
        <input class="form-control" type="text" name="first_name" placeholder="First Name"></input>
        <input class="form-control" type="text" name="last_name" placeholder="Last Name"></input>
        <div>
          <input class="form-control" type="text" name="email" placeholder="Email"></input>
        </div>
        <br>
        <div>
          <button class="form-control btn subscribe-btn" type="submit">馬上訂閱技術週刊</button>
        </div>
        <br>
        <label for="">PS. 我們討厭垃圾信，所以我們只提供有價值的內容給您 :)</label>
      </form>
    </div>
    <footer class="post-footer">
      <section class="author">
    <h4>TechBridge Weekly 技術週刊編輯團隊</h4>
    <p>TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、資料科學與產品設計等技術分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robotics, IoT, Data Science technology sharing.</p>
    <span><a href="/2016/03/19/about/">關於我們</a></span> / <span><a href="https://www.techbridge.cc/" target="_blank">技術日報</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>   
	<div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-size="large" data-action="like" data-show-faces="false" data-share="true"></div>    
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=https://blog.techbridge.cc/2017/09/24/binary-data-manipulations-in-javascript/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.techbridge.cc/2017/09/24/binary-data-manipulations-in-javascript/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=https://blog.techbridge.cc/2017/09/24/binary-data-manipulations-in-javascript/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
    <iframe src="https://ghbtns.com/github-btn.html?user=TechBridgeHQ&repo=blog-starter-kit&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>      
</section>
    </footer>
    <br>
  </article>
  <nav class="pagination" role="pagination">
    <h2>更多優質技術文章</h2>
    
    <a class="newer-posts" href="/2017/09/30/cpp-header-guard/">
        ← C++ Header Guard 簡介
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2017/09/23/webvr-d3/">
        D3v4 工作坊 - WebVR 與資料視覺化 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">留言討論</a></h1>

    
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    
</div>
</main>


  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75308642-1', 'auto');
  ga('send', 'pageview');

</script>
<footer class="site-footer">
  
  <a class="subscribe icon-feed" href="/atom.xml"><span class="tooltip">Subscribe!</span></a>
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">TechBridge 技術共筆部落格</a> &copy; 2017 &bull; All rights reserved.</section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>


<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '[object Object]']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>


<script type="text/javascript">
    var disqus_shortname = 'techbridgeweekly';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.4/dist/medium-zoom.min.js"></script>
<script>
// NodeList
mediumZoom(document.querySelectorAll('img'));
</script>
  <div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, 'script', 'facebook-jssdk'));</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
