<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>希望是最淺顯易懂的 RxJS 教學 | TechBridge 技術共筆部落格</title>
  <meta name="description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- google-site-verification -->
  <meta name="google-site-verification" content="WX_9sZlrIYOEpy8RR7zCoa7-pJk611zZt11BSBUcDVY">
  <link rel="stylesheet preload" type="text/css" href="/css/screen.css" as="style">
  <link rel="stylesheet preload" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" as="style">

  <!-- Favicons -->
  <link rel="apple-touch-icon" href="/img/favicon.ico">
  <link rel="icon preload" href="/img/favicon.ico" as="image">

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
  

  
</head>


<body class="post-template">

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="site-head" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="/img/logo-tb-500-500.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">TechBridge 技術共筆部落格</h1>
            <h2 class="blog-description">var topics = ['Web前後端', '行動網路', '機器人/物聯網', '數據分析', '產品設計', 'etc.']</h2>
            <div class="navbar-block">
                <span><a href="/">首頁</a></span> / <span><a href="/about/">關於我們</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>
                <br>
            </div>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-12-08T22:55:15.000Z" itemprop="datePublished">
          2017-12-08
      </time>
    
    
    | 
    <a href='/tags/rxjs/'>rxjs</a>
    
    
</span>

<meta name="generator" content="希望是最淺顯易懂的 RxJS 教學">
<meta name="og:title" content="希望是最淺顯易懂的 RxJS 教學">
<meta name="og:description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享。">
<meta name="og:type" content="website">
<meta name="og:image" content="/img/og-cover.png">

    <h1 class="post-title">希望是最淺顯易懂的 RxJS 教學</h1>
    <section class="post-content">
      <div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>   
      <hr>
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>關注 RxJS 已經好一段時間了，最早知道這個東西是因為 <a href="https://redux-observable.js.org/" target="_blank" rel="noopener">redux-observable</a>，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連<code>redux-saga</code>都還沒搞懂，沒想到就又有新的東西出來了。</p>
<p>半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學者無所適從。</p>
<p>這次有機會在公司的新專案裡面嘗試導入<code>redux-observable</code>，身為提倡要導入的人，勢必要對這東西有一定的瞭解。秉持著這個想法，上週認真花了點時間再次把相關資源都研究了一下，漸漸整理出一套「我覺得應該可以把 RxJS 講得更好懂」的方法，在這邊跟大家分享一下。</p>
<p>在開始之前，要先大力稱讚去年 iT 邦幫忙鐵人賽的 Web 組冠軍：<a href="https://ithelp.ithome.com.tw/users/20103367/ironman/1199" target="_blank" rel="noopener">30 天精通 RxJS</a>，這系列文章寫得很完整，感受得出來作者下了很多功夫在這上面。看完這篇之後如果對更多應用有興趣的，可以去把這系列的文章讀完。</p>
<p>好，那就讓我們開始吧！</p>
<h1 id="請你先忘掉-RxJS"><a href="#請你先忘掉-RxJS" class="headerlink" title="請你先忘掉 RxJS"></a>請你先忘掉 RxJS</h1><p>沒錯，你沒看錯。</p>
<p>要學會 RxJS 的第一件事情就是：忘記它。</p>
<p>忘記有這個東西，完全忘記，先讓我講幾個其他東西，等我們需要講到 RxJS 的時候我會再提醒你的。</p>
<p>在我們談到主角之前，先來做一些有趣的事情吧！</p>
<h1 id="程式基礎能力測試"><a href="#程式基礎能力測試" class="headerlink" title="程式基礎能力測試"></a>程式基礎能力測試</h1><p>先讓我們做一個簡單的練習題暖身，題目是這樣的：</p>
<blockquote>
<p>有一個陣列，裡面有三種類型的資料：數字、a~z組成的字串、數字組成的字串，請你把每個數字以及數字組成的字串乘以二之後加總<br>範例輸入：[1, 5, 9, 3, ‘hi’, ‘tb’, 456, ‘11’, ‘yoyoyo’]</p>
</blockquote>
<p>你看完之後應該會說：「這有什麼難的？」，並且在一分鐘以內就寫出下面的程式碼：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="string">'hi'</span>, <span class="string">'tb'</span>, <span class="number">456</span>, <span class="string">'11'</span>, <span class="string">'yoyoyo'</span>];</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(source[i], <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(num)) &#123;</span><br><span class="line">    total += num * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信大家一定都是很直覺的就寫出上面的程式碼，但如果你是個 functional programming 的愛好者，你可能會改用另外一種思路來解決問題：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="string">'hi'</span>, <span class="string">'tb'</span>, <span class="number">456</span>, <span class="string">'11'</span>, <span class="string">'yoyoyo'</span>];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> total = source</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x, <span class="number">10</span>))</span><br><span class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> !<span class="built_in">isNaN</span>(x))</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br><span class="line">  .reduce(<span class="function">(<span class="params">total, value</span>) =&gt;</span> total + value )</span><br></pre></td></tr></table></figure>
<p>一開始的例子叫做<code>Imperative（命令式）</code>，用陣列搭配一堆函式的例子叫做<code>Declarative（聲明式）</code>。如果你去查了一下定義，應該會看到這兩個的解釋：</p>
<blockquote>
<p>Imperative 是命令機器去做事情（how），這樣不管你想要的是什麼（what），都會按照你的命令實現；Declarative 是告訴機器你想要的是什麼（what），讓機器想出如何去做（how）</p>
</blockquote>
<p>好，你有看懂上面這些在說什麼嗎？</p>
<p>我是沒有啦。</p>
<p>所以讓我們再看一個例子，其實 Declarative 你已經常常在用了，只是你不知道而已，那就是 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> dogs <span class="keyword">INNER</span> <span class="keyword">JOIN</span> owners <span class="keyword">WHERE</span> dogs.owner_id = owners.id</span><br></pre></td></tr></table></figure>
<p>這句話就是：我要所有狗的資料加上主人的資料。</p>
<p>我只有說「我要」而已，那要怎麼拿到這些資料？我不知道，我也不用知道，都讓 SQL 底層決定怎麼去操作就好。</p>
<p>如果我要自己做出這些資料，在 JavaScript 裡面我必須這樣寫（程式碼取自<a href="http://www.vaikan.com/imperative-vs-declarative/" target="_blank" rel="noopener">声明式编程和命令式编程的比较</a>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dogs = [&#123;name: 'Fido', owner_id: 1&#125;, &#123;...&#125;, ... ]</span></span><br><span class="line"><span class="comment">//owners = [&#123;id: 1, name: 'Bob'&#125;, &#123;...&#125;, ...]</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dogsWithOwners = []</span><br><span class="line"><span class="keyword">var</span> dog, owner</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> di=<span class="number">0</span>; di &lt; dogs.length; di++) &#123;</span><br><span class="line">  dog = dogs[di]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> oi=<span class="number">0</span>; oi &lt; owners.length; oi++) &#123;</span><br><span class="line">    owner = owners[oi]</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; dog.owner_id == owner.id) &#123;</span><br><span class="line">      dogsWithOwners.push(&#123;</span><br><span class="line">        dog: dog,</span><br><span class="line">        owner: owner</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>應該可以大致體驗出兩者的差別吧？後者你必須自己一步步去決定該怎麼做，而前者只是僅僅跟你說：「我想要怎樣的資料」而已。</p>
<p>接著我們再把目光放回到把數字乘以二相加的那個練習。對我來說，最大的不同點是後面那個用陣列搭配函式的例子，他的核心概念是：</p>
<blockquote>
<p>把原始資料經過一連串的轉換，變成你想要的資訊</p>
</blockquote>
<p>這點超級重要，因為在一開始的例子中，我們是自己一步步去 parse，去檢查去相加，得出數字的總和。而後面的那個例子，他是把原始的資料（陣列），經過一系列的轉換（map, filter, reduce），最後變成了我們想要的答案。</p>
<p>畫成圖的話，應該會長這樣（請原諒我偷懶把乘二的部分拿掉了，但意思不影響）：</p>
<p><img src="/img/huli/rxjs/map.png" alt></p>
<p>把原始資料經過一連串的轉換，最後變成你想要的答案，這點就是後者最大的不同。只要你有了這個基礎知識之後，再來看 RxJS 就不會覺得太奇怪了。</p>
<h1 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h1><p>談到 RxJS 的時候，都會談到 Reactive 這個詞，那什麼是 Reactive 呢？可以從英文上的字義來看，這個單字的意思是：「反應、反應性的」，意思就是你要對一些事情做出反應。</p>
<p>所以 Reactive 其實就是在講說：「某些事情發生時，我能夠做出反應」。</p>
<p>讓我們來舉一個大家非常熟知的例子：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click!'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我們加了一個 event listener 在 window 上面，所以我們可以監聽到這個事件，每當使用者點擊的時候就列印出 log。換句話說，這樣就是：「當 window 被點擊時，我可以做出反應」。</p>
<h1 id="正式進入-RxJS"><a href="#正式進入-RxJS" class="headerlink" title="正式進入 RxJS"></a>正式進入 RxJS</h1><p>如果你去看 <a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> 的網頁，你會發現他有明確的定義 ReactiveX：</p>
<blockquote>
<p>ReactiveX is a combination of the best ideas from<br>the Observer pattern, the Iterator pattern, and functional programming</p>
</blockquote>
<p>第一個 Observer pattern 就像是 event listener 那樣，在某些事情發生時，我們可以對其作出反應；第二個 Iterator pattern 我們跳過不講，我認為暫時不影響理解；第三個就像是一開始的例子，我們可以把一個陣列經過多次轉換，轉換成我們想要的資料。</p>
<p>在 Reactive Programming 裡面，最重要的兩個東西叫做 Observable 跟 Observer，其實一開始讓我最困惑的點是因為我英文不好，不知道這兩個到底誰是觀察的誰是被觀察的。</p>
<p>先把它們翻成中文，Observable 就是「可被觀察的」，Observer 就是所謂的「觀察者」。</p>
<p>這是什麼意思呢？就如同上面的例子一樣，當（可被觀察的東西）有事情發生，（Observer，觀察者）就可以做出反應。</p>
<p>直接舉一個例子你就知道了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="built_in">window</span>, <span class="string">'click'</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click~'</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>上面這段程式碼跟我幫 window 加上 event listener 在做的事情完全一樣，只是這邊我們使用了 RxJS 提供的方法叫做<code>fromEvent</code>，來把一個 event 轉成 Observable（可被觀察的），並且在最後加上 subscribe。</p>
<p>這樣寫就代表說我訂閱了這個 Observable，只要有任何事情發生，就會執行我傳進去的 function。</p>
<p>所以到底什麼是 Observable？</p>
<p>Observable 就是一個可被觀察的對象，這個對象可以是任何東西（例如說上述例子就是 window 的 click 事件），當有新資料的時候（例如說新的點擊事件），你就可以接收到這個新資料的資訊並且做出反應。</p>
<p>比起 Observable 這個冷冰冰的說法，我更喜歡的一個說法是 stream，資料流。其實每一個 Observable 就是一個資料流，但什麼是資料流？你就想像成是會一直增加元素的陣列就好了，有新的事件發生就 push 進去。如果你喜歡更專業一點的說法，可以叫它：「時間序列上的一連串資料事件」（取自 <a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/">Reactive Programming 簡介與教學(以 RxJS 為例)</a>）</p>
<p>或是我再舉一個例子，stream 的另外一個解釋就是所謂的「串流影片」，意思就是隨著你不斷播放，就會不斷下載新的片段進來。此時你腦中應該要有個畫面，就是像水流那樣，不斷有新的東西流進來，這個東西就叫做 stream。</p>
<p><img src="https://media.giphy.com/media/xIkKIodaqNBdK/giphy.gif" alt><br>（圖片取自 <a href="https://media.giphy.com/media/xIkKIodaqNBdK/giphy.gif" target="_blank" rel="noopener">giphy</a>）</p>
<h1 id="我理解資料流了，然後呢？"><a href="#我理解資料流了，然後呢？" class="headerlink" title="我理解資料流了，然後呢？"></a>我理解資料流了，然後呢？</h1><p>上面有說過，我們可以把任何一個東西轉成 Observable，讓它變成資料流，可是這不就跟 addEventListener 一樣嗎？有什麼特別的？</p>
<p>有，還真的比較特別。</p>
<p>希望你沒有忘記我們剛開始做的那個小練習，就是把一個陣列透過一系列轉換，變成我們要的資料的那個練習。我剛剛有說，你可以把 Observable 想成是「會一直增加元素的陣列」，這代表什麼呢？</p>
<p>代表我們也可以把 Observable 做一系列的轉換！我們也可以用那些用在陣列上的 function！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="built_in">window</span>, <span class="string">'click'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click: '</span>, value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/img/huli/rxjs/click.gif" alt></p>
<p>我們把 click 事件經過 map 轉換為點擊到的 element，所以當我們最後在 subscribe 的時候，收到的 value 就會是我們點擊的東西。</p>
<p>接著來看一個稍微進階一點的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="built_in">window</span>, <span class="string">'click'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> <span class="number">1</span>)</span><br><span class="line">  .scan(<span class="function">(<span class="params">total, now</span>) =&gt;</span> total + now)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#counter'</span>).innerText = value;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/img/huli/rxjs/counter.gif" alt></p>
<p>首先我們先把每一個 click 事件都透過<code>map</code>轉換成 1（或者你也可以寫成<code>.mapTo(1)</code>），所以每按一次就送出一個數字 1。<code>scan</code>的話其實就是我們一開始對陣列用的<code>reduce</code>，你可以想成是換個名字而已。透過<code>scan</code>加總以後傳給 subscriber，顯示在頁面上面。</p>
<p>就這樣簡單幾行，就完成了一個計算點擊次數的 counter。</p>
<p>可以用一個簡單的 gif 圖來表示上面的範例：</p>
<p><img src="/img/huli/rxjs/click_stream.gif" alt></p>
<p>可是 Observable 不只這樣而已，接下來我們要進入到它最厲害的地方了。</p>
<h1 id="威力無窮的組合技"><a href="#威力無窮的組合技" class="headerlink" title="威力無窮的組合技"></a>威力無窮的組合技</h1><p>如果把兩個陣列合併，會變成什麼？例如說<code>[1, 2, 3]</code>跟<code>[4, 5, 6]</code>？</p>
<p>這要看你指的「合併」是什麼，如果是指串接，那就是<code>[1, 2, 3, 4, 5, 6]</code>，如果是指相加，那就是<code>[5, 7, 9]</code>。</p>
<p>那如果把兩個 Observable 合併會變成什麼？</p>
<p>Observable 跟陣列的差別就在於多了一個維度：時間。</p>
<p>Observable 是「時間序列上的一連串資料事件」，就像我前面講的一樣，可以看成是一個一直會有新資料進來的陣列。</p>
<p>我們先來看看一張很棒的圖，很清楚地解釋了兩個 Observable 合併會變成什麼：</p>
<p><img src="/img/huli/rxjs/merge.png" alt><br>（取自：<a href="http://rxmarbles.com/#merge）" target="_blank" rel="noopener">http://rxmarbles.com/#merge）</a></p>
<p>上面是一個 Observable，每一個圓點代表一個資料，下面也是一樣，把這兩個合併之後就變成最下面那一條，看圖解應該還滿好懂的，就像是把兩個時間軸合併一樣。</p>
<p>讓我們來看一個可以展現合併強大之處的範例，我們有 +1 跟 -1 兩個按鈕以及文字顯示現在的數字是多少：</p>
<p><img src="/img/huli/rxjs/counter_adv.gif" alt></p>
<p>該怎麼達成這個功能呢？基本的想法就是我們先把每個 +1 的 click 事件都通過<code>mapTo</code>變成數字 1，取叫 Observable_plus1 好了。再做出一個 Observable_minus1 是把每個 -1 的 click 事件都通過<code>mapTo</code>變成數字 -1。</p>
<p>把這兩個 Observable 合併之後，再利用剛剛提到的<code>scan</code>加總，就是目前應該要顯示的數字了！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'input[name=plus]'</span>), <span class="string">'click'</span>)</span><br><span class="line">  .mapTo(<span class="number">1</span>)</span><br><span class="line">  .merge(</span><br><span class="line">    Rx.Observable.fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'input[name=minus]'</span>), <span class="string">'click'</span>)</span><br><span class="line">      .mapTo(<span class="number">-1</span>)</span><br><span class="line">  )</span><br><span class="line">  .scan(<span class="function">(<span class="params">total, now</span>) =&gt;</span> total + now)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#counter'</span>).innerText = value;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>如果你還是不懂的話，可以參考下面的精美範例，示範這兩個 Observable 是怎麼合在一起的（<code>O</code>代表點擊事件，<code>+1</code>跟<code>-1</code>則是<code>mapTo</code>之後的結果）：</p>
<p><img src="/img/huli/rxjs/plus.gif" alt></p>
<p>讓我們來比較一下如果不用 Observable 的話，程式碼會長怎樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[name=plus]'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  total++;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#counter'</span>).innerText = total;</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[name=minus]'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  total--;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#counter'</span>).innerText = total;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有沒有發覺兩者真的差別很大？就如同我之前所說的，是兩種完全不同的思考模式，所以 Reactive Programming 困難的地方不是在於理解，也不是在於語法（這兩者相信你目前都有些概念了），而是在於換一種全新的思考模式。</p>
<p>以上面的寫法來說，就是告訴電腦：「按下加的時候就把一個變數 +1，然後更改文字；按下減的時候就 -1 並且也更改文字」，就可以達成計數器的功能。</p>
<p>以 Reactive 的寫法，就是把按下加當成一個資料流，把按下減也當成一個資料流，再透過各種 function 把這兩個流轉換並且合併起來，讓最後的那個流就是我們想要的結果（計數器）。</p>
<p>你現在應該能體會到我一開始說的了：「把原始資料經過一連串的轉換，最後變成你想要的答案」，這點就是 Reactive Programming 最大的特色。</p>
<h1 id="組合技中的組合技"><a href="#組合技中的組合技" class="headerlink" title="組合技中的組合技"></a>組合技中的組合技</h1><p>我們來看一個更複雜一點的範例，是在 canvas 上面實現非常簡單的繪圖功能，就是滑鼠按下去之後可以畫畫，放開來就停止。</p>
<p><img src="/img/huli/rxjs/draw.gif" alt></p>
<p>要實現這個功能很間單，canvas 提供<code>lineTo(x, y)</code>這個方法，只要在滑鼠移動時不斷呼叫這個方法，就可以不斷畫出圖形來。但有一點要注意的是當你在按下滑鼠時，應該先呼叫<code>moveTo(x, y)</code>把繪圖的點移到指定位置，為什麼呢？</p>
<p>假設我們第一次畫圖是在左上角，第二次按下滑鼠的位置是在右下角，如果沒有先用<code>moveTo</code>移動而是直接用<code>lineTo</code>的話，就會多一條線從左上角延伸到右下角。<code>moveTo</code>跟<code>lineTo</code>的差別就是前者只是移動，後者會跟上次的點連接在一起畫成一條線。</p>
<p><img src="/img/huli/rxjs/draw2.gif" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath(); <span class="comment">// 開始畫畫</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  ctx.lineTo(e.clientX,e.clientY); <span class="comment">// 移到滑鼠在的位置</span></span><br><span class="line">  ctx.stroke(); <span class="comment">// 畫畫</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 按下去滑鼠才開始偵測 mousemove 事件</span></span><br><span class="line">canvas.addEventListener(<span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  ctx.moveTo(e.clientX, e.clientY); <span class="comment">// 每次按下的時候必須要先把繪圖的點移到那邊，否則會受上次畫的位置影響</span></span><br><span class="line">  canvas.addEventListener(<span class="string">'mousemove'</span>, draw);</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 放開滑鼠就停止偵測 </span></span><br><span class="line">canvas.addEventListener(<span class="string">'mouseup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  canvas.removeEventListener(<span class="string">'mousemove'</span>, draw);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那如果在 RxJS 裡面，該怎麼實作這個功能呢？</p>
<p>首先憑直覺，應該就是先加上<code>mousedown</code>的事件對吧！至少有個開頭。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="string">'mousedown'</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mousedown'</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>可是滑鼠按下去之後應該要變成什麼？這個時候應該要開始監聽<code>mousemove</code>對吧，所以我們這樣寫，用<code>mapTo</code>把每一個<code>mousedown</code>的事件都轉換成<code>mousemove</code>的 Observable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="string">'mousedown'</span>)</span><br><span class="line">  .mapTo(</span><br><span class="line">    Rx.Observable.fromEvent(canvas, <span class="string">'mousemove'</span>)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'value: '</span>, value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>接著你看一下 console，你會發現每當我點擊的時候，console 就會印出<code>FromEventObservable {_isScalar: false, sourceObj: canvas#canvas, eventName: &quot;mousemove&quot;, selector: undefined, options: undefined}</code></p>
<p>仔細想一下你會發現也滿合理的，因為我用<code>mapTo</code>把每一個滑鼠按下去的事件轉成一個 mousemove 的 Observable，所以用 subscribe 訂閱之後拿到的東西就會是這個 Observable。如果畫成圖，大概長得像這樣：</p>
<p><img src="/img/huli/rxjs/flat.png" alt></p>
<p>好了，那怎麼辦呢？我想要的其實不是 Observable 本身，而是屬於這個 Observable 裡面的那些東西啊！現在這個情形就是 Observable 裡面又有 Observable，有兩層，可是我想要讓它變成一層就好，該怎麼辦呢？</p>
<p>在此提供一個讓 Observable 變簡單的訣竅：</p>
<blockquote>
<p>只要有問題，先想想 Array 就對了！</p>
</blockquote>
<p>我前面有提過，可以把 Observable 看成是加上時間維度的進階版陣列，因此只要是陣列有的方法，Observable 通常也都會有。</p>
<p>舉例來說，一個陣列可能長這樣：<code>[1, [2, 2.5], 3, [4, 5]]</code>一共有兩層，第二層也是一個陣列。</p>
<p>如果想讓它變一層的話怎麼辦呢？壓平！</p>
<p>有用過 lodash 或是其他類似的 library 的話，你應該有聽過<code>_.flatten</code>這個方法，可以把這種陣列壓平，變成：<code>[1, 2, 2.5, 3, 4, 5]</code>。</p>
<p>用 flat 這個關鍵字去搜尋 Rx 文件的話，你會找到一個方法叫做 <a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">FlatMap</a>，簡單來說就是先<code>map</code>之後再自動幫你壓平。</p>
<p>所以，我們可以把程式碼改成這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="string">'mousedown'</span>)</span><br><span class="line">  .flatMap(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="string">'mousemove'</span>))            </span><br><span class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>當你點擊之後，會發現隨著滑鼠移動，console 會印出一大堆 log，就代表我們成功了。</p>
<p>畫成示意圖的話會變成這樣（為了方便說明，我把<code>flatMap</code>在圖片上變成<code>map</code>跟<code>flatten</code>兩個步驟）：</p>
<p><img src="/img/huli/rxjs/flat2.png" alt></p>
<p>接下來呢？接下來我們要讓它可以在滑鼠鬆開的時候停止，該怎麼做呢？RxJS 有一個方法叫做<code>takeUntil</code>，意思就是拿到…發生為止，傳進去的參數必須是一個 Observable。</p>
<p>舉例來說，如果寫<code>.takeUntil(window, &#39;click&#39;)</code>，就表示如果任何<code>window</code>的點擊事件發生，這個 Observable 就會立刻終止，不會再送出任何資料。</p>
<p>應用在繪畫的例子上，我們只要把<code>takeUntil</code>後面傳的參數換成滑鼠鬆開就好！順便把<code>subscribe</code>跟畫畫的 function 也一起完成吧！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="string">'mousedown'</span>)</span><br><span class="line">  .flatMap(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="string">'mousemove'</span>))</span><br><span class="line">  .takeUntil(Rx.Observable.fromEvent(canvas, <span class="string">'mouseup'</span>))         </span><br><span class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    draw(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>改完之後馬上來實驗一下！滑鼠按下去之後順利開始畫圖，鬆開以後畫圖停止，完美！</p>
<p>咦，可是怎麼按下第二次就沒反應了？我們做出了一個「只能夠成功畫一次圖」的 Observable。</p>
<p>為什麼呢？我們可以先來看一下<code>takeUntil</code>的示意圖（取自：<a href="http://rxmarbles.com/#takeUntil）" target="_blank" rel="noopener">http://rxmarbles.com/#takeUntil）</a></p>
<p><img src="/img/huli/rxjs/takeuntil.png" alt></p>
<p>以我們的情形來說，就是只要<code>mouseup</code>事件發生，「整個 Observable」就會停止，所以只有第一次能夠畫圖成功。但我們想要的其實不是這樣，我們想要的是只有<code>mousemove</code>停止而已，而不是整個都停止。</p>
<p>所以，我們應該把<code>takeUntil</code>放在<code>mousemove</code>的後面，也就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="string">'mousedown'</span>)</span><br><span class="line">  .flatMap(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="string">'mousemove'</span>)</span><br><span class="line">      .takeUntil(Rx.Observable.fromEvent(canvas, <span class="string">'mouseup'</span>))  </span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    draw(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>這樣子裡面的那個<code>mousemove</code>的 Observable 就會在滑鼠鬆開時停止發送事件，而我們最外層的這個 Observable 監聽的是滑鼠按下，會一直監聽下去。</p>
<p>到這邊其實就差不多了，但還有一個小 bug 要修，就是我們沒有在<code>mousedown</code>的時候利用<code>moveTo</code>移動，造成我們一開始說的那個會把上次畫的跟這次畫的連在一起的問題。</p>
<p>那怎麼辦呢？我已經把<code>mousedown</code>事件轉成其他資料流了，我要怎麼在<code>mousedown</code>的時候做事？</p>
<p>有一個方法叫做<code>do</code>，就是為了這種情形而設立的，使用時機是：「你想做一點事，卻又不想影響資料流」，有點像是能夠針對不同階段 subscribe 的感覺，<code>mousedown</code>的時候 subscribe 一次，最後要畫圖的時候又 subscribe 一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="string">'mousedown'</span>)</span><br><span class="line">  .do(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.moveTo(e.clientX, e.clientY)</span><br><span class="line">  &#125;)</span><br><span class="line">  .flatMap(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="string">'mousemove'</span>)</span><br><span class="line">      .takeUntil(Rx.Observable.fromEvent(canvas, <span class="string">'mouseup'</span>))  </span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    draw(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>到這邊，我們就順利完成了畫圖的功能。</p>
<p>如果你想試試看你有沒有搞懂，可以實作看看拖拉移動物體的功能，原理跟這個很類似，都是偵測滑鼠的事件並且做出反應。</p>
<h1 id="喝口水休息一下，下半場要開始了"><a href="#喝口水休息一下，下半場要開始了" class="headerlink" title="喝口水休息一下，下半場要開始了"></a>喝口水休息一下，下半場要開始了</h1><p>上半場的目標在於讓你理解什麼是 Rx，並且掌握幾個基本概念：</p>
<ol>
<li>一個資料流可以經過一系列轉換，變成另一個資料流</li>
<li>這些轉換基本上都跟陣列有的差不多，像是<code>map</code>、<code>filter</code>、<code>flatten</code>等等</li>
<li>你可以合併多個 Observable，也可以把二維的 Observable 壓平</li>
</ol>
<p>下半場專注的點則是在於實戰應用，並且圍繞著 RxJS 最適合的場景之一：API。</p>
<p>前面我們有提到說可以把 DOM 物件的 event 變成資料流，但除了這個以外，Promise 其實也可以變成資料流。概念其實也很簡單啦，就是 Promise 被 resovle 的時候就發送一個資料，被 reject 的時候就終止。</p>
<p>讓我們來看一個簡單的小範例，每按一次按鈕就會發送一個 request</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendRequest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'https://jsonplaceholder.typicode.com/posts/1'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Rx.Observable.fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'input[name=send]'</span>), <span class="string">'click'</span>)</span><br><span class="line">  .flatMap(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.fromPromise(sendRequest()))</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>這邊用<code>flatMap</code>的原因跟剛才的畫圖範例一樣，我們要在按下按鈕時，把原本的資料流轉換成新的資料流，如果只用<code>map</code>的話，會變成一個二維的 Observable，所以必須要用<code>flatten</code>把它壓平。</p>
<p>你可以試試看把<code>flatMap</code>改成<code>map</code>，你最後 subscribe 得到的值就會是一堆 Observable 而不是你想要的資料。</p>
<p>知道怎麼用 Rx 來處理 API 之後，就可以來做一個經典範例了：AutoComplete。</p>
<p>我在做這個範例的時候有極大部分參考<a href="https://ithelp.ithome.com.tw/articles/10188457" target="_blank" rel="noopener">30 天精通 RxJS(19): 實務範例 - 簡易 Auto Complete 實作</a>、<a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/">Reactive Programming 簡介與教學(以 RxJS 為例)</a>以及<a href="http://www.alloyteam.com/2016/12/learn-rxjs/" target="_blank" rel="noopener">构建流式应用—RxJS详解</a>，再次感謝這三篇文章。</p>
<p><img src="/img/huli/rxjs/auto.gif" alt></p>
<p>為了要讓大家能夠體會 Reactive Programming 跟一般的有什麼不一樣，我們先用老方法做出這個 Auto Complete 的功能吧！</p>
<p>先來寫一下最底層的兩個函式，負責抓資料的以及 render 建議清單的，我們使用維基百科的 API 來當作範例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchWikipedia</span> (<span class="params">term</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'http://en.wikipedia.org/w/api.php'</span>,</span><br><span class="line">        dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            action: <span class="string">'opensearch'</span>,</span><br><span class="line">            format: <span class="string">'json'</span>,</span><br><span class="line">            search: term</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).promise();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderList</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'.auto-complete__list'</span>).empty();</span><br><span class="line">  $(<span class="string">'.auto-complete__list'</span>).append(list.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">'&lt;li&gt;'</span> + item + <span class="string">'&lt;/li&gt;'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊要注意的一個點是維基百科回傳的資料會是一個陣列，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[你輸入的關鍵字, 關鍵字清單, 每個關鍵字的介紹, 每個關鍵字的連結]</span><br><span class="line">  </span><br><span class="line">// 範例：</span><br><span class="line">[</span><br><span class="line">  &quot;dd&quot;,</span><br><span class="line">  [&quot;Dd&quot;, &quot;DDR3 SDRAM&quot;, &quot;DD tank&quot;],</span><br><span class="line">  [&quot;&quot;, &quot;Double data rate type three SDRAM (DDR3 SDRAM)&quot;, &quot;DD or Duplex Drive tanks&quot;],</span><br><span class="line">  [https://en.wikipedia.org/wiki/Dd&quot;, &quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;, &quot;...略&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在我們的簡單示範中，只需要取 index 為 1 的那個關鍵字清單就好了。而<code>renderList</code>這個 function 則是傳進一個陣列，就會把陣列內容轉成<code>li</code>顯示出來。</p>
<p>有了這兩個最基礎的 function 之後，就可以很輕易地完成 Auto Complete 的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>).addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  searchWikipedia(e.target.value).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    renderList(data[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>程式碼應該很好懂，就是每次按下輸入東西的時候去 call api，把回傳的資料餵給<code>renderList</code>去渲染。</p>
<p>最基本的功能完成了，我們要來做一點優化，因為這樣子的實作其實是有一些問題的。</p>
<p>第一個問題，現在只要每打一個字就會送出一個 request，可是這樣做其實有點浪費，因為使用者可能快速的輸入了：<code>java</code>想要找相關的資料，他根本不在乎<code>j</code>、<code>ja</code>、<code>jav</code>這三個 request。</p>
<p>要怎麼做呢？我們就改寫成如果 250ms 裡面沒有再輸入新的東西才發送 request 就好，就可以避免這種多餘的浪費。</p>
<p>這種技巧稱作<code>debounce</code>，實作上也很簡單，就是利用<code>setTimeout</code>跟<code>clearTimeout</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>).addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    searchWikipedia(e.target.value).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      renderList(data[<span class="number">1</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">250</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 input 事件被觸發之後，我們不直接做事情，而是設置了一個 250ms 過後會觸發的 timer，如果 250ms 內 input 再次被觸發的話，我們就把上次的 timer 清掉，再重新設置一個。</p>
<p>如此一來，就可以保證使用者如果在短時間內不斷輸入文字的話，不會送出相對應的 request，而是會等到最後一個字打完之後的 250 ms 才發出 request。</p>
<p>解決了第一個問題之後，還有一個潛在的問題需要解決。</p>
<p>假設我現在輸入<code>a</code>，接著刪除然後再輸入<code>b</code>，所以第一個 request 會是<code>a</code>的結果，第二個 request 會是<code>b</code>的結果。我們假設 server 出了一點問題，所以第二個的 response 反而比第一個還先到達（可能<code>b</code>的搜尋結果有 cache 但是<code>a</code>沒有），這時候就會先顯示<code>b</code>的內容，等到第一個 response 回來時，再顯示<code>a</code>的內容。</p>
<p>可是這樣 UI 就有問題了，我明明輸入的是<code>b</code>，怎麼 auto complete 的推薦關鍵字是<code>a</code>開頭？</p>
<p>所以我們必須要做個檢查，檢查返回的資料跟我現在輸入的資料是不是一致，如果一致的話才 render：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>).addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    searchWikipedia(e.target.value).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[<span class="number">0</span>] === <span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>).value) &#123;</span><br><span class="line">        renderList(data[<span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">250</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>到這裡應該就差不多了，該有的功能都有了。</p>
<p>接著，讓我們來挑戰用 RxJS 實作吧！</p>
<p>首先，先從簡單版的開始做，就是不包含 debounce 跟上面 API 順序問題的實作，監聽 input 事件轉換成 request，然後用<code>flatMap</code>壓平，其實就跟上面的流程差不多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>), <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .flatMap(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.from(searchWikipedia(value)).map(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>這邊用了兩個<code>map</code>，一個是把<code>e</code>轉成<code>e.target.value</code>，一個是把傳回來的結果轉成<code>res[1]</code>，因為我們只需要關鍵字列表，其他的東西其實都不用。</p>
<p>那要如何實作<code>debounce</code>的功能呢？</p>
<p>RxJS 已經幫你實作好了，所以你只要加上<code>.debounceTime(250)</code>就好了，就是這麼簡單。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>), <span class="string">'input'</span>)</span><br><span class="line">  .debounceTime(<span class="number">250</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .flatMap(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.from(searchWikipedia(value)).map(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>還有最後一個問題要解決，那就是剛才提到的 request 的順序問題。</p>
<p>Observable 有一個不同的解法，我來解釋給大家聽聽。</p>
<p>其實除了<code>flatMap</code>以外，還有另外一種方式叫做<code>switchMap</code>，他們的差別在於要怎麼把 Observable 給壓平。前者我們之前介紹過了，就是會把每一個二維的 Observable 都壓平，並且「每一個都執行」。</p>
<p>而<code>switchMap</code>的差別在於，他永遠只會處理最後一個 Observable。拿我們的例子來說，假設第一個 request 還沒回來的時候，第二個 request 就發出去了，那我們的 Observable 就只會處理第二個 request，而不管第一個。</p>
<p>第一個還是會發送，還是會接收到資料，只是接收到資料以後不會再把這個資料 emit 到 Observable 上面，意思就是根本沒人理這個資料了。</p>
<p>可以看一下簡陋的圖解，<code>flatMap</code>每一個 promise resolve 之後的資料都會被發送到我們的 Observable 上面：</p>
<p><img src="/img/huli/rxjs/flatmap.png" alt></p>
<p>而<code>switchMap</code>只會處理最後一個：</p>
<p><img src="/img/huli/rxjs/switchmap.png" alt></p>
<p>所以我們只要把<code>flatMap</code>改成<code>switchMap</code>，就可以永遠只關注最後一個發送的 request，不用去管 request 傳回來的順序，因為前面的 request 都跟這個 Observable 無關了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>), <span class="string">'input'</span>)</span><br><span class="line">  .debounceTime(<span class="number">250</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .switchMap(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.from(searchWikipedia(value)).map(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>做到這邊，就跟剛剛實作的功能一模一樣了。</p>
<p>但其實還有地方可以改進，我們來做個小小的加強好了。現在的話當我輸入<code>abc</code>，會出現<code>abc</code>的相關關鍵字，接著我把<code>abc</code>全部刪掉，讓 input 變成空白，會發現 API 這時候回傳一個錯誤：<code>The &quot;search&quot; parameter must be set.</code>。</p>
<p>因此，我們可以在 input 是空的時候，不發送 request，只回傳一個空陣列，而回傳空陣列這件事情可以用<code>Rx.Observable.of([])</code>來完成，這樣會創造一個會發送空陣列的 Observable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>), <span class="string">'input'</span>)</span><br><span class="line">  .debounceTime(<span class="number">250</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .switchMap(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length &lt; <span class="number">1</span> ? Rx.Observable.of([]) : Rx.Observable.from(searchWikipedia(value)).map(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>還有一個點擊關鍵字清單之後把文字設定成關鍵字的功能，在這邊就不示範給大家看了，但其實就是再創造一個 Observable 去監聽點擊事件，點到的時候就設定文字並且把關鍵字清單給清掉。</p>
<p>我直接附上參考程式碼：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete__list'</span>), <span class="string">'click'</span>)</span><br><span class="line">  .filter(<span class="function"><span class="params">e</span> =&gt;</span> e.target.matches(<span class="string">'li'</span>))</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.innerHTML)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'.auto-complete input'</span>).value = value;</span><br><span class="line">    renderList([])</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>雖然我只介紹了最基本的操作，但 RxJS 的強大之處就在於除了這些，你甚至還有<code>retry</code>可以用，只要輕鬆加上這個，就能夠有自動重試的功能。</p>
<p>相關的應用場景還有很多，只要是跟 API 有關連的幾乎都可以用 RxJS 很優雅的解決。</p>
<h1 id="React-Redux-的非同步解決方案：redux-observable"><a href="#React-Redux-的非同步解決方案：redux-observable" class="headerlink" title="React + Redux 的非同步解決方案：redux-observable"></a>React + Redux 的非同步解決方案：redux-observable</h1><p>這是我們今天的最後一個主題了，也是我開場所提到的。</p>
<p>React + Redux 這一套非常常見的組合，一直都有一個問題存在，那就是沒有規範非同步行為（例如說 API）到底應該怎麼處理。而開源社群也有許多不同的解決方案，例如說 redux-thunk、redux-promise、redux-saga 等等。</p>
<p>我們前面講了這麼多東西，舉了這麼多範例，就是要證明給大家看 Reactive programming 很適合拿來解決複雜的非同步問題。因此，Netflix 就開源了這套<a href="https://redux-observable.js.org/" target="_blank" rel="noopener">redux-observable</a>，用 RxJS 來處理非同步行為。</p>
<p>在瞭解 RxJS 之後，可以很輕鬆的理解<code>redux-observable</code>的原理。</p>
<p>在 redux 的應用裡面，所有的 action 都會通過 middleware，你可以在這邊對 action 做任何處理。或者我們也可以把 action 看做是一個 Observable，例如說：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例而已</span></span><br><span class="line">Rx.Observable.from(actionStreams)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(action.type, action.payload)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>有了這個以後，我們就可以做一些很有趣的事情，例如說偵測到某個 action 的時候，我們就發送 request，並且把 response 放進另外一個 action 裡面送出去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.from(actionStreams)</span><br><span class="line">  .filter(<span class="function"><span class="params">action</span> =&gt;</span> action.type === <span class="string">'GET_USER_INFO'</span>)</span><br><span class="line">  .switchMap(</span><br><span class="line">    action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId))</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: <span class="string">'SET_USER_INFO'</span>,</span><br><span class="line">      payload: userInfo</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>上面就是一個簡單的例子，但其實<code>redux-observable</code>已經幫我們處理掉很多東西了，所以我們只要記得一個概念：</p>
<blockquote>
<p>action in, action out</p>
</blockquote>
<p><code>redux-observable</code> 是一個 middleware，你可以在裡面加上很多<code>epic</code>，每一個<code>epic</code>就是一個 Observable，你可以監聽某一個指定的 action，做一些處理，再轉成另外一個 action。</p>
<p>直接看程式碼會比較好懂：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">'./actions/user'</span>;</span><br><span class="line"><span class="keyword">import</span> ActionTypes <span class="keyword">from</span> <span class="string">'./actionTypes/user'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserEpic = <span class="function"><span class="params">action$</span> =&gt;</span></span><br><span class="line">  action$.ofType(actionTypes.GET_USER)</span><br><span class="line">    .switchMap(</span><br><span class="line">      action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId))</span><br><span class="line">    ).map(<span class="function"><span class="params">userInfo</span> =&gt;</span> Actions.setUsers(userInfo))</span><br></pre></td></tr></table></figure>
<p>大概就是像這樣，我們監聽一個 action type（GET_USER），一接收到的時候就發送 request，並且把結果轉為<code>setUsers</code>這個 action，這就是所謂的 action in, action out。</p>
<p>這樣的好處是什麼？好處是明確制定了一個規範，當你的 component 需要資料的時候，就送出一個 get 的 action，這個 action 經過 middleware 的時候會觸發 epic，epic 發 request 給 server 拿資料，轉成另外一個 set 的 action，經過 reducer 設定資料以後更新到 component 的 props。</p>
<p>可以看這張流程圖：</p>
<p><img src="/img/huli/rxjs/observable.png" alt></p>
<p>總之呢，<code>epic</code>就是一個 Observable，你只要確保你最後回傳的東西是一個 action 就好，那個 action 就會被送到 reducer 去。</p>
<p>礙於篇幅的關係，今天對於<code>redux-observable</code>只是概念性的帶過去而已，沒有時間好好示範，之後再來找個時間好好寫一下<code>redux-observable</code>的實戰應用。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>從一開始的陣列講到 Observable，講到畫圖的範例再講到經典的 Auto Complete，最後還講了<code>redux-observable</code>，這一路的過程中，希望大家有體會到 Observable 在處理非同步行為的強大之處以及簡潔。</p>
<p>這篇的目的是希望能讓大家理解 Observable 大概在做什麼，以及介紹一些簡單的應用場景，希望能提供一篇簡單易懂的中文入門文章，讓更多人能體會到 Observable 的威力。</p>
<p>喜歡這篇的話可以幫忙分享出去，發現哪邊有寫錯也歡迎留言指正，感謝。</p>
<p>參考資料：</p>
<p><a href="https://ithelp.ithome.com.tw/articles/10186104" target="_blank" rel="noopener">30 天精通 RxJS (01)：認識 RxJS</a><br><a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/">Reactive Programming 簡介與教學(以 RxJS 為例)</a><br><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">The introduction to Reactive Programming you’ve been missing</a><br><a href="http://www.alloyteam.com/2016/12/learn-rxjs/" target="_blank" rel="noopener">构建流式应用—RxJS详解</a><br><a href="https://medium.com/kevin-salters-blog/epic-middleware-in-redux-e4385b6ff7c6" target="_blank" rel="noopener">Epic Middleware in Redux</a><br><a href="http://blog.danieleghidoli.it/2016/10/22/http-rxjs-observables-angular/" target="_blank" rel="noopener">Combining multiple Http streams with RxJS Observables in Angular2</a></p>
<p>影片：<br><a href="https://www.youtube.com/watch?v=AslncyG8whg" target="_blank" rel="noopener">Netflix JavaScript Talks - RxJS + Redux + React = Amazing!</a><br><a href="https://www.youtube.com/watch?v=2LCo926NFLI" target="_blank" rel="noopener">RxJS Quick Start with Practical Examples</a><br><a href="https://www.youtube.com/watch?v=ei7FsoXKPl0" target="_blank" rel="noopener">RxJS Observables Crash Course</a><br><a href="https://www.youtube.com/watch?v=COviCoUtwx4" target="_blank" rel="noopener">Netflix JavaScript Talks - RxJS Version 5</a><br><a href="https://www.youtube.com/watch?v=3LKMwkuK0ZE" target="_blank" rel="noopener">RxJS 5 Thinking Reactively | Ben Lesh</a></p>
<p>關於作者：<br><a href="http://huli.logdown.com/" target="_blank" rel="noopener">@huli</a> 野生工程師，相信分享與交流能讓世界變得更美好</p>
  
      <div>喜歡我們的文章嗎？歡迎分享按讚給予我們支持和鼓勵！</div>
      <div class="fb-like" data-href="https://blog.techbridge.cc/2017/12/08/rxjs/index.html" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>
      <br>
      <br>
      <div class="fb-page" data-href="https://www.facebook.com/techbridge.cc" data-small-header="false" data-adapt-container-width="true" data-hide-cover="false" data-show-facepile="true"><blockquote cite="https://www.facebook.com/techbridge.cc" class="fb-xfbml-parse-ignore"><a href="https://www.facebook.com/techbridge.cc">TechBridge 技術日報</a></blockquote></div>
      <br>
    </section>
    <br>
    <hr>
    <div>
      <h4>訂閱 TechBridge Weekly 技術週刊，每週發送最精華的技術開發、產品設計的資訊給您</h4>
      <form class="form-control" method="post" action="https://goodbits.io/e/cab8a418-6b70-48d6-97ea-b5f0ef34b22c" target="_blank">
        <input class="form-control" type="text" name="first_name" placeholder="First Name"></input>
        <input class="form-control" type="text" name="last_name" placeholder="Last Name"></input>
        <div>
          <input class="form-control" type="text" name="email" placeholder="Email"></input>
        </div>
        <br>
        <div>
          <button class="form-control btn subscribe-btn" type="submit">馬上訂閱技術週刊</button>
        </div>
        <br>
        <label for="">PS. 我們討厭垃圾信，所以我們只提供有價值的內容給您 :)</label>
      </form>
    </div>
    <footer class="post-footer">
      <section class="author">
    <h4>TechBridge Weekly 技術週刊編輯團隊</h4>
    <p>TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、資料科學與產品設計等技術分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robotics, IoT, Data Science technology sharing.</p>
    <span><a href="/2016/03/19/about/">關於我們</a></span> / <span><a href="https://www.techbridge.cc/" target="_blank">技術日報</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>   
	<div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-size="large" data-action="like" data-show-faces="false" data-share="true"></div>    
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=https://blog.techbridge.cc/2017/12/08/rxjs/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.techbridge.cc/2017/12/08/rxjs/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=https://blog.techbridge.cc/2017/12/08/rxjs/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
    <iframe src="https://ghbtns.com/github-btn.html?user=TechBridgeHQ&repo=blog-starter-kit&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>      
</section>
    </footer>
    <br>
  </article>
  <nav class="pagination" role="pagination">
    <h2>更多優質技術文章</h2>
    
    <a class="newer-posts" href="/2017/12/12/d3v4-calendar-yearendreview/">
        ← 一起用 Google Calendar 與 D3.js 進行年終回顧吧！
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2017/12/02/ros-gps-install-intro/">
        Guided Policy Search 環境安裝 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">留言討論</a></h1>

    
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    
</div>
</main>


  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75308642-1', 'auto');
  ga('send', 'pageview');

</script>
<footer class="site-footer">
  
  <a class="subscribe icon-feed" href="/atom.xml"><span class="tooltip">Subscribe!</span></a>
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">TechBridge 技術共筆部落格</a> &copy; 2017 &bull; All rights reserved.</section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>


<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '[object Object]']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>


<script type="text/javascript">
    var disqus_shortname = 'techbridgeweekly';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.4/dist/medium-zoom.min.js"></script>
<script>
// NodeList
mediumZoom(document.querySelectorAll('img'));
</script>
  <div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, 'script', 'facebook-jssdk'));</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
