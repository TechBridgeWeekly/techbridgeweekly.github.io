<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>希望是最淺顯易懂的 RxJS 教學 | TechBridge 技術共筆部落格</title>
  <meta name="description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- google-site-verification -->
  <meta name="google-site-verification" content="WX_9sZlrIYOEpy8RR7zCoa7-pJk611zZt11BSBUcDVY" />
  <link rel="stylesheet preload" type="text/css" href="/css/screen.css" as="style" />
  <link rel="stylesheet preload" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" as="style" />

  <!-- Favicons -->
  <link rel="apple-touch-icon" href="/img/favicon.ico">
  <link rel="icon preload" href="/img/favicon.ico" as="image">

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml">
  
  

  
</head>


<body class="post-template">

  <header class="site-head" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="/img/logo-tb-500-500.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">TechBridge 技術共筆部落格</h1>
            <h2 class="blog-description">var topics = ['Web前後端', '行動網路', '機器人/物聯網', '數據分析', '產品設計', 'etc.']</h2>
            <div class="navbar-block">
                <span><a href="/">首頁</a></span> / <span><a href="/about/">關於我們</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>
                <br>
            </div>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-12-08T22:55:15.000Z" itemprop="datePublished">
          2017-12-08
      </time>
    
    
    | 
    <a href='/tags/rxjs/'>rxjs</a>
    
    
</span>

<meta name="generator" content="希望是最淺顯易懂的 RxJS 教學">
<meta name="og:title" content="希望是最淺顯易懂的 RxJS 教學">
<meta name="og:description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享。">
<meta name="og:type" content="website">
<meta name="og:image" content="/img/og-cover.png">

    <h1 class="post-title">希望是最淺顯易懂的 RxJS 教學</h1>
    <section class="post-content">
      <div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>   
      <hr>
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>關注 RxJS 已經好一段時間了，最早知道這個東西是因為 <a target="_blank" rel="noopener" href="https://redux-observable.js.org/">redux-observable</a>，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連<code>redux-saga</code>都還沒搞懂，沒想到就又有新的東西出來了。</p>
<p>半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學者無所適從。</p>
<p>這次有機會在公司的新專案裡面嘗試導入<code>redux-observable</code>，身為提倡要導入的人，勢必要對這東西有一定的瞭解。秉持著這個想法，上週認真花了點時間再次把相關資源都研究了一下，漸漸整理出一套「我覺得應該可以把 RxJS 講得更好懂」的方法，在這邊跟大家分享一下。</p>
<p>在開始之前，要先大力稱讚去年 iT 邦幫忙鐵人賽的 Web 組冠軍：<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/users/20103367/ironman/1199">30 天精通 RxJS</a>，這系列文章寫得很完整，感受得出來作者下了很多功夫在這上面。看完這篇之後如果對更多應用有興趣的，可以去把這系列的文章讀完。</p>
<p>好，那就讓我們開始吧！</p>
<h1 id="請你先忘掉-RxJS"><a href="#請你先忘掉-RxJS" class="headerlink" title="請你先忘掉 RxJS"></a>請你先忘掉 RxJS</h1><p>沒錯，你沒看錯。</p>
<p>要學會 RxJS 的第一件事情就是：忘記它。</p>
<p>忘記有這個東西，完全忘記，先讓我講幾個其他東西，等我們需要講到 RxJS 的時候我會再提醒你的。</p>
<p>在我們談到主角之前，先來做一些有趣的事情吧！</p>
<h1 id="程式基礎能力測試"><a href="#程式基礎能力測試" class="headerlink" title="程式基礎能力測試"></a>程式基礎能力測試</h1><p>先讓我們做一個簡單的練習題暖身，題目是這樣的：</p>
<blockquote>
<p>有一個陣列，裡面有三種類型的資料：數字、a~z組成的字串、數字組成的字串，請你把每個數字以及數字組成的字串乘以二之後加總<br>範例輸入：[1, 5, 9, 3, ‘hi’, ‘tb’, 456, ‘11’, ‘yoyoyo’]</p>
</blockquote>
<p>你看完之後應該會說：「這有什麼難的？」，並且在一分鐘以內就寫出下面的程式碼：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;tb&#x27;</span>, <span class="number">456</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;yoyoyo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; source.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(source[i], <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(num)) &#123;</span><br><span class="line">    total += num * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信大家一定都是很直覺的就寫出上面的程式碼，但如果你是個 functional programming 的愛好者，你可能會改用另外一種思路來解決問題：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;tb&#x27;</span>, <span class="number">456</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;yoyoyo&#x27;</span>];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> total = source</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x, <span class="number">10</span>))</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !<span class="built_in">isNaN</span>(x))</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, value</span>) =&gt;</span> total + value )</span><br></pre></td></tr></table></figure>

<p>一開始的例子叫做<code>Imperative（命令式）</code>，用陣列搭配一堆函式的例子叫做<code>Declarative（聲明式）</code>。如果你去查了一下定義，應該會看到這兩個的解釋：</p>
<blockquote>
<p>Imperative 是命令機器去做事情（how），這樣不管你想要的是什麼（what），都會按照你的命令實現；Declarative 是告訴機器你想要的是什麼（what），讓機器想出如何去做（how）</p>
</blockquote>
<p>好，你有看懂上面這些在說什麼嗎？</p>
<p>我是沒有啦。</p>
<p>所以讓我們再看一個例子，其實 Declarative 你已經常常在用了，只是你不知道而已，那就是 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> dogs <span class="keyword">INNER</span> <span class="keyword">JOIN</span> owners <span class="keyword">WHERE</span> dogs.owner_id <span class="operator">=</span> owners.id</span><br></pre></td></tr></table></figure>

<p>這句話就是：我要所有狗的資料加上主人的資料。</p>
<p>我只有說「我要」而已，那要怎麼拿到這些資料？我不知道，我也不用知道，都讓 SQL 底層決定怎麼去操作就好。</p>
<p>如果我要自己做出這些資料，在 JavaScript 裡面我必須這樣寫（程式碼取自<a target="_blank" rel="noopener" href="http://www.vaikan.com/imperative-vs-declarative/">声明式编程和命令式编程的比较</a>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dogs = [&#123;name: &#x27;Fido&#x27;, owner_id: 1&#125;, &#123;...&#125;, ... ]</span></span><br><span class="line"><span class="comment">//owners = [&#123;id: 1, name: &#x27;Bob&#x27;&#125;, &#123;...&#125;, ...]</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dogsWithOwners = []</span><br><span class="line"><span class="keyword">var</span> dog, owner</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> di=<span class="number">0</span>; di &lt; dogs.<span class="property">length</span>; di++) &#123;</span><br><span class="line">  dog = dogs[di]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> oi=<span class="number">0</span>; oi &lt; owners.<span class="property">length</span>; oi++) &#123;</span><br><span class="line">    owner = owners[oi]</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; dog.<span class="property">owner_id</span> == owner.<span class="property">id</span>) &#123;</span><br><span class="line">      dogsWithOwners.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">dog</span>: dog,</span><br><span class="line">        <span class="attr">owner</span>: owner</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>應該可以大致體驗出兩者的差別吧？後者你必須自己一步步去決定該怎麼做，而前者只是僅僅跟你說：「我想要怎樣的資料」而已。</p>
<p>接著我們再把目光放回到把數字乘以二相加的那個練習。對我來說，最大的不同點是後面那個用陣列搭配函式的例子，他的核心概念是：</p>
<blockquote>
<p>把原始資料經過一連串的轉換，變成你想要的資訊</p>
</blockquote>
<p>這點超級重要，因為在一開始的例子中，我們是自己一步步去 parse，去檢查去相加，得出數字的總和。而後面的那個例子，他是把原始的資料（陣列），經過一系列的轉換（map, filter, reduce），最後變成了我們想要的答案。</p>
<p>畫成圖的話，應該會長這樣（請原諒我偷懶把乘二的部分拿掉了，但意思不影響）：</p>
<p><img src="/img/huli/rxjs/map.png"></p>
<p>把原始資料經過一連串的轉換，最後變成你想要的答案，這點就是後者最大的不同。只要你有了這個基礎知識之後，再來看 RxJS 就不會覺得太奇怪了。</p>
<h1 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h1><p>談到 RxJS 的時候，都會談到 Reactive 這個詞，那什麼是 Reactive 呢？可以從英文上的字義來看，這個單字的意思是：「反應、反應性的」，意思就是你要對一些事情做出反應。</p>
<p>所以 Reactive 其實就是在講說：「某些事情發生時，我能夠做出反應」。</p>
<p>讓我們來舉一個大家非常熟知的例子：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click!&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我們加了一個 event listener 在 window 上面，所以我們可以監聽到這個事件，每當使用者點擊的時候就列印出 log。換句話說，這樣就是：「當 window 被點擊時，我可以做出反應」。</p>
<h1 id="正式進入-RxJS"><a href="#正式進入-RxJS" class="headerlink" title="正式進入 RxJS"></a>正式進入 RxJS</h1><p>如果你去看 <a target="_blank" rel="noopener" href="http://reactivex.io/">ReactiveX</a> 的網頁，你會發現他有明確的定義 ReactiveX：</p>
<blockquote>
<p>ReactiveX is a combination of the best ideas from<br>the Observer pattern, the Iterator pattern, and functional programming</p>
</blockquote>
<p>第一個 Observer pattern 就像是 event listener 那樣，在某些事情發生時，我們可以對其作出反應；第二個 Iterator pattern 我們跳過不講，我認為暫時不影響理解；第三個就像是一開始的例子，我們可以把一個陣列經過多次轉換，轉換成我們想要的資料。</p>
<p>在 Reactive Programming 裡面，最重要的兩個東西叫做 Observable 跟 Observer，其實一開始讓我最困惑的點是因為我英文不好，不知道這兩個到底誰是觀察的誰是被觀察的。</p>
<p>先把它們翻成中文，Observable 就是「可被觀察的」，Observer 就是所謂的「觀察者」。</p>
<p>這是什麼意思呢？就如同上面的例子一樣，當（可被觀察的東西）有事情發生，（Observer，觀察者）就可以做出反應。</p>
<p>直接舉一個例子你就知道了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(<span class="variable language_">window</span>, <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click~&#x27;</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>上面這段程式碼跟我幫 window 加上 event listener 在做的事情完全一樣，只是這邊我們使用了 RxJS 提供的方法叫做<code>fromEvent</code>，來把一個 event 轉成 Observable（可被觀察的），並且在最後加上 subscribe。</p>
<p>這樣寫就代表說我訂閱了這個 Observable，只要有任何事情發生，就會執行我傳進去的 function。</p>
<p>所以到底什麼是 Observable？</p>
<p>Observable 就是一個可被觀察的對象，這個對象可以是任何東西（例如說上述例子就是 window 的 click 事件），當有新資料的時候（例如說新的點擊事件），你就可以接收到這個新資料的資訊並且做出反應。</p>
<p>比起 Observable 這個冷冰冰的說法，我更喜歡的一個說法是 stream，資料流。其實每一個 Observable 就是一個資料流，但什麼是資料流？你就想像成是會一直增加元素的陣列就好了，有新的事件發生就 push 進去。如果你喜歡更專業一點的說法，可以叫它：「時間序列上的一連串資料事件」（取自 <a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/">Reactive Programming 簡介與教學(以 RxJS 為例)</a>）</p>
<p>或是我再舉一個例子，stream 的另外一個解釋就是所謂的「串流影片」，意思就是隨著你不斷播放，就會不斷下載新的片段進來。此時你腦中應該要有個畫面，就是像水流那樣，不斷有新的東西流進來，這個東西就叫做 stream。</p>
<p><img src="https://media.giphy.com/media/xIkKIodaqNBdK/giphy.gif"><br>（圖片取自 <a target="_blank" rel="noopener" href="https://media.giphy.com/media/xIkKIodaqNBdK/giphy.gif">giphy</a>）</p>
<h1 id="我理解資料流了，然後呢？"><a href="#我理解資料流了，然後呢？" class="headerlink" title="我理解資料流了，然後呢？"></a>我理解資料流了，然後呢？</h1><p>上面有說過，我們可以把任何一個東西轉成 Observable，讓它變成資料流，可是這不就跟 addEventListener 一樣嗎？有什麼特別的？</p>
<p>有，還真的比較特別。</p>
<p>希望你沒有忘記我們剛開始做的那個小練習，就是把一個陣列透過一系列轉換，變成我們要的資料的那個練習。我剛剛有說，你可以把 Observable 想成是「會一直增加元素的陣列」，這代表什麼呢？</p>
<p>代表我們也可以把 Observable 做一系列的轉換！我們也可以用那些用在陣列上的 function！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(<span class="variable language_">window</span>, <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">target</span>)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click: &#x27;</span>, value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/img/huli/rxjs/click.gif"></p>
<p>我們把 click 事件經過 map 轉換為點擊到的 element，所以當我們最後在 subscribe 的時候，收到的 value 就會是我們點擊的東西。</p>
<p>接著來看一個稍微進階一點的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(<span class="variable language_">window</span>, <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">scan</span>(<span class="function">(<span class="params">total, now</span>) =&gt;</span> total + now)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#counter&#x27;</span>).<span class="property">innerText</span> = value;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/img/huli/rxjs/counter.gif"></p>
<p>首先我們先把每一個 click 事件都透過<code>map</code>轉換成 1（或者你也可以寫成<code>.mapTo(1)</code>），所以每按一次就送出一個數字 1。<code>scan</code>的話其實就是我們一開始對陣列用的<code>reduce</code>，你可以想成是換個名字而已。透過<code>scan</code>加總以後傳給 subscriber，顯示在頁面上面。</p>
<p>就這樣簡單幾行，就完成了一個計算點擊次數的 counter。</p>
<p>可以用一個簡單的 gif 圖來表示上面的範例：</p>
<p><img src="/img/huli/rxjs/click_stream.gif"></p>
<p>可是 Observable 不只這樣而已，接下來我們要進入到它最厲害的地方了。</p>
<h1 id="威力無窮的組合技"><a href="#威力無窮的組合技" class="headerlink" title="威力無窮的組合技"></a>威力無窮的組合技</h1><p>如果把兩個陣列合併，會變成什麼？例如說<code>[1, 2, 3]</code>跟<code>[4, 5, 6]</code>？</p>
<p>這要看你指的「合併」是什麼，如果是指串接，那就是<code>[1, 2, 3, 4, 5, 6]</code>，如果是指相加，那就是<code>[5, 7, 9]</code>。</p>
<p>那如果把兩個 Observable 合併會變成什麼？</p>
<p>Observable 跟陣列的差別就在於多了一個維度：時間。</p>
<p>Observable 是「時間序列上的一連串資料事件」，就像我前面講的一樣，可以看成是一個一直會有新資料進來的陣列。</p>
<p>我們先來看看一張很棒的圖，很清楚地解釋了兩個 Observable 合併會變成什麼：</p>
<p><img src="/img/huli/rxjs/merge.png"><br>（取自：<a target="_blank" rel="noopener" href="http://rxmarbles.com/#merge%EF%BC%89">http://rxmarbles.com/#merge）</a></p>
<p>上面是一個 Observable，每一個圓點代表一個資料，下面也是一樣，把這兩個合併之後就變成最下面那一條，看圖解應該還滿好懂的，就像是把兩個時間軸合併一樣。</p>
<p>讓我們來看一個可以展現合併強大之處的範例，我們有 +1 跟 -1 兩個按鈕以及文字顯示現在的數字是多少：</p>
<p><img src="/img/huli/rxjs/counter_adv.gif"></p>
<p>該怎麼達成這個功能呢？基本的想法就是我們先把每個 +1 的 click 事件都通過<code>mapTo</code>變成數字 1，取叫 Observable_plus1 好了。再做出一個 Observable_minus1 是把每個 -1 的 click 事件都通過<code>mapTo</code>變成數字 -1。</p>
<p>把這兩個 Observable 合併之後，再利用剛剛提到的<code>scan</code>加總，就是目前應該要顯示的數字了！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=plus]&#x27;</span>), <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">mapTo</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">merge</span>(</span><br><span class="line">    <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=minus]&#x27;</span>), <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">      .<span class="title function_">mapTo</span>(-<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">scan</span>(<span class="function">(<span class="params">total, now</span>) =&gt;</span> total + now)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#counter&#x27;</span>).<span class="property">innerText</span> = value;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>如果你還是不懂的話，可以參考下面的精美範例，示範這兩個 Observable 是怎麼合在一起的（<code>O</code>代表點擊事件，<code>+1</code>跟<code>-1</code>則是<code>mapTo</code>之後的結果）：</p>
<p><img src="/img/huli/rxjs/plus.gif"></p>
<p>讓我們來比較一下如果不用 Observable 的話，程式碼會長怎樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=plus]&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  total++;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#counter&#x27;</span>).<span class="property">innerText</span> = total;</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=minus]&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  total--;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#counter&#x27;</span>).<span class="property">innerText</span> = total;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有沒有發覺兩者真的差別很大？就如同我之前所說的，是兩種完全不同的思考模式，所以 Reactive Programming 困難的地方不是在於理解，也不是在於語法（這兩者相信你目前都有些概念了），而是在於換一種全新的思考模式。</p>
<p>以上面的寫法來說，就是告訴電腦：「按下加的時候就把一個變數 +1，然後更改文字；按下減的時候就 -1 並且也更改文字」，就可以達成計數器的功能。</p>
<p>以 Reactive 的寫法，就是把按下加當成一個資料流，把按下減也當成一個資料流，再透過各種 function 把這兩個流轉換並且合併起來，讓最後的那個流就是我們想要的結果（計數器）。</p>
<p>你現在應該能體會到我一開始說的了：「把原始資料經過一連串的轉換，最後變成你想要的答案」，這點就是 Reactive Programming 最大的特色。</p>
<h1 id="組合技中的組合技"><a href="#組合技中的組合技" class="headerlink" title="組合技中的組合技"></a>組合技中的組合技</h1><p>我們來看一個更複雜一點的範例，是在 canvas 上面實現非常簡單的繪圖功能，就是滑鼠按下去之後可以畫畫，放開來就停止。</p>
<p><img src="/img/huli/rxjs/draw.gif"></p>
<p>要實現這個功能很間單，canvas 提供<code>lineTo(x, y)</code>這個方法，只要在滑鼠移動時不斷呼叫這個方法，就可以不斷畫出圖形來。但有一點要注意的是當你在按下滑鼠時，應該先呼叫<code>moveTo(x, y)</code>把繪圖的點移到指定位置，為什麼呢？</p>
<p>假設我們第一次畫圖是在左上角，第二次按下滑鼠的位置是在右下角，如果沒有先用<code>moveTo</code>移動而是直接用<code>lineTo</code>的話，就會多一條線從左上角延伸到右下角。<code>moveTo</code>跟<code>lineTo</code>的差別就是前者只是移動，後者會跟上次的點連接在一起畫成一條線。</p>
<p><img src="/img/huli/rxjs/draw2.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.<span class="title function_">beginPath</span>(); <span class="comment">// 開始畫畫</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(e.<span class="property">clientX</span>,e.<span class="property">clientY</span>); <span class="comment">// 移到滑鼠在的位置</span></span><br><span class="line">  ctx.<span class="title function_">stroke</span>(); <span class="comment">// 畫畫</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 按下去滑鼠才開始偵測 mousemove 事件</span></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(e.<span class="property">clientX</span>, e.<span class="property">clientY</span>); <span class="comment">// 每次按下的時候必須要先把繪圖的點移到那邊，否則會受上次畫的位置影響</span></span><br><span class="line">  canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, draw);</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 放開滑鼠就停止偵測 </span></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  canvas.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, draw);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那如果在 RxJS 裡面，該怎麼實作這個功能呢？</p>
<p>首先憑直覺，應該就是先加上<code>mousedown</code>的事件對吧！至少有個開頭。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousedown&#x27;</span>)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mousedown&#x27;</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>可是滑鼠按下去之後應該要變成什麼？這個時候應該要開始監聽<code>mousemove</code>對吧，所以我們這樣寫，用<code>mapTo</code>把每一個<code>mousedown</code>的事件都轉換成<code>mousemove</code>的 Observable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousedown&#x27;</span>)</span><br><span class="line">  .<span class="title function_">mapTo</span>(</span><br><span class="line">    <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousemove&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value: &#x27;</span>, value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>接著你看一下 console，你會發現每當我點擊的時候，console 就會印出<code>FromEventObservable &#123;_isScalar: false, sourceObj: canvas#canvas, eventName: &quot;mousemove&quot;, selector: undefined, options: undefined&#125;</code></p>
<p>仔細想一下你會發現也滿合理的，因為我用<code>mapTo</code>把每一個滑鼠按下去的事件轉成一個 mousemove 的 Observable，所以用 subscribe 訂閱之後拿到的東西就會是這個 Observable。如果畫成圖，大概長得像這樣：</p>
<p><img src="/img/huli/rxjs/flat.png"></p>
<p>好了，那怎麼辦呢？我想要的其實不是 Observable 本身，而是屬於這個 Observable 裡面的那些東西啊！現在這個情形就是 Observable 裡面又有 Observable，有兩層，可是我想要讓它變成一層就好，該怎麼辦呢？</p>
<p>在此提供一個讓 Observable 變簡單的訣竅：</p>
<blockquote>
<p>只要有問題，先想想 Array 就對了！</p>
</blockquote>
<p>我前面有提過，可以把 Observable 看成是加上時間維度的進階版陣列，因此只要是陣列有的方法，Observable 通常也都會有。</p>
<p>舉例來說，一個陣列可能長這樣：<code>[1, [2, 2.5], 3, [4, 5]]</code>一共有兩層，第二層也是一個陣列。</p>
<p>如果想讓它變一層的話怎麼辦呢？壓平！</p>
<p>有用過 lodash 或是其他類似的 library 的話，你應該有聽過<code>_.flatten</code>這個方法，可以把這種陣列壓平，變成：<code>[1, 2, 2.5, 3, 4, 5]</code>。</p>
<p>用 flat 這個關鍵字去搜尋 Rx 文件的話，你會找到一個方法叫做 <a target="_blank" rel="noopener" href="http://reactivex.io/documentation/operators/flatmap.html">FlatMap</a>，簡單來說就是先<code>map</code>之後再自動幫你壓平。</p>
<p>所以，我們可以把程式碼改成這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousedown&#x27;</span>)</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousemove&#x27;</span>))            </span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>當你點擊之後，會發現隨著滑鼠移動，console 會印出一大堆 log，就代表我們成功了。</p>
<p>畫成示意圖的話會變成這樣（為了方便說明，我把<code>flatMap</code>在圖片上變成<code>map</code>跟<code>flatten</code>兩個步驟）：</p>
<p><img src="/img/huli/rxjs/flat2.png"></p>
<p>接下來呢？接下來我們要讓它可以在滑鼠鬆開的時候停止，該怎麼做呢？RxJS 有一個方法叫做<code>takeUntil</code>，意思就是拿到…發生為止，傳進去的參數必須是一個 Observable。</p>
<p>舉例來說，如果寫<code>.takeUntil(window, &#39;click&#39;)</code>，就表示如果任何<code>window</code>的點擊事件發生，這個 Observable 就會立刻終止，不會再送出任何資料。</p>
<p>應用在繪畫的例子上，我們只要把<code>takeUntil</code>後面傳的參數換成滑鼠鬆開就好！順便把<code>subscribe</code>跟畫畫的 function 也一起完成吧！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousedown&#x27;</span>)</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousemove&#x27;</span>))</span><br><span class="line">  .<span class="title function_">takeUntil</span>(<span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mouseup&#x27;</span>))         </span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>改完之後馬上來實驗一下！滑鼠按下去之後順利開始畫圖，鬆開以後畫圖停止，完美！</p>
<p>咦，可是怎麼按下第二次就沒反應了？我們做出了一個「只能夠成功畫一次圖」的 Observable。</p>
<p>為什麼呢？我們可以先來看一下<code>takeUntil</code>的示意圖（取自：<a target="_blank" rel="noopener" href="http://rxmarbles.com/#takeUntil%EF%BC%89">http://rxmarbles.com/#takeUntil）</a></p>
<p><img src="/img/huli/rxjs/takeuntil.png"></p>
<p>以我們的情形來說，就是只要<code>mouseup</code>事件發生，「整個 Observable」就會停止，所以只有第一次能夠畫圖成功。但我們想要的其實不是這樣，我們想要的是只有<code>mousemove</code>停止而已，而不是整個都停止。</p>
<p>所以，我們應該把<code>takeUntil</code>放在<code>mousemove</code>的後面，也就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousedown&#x27;</span>)</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousemove&#x27;</span>)</span><br><span class="line">      .<span class="title function_">takeUntil</span>(<span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mouseup&#x27;</span>))  </span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>這樣子裡面的那個<code>mousemove</code>的 Observable 就會在滑鼠鬆開時停止發送事件，而我們最外層的這個 Observable 監聽的是滑鼠按下，會一直監聽下去。</p>
<p>到這邊其實就差不多了，但還有一個小 bug 要修，就是我們沒有在<code>mousedown</code>的時候利用<code>moveTo</code>移動，造成我們一開始說的那個會把上次畫的跟這次畫的連在一起的問題。</p>
<p>那怎麼辦呢？我已經把<code>mousedown</code>事件轉成其他資料流了，我要怎麼在<code>mousedown</code>的時候做事？</p>
<p>有一個方法叫做<code>do</code>，就是為了這種情形而設立的，使用時機是：「你想做一點事，卻又不想影響資料流」，有點像是能夠針對不同階段 subscribe 的感覺，<code>mousedown</code>的時候 subscribe 一次，最後要畫圖的時候又 subscribe 一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousedown&#x27;</span>)</span><br><span class="line">  .<span class="title function_">do</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(e.<span class="property">clientX</span>, e.<span class="property">clientY</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mousemove&#x27;</span>)</span><br><span class="line">      .<span class="title function_">takeUntil</span>(<span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(canvas, <span class="string">&#x27;mouseup&#x27;</span>))  </span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>到這邊，我們就順利完成了畫圖的功能。</p>
<p>如果你想試試看你有沒有搞懂，可以實作看看拖拉移動物體的功能，原理跟這個很類似，都是偵測滑鼠的事件並且做出反應。</p>
<h1 id="喝口水休息一下，下半場要開始了"><a href="#喝口水休息一下，下半場要開始了" class="headerlink" title="喝口水休息一下，下半場要開始了"></a>喝口水休息一下，下半場要開始了</h1><p>上半場的目標在於讓你理解什麼是 Rx，並且掌握幾個基本概念：</p>
<ol>
<li>一個資料流可以經過一系列轉換，變成另一個資料流</li>
<li>這些轉換基本上都跟陣列有的差不多，像是<code>map</code>、<code>filter</code>、<code>flatten</code>等等</li>
<li>你可以合併多個 Observable，也可以把二維的 Observable 壓平</li>
</ol>
<p>下半場專注的點則是在於實戰應用，並且圍繞著 RxJS 最適合的場景之一：API。</p>
<p>前面我們有提到說可以把 DOM 物件的 event 變成資料流，但除了這個以外，Promise 其實也可以變成資料流。概念其實也很簡單啦，就是 Promise 被 resovle 的時候就發送一個資料，被 reject 的時候就終止。</p>
<p>讓我們來看一個簡單的小範例，每按一次按鈕就會發送一個 request</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendRequest</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=send]&#x27;</span>), <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromPromise</span>(<span class="title function_">sendRequest</span>()))</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>這邊用<code>flatMap</code>的原因跟剛才的畫圖範例一樣，我們要在按下按鈕時，把原本的資料流轉換成新的資料流，如果只用<code>map</code>的話，會變成一個二維的 Observable，所以必須要用<code>flatten</code>把它壓平。</p>
<p>你可以試試看把<code>flatMap</code>改成<code>map</code>，你最後 subscribe 得到的值就會是一堆 Observable 而不是你想要的資料。</p>
<p>知道怎麼用 Rx 來處理 API 之後，就可以來做一個經典範例了：AutoComplete。</p>
<p>我在做這個範例的時候有極大部分參考<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10188457">30 天精通 RxJS(19): 實務範例 - 簡易 Auto Complete 實作</a>、<a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/">Reactive Programming 簡介與教學(以 RxJS 為例)</a>以及<a target="_blank" rel="noopener" href="http://www.alloyteam.com/2016/12/learn-rxjs/">构建流式应用—RxJS详解</a>，再次感謝這三篇文章。</p>
<p><img src="/img/huli/rxjs/auto.gif"></p>
<p>為了要讓大家能夠體會 Reactive Programming 跟一般的有什麼不一樣，我們先用老方法做出這個 Auto Complete 的功能吧！</p>
<p>先來寫一下最底層的兩個函式，負責抓資料的以及 render 建議清單的，我們使用維基百科的 API 來當作範例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">searchWikipedia</span> (<span class="params">term</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://en.wikipedia.org/w/api.php&#x27;</span>,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">action</span>: <span class="string">&#x27;opensearch&#x27;</span>,</span><br><span class="line">            <span class="attr">format</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">            <span class="attr">search</span>: term</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">promise</span>();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderList</span> (<span class="params">list</span>) &#123;</span><br><span class="line">  $(<span class="string">&#x27;.auto-complete__list&#x27;</span>).<span class="title function_">empty</span>();</span><br><span class="line">  $(<span class="string">&#x27;.auto-complete__list&#x27;</span>).<span class="title function_">append</span>(list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">&#x27;&lt;li&gt;&#x27;</span> + item + <span class="string">&#x27;&lt;/li&gt;&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊要注意的一個點是維基百科回傳的資料會是一個陣列，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[你輸入的關鍵字, 關鍵字清單, 每個關鍵字的介紹, 每個關鍵字的連結]</span><br><span class="line">  </span><br><span class="line">// 範例：</span><br><span class="line">[</span><br><span class="line">  &quot;dd&quot;,</span><br><span class="line">  [&quot;Dd&quot;, &quot;DDR3 SDRAM&quot;, &quot;DD tank&quot;],</span><br><span class="line">  [&quot;&quot;, &quot;Double data rate type three SDRAM (DDR3 SDRAM)&quot;, &quot;DD or Duplex Drive tanks&quot;],</span><br><span class="line">  [https://en.wikipedia.org/wiki/Dd&quot;, &quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;, &quot;...略&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在我們的簡單示範中，只需要取 index 為 1 的那個關鍵字清單就好了。而<code>renderList</code>這個 function 則是傳進一個陣列，就會把陣列內容轉成<code>li</code>顯示出來。</p>
<p>有了這兩個最基礎的 function 之後，就可以很輕易地完成 Auto Complete 的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">searchWikipedia</span>(e.<span class="property">target</span>.<span class="property">value</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderList</span>(data[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>程式碼應該很好懂，就是每次按下輸入東西的時候去 call api，把回傳的資料餵給<code>renderList</code>去渲染。</p>
<p>最基本的功能完成了，我們要來做一點優化，因為這樣子的實作其實是有一些問題的。</p>
<p>第一個問題，現在只要每打一個字就會送出一個 request，可是這樣做其實有點浪費，因為使用者可能快速的輸入了：<code>java</code>想要找相關的資料，他根本不在乎<code>j</code>、<code>ja</code>、<code>jav</code>這三個 request。</p>
<p>要怎麼做呢？我們就改寫成如果 250ms 裡面沒有再輸入新的東西才發送 request 就好，就可以避免這種多餘的浪費。</p>
<p>這種技巧稱作<code>debounce</code>，實作上也很簡單，就是利用<code>setTimeout</code>跟<code>clearTimeout</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">searchWikipedia</span>(e.<span class="property">target</span>.<span class="property">value</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">renderList</span>(data[<span class="number">1</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">250</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 input 事件被觸發之後，我們不直接做事情，而是設置了一個 250ms 過後會觸發的 timer，如果 250ms 內 input 再次被觸發的話，我們就把上次的 timer 清掉，再重新設置一個。</p>
<p>如此一來，就可以保證使用者如果在短時間內不斷輸入文字的話，不會送出相對應的 request，而是會等到最後一個字打完之後的 250 ms 才發出 request。</p>
<p>解決了第一個問題之後，還有一個潛在的問題需要解決。</p>
<p>假設我現在輸入<code>a</code>，接著刪除然後再輸入<code>b</code>，所以第一個 request 會是<code>a</code>的結果，第二個 request 會是<code>b</code>的結果。我們假設 server 出了一點問題，所以第二個的 response 反而比第一個還先到達（可能<code>b</code>的搜尋結果有 cache 但是<code>a</code>沒有），這時候就會先顯示<code>b</code>的內容，等到第一個 response 回來時，再顯示<code>a</code>的內容。</p>
<p>可是這樣 UI 就有問題了，我明明輸入的是<code>b</code>，怎麼 auto complete 的推薦關鍵字是<code>a</code>開頭？</p>
<p>所以我們必須要做個檢查，檢查返回的資料跟我現在輸入的資料是不是一致，如果一致的話才 render：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">searchWikipedia</span>(e.<span class="property">target</span>.<span class="property">value</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[<span class="number">0</span>] === <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>).<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="title function_">renderList</span>(data[<span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">250</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>到這裡應該就差不多了，該有的功能都有了。</p>
<p>接著，讓我們來挑戰用 RxJS 實作吧！</p>
<p>首先，先從簡單版的開始做，就是不包含 debounce 跟上面 API 順序問題的實作，監聽 input 事件轉換成 request，然後用<code>flatMap</code>壓平，其實就跟上面的流程差不多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span></span><br><span class="line">  .<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>), <span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(<span class="title function_">searchWikipedia</span>(value)).<span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderList</span>(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>這邊用了兩個<code>map</code>，一個是把<code>e</code>轉成<code>e.target.value</code>，一個是把傳回來的結果轉成<code>res[1]</code>，因為我們只需要關鍵字列表，其他的東西其實都不用。</p>
<p>那要如何實作<code>debounce</code>的功能呢？</p>
<p>RxJS 已經幫你實作好了，所以你只要加上<code>.debounceTime(250)</code>就好了，就是這麼簡單。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span></span><br><span class="line">  .<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>), <span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .<span class="title function_">debounceTime</span>(<span class="number">250</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(<span class="title function_">searchWikipedia</span>(value)).<span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderList</span>(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>還有最後一個問題要解決，那就是剛才提到的 request 的順序問題。</p>
<p>Observable 有一個不同的解法，我來解釋給大家聽聽。</p>
<p>其實除了<code>flatMap</code>以外，還有另外一種方式叫做<code>switchMap</code>，他們的差別在於要怎麼把 Observable 給壓平。前者我們之前介紹過了，就是會把每一個二維的 Observable 都壓平，並且「每一個都執行」。</p>
<p>而<code>switchMap</code>的差別在於，他永遠只會處理最後一個 Observable。拿我們的例子來說，假設第一個 request 還沒回來的時候，第二個 request 就發出去了，那我們的 Observable 就只會處理第二個 request，而不管第一個。</p>
<p>第一個還是會發送，還是會接收到資料，只是接收到資料以後不會再把這個資料 emit 到 Observable 上面，意思就是根本沒人理這個資料了。</p>
<p>可以看一下簡陋的圖解，<code>flatMap</code>每一個 promise resolve 之後的資料都會被發送到我們的 Observable 上面：</p>
<p><img src="/img/huli/rxjs/flatmap.png"></p>
<p>而<code>switchMap</code>只會處理最後一個：</p>
<p><img src="/img/huli/rxjs/switchmap.png"></p>
<p>所以我們只要把<code>flatMap</code>改成<code>switchMap</code>，就可以永遠只關注最後一個發送的 request，不用去管 request 傳回來的順序，因為前面的 request 都跟這個 Observable 無關了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span></span><br><span class="line">  .<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>), <span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .<span class="title function_">debounceTime</span>(<span class="number">250</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  .<span class="title function_">switchMap</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(<span class="title function_">searchWikipedia</span>(value)).<span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderList</span>(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>做到這邊，就跟剛剛實作的功能一模一樣了。</p>
<p>但其實還有地方可以改進，我們來做個小小的加強好了。現在的話當我輸入<code>abc</code>，會出現<code>abc</code>的相關關鍵字，接著我把<code>abc</code>全部刪掉，讓 input 變成空白，會發現 API 這時候回傳一個錯誤：<code>The &quot;search&quot; parameter must be set.</code>。</p>
<p>因此，我們可以在 input 是空的時候，不發送 request，只回傳一個空陣列，而回傳空陣列這件事情可以用<code>Rx.Observable.of([])</code>來完成，這樣會創造一個會發送空陣列的 Observable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span></span><br><span class="line">  .<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>), <span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .<span class="title function_">debounceTime</span>(<span class="number">250</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  .<span class="title function_">switchMap</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="property">length</span> &lt; <span class="number">1</span> ? <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">of</span>([]) : <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(<span class="title function_">searchWikipedia</span>(value)).<span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderList</span>(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>還有一個點擊關鍵字清單之後把文字設定成關鍵字的功能，在這邊就不示範給大家看了，但其實就是再創造一個 Observable 去監聽點擊事件，點到的時候就設定文字並且把關鍵字清單給清掉。</p>
<p>我直接附上參考程式碼：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span></span><br><span class="line">  .<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete__list&#x27;</span>), <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;li&#x27;</span>))</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">target</span>.<span class="property">innerHTML</span>)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.auto-complete input&#x27;</span>).<span class="property">value</span> = value;</span><br><span class="line">    <span class="title function_">renderList</span>([])</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>雖然我只介紹了最基本的操作，但 RxJS 的強大之處就在於除了這些，你甚至還有<code>retry</code>可以用，只要輕鬆加上這個，就能夠有自動重試的功能。</p>
<p>相關的應用場景還有很多，只要是跟 API 有關連的幾乎都可以用 RxJS 很優雅的解決。</p>
<h1 id="React-Redux-的非同步解決方案：redux-observable"><a href="#React-Redux-的非同步解決方案：redux-observable" class="headerlink" title="React + Redux 的非同步解決方案：redux-observable"></a>React + Redux 的非同步解決方案：redux-observable</h1><p>這是我們今天的最後一個主題了，也是我開場所提到的。</p>
<p>React + Redux 這一套非常常見的組合，一直都有一個問題存在，那就是沒有規範非同步行為（例如說 API）到底應該怎麼處理。而開源社群也有許多不同的解決方案，例如說 redux-thunk、redux-promise、redux-saga 等等。</p>
<p>我們前面講了這麼多東西，舉了這麼多範例，就是要證明給大家看 Reactive programming 很適合拿來解決複雜的非同步問題。因此，Netflix 就開源了這套<a target="_blank" rel="noopener" href="https://redux-observable.js.org/">redux-observable</a>，用 RxJS 來處理非同步行為。</p>
<p>在瞭解 RxJS 之後，可以很輕鬆的理解<code>redux-observable</code>的原理。</p>
<p>在 redux 的應用裡面，所有的 action 都會通過 middleware，你可以在這邊對 action 做任何處理。或者我們也可以把 action 看做是一個 Observable，例如說：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例而已</span></span><br><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(actionStreams)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(action.<span class="property">type</span>, action.<span class="property">payload</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>有了這個以後，我們就可以做一些很有趣的事情，例如說偵測到某個 action 的時候，我們就發送 request，並且把 response 放進另外一個 action 裡面送出去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(actionStreams)</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">action</span> =&gt;</span> action.<span class="property">type</span> === <span class="string">&#x27;GET_USER_INFO&#x27;</span>)</span><br><span class="line">  .<span class="title function_">switchMap</span>(</span><br><span class="line">    <span class="function"><span class="params">action</span> =&gt;</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(<span class="variable constant_">API</span>.<span class="title function_">getUserInfo</span>(action.<span class="property">payload</span>.<span class="property">userId</span>))</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function"><span class="params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;SET_USER_INFO&#x27;</span>,</span><br><span class="line">      <span class="attr">payload</span>: userInfo</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>上面就是一個簡單的例子，但其實<code>redux-observable</code>已經幫我們處理掉很多東西了，所以我們只要記得一個概念：</p>
<blockquote>
<p>action in, action out</p>
</blockquote>
<p><code>redux-observable</code> 是一個 middleware，你可以在裡面加上很多<code>epic</code>，每一個<code>epic</code>就是一個 Observable，你可以監聽某一個指定的 action，做一些處理，再轉成另外一個 action。</p>
<p>直接看程式碼會比較好懂：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Actions</span> <span class="keyword">from</span> <span class="string">&#x27;./actions/user&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ActionTypes</span> <span class="keyword">from</span> <span class="string">&#x27;./actionTypes/user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserEpic = action$ =&gt;</span><br><span class="line">  action$.<span class="title function_">ofType</span>(actionTypes.<span class="property">GET_USER</span>)</span><br><span class="line">    .<span class="title function_">switchMap</span>(</span><br><span class="line">      <span class="function"><span class="params">action</span> =&gt;</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">from</span>(<span class="variable constant_">API</span>.<span class="title function_">getUserInfo</span>(action.<span class="property">payload</span>.<span class="property">userId</span>))</span><br><span class="line">    ).<span class="title function_">map</span>(<span class="function"><span class="params">userInfo</span> =&gt;</span> <span class="title class_">Actions</span>.<span class="title function_">setUsers</span>(userInfo))</span><br></pre></td></tr></table></figure>

<p>大概就是像這樣，我們監聽一個 action type（GET_USER），一接收到的時候就發送 request，並且把結果轉為<code>setUsers</code>這個 action，這就是所謂的 action in, action out。</p>
<p>這樣的好處是什麼？好處是明確制定了一個規範，當你的 component 需要資料的時候，就送出一個 get 的 action，這個 action 經過 middleware 的時候會觸發 epic，epic 發 request 給 server 拿資料，轉成另外一個 set 的 action，經過 reducer 設定資料以後更新到 component 的 props。</p>
<p>可以看這張流程圖：</p>
<p><img src="/img/huli/rxjs/observable.png"></p>
<p>總之呢，<code>epic</code>就是一個 Observable，你只要確保你最後回傳的東西是一個 action 就好，那個 action 就會被送到 reducer 去。</p>
<p>礙於篇幅的關係，今天對於<code>redux-observable</code>只是概念性的帶過去而已，沒有時間好好示範，之後再來找個時間好好寫一下<code>redux-observable</code>的實戰應用。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>從一開始的陣列講到 Observable，講到畫圖的範例再講到經典的 Auto Complete，最後還講了<code>redux-observable</code>，這一路的過程中，希望大家有體會到 Observable 在處理非同步行為的強大之處以及簡潔。</p>
<p>這篇的目的是希望能讓大家理解 Observable 大概在做什麼，以及介紹一些簡單的應用場景，希望能提供一篇簡單易懂的中文入門文章，讓更多人能體會到 Observable 的威力。</p>
<p>喜歡這篇的話可以幫忙分享出去，發現哪邊有寫錯也歡迎留言指正，感謝。</p>
<p>參考資料：</p>
<p><a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10186104">30 天精通 RxJS (01)：認識 RxJS</a><br><a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/">Reactive Programming 簡介與教學(以 RxJS 為例)</a><br><a target="_blank" rel="noopener" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you’ve been missing</a><br><a target="_blank" rel="noopener" href="http://www.alloyteam.com/2016/12/learn-rxjs/">构建流式应用—RxJS详解</a><br><a target="_blank" rel="noopener" href="https://medium.com/kevin-salters-blog/epic-middleware-in-redux-e4385b6ff7c6">Epic Middleware in Redux</a><br><a target="_blank" rel="noopener" href="http://blog.danieleghidoli.it/2016/10/22/http-rxjs-observables-angular/">Combining multiple Http streams with RxJS Observables in Angular2</a></p>
<p>影片：<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=AslncyG8whg">Netflix JavaScript Talks - RxJS + Redux + React &#x3D; Amazing!</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=2LCo926NFLI">RxJS Quick Start with Practical Examples</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ei7FsoXKPl0">RxJS Observables Crash Course</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=COviCoUtwx4">Netflix JavaScript Talks - RxJS Version 5</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=3LKMwkuK0ZE">RxJS 5 Thinking Reactively | Ben Lesh</a></p>
<p>關於作者：<br><a target="_blank" rel="noopener" href="http://huli.logdown.com/">@huli</a> 野生工程師，相信分享與交流能讓世界變得更美好</p>
  
      <div>喜歡我們的文章嗎？歡迎分享按讚給予我們支持和鼓勵！</div>
      <div class="fb-like" data-href="https://blog.techbridge.cc/2017/12/08/rxjs/index.html" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>
      <br>
      <br>
      <div class="fb-page" data-href="https://www.facebook.com/techbridge.cc" data-small-header="false" data-adapt-container-width="true" data-hide-cover="false" data-show-facepile="true"><blockquote cite="https://www.facebook.com/techbridge.cc" class="fb-xfbml-parse-ignore"><a target="_blank" rel="noopener" href="https://www.facebook.com/techbridge.cc">TechBridge 技術日報</a></blockquote></div>
      <br>
    </section>
    <br>
    <hr>
    <div>
      <h4>訂閱 TechBridge Weekly 技術週刊，每週發送最精華的技術開發、產品設計的資訊給您</h4>
      <form class="form-control" method="post" action="https://goodbits.io/e/cab8a418-6b70-48d6-97ea-b5f0ef34b22c" target="_blank">
        <input class="form-control" type="text" name="first_name" placeholder="First Name"></input>
        <input class="form-control" type="text" name="last_name" placeholder="Last Name"></input>
        <div>
          <input class="form-control" type="text" name="email" placeholder="Email"></input>
        </div>
        <br>
        <div>
          <button class="form-control btn subscribe-btn" type="submit">馬上訂閱技術週刊</button>
        </div>
        <br>
        <label for="">PS. 我們討厭垃圾信，所以我們只提供有價值的內容給您 :)</label>
      </form>
    </div>
    <footer class="post-footer">
      <section class="author">
    <h4>TechBridge Weekly 技術週刊編輯團隊</h4>
    <p>TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、資料科學與產品設計等技術分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robotics, IoT, Data Science technology sharing.</p>
    <span><a href="/2016/03/19/about/">關於我們</a></span> / <span><a href="https://www.techbridge.cc/" target="_blank">技術日報</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>   
	<div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-size="large" data-action="like" data-show-faces="false" data-share="true"></div>    
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" target="_blank" rel="noopener" href="http://twitter.com/share?url=https://blog.techbridge.cc/2017/12/08/rxjs/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" target="_blank" rel="noopener" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.techbridge.cc/2017/12/08/rxjs/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" target="_blank" rel="noopener" href="https://plus.google.com/share?url=https://blog.techbridge.cc/2017/12/08/rxjs/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
    <iframe src="https://ghbtns.com/github-btn.html?user=TechBridgeHQ&repo=blog-starter-kit&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>      
</section>
    </footer>
    <br>
  </article>
  <nav class="pagination" role="pagination">
    <h2>更多優質技術文章</h2>
    
    <a class="newer-posts" href="/2017/12/12/d3v4-calendar-yearendreview/">
        ← 一起用 Google Calendar 與 D3.js 進行年終回顧吧！
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2017/12/02/ros-gps-install-intro/">
        Guided Policy Search 環境安裝 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">留言討論</a></h1>

    
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    
</div>
</main>


  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75308642-1', 'auto');
  ga('send', 'pageview');

</script>
<footer class="site-footer">
  
  <a class="subscribe icon-feed" href="/atom.xml"><span class="tooltip">Subscribe!</span></a>
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">TechBridge 技術共筆部落格</a> &copy; 2017 &bull; All rights reserved.</section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>


<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '[object Object]']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>


<script type="text/javascript">
    var disqus_shortname = 'techbridgeweekly';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.4/dist/medium-zoom.min.js"></script>
<script>
// NodeList
mediumZoom(document.querySelectorAll('img'));
</script>
  <div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, 'script', 'facebook-jssdk'));</script>
</body>
</html>
