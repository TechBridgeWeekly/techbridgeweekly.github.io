<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架 | TechBridge 技術共筆部落格</title>
  <meta name="description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- google-site-verification -->
  <meta name="google-site-verification" content="WX_9sZlrIYOEpy8RR7zCoa7-pJk611zZt11BSBUcDVY" />
  <link rel="stylesheet preload" type="text/css" href="/css/screen.css" as="style" />
  <link rel="stylesheet preload" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" as="style" />

  <!-- Favicons -->
  <link rel="apple-touch-icon" href="/img/favicon.ico">
  <link rel="icon preload" href="/img/favicon.ico" as="image">

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml">
  
  

  
</head>


<body class="post-template">

  <header class="site-head" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="/img/logo-tb-500-500.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">TechBridge 技術共筆部落格</h1>
            <h2 class="blog-description">var topics = ['Web前後端', '行動網路', '機器人/物聯網', '數據分析', '產品設計', 'etc.']</h2>
            <div class="navbar-block">
                <span><a href="/">首頁</a></span> / <span><a href="/about/">關於我們</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>
                <br>
            </div>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2018-01-05T12:12:43.000Z" itemprop="datePublished">
          2018-01-05
      </time>
    
    
    | 
    <a href='/tags/Rust-Tokio-Asynchronous-I-O-Translation/'>Rust, Tokio, Asynchronous I/O, Translation</a>
    
    
</span>

<meta name="generator" content="【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架">
<meta name="og:title" content="【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架">
<meta name="og:description" content="TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等技術分享。">
<meta name="og:type" content="website">
<meta name="og:image" content="/img/og-cover.png">

    <h1 class="post-title">【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架</h1>
    <section class="post-content">
      <div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>   
      <hr>
      <div style="text-align: center;">
  <img src="https://cafbit.com/resource/tokio/welcome_to_the_futures.jpg">
</div>

<blockquote>
<p>本文譯自 <a target="_blank" rel="noopener" href="https://cafbit.com/post/tokio_internals/">Tokio internals: Understanding Rust’s asynchronous I&#x2F;O framework from the bottom up</a>。<br>Thanks <a target="_blank" rel="noopener" href="https://www.davidsimmons.com/">David Simmons</a> for this awesome article!</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://tokio.rs/">Tokio</a> 是 Rust 的開發框架，用於開發非同步 I&#x2F;O 程式（asynchronous I&#x2F;O，一種事件驅動的作法，可實現比傳統同步 I&#x2F;O 更好的延伸性、效能與資源利用）。可惜的是，Tokio 過於精密的抽象設計，招致難以學習的惡名。即使我讀完教程後，依然不認為自己充分內化這些抽象層，以便推斷實際發生的事情。</p>
<p>從前的非同步 I&#x2F;O 相關開發經驗甚至阻礙我學習 Tokio。我習慣使用作業系統提供的 selection 工具（例如 Linux epoll）當作起點，再轉移至 dispatch、state machine 等等。倘若直接從 Tokio 抽象層出發，卻沒有清楚了解 <code>epoll_wait()</code> 在何處及如何發生，我會覺得難以連結每個概念。Tokio 與 future-driven 的方法就好像一個黑盒子。</p>
<p>我決定不繼續由上而下的方法學習 Tokio，反其道而行，而是透過閱讀原始碼，確切理解具體實作是如何驅動從 epoll 事件到 <code>Future::poll()</code> 消耗 I&#x2F;O 的整個過程。我不會深入高層次的 Tokio 與 futures 使用細節，<a target="_blank" rel="noopener" href="https://tokio.rs/docs/getting-started/tokio/">現有的教程</a> 有更完整詳細的內容。除了簡短的小結，我也不會探討一般性的非同步 I&#x2F;O 問題，畢竟這些問題都可寫個獨立的主題了。我的目標是有信心讓 futures 與 Tokio 以我所認知的方式執行。</p>
<p>首先，有些重要的聲明。請注意，Tokio 正快速開發中，這裡所見所聞可能不久就會過時。這個研究中我用了 <code>tokio-core 0.1.10</code>、<code>futures- 0.1.17</code> 與 <code>mio 0.6.10</code>。由於我想從最底層理解 Tokio，我並不會考慮更高層次的套件如 <code>tokio-proto</code> 與 <code>tokio-service</code>。tokio-core 的事件系統本身有許多細節，為了精簡，我會盡量避開這些細項。我在 Linux 作業系統上研究 Tokio，而有些討論細節與作業系統相依，如 epoll。最後，這裡所有東西都是我這個 Tokio 新手的詮釋，可能會有錯誤或誤導。</p>
<h2 id="Asynchronous-I-O-in-a-nutshell"><a href="#Asynchronous-I-O-in-a-nutshell" class="headerlink" title="Asynchronous I&#x2F;O in a nutshell"></a>Asynchronous I&#x2F;O in a nutshell</h2><p>同步 I&#x2F;O 程式會執行阻塞性的 I&#x2F;O 操作，直到操作完成。例如讀取會阻塞至資料抵達，寫入會阻塞線程直到欲傳遞的 bytes 送達 kernel。這些操作非常適合依序執行的傳統命令式程式設計。舉例來說，一個 HTTP 伺服器替每個新連線產生一個新線程，這個線程會讀取資料並阻塞線程直到接收完整的 request，之後處理請求，再來阻塞線程至資料完全寫入 response。這是個方法非常直觀，缺點是會阻塞線程，因此每個連線的線程要各自獨立，每個線程也需有自己的 stack。然而，線程開銷阻礙了伺服器處理大量連線的可延伸性（參閱 <a target="_blank" rel="noopener" href="https://wikipedia.org/wiki/C10k_problem">C10k problem</a>)，對低階系統來說也不易負荷。</p>
<p>如果 HTTP server 使用非同步 I&#x2F;O 開發，換句話說，在同一個線程上處理所有 I&#x2F;O 操作。如此一來，所有活躍的連線以及 socket 監聽都會配置為非阻塞狀態（non-blocking），並在 event loop 中監控讀取與寫入是否就緒，進而在事件發生時分派給對應的處理程式（handler）。而每個連線都需維護自身的狀態與 buffer，如果一個處理程式一次僅能從 200 bytes 的 request 中讀取 100 個位元組（bytes），它就不能等待剩下的 bytes 而造成線程阻塞，處理程式必須將部分資料儲存在 buffer 中，設定當前的狀態為「讀取請求中」，並返回給 event loop。待到下一次連線調用的相同的處理程式，它才可讀取剩餘的 bytes 並將狀態轉為「寫入回應中」。如此的資源管理系統將會非常迅速，但同時也產生更複雜的 state machine 與容易出錯的毛病。</p>
<p>理想中的非同步 I&#x2F;O 框架應該要提供能寫出近似於同步 I&#x2F;O 的程式，但底層是 event loop 與 state machine。這對每個語言來說都很不容易，不過 Tokio 的實現已接近了。</p>
<h2 id="The-Tokio-stack"><a href="#The-Tokio-stack" class="headerlink" title="The Tokio stack"></a>The Tokio stack</h2><p><img src="https://cafbit.com/resource/tokio/tokio-stack.svg"></p>
<p>Tokio 的技術棧由下列幾個部分組成：</p>
<ol>
<li><strong>The system selector</strong>。每個作業系統皆提供接收 I&#x2F;O 事件的工具，如 epoll（linux）、<code>kqueue()</code>（FreeBSD&#x2F;macOS），與 IOCP（Windows）。</li>
<li><strong>Mio - Metal I&#x2F;O</strong>。<a target="_blank" rel="noopener" href="https://docs.rs/mio/0.6.10/mio/">Mio</a> 是一個 Rust crate，提供低階通用的 I&#x2F;O API，內部處理特定作業系統的 selector 實作細節，所以你不需再處理這件事。</li>
<li><strong>Futures</strong>。<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/">Futures</a> 以強大的抽象來表示尚未發生的事物。這些 future 以許多好用的方式組合成另一新的複合 future 來代表一系列複雜的事件。這個抽象層足以通用於許多 I&#x2F;O 之外的事件，但在 Tokio 中<br>，我們專注在利用 futures 開發非同步 I&#x2F;O state machines。</li>
<li><strong>Tokio</strong>。<a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/">tokio-core</a> 提供一個中心的 event loop，這個 event loop 整合 Mio 回應 I&#x2F;O 事件，並驅動 futures 完成（completion）。</li>
<li><strong>Your program</strong>。一個採用 Tokio 框架的程式，會以 futures 操作非同步 I&#x2F;O，並將這些 futures 傳遞給 Tokio 的 event loop 來執行。</li>
</ol>
<h2 id="Mio-Metal-I-O"><a href="#Mio-Metal-I-O" class="headerlink" title="Mio: Metal I&#x2F;O"></a>Mio: Metal I&#x2F;O</h2><p>Mio 旨在提供一系列低階的 I&#x2F;O API，允許調用端接收事件，如 socket 讀寫就緒狀態（readiness state）改變等。重點如下：</p>
<ol>
<li><p><strong>Poll 與 Evented</strong>。Mio 提供 <a target="_blank" rel="noopener" href="https://docs.rs/mio/0.6.10/mio/event/trait.Evented.html"><code>Evented</code></a> trait 來表示任何可當作事件來源的事物。在你的 event loop 中，你會利用 <a target="_blank" rel="noopener" href="https://docs.rs/mio/0.6.10/mio/struct.Poll.html"><code>mio::Poll</code></a> 物件註冊一定數量的 <code>Evented</code>，再調用 <a target="_blank" rel="noopener" href="https://docs.rs/mio/0.6.10/mio/struct.Poll.html#method.poll"><code>mio::Poll::poll</code></a> 來阻塞 loop，直到一至多個 <code>Evented</code> 產生事件（或超時）。</p>
</li>
<li><p><strong>System selector</strong>。Mio 提供可跨平台的 system selector 訪問，所以 Linux epoll、Windows IOCP、FreeBSD&#x2F;macOS <code>kqueue()</code>，甚至許多有潛力的平台都可調用相同的 API。不同平台使用 Mio API 的開銷不盡相同。由於 Mio 是提供基於 readiness（就緒狀態）的 API，與 Linux epoll 相似，不少 API 在 Linux 上都可以一對一映射。（例如：<code>mio::Events</code> 實質上是一個 <code>struct epoll_event</code> 陣列。）對比之下，Windows IOCP 是基於完成（completion-based）而非基於 readiness 的 API，所以兩者間會需要較多橋接。Mio 同時提供自身版本的 <code>std::net</code> struct 如 <code>TcpListener</code>、<code>TcpStream</code> 與 <code>UdpSocket</code>。這些 API 封裝 <code>std::net</code> 版本的 API，預設為非阻塞且提供 <code>Evented</code> 實作讓其將 socket 加入 system selector。</p>
</li>
<li><p><strong>Non-system events</strong>。Mio 除了提供從 I&#x2F;O 所得的 readiness 狀態來源，也可以用來指示從 user-space 來的 readiness 事件（非系統事件）。舉例來說，當一個工作線程（worker thread）完成一單位的工作，它就可以向 event loop 發出完成信號。你的程式調用 <a target="_blank" rel="noopener" href="https://docs.rs/mio/0.6.10/mio/struct.Registration.html#method.new2"><code>Registration::new2()</code></a> 以取得一個 <code>(Registration, SetReadiness)</code> 元組。<code>Registration</code> 是一個實作 <code>Evented</code> 且藉由 Mio 註冊在 event loop 的物件；而需要指示當前 readiness 狀態時，則會調用 <a target="_blank" rel="noopener" href="https://docs.rs/mio/0.6.10/mio/struct.SetReadiness.html#method.set_readiness"><code>SetReadiness::set_readiness</code></a>。在 Linux 上，非系統事件通知以 pipe 實作，當調用 <code>SetReadiness::set_readiness()</code> 時，會將 <code>0x01</code> 這個位元組寫入 pipe 中。而 <code>mio::Poll</code> 底層的 epoll 會配置為監控 pipe 讀取結束，所以 <code>epoll_wait()</code> 會解除阻塞，而 Mio 就可以將事件傳遞到調用端。另外，無論註冊多少非系統事件，都只會在 Poll 實例化時建立唯一一個 pipe。</p>
</li>
</ol>
<p>每個 <code>Evented</code> 的註冊皆與一個由調用端提供 <code>usize</code> 型別的 <a target="_blank" rel="noopener" href="https://docs.rs/mio/0.6.10/mio/struct.Token.html"><code>mio::Token</code></a> 綁定，這個 token 將會與事件一起返回，以指示出對應的註冊資訊。這種作法很好地映射到 Linux 的 system selector，因為 token 可以放置在 64-bit 的 <code>epoll_data</code> union 中，並保持相同的功能。</p>
<p>這裡提供一個 Mio 操作的實際案例，下面是我們在 Linux 上使用 Mio 監控一個 UDP socket 的情況：</p>
<ol>
<li><p><strong>建立 socket</strong>。</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">socket</span> = mio::net::UdpSocket::<span class="title function_ invoke__">bind</span>(</span><br><span class="line">    &amp;SocketAddr::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        std::net::IpAddr::<span class="title function_ invoke__">V4</span>(std::net::Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)),</span><br><span class="line">        <span class="number">2000</span></span><br><span class="line">    )</span><br><span class="line">).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p> 建立一個 Linux UDP socket，其中封裝一個 <code>std::net::UdpSocket</code>，再封裝在 <code>mio::net::UdpSocket</code> 中。這個 socket 為非阻塞性（non-blocking）。</p>
</li>
<li><p><strong>建立 poll 實例</strong>。</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">poll</span> = mio::Poll::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p> 在這步驟，Mio 初始化 system selector、readiness 佇列（用於非系統事件），以及併發保護。當 readiness 佇列初始化時，會建立一個 pipe，讓 readiness 從 user-space 發出信號，而這個 pipe 的檔案描述符（file descriptor）會加入 epoll 中。每個 <code>Poll</code> 物件建立時，都會賦予一個獨特、遞增的 <code>selector_id</code>。</p>
</li>
<li><p><strong>透過 poll 註冊 socket</strong>。</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">poll.<span class="title function_ invoke__">register</span>(</span><br><span class="line">    &amp;socket,</span><br><span class="line">    mio::<span class="title function_ invoke__">Token</span>(<span class="number">0</span>),</span><br><span class="line">    mio::Ready::<span class="title function_ invoke__">readable</span>(),</span><br><span class="line">    mio::PollOpt::<span class="title function_ invoke__">level</span>()</span><br><span class="line">).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p> <code>UdpSocket</code> 的 <code>Evented::register()</code> 被調用時，會將代理指向一個封裝的 <code>EventedFd</code>，這個 <code>EventedFd</code> 會將 socket 的 file descriptor 加入 poll selector 中（最終會調用 <code>epoll_ctl(fepd, EPOLL_CTL_ADD, fd, &amp;epoll_event)</code>，而 <code>epoll_event.data</code> 設置為傳入的 token 值）。當一個 <code>UdpSocket</code> 註冊後，<code>selector_id</code> 會設置到與傳入的 <code>Poll</code> 相同，從而與 selector 產生連結。</p>
</li>
<li><p>**在 event loop 中呼叫 <code>poll()</code>**。</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    poll.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> events, <span class="literal">None</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">event</span> <span class="keyword">in</span> &amp;events &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_event</span>(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> System selector（<code>epoll_wait()</code>）與 readiness 佇列將會輪詢（poll）新的事件。（<code>epoll_wait()</code> 會阻塞，但由於非系統事件是透過 pipe 出發 epoll，事件仍會即時處理。）這一系列組合的事件可供調用端處理。</p>
</li>
</ol>
<h2 id="Futures-and-Tasks"><a href="#Futures-and-Tasks" class="headerlink" title="Futures and Tasks"></a>Futures and Tasks</h2><p><a target="_blank" rel="noopener" href="https://wikipedia.org/wiki/Futures_and_promises">Futures</a> 是從函數式程式設計借來的技術，一個尚未完成的運算會以一個 future 代表，而這些獨立的 future 可以組合起來，開發更複雜的系統。這個概念對非同步 I&#x2F;O 非常中用，因為在處理交易（transaction）的所有基礎步驟，都可以模化為合成 futures（combinded futures）。以 HTTP 伺服器為例，一個 future 讀取 request，會從接收到有效資料開始讀取到 request 結束，另一個 future 則會處理這個 request 並產生 response，再另一個 future 則會寫入 responses。</p>
<p>在 Rust 中，<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/">futures crate</a> 實現了 futures。你可以透過實作 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html">Future</a> trait 來定義自己的 future，這個 trait 需實現 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html#tymethod.poll"><code>poll()</code></a> 方法，這個方法會在需要時調用，允許 future 開始執行。<code>poll()</code> 方法會回傳一個錯誤（error），或回傳一個指示告知 future 仍在處理，或是當 future 完成時返回一個值。<code>Future</code> trait 也提供許多組合操作子（combinator）作為預設方法。</p>
<p>欲理解 futures，須先探討三個重要的概念：<strong>tasks</strong>、<strong>executors</strong>，以及 <strong>notifications</strong>，且需理解此三者該如何安排，才能在正確時間點調用 future 的 <code>poll()</code> 方法。每一個 future 都在一個 task 語彙環境（context）中執行。一個 task 只與一個 future 關聯，而這個 future 卻可能是一個合成的 future，驅動其他封裝的 futures。（舉例來說，多個 future 用 <code>join_all()</code> 組合操作子，串連成單一一個 future，或是兩個 future 利用 <code>and_then()</code> 組合操作子來依序執行。）</p>
<p>Task 與它的 futures 需要被一個 <em>executor</em> 執行。一個 executor 的責任是在正確時間點輪詢 task&#x2F;future，輪詢通常會在接收到執行進度開始的通知時。而這個通知將在一個實作 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/executor/trait.Notify.html"><code>futures::executor::Notify</code></a> trait 的物件調用 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/executor/trait.Notify.html"><code>notify</code></a> 時發布。這裡有個例子，是由 futures crate 所提供的非常簡單的 executor，在調用 future 上的 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html#method.wait"><code>wait()</code></a> 被呼叫。擷自<a target="_blank" rel="noopener" href="https://github.com/alexcrichton/futures-rs/blob/0.1.17/src/task_impl/std/mod.rs#L233">原始碼</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Waits for the internal future to complete, blocking this thread&#x27;s</span></span><br><span class="line"><span class="comment">/// execution until it does.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This function will call `poll_future` in a loop, waiting for the future</span></span><br><span class="line"><span class="comment">/// to complete. When a future cannot make progress it will use</span></span><br><span class="line"><span class="comment">/// `thread::park` to block the current thread.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait_future</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;F::Item, F::Error&gt; &#123;</span><br><span class="line">    ThreadNotify::<span class="title function_ invoke__">with_current</span>(|notify| &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">poll_future_notify</span>(notify, <span class="number">0</span>)? &#123;</span><br><span class="line">                Async::NotReady =&gt; notify.<span class="title function_ invoke__">park</span>(),</span><br><span class="line">                Async::<span class="title function_ invoke__">Ready</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>給定一個融合 task 與 future 的 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/executor/struct.Spawn.html"><code>futures::executor::Spawn</code></a> 物件，這個 executor 在迴圈中調用 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/executor/struct.Spawn.html#method.poll_future_notify"><code>poll_future_notify</code></a>。這個 <code>Notify</code> 會成為 task 執行語彙環境的一部分，future 也會被輪詢。如果一個 future <code>poll</code> 方法回傳 <code>Async::NotReady</code>，表示 future 仍等待中，必須在往後再次輪詢。<code>Notify</code> object 會從 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/task/fn.current.html"><code>futures::task::current()</code></a> 取得一個指向 task 的 handle，且在 future 有些進展時調用 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/task/struct.Task.html#method.notify"><code>notify()</code></a> 方法。（當一個 future 被輪詢時，與該 future 相關的 task 訊息將會儲存到 thread-local 中，thread-local 可以透過 <code>current()</code> 存取取得。）上例中，如果輪詢回傳 <code>Async::NotReady</code>，executor 會阻塞至接收到通知。也許 future 在其他線程運算，在完成時調用 <code>notify()</code>；或是 <code>poll()</code> 方法在返回 <code>Asynx::NotReady</code> 之前，自身直接調用了 <code>notify()</code>（後者並不常見，因為理論上一個 <code>poll()</code> 在返回之前應該持續取得進展）。 </p>
<p>Tokio 的 event loop 行為上比簡單整合「 Mio 事件驅動 future 完成」來得精細。舉例來說，一個 Mio event 表示一個 socket 的 readiness（就緒狀態），最後會產生一個通知，足以告知相對應的 future 需要輪詢。</p>
<p>處理 future 時，Task 是最基礎的執行單元，且基本上就是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Green_threads">綠色線程</a>，提供<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cooperative_multitasking">協調式多工</a>，允許在同一個系統線程有多個執行語彙環境。當一個 task 無法有所進展，會讓處理器先處理其他可執行的 task。我們必須理解的是，「通知」會發生在 task 層級而非 future 層級。當一個 task 被通知時，它會輪詢它連結的最高層級的 future，這會導致任何或是全部的 child future 同樣被輪詢。例如，如果一個 task 最高層級的 future 是一個以 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/future/fn.join_all.html"><code>join_all</code></a> 組合的十個 future，而其中一個 future 安排要通知此一 task，則無論需不需要，全部十個 future 皆須接受輪詢。</p>
<h2 id="Tokio’s-interface-with-Mio"><a href="#Tokio’s-interface-with-Mio" class="headerlink" title="Tokio’s interface with Mio"></a>Tokio’s interface with Mio</h2><p>Tokio 利用上述的 Mio 「非系統事件」，將 task 通知轉換為 Mio 的事件。在取得一個 Mio 的 (<code>Registration</code>、<code>SetReadiness</code>）元組後，Tokio 會將 <code>Registration</code>（一個 <code>Evented</code>）註冊至 Mio 的 poll （event loop）中，再將 <code>SetReadiness</code> 封裝在實作了 <code>Notify</code> trait 的 <code>MySetReadiness</code> 中。<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/tokio-core/blob/0.1.10/src/reactor/mod.rs#L791">原始碼</a>如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MySetReadiness</span>(mio::SetReadiness);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Notify</span> <span class="keyword">for</span> <span class="title class_">MySetReadiness</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify</span>(&amp;<span class="keyword">self</span>, _id: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">set_readiness</span>(mio::Ready::<span class="title function_ invoke__">readable</span>())</span><br><span class="line">              .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to set readiness&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個作法中，task 的通知將轉換為 Mio 事件，且可以透過 Tokio 的事件處理與分派機制與其他 Mio 事件作伙處理。</p>
<p>如同 Mio 封裝 <code>std::net</code> 內的 <code>UdpSocket</code>、<code>TcpListener</code>，以及 <code>TcpStream</code> 來客製化需求，Tokio 也利用了組合（composition）與裝飾（decoration）建立這些型別的 Tokio 版。舉例來說，Tokio 的 <code>UdpSocket</code> 架構大致如下：</p>
<p><img src="https://cafbit.com/resource/tokio/udpsocket.svg"></p>
<p>Tokio 版本的 I&#x2F;O 來源型別的建構子都需要傳入 event loop 的 handle（<a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Handle.html"><code>tokio_core::reactor::Handle</code></a>）。當實例化時，這些型別會將它們的 socket 註冊至 Mio poll 的 event loop 上，以利接收 edge-triggred（譯注：一種 epoll event 的觸發模式）的事件及其新賦予的偶數數字 token（以下會解釋）。當底層的 I&#x2F;O 操作回傳 <code>WouldBlock</code> 時，這些型別可以很方便地安排當前的 task 來接收讀寫的 readiness。</p>
<p>Tokio 在 Mio 上註冊了許多 <code>Evented</code> 型別，儲存在特定的 token 上：</p>
<ul>
<li><p><strong>Token 0（<code>TOKEN_MESSAGES</code>）</strong>：用於 Tokio 內部的消息佇列（message queue），這個佇列提供移除 I&#x2F;O 來源、接收讀寫 readiness 通知的 task 排程，設定 timeout，以及執行在 event loop 語彙環境中的任意閉包。這個 token 可以安全地從其他線程與 event loop 溝通。例如，<a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Remote.html#method.spawn"><code>Remote::spawn()</code></a> 透過訊息系統，將 future 送達 event loop。</p>
<p>  實作上，消息佇列是一個 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/sync/mpsc/index.html"><code>futures::sync::mpsc</code></a> stream。身為一個 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html"><code>futures::stream::Stream</code></a>（與 future 類似，但是產生一序列的值而非單一值），消息佇列使用上述 <code>MySetReadiness</code> 方案來處理，而 <code>Registration</code> 則是以 <code>TOKEN_MESSAGES</code> 這個 token 註冊。當接收到 <code>TOKEN_MESSAGES</code> 事件時，該事件會分派到 <code>consume_queue()</code> 方法進一步處理。（原始碼：<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/tokio-core/blob/0.1.10/src/reactor/mod.rs#L133"><code>enum Message</code></a>、<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/tokio-core/blob/0.1.10/src/reactor/mod.rs#L403"><code>consume_queue()</code></a>）</p>
</li>
<li><p><strong>Token 1（<code>TOKEN_FUTURE</code>）</strong>：用於通知 Tokio 需要輪詢 main task。這個 token 會在與 main task 相關聯的通知上（也就是傳入 <code>Core::run()</code> 的 future 或它的子 future，而非透過 <code>spawn()</code> 在不同 task 中執行的 future）。這個事件同樣用了 <code>MySetReadiness</code> 方案將 future 轉譯成 Mio 的事件。在一個 future 被 main task 執行前，會先回傳 <code>Async::NotReady</code>，並以其所選的方式在稍後發布通知。當接收了 <code>TOKEN_FUTURE</code> 事件，Tokio event loop 就會再次輪詢 main task。</p>
</li>
<li><p><strong>大於 1 的偶數 token（<code>TOKEN_START + key * 2</code>）</strong>：用來指示 I&#x2F;O 來源的 readiness 改變。Token 中的 key 是 <code>Slab</code> key，關聯值是 <code>Core::inner::io_dispatch Slab&lt;ScheduledIo&gt;</code>。當 Mio 的 I&#x2F;O 來源型別（<code>UdpSocket</code>、<code>TcpListener</code>、<code>TcpStream</code>）實例化之初，會自動以此 token 註冊。</p>
</li>
<li><p><strong>大於 1 的奇數 token（<code>TOKEN_START + key * 2 + 1</code>）</strong>：用來指示一個 spawned task（及其關聯的 future）需要被輪詢。Token 中的 key 是 <code>Slab</code> key，關聯值是 <code>Core::inner::task_dispatch Slab&lt;ScheduledTask&gt;</code>。和 <code>TOKEN_MESSAGES</code> 與 <code>TOKEN_FUTURE</code> 事件相同，這個事件也用了 <code>MySetReadiness</code> 溝通。</p>
</li>
</ul>
<h2 id="Tokio-event-loop"><a href="#Tokio-event-loop" class="headerlink" title="Tokio event loop"></a>Tokio event loop</h2><p>Tokio，更精確來說是 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Core.html"><code>tokio_core::reactor::Core</code></a> 提供了 event loop 來管理 futures 和 tasks，驅動 future 完成，以及與 Mio 介接的介面，讓 I&#x2F;O 事件可正確通知對應的 task。使用 event loop 需透過 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Core.html#method.new"><code>Core::new()</code></a> 實例化一個 <code>Core</code>，並調用 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Core.html#method.run"><code>Core::run()</code></a> 傳入一個 future。這個 event loop 在返回之前，將會驅動傳入的 future 至完成。以伺服器程式來說（serve application），這個 future 很可能生命週期較長，例如使用 <code>TcpListener</code> 持續接收新傳入的連結，每個連結透過 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Handle.html#method.spawn"><code>Handle.spawn()</code></a> 分別建立 task，由自身的 future 獨立處理。</p>
<p>以下的流程圖大略點出 Tokio event loop 的基本輪廓：</p>
<p><img src="https://cafbit.com/resource/tokio/tokio-event-loop.svg"></p>
<h2 id="What-happens-when-data-arrives-on-a-socket"><a href="#What-happens-when-data-arrives-on-a-socket" class="headerlink" title="What happens when data arrives on a socket?"></a>What happens when data arrives on a socket?</h2><p>想了解 Tokio，可以觀察當資料抵達 socket 時，event loop 發生的每個步驟。我很訝異地發現，這個過程最終分為兩部分，分別在 event loop 內各自的迭代中，進行各自的 epoll 交易處理。第一部分負責當 socket 讀取就緒時（例如，Mio 事件帶著比 1 大的偶數 token，或 main task 的 <code>TOKEN_FUTURE</code>），傳送通知到對該 socket 有興趣的 task；第二部分則是透過輪詢 task 與它的 future 來處理通知（例如，Mio 事件帶著比 1 大的奇數 token）。我們來了解以下情境：一個 spawned task 從 Linux 上的 <code>UdpSocket</code>，透過 Tokio event loop 讀取資料，並假設前一次輪詢結果導致 <code>recv_from()</code> 回傳一個 <code>WouldBlock</code> 錯誤。</p>
<p><img src="https://cafbit.com/resource/tokio/recv-sequence-1.svg"></p>
<p>Tokio event loop 調用 <code>mio::Poll:poll()</code>，該方法轉而調用 <code>epoll_wait()</code>（在 Linux 上）進而阻塞到某個監測中的 file descriptor 發生了 readiness 改變的事件。當上述情形發生後，<code>epoll_wait()</code> 回傳一個 <code>epoll_event</code> structs 的陣列，用以描述發生什麼事，這些 structs 也將透過 Mio 轉譯為 <code>mio::Events</code>，並返回 Tokio。（在 Linux 上，這些轉譯應該是零成本（zero-cost），因為 <code>mio::Events</code> 就只是簡單，以一個 <code>epoll_event</code> 陣列組成的元組結構（tuple struct）。）在我們的例子，假設在陣列中只有一個事件指出 socket 已讀取就緒。由於該事件的 token 是大於 1 的偶數，Tokio 辨識其為 I&#x2F;O 事件，並從 <code>Slab&lt;ScheduledIo&gt;</code> 中尋找對應的元素，以取得有哪些 task 對這個 socket 的讀寫 readiness 狀態有興趣。接下來，Tokio 會通知對讀取有興趣的 task，這些 task 透過前述的 <code>MySetReadiness</code>，調用 Mio 的 <code>set_readiness()</code>。Mio 會將這個非系統的事件詳細資訊加到 readiness 佇列中，並寫入 <code>0x01</code> 到 readiness pipe 中。</p>
<p><img src="https://cafbit.com/resource/tokio/recv-sequence-2.svg"></p>
<p>在 Tokio event loop 往下一個迭代前進之前，它會再次輪詢 Mio，Mio 則調用 <code>epoll_wait()</code>，而 <code>epoll_wait()</code> 這次返回一個在 Mio 的 readiness pipe 上發生的讀取 readiness 事件。Mio 讀取之前寫入的 <code>0x01</code>，並從 readiness 佇列取出最前端（dequeue）的非系統事件資料，並將這個事件回傳到 Tokio。由於該事件的 token 是大於 1 的奇數 token，Tokio 辨識其為 task 通知事件，並從 <code>Slab&lt;ScheduledTask&gt;</code> 中尋找對應的元素，以取得 task 從 <code>spawn()</code> 回傳的最原始的 <code>Spawn</code> 物件。接下來，Tokio 透過 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/executor/struct.Spawn.html#method.poll_future_notify"><code>poll_future_notify()</code></a> 輪詢這個 task 與它的 future，這個 future 可能會從 socket 讀取資料，直至得到 <code>WouldBlock</code> 錯誤。</p>
<p>這個二迭代的方法涉及了 pipe 讀寫，對比其他非同步 I&#x2F;O event loop，可能會有一點額外開銷。如果在一個單線程的程式中，使用 <code>strace</code> 會看到一個線程用 pipe 與自己溝通，很是奇怪：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pipe2([<span class="number">4</span>, <span class="number">5</span>], O_NONBLOCK|O_CLOEXEC) = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">epoll_wait(<span class="number">3</span>, [&#123;EPOLLIN|EPOLLOUT, &#123;u32=<span class="number">14</span>, u64=<span class="number">14</span>&#125;&#125;], <span class="number">1024</span>, <span class="number">-1</span>) = <span class="number">1</span></span><br><span class="line">write(<span class="number">5</span>, <span class="string">&quot;\1&quot;</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">epoll_wait(<span class="number">3</span>, [&#123;EPOLLIN, &#123;u32=<span class="number">4294967295</span>, u64=<span class="number">18446744073709551615</span>&#125;&#125;], <span class="number">1024</span>, <span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">read(<span class="number">4</span>, <span class="string">&quot;\1&quot;</span>, <span class="number">128</span>) = <span class="number">1</span></span><br><span class="line">read(<span class="number">4</span>, <span class="number">0x7ffce1140f58</span>, <span class="number">128</span>) = <span class="number">-1</span> EAGAIN (Resource temporarily unavailable)</span><br><span class="line">recvfrom(<span class="number">12</span>, <span class="string">&quot;hello\n&quot;</span>, <span class="number">1024</span>, <span class="number">0</span>, &#123;sa_family=AF_INET, sin_port=htons(<span class="number">43106</span>), sin_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;, [<span class="number">16</span>]) = <span class="number">6</span></span><br><span class="line">recvfrom(<span class="number">12</span>, <span class="number">0x7f576621c800</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0x7ffce1140070</span>, <span class="number">0x7ffce114011c</span>) = <span class="number">-1</span> EAGAIN (Resource temporarily unavailable)</span><br><span class="line">epoll_wait(<span class="number">3</span>, [], <span class="number">1024</span>, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">epoll_wait(<span class="number">3</span>, <span class="number">0x7f5765b24000</span>, <span class="number">1024</span>, <span class="number">-1</span>) = <span class="number">-1</span> EINTR (Interrupted system call)</span><br></pre></td></tr></table></figure>

<p>Mio 選用 pipe 的方案來支持通用性，以防 <code>set_readiness()</code> 可能被其他線程調用。也有可能這種作法對強制實施公平的事件調節與維持 futures 與 I&#x2F;O 的間接層有所幫助。</p>
<h2 id="Lessons-learned-Combining-futures-vs-spawning-futures"><a href="#Lessons-learned-Combining-futures-vs-spawning-futures" class="headerlink" title="Lessons learned: Combining futures vs. spawning futures"></a>Lessons learned: Combining futures vs. spawning futures</h2><p>最初探索 Tokio 時，我寫了一個小程式，負責監聽不同 UDP socket 進來的資料。這個程式建立十個讀取 socket 的 future 實例，每個都監聽不同的埠口（port）。我天真地使用 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/future/fn.join_all.html"><code>join_all()</code></a> 將所有 future 合成為單一 future，並將之傳入 <code>Core::run()</code>，訝異的是，我發現每當一個封包送達，所有 future 都會輪詢一次。另一個驚訝的點是，<code>tokio_core::net:UdpSocket::recv_from()</code>（以及底層的 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.PollEvented.html"><code>PollEvented</code></a>）非常聰明，當 socket 在前一次的 Mio 輪詢中尚未標記為讀取就緒時，會避免調用作業系統 <code>rectfrom()</code>。以下的 <code>strace</code> 反映出我寫的 future <code>poll()</code> 的除錯 <code>println!()</code>，大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">epoll_wait(<span class="number">3</span>, [&#123;EPOLLIN|EPOLLOUT, &#123;u32=<span class="number">14</span>, u64=<span class="number">14</span>&#125;&#125;], <span class="number">1024</span>, <span class="number">-1</span>) = <span class="number">1</span></span><br><span class="line">write(<span class="number">5</span>, <span class="string">&quot;\1&quot;</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">epoll_wait(<span class="number">3</span>, [&#123;EPOLLIN, &#123;u32=<span class="number">4294967295</span>, u64=<span class="number">18446744073709551615</span>&#125;&#125;], <span class="number">1024</span>, <span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">read(<span class="number">4</span>, <span class="string">&quot;\1&quot;</span>, <span class="number">128</span>) = <span class="number">1</span></span><br><span class="line">read(<span class="number">4</span>, <span class="number">0x7ffc183129d8</span>, <span class="number">128</span>) = <span class="number">-1</span> EAGAIN (Resource temporarily unavailable)</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">recvfrom(<span class="number">12</span>, <span class="string">&quot;hello\n&quot;</span>, <span class="number">1024</span>, <span class="number">0</span>, &#123;sa_family=AF_INET, sin_port=htons(<span class="number">43106</span>), sin_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;, [<span class="number">16</span>]) = <span class="number">6</span></span><br><span class="line">getsockname(<span class="number">12</span>, &#123;sa_family=AF_INET, sin_port=htons(<span class="number">2006</span>), sin_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;, [<span class="number">16</span>]) = <span class="number">0</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;recv 6 bytes from 127.0.0.1:43106 at 127.0.0.1:2006\n&quot;</span>, <span class="number">52</span>) = <span class="number">52</span></span><br><span class="line">recvfrom(<span class="number">12</span>, <span class="number">0x7f2a11c1c400</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0x7ffc18312ba0</span>, <span class="number">0x7ffc18312c4c</span>) = <span class="number">-1</span> EAGAIN (Resource temporarily unavailable)</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;UdpServer::poll()...\n&quot;</span>, <span class="number">21</span>) = <span class="number">21</span></span><br><span class="line">epoll_wait(<span class="number">3</span>, [], <span class="number">1024</span>, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">epoll_wait(<span class="number">3</span>, <span class="number">0x7f2a11c36000</span>, <span class="number">1024</span>, <span class="number">-1</span>) = ...</span><br></pre></td></tr></table></figure>

<p>有鑑於 Tokio 與 futures 的具體內部運作某個程度上對我來說有點隱晦，我想我希望背後有些魔法路由，可以只輪詢必要的 futures。當然，對 Tokio 有更深入的理解後，我的程式很明顯這樣利用 futures：</p>
<p><img src="https://cafbit.com/resource/tokio/futures-join.svg"></p>
<p>這的確可以執行，但不夠好，尤其是當你有一拖拉庫 socket 時。由於通知在 task 層級發生，上圖中任意一個綠色方格中通知都會導致 main task 被通知。它將會輪詢 <code>FromAll</code> future 使得所有 <code>FromAll</code> 的 child future 都須接受輪詢。我真正需要的是一個簡單的 main future，使用 <code>Handle::spawn()</code> 來啟動每個封裝在各自的 task 中的 future。這種安排大致如下圖：</p>
<p><img src="https://cafbit.com/resource/tokio/futures-spawn.svg"></p>
<p>當任何 future 安排一個通知，只有該 future 的 task 會收到通知，也只有該 future 會被輪詢（回想一下，「安排一個通知」會自動發生在 <code>tokio_core::net:UdpSocket::rect_from()</code> 從 <code>mio::net::UdpSocket::rect_from()</code> 回傳值中接收到 <code>WouldBlock</code> ）。future 組合操作子敘述表達能力強勁，可好整以暇地描述協議（protocol）的流程而不須弄髒手寫手動輪詢的狀態機。然而重要的是，你必須理解你的設計也許需要支援各自獨立，獨自且並行運作的 tasks。（譯注：而非都在 main task 上使用 <code>join_all()</code>）</p>
<h2 id="Final-thoughts"><a href="#Final-thoughts" class="headerlink" title="Final thoughts"></a>Final thoughts</h2><p>閱讀 Tokio、Mio 以及 futures 原始碼後，大大幫助我鞏固對 Tokio 的理解，也驗證了透過理解具體實作來釐清抽象層的學習策略。這個方法在僅僅學習抽象層的狹隘使用案例時非常危險，我們必須意識到具體的示例僅是助於理解一般通例。在閱讀完原始碼之後，再次閱讀 Tokio 的教學文件，我有些馬後炮的意見：<strong>Tokio 非常合理，應該要很容易理解與上手！</strong></p>
<p>我仍有些問題待日後研究：</p>
<ul>
<li>Tokio 有處理 edge triggering（Linux <code>epoll</code>）的飢餓問題（starvation problem）嗎？我認為這個問題可以在 future 中，以單一一個 <code>poll()</code> 限制讀 &#x2F; 寫的數量。當達到這個限制時，future 可以在顯式通知當前 task 提前返回，而非依靠 Tokio I&#x2F;O 來源類型的隱式「<code>WouldBlock</code> 排程」行為。因此這使得其他 task 與 future 有機會有所進展。</li>
<li>Tokio 是否不依賴於將工作卸載給工作線程（worker thread）以最大化處理器核心運用，而是直接支援多線程環境下執行 event loop 嗎？</li>
</ul>
<blockquote>
<p><strong>2017-12-19 更新</strong>：這裡有 Reddit 對話串討論本文。Mio 的作者 Carl Lerche 在<a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/7klghl/tokio_internals_understanding_rusts_asynchronous/drfw5n1/">這裡</a>和<a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/7klghl/tokio_internals_understanding_rusts_asynchronous/drfwc1m/">這裡</a>貼了些資訊量充足的留言。除了回應上述問題，他也點出 <a target="_blank" rel="noopener" href="https://docs.rs/futures/0.1.17/futures/stream/struct.FuturesUnordered.html"><code>FuturesUnordered</code></a> 是一種合成 futures 的方法，只有相關的 child future 會被輪詢，以避免所有 future 像使用 <code>join_all()</code> 全部輪詢，不過這方法有些額外的記憶體配置開銷要衡量。另外，未來的 Tokio 將要遷離 <code>mio::Registration</code> 的通知方案，目的是簡化前述一些步驟。</p>
<!-- -->
<!-- -->
<p><strong>2017-12-21 更新</strong>：看起來 Hacker News 也有在<a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=15972593">討論這篇文章</a>。</p>
</blockquote>
<p>關於譯者：<br><a target="_blank" rel="noopener" href="https://weihanglo.tw/">@weihanglo</a> 掛著 iOS 工程師之名，行開發 Web App 之實。</p>
  
      <div>喜歡我們的文章嗎？歡迎分享按讚給予我們支持和鼓勵！</div>
      <div class="fb-like" data-href="https://blog.techbridge.cc/2018/01/05/tokio-internal/index.html" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="true"></div>
      <br>
      <br>
      <div class="fb-page" data-href="https://www.facebook.com/techbridge.cc" data-small-header="false" data-adapt-container-width="true" data-hide-cover="false" data-show-facepile="true"><blockquote cite="https://www.facebook.com/techbridge.cc" class="fb-xfbml-parse-ignore"><a target="_blank" rel="noopener" href="https://www.facebook.com/techbridge.cc">TechBridge 技術日報</a></blockquote></div>
      <br>
    </section>
    <br>
    <hr>
    <div>
      <h4>訂閱 TechBridge Weekly 技術週刊，每週發送最精華的技術開發、產品設計的資訊給您</h4>
      <form class="form-control" method="post" action="https://goodbits.io/e/cab8a418-6b70-48d6-97ea-b5f0ef34b22c" target="_blank">
        <input class="form-control" type="text" name="first_name" placeholder="First Name"></input>
        <input class="form-control" type="text" name="last_name" placeholder="Last Name"></input>
        <div>
          <input class="form-control" type="text" name="email" placeholder="Email"></input>
        </div>
        <br>
        <div>
          <button class="form-control btn subscribe-btn" type="submit">馬上訂閱技術週刊</button>
        </div>
        <br>
        <label for="">PS. 我們討厭垃圾信，所以我們只提供有價值的內容給您 :)</label>
      </form>
    </div>
    <footer class="post-footer">
      <section class="author">
    <h4>TechBridge Weekly 技術週刊編輯團隊</h4>
    <p>TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、資料科學與產品設計等技術分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robotics, IoT, Data Science technology sharing.</p>
    <span><a href="/2016/03/19/about/">關於我們</a></span> / <span><a href="https://www.techbridge.cc/" target="_blank">技術日報</a></span> / <span><a href="http://weekly.techbridge.cc/" target="_blank">技術週刊</a></span> / <span><a href="https://www.facebook.com/techbridge.cc/" target="_blank">粉絲專頁</a></span> / <span><a href="/atom.xml" target="_blank">訂閱RSS </a></span>   
	<div class="fb-like" data-href="https://www.facebook.com/techbridge.cc" data-layout="button_count" data-size="large" data-action="like" data-show-faces="false" data-share="true"></div>    
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" target="_blank" rel="noopener" href="http://twitter.com/share?url=https://blog.techbridge.cc/2018/01/05/tokio-internal/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" target="_blank" rel="noopener" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.techbridge.cc/2018/01/05/tokio-internal/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" target="_blank" rel="noopener" href="https://plus.google.com/share?url=https://blog.techbridge.cc/2018/01/05/tokio-internal/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
    <iframe src="https://ghbtns.com/github-btn.html?user=TechBridgeHQ&repo=blog-starter-kit&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>      
</section>
    </footer>
    <br>
  </article>
  <nav class="pagination" role="pagination">
    <h2>更多優質技術文章</h2>
    
    <a class="newer-posts" href="/2018/01/05/react-render-optimization/">
        ← React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2017/12/31/intro-to-ceres-solver/">
        Ceres 函式庫簡介 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">留言討論</a></h1>

    
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    
</div>
</main>


  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75308642-1', 'auto');
  ga('send', 'pageview');

</script>
<footer class="site-footer">
  
  <a class="subscribe icon-feed" href="/atom.xml"><span class="tooltip">Subscribe!</span></a>
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">TechBridge 技術共筆部落格</a> &copy; 2017 &bull; All rights reserved.</section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>


<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '[object Object]']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>


<script type="text/javascript">
    var disqus_shortname = 'techbridgeweekly';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.4/dist/medium-zoom.min.js"></script>
<script>
// NodeList
mediumZoom(document.querySelectorAll('img'));
</script>
  <div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, 'script', 'facebook-jssdk'));</script>
</body>
</html>
